.head 0 +  Application Description: GHS application module
ASf
Galilei Software GmbH
KHE_CLS.APL

22.03.2001 AS moved all "black" constants, resources, variables, classes from KHE.APL
25.03.2002 IK engine rewritten according to new demands.
	   new features: auto/manual mode, node children  shown correclty,
	   useless levels removed, etc.
08.03.2002 IK occupied bed is shown in other abteilungen
16.05.2002 IK bug fixed with single gruppe label refresh
28.05.2002 IK clear gruppe attributes concept
19.07.2002 VM: @datevalue() added in @nullvalue(...) for DB compatibility in:
                             clsSerialIterator.RefreshStartData(),
                             clsSerialIterator.PopulateStation(),
                             clsSerialIterator.PopulateBett(),
                             clsSerialIterator On SAM_Create
06.08.02 AH added group entlassung, changed bett label content
03.09.02 AH added Datum, Grund1,2 input to group entlassung
18.09.02 AH rearranged Bett level content (Fall data)
27.09.2002 AS refreshing Gruppe line after UE/VE ( __Move_PasteBettToCurrent )
02.10.2002 AS: added new function: clsKHExplorerLeft.GetGruppeFormular
03.10.2002 VM: Added MDB_GetServerType() in clsKHExplorerLeft.PopulateBett for DB compatibility
09.10.2002 AS: removed refreshing from On SAM_Create
05.11.2002 AS: added SetItemHasFall(  ) to PopulateGruppe and to PopulateStation
28.11.02 AH added Culling, AddToGroup, different menus for Human and Mice at Group(Cage) level
04.12.02 AH: use clsComboBoxBewGrund
10.12.02 AH added 'Dead' sign, refresh after culling
16.12.02 AH changed 'Dead' sign to 'T' to avoid displaying problems
09.01.03 AH added Health Status
10.01.03 AH fixed Station select (einrichtung check)
14.01.03 AH added GetCurrentLevelKey( ), Mice menu for Station (rack)
21.04.03 AH uncommented Level 3, 4 expand, moved here group refresh after paste, changed 'Commit' to DoCloseTransaction()
24.04.2003 AS: using Transfer_AppendToAll(  ) instead of Transfer.AppendToAll(  )
30.04.03 AH changed SetItemData() to SetItemValue() and SetItemText() to fix GHS crash
13.05.03 AH commented piece of code to avoid KHE hanging
27.06.03 AH excluded KHE Toolbox
01.07.03 AD implemented IR in clsKHExplorerLeft : RefreshStartData
	     corrected queries for Sybase compatibility
07.07.03 AH added asterix on LE comment
16.07.03 AH: show empty places after full if bBreedingIsON
07.08.2003 AS: corrected clsKHExplorerLeft.Move_GroupRelease(  ) -> instead of using InsertBewegung we 
	LockSysadm, call _InsertBewgung(  ) and ReleaseSysadm + all manual sendings a-la Transsfer2All
18.08.2003 AD: added branch with SQL for Sybase in clsKHExplorerLeft.PopulateBett()
12.09.2003 AS: using of corrected __InsertBewegung();
		replaced some "SELECT * " by "SELECT <key>"
23.09.2003 AS: Implemented processing of AM_KHE_* messages
29.09.2003 AS: Implemented using sUsers_AbtSet, sUsers_StstSet for populating only avelable items
30.09.2003 AS: using dtBewZeit_New for Move_Paste....
06.10.2003 AS: added condition: " f.STATUS = 'A' "
30.10.2003 AS: AM_KHE_GotoGrp operates wParam
28.11.2003 AH: clear GroupPurpose on bulk release
23.12.2003 AS: implemented using of GalGetAsWinMsg*Param_***()
24.12.2003 AH: show '[+]' for Gruppes Ocupied by other Abteilung
09.12.2003 AS: using ':dtKHK_RefreshTime' instead of 'SYSDATETIME' and '@now'
10.04.2004 AS: changed: loading and populating; using/setting dtDateTime4Refresh,...
12.03.2004 AS: Move_FindFreeBeds() was modified
16.03.2004 AS: using SETTINGS->"KHE"-"ALWAYS SHOW ALL ABT/STAT" (db v.6.26)
05.04.2004 AS: messages from GHS.MSG are implemented
06.04.2004 AS: removed collapsing from PopulateAndExpand(); Creating on Planning works through existing Virt.FallKey
15.04.2004 AS: AM_KHE_Download2Reader
15.10.2004 AH: plan mode cut/puste takes only members of selected Experiment;
		Target Free bett search scans KHE instead of DB;
		Delete Planning is implemented
03.11.2004 AH: do not reset cut/paste mode during expand if cut source is not affected
11.11.2004 AS: Go to the same place after Date changing ( see KHE_Options() )
17.11.2004 AD: added 'Find Animal' feature with Bluetooth reader
24.02.2005 AH: adding Gruppe to Experiment
12.03.2005 AD: clsKHExplorerLeft.OpenBettByFallKey( ) - added check if the case exists
23.03.2005 AH: use APD to select Virtual Fall of Experiment
24.03.2005 AS: show 'Exp.:" or 'Not in Exp.:'; use dfDateTime4Refresh as default for dlgKHE_StartPlanningMode;
	         added some messages to Gruppe2Experiment()
25.04.2005 AH: use APD to add Case to StudyGroup
20.05.2005 AS: "Experiment" titles were replace by "License"
16.08.2005 AD: use of LE.TRANSPONDER_ID instead of LE.NAME1
23.03.2006 AD: Assigning cage members to license - using standard functions
11.04.2006 AD: Implemented 'Print Cage Cards' for a Rack
28.04.2006 TO: clsKHExplorerLeft.OpenGruppe() : CageCard menu popups
05.05.2006 TO: clsKHExplorerLeft.OpenBett() - Mouse menu popus on Find and scan; added sOpenKHKItemOnScan
08.05.2006 TO: clsKHExplorerLeft: preventing of opening Cage and Bett Menu after paste; small fixes
11.05.2006 TO: clsKHExplorerLeft: changes in Move_CanCut () for KHEL_Gruppe
18.05.2006 AD: printing of cage cards after a movement
20.06.2006 AD: closing popups after scanning
08.06.2006 AD: refreshing after bulkimport
08.06.2006 TO: aded KHE_CageFormularWithLitter( );  changed KHE_CageCard ( )
13.06.2006 TO: changes and fixes in KHE_CageFormularWithLitter( )  
19.06.2006 TO: changes and fixes in KHE_CageFormularWithLitter( )
06.07.2006 TO: added KHE_RackIsIntensiv ( )
06.10.2006 AD: changed clsKHExplorerLeft.PopulateEinrichtung( ) and PopulateAbteilung( )
18.01.2007 Sh: chenged picture on each level on clsExplorerLeft
22.02.2007 Sh: create new function HEGetHasFall_Sex for change picture according to sex
02.08.2007 Sh: sort Station by users mine, add variable n.CurrNum- Current Number
24.10.2007 IB:  moved classes clsLocation, clsLocationCage, clsLocationPlace, clsLocationRack, clsLocationScreen
	          and function Requst_ListForCageCard into library location.apl
05.11.2007 IB: moved variable dtKHK_RefreshTime into file location.apl
20.12.2007 IB: added information about genotypes (1,2,3) and color to bet string in KHE
22.01.2008 IB: working with unpress buttons on Rack2D (look for UNPRESS2D)
24.01.2008 EA: added colored strain feature
28.01.2008 IB: added information about genotype4 to bet string in KHE
19.03.2008 Sh: added function PlanedMovement_WithRack2d for automate meating, and CanPlanedMovement_WithRack2d 
		for check is posible meating
29.04.2008 EA: add transfer cage into another screen feature

.head 1 -  Outline Version - 4.0.35
.head 1 +  Design-time Settings
.data VIEWINFO
0000: 6F00000001000000 FFFF01000D004347 5458566965775374 6174650400010000
0020: 0000000000170100 002C000000020000 0003000000FFFFFF FFFFFFFFFFFCFFFF
0040: FFE9FFFFFFFAFFFF FF14000000340300 00DC010000010000 0001000000010000
0060: 000F4170706C6963 6174696F6E497465 6D00000000
.enddata
.data DT_MAKERUNDLG
0000: 0000000000184B3A 5C47485333322E69 6E735C6B68655F63 6C732E657865184B
0020: 3A5C47485333322E 696E735C6B68655F 636C732E646C6C18 4B3A5C4748533332
0040: 2E696E735C6B6865 5F636C732E617063 000001010114433A 5C47485333325C6B
0060: 68655F636C732E72 756E14433A5C4748 5333325C6B68655F 636C732E646C6C14
0080: 433A5C4748533332 5C6B68655F636C73 2E61706300000101 0114433A5C474853
00A0: 33325C6B68655F63 6C732E6170641443 3A5C47485333325C 6B68655F636C732E
00C0: 646C6C14433A5C47 485333325C6B6865 5F636C732E617063 000001010114433A
00E0: 5C47485333325C6B 68655F636C732E61 706C14433A5C4748 5333325C6B68655F
0100: 636C732E646C6C14 433A5C4748533332 5C6B68655F636C73 2E61706300000101
0120: 01
.enddata
.head 2 -  Outline Window State: Maximized
.head 2 +  Outline Window Location and Size
.data VIEWINFO
0000: 6600040003001B00 0200000000000000 0000081E63140500 1D00FFFF4D61696E
0020: 001E000100040028 0000000000F51E10 0D0000F400FFFF43 6C61737365730029
0040: 0001000400260000 000000E91E800A00 008600FFFF496E74 65726E616C204675
0060: 6E6374696F6E7300 2000010004002500 00000000E91E800A 0000DF00FFFF5661
0080: 726961626C657300
.enddata
.data VIEWSIZE
0000: 8800
.enddata
.head 3 -  Left: 3.563"
.head 3 -  Top: 1.073"
.head 3 -  Width:  8.013"
.head 3 -  Height: 4.969"
.head 2 +  Options Box Location
.data VIEWINFO
0000: D418BD06B80B2A00
.enddata
.data VIEWSIZE
0000: 0800
.enddata
.head 3 -  Visible? Yes
.head 3 -  Left: 4.15"
.head 3 -  Top: 1.885"
.head 3 -  Width:  3.8"
.head 3 -  Height: 2.073"
.head 2 +  Class Editor Location
.head 3 -  Visible? No
.head 3 -  Left: 0.5"
.head 3 -  Top: 0.083"
.head 3 -  Width:  5.063"
.head 3 -  Height: 2.688"
.head 2 +  Tool Palette Location
.head 3 -  Visible? No
.head 3 -  Left: 8.125"
.head 3 -  Top: 0.302"
.head 2 -  Fully Qualified External References? No
.head 2 -  Reject Multiple Window Instances? Yes
.head 2 -  Enable Runtime Checks Of External References? Yes
.head 2 -  Use Release 4.0 Scope Rules? No
.head 2 -  Edit Fields Read Only On Disable? Yes
.head 1 +  Libraries
.head 2 -  File Include: vtlbx.apl
.head 2 -  File Include: storno.apl
.head 2 -  File Include: prgr_ind.apl
.head 2 -  File Include: hasharr.apl
.head 2 -  File Include: cls_tabl.apl
.head 2 -  File Include: cls_clmn.apl
.head 2 -  File Include: modul.apl
.head 2 -  File Include: culling.apl
.head 2 -  Dynalib: dyna_dialogs.apd
.head 2 -  Dynalib: Dyna_HelthStatFnc.apd
.head 2 -  Dynalib: Dyna_profile.apd
.head 2 -  Dynalib: Dyna_Sex.apd
.head 2 -  Dynalib: Dyna_Vars_INI.apd
.head 2 -  Dynalib: Dyna_Vars_Gnrl.apd
.head 2 -  Dynalib: Dyna_Vars_GHS.apd
.head 2 -  File Include: HelStat.apl
.head 2 -  ! File Include: clsFall.apl
.head 2 -  File Include: Formular_fnc.apl
.head 2 -  Dynalib: Dyna_LicenseExt.APD
.head 2 -  Dynalib: Dyna_Reader.apd
.head 2 -  ! -- -----------------------------------------------
.head 2 -  File Include: mtbl_cut.apl
.head 2 -  File Include: SQLHANDL.APL
.head 2 -  File Include: Cls_gnrl.apl
.head 2 -  ! -- -----------------------------------------------
.head 2 -  File Include: CONST.APL
.head 2 -  File Include: Glb_F_VT.apl
.head 2 -  File Include: CLSMODUL.APL
.head 2 -  File Include: CLS_PB.apl
.head 2 -  File Include: transfer.apl
.head 2 -  ! File Include: dyna_expfnc.apl
.head 2 -  Dynalib: dyna_expfnc.apd
.head 2 -  Dynalib: dyna_group_fnc.apd
.head 2 -  Dynalib: dyna_request.apd
.head 2 -  Dynalib: dyna_aos_fnc.apd
.head 2 -  ! -- -----------------------------------------------
.head 2 -  File Include: const_system.apl
.head 2 -  File Include: order_list_fnc.apl
.head 2 -  File Include: rack_2d_view.apl
.head 2 -  File Include: location.apl
.head 2 -  File Include: POC.apl
.head 2 -  ! File Include: Litter_widget.apl
.head 2 -  Dynalib: dyna_routine.apd
.head 2 -  Dynalib: Dyna_UserInit.apd
.head 2 -  Dynalib: d_cages.apd
.head 2 -  File Include: cullingStructs.apl
.head 2 -  Dynalib: litter_widget.apd
.head 1 +  Global Declarations
.head 2 +  Window Defaults
.head 3 +  Tool Bar
.head 4 -  Display Style? Etched
.head 4 -  Font Name: System Default
.head 4 -  Font Size: System Default
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Form Window
.head 4 -  Display Style? Etched
.head 4 -  Font Name: System Default
.head 4 -  Font Size: System Default
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Dialog Box
.head 4 -  Display Style? Etched
.head 4 -  Font Name: System Default
.head 4 -  Font Size: System Default
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Top Level Table Window
.head 4 -  Font Name: System Default
.head 4 -  Font Size: System Default
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Data Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Multiline Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Spin Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Background Text
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Pushbutton
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Radio Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Check Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Option Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Group Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Child Table Window
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  List Box
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Combo Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Line
.head 4 -  Line Color: Use Parent
.head 3 +  Frame
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Picture
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 2 +  Formats
.head 3 -  Number: 0'%'
.head 3 -  Number: #0
.head 3 -  Number: ###000
.head 3 -  Number: ###000;'($'###000')'
.head 3 -  Date/Time: dd.MM.yyyy
.head 3 -  Date/Time: dd.MM.yy
.head 3 -  Date/Time: dd.MM.yyyy hhhh:mm
.head 3 -  Input: 99.99.9999 99:99
.head 3 -  Input: 999999
.head 3 -  Date/Time: dd.MM.yyyy hhhh:mm:ss
.head 3 -  Input: 99.99.9999 99:99:99
.head 3 -  Input: 99.99.9999
.head 2 +  External Functions
.head 3 +  Library name: user32.dll
.head 4 -  ThreadSafe: No
.head 4 +  Function: GetClassNameA
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 +  Returns
.head 6 -  Number: INT
.head 5 +  Parameters
.head 6 -  Window Handle: HWND
.head 6 -  Receive String: LPSTR
.head 6 -  Number: INT
.head 4 +  Function: keybd_event
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 -  Returns
.head 5 +  Parameters
.head 6 -  Number: BYTE
.head 6 -  Number: BYTE
.head 6 -  Number: DWORD
.head 6 -  Number: DWORD
.head 4 +  Function: LoadIconA
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 +  Returns
.head 6 -  Number: HANDLE
.head 5 +  Parameters
.head 6 -  Number: HANDLE
.head 6 -  String: LPCSTR
.head 4 +  Function: CreateIconFromResource
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 +  Returns
.head 6 -  Number: HANDLE
.head 5 +  Parameters
.head 6 -  Number: LPVOID
.head 6 -  Number: DWORD
.head 6 -  Boolean: BOOL
.head 6 -  Number: DWORD
.head 4 +  ! Function: SetForegroundWindow
.head 5 -  Description: 
.head 5 -  Export Ordinal: 0
.head 5 +  Returns 
.head 6 -  Boolean: BOOL
.head 5 +  Parameters 
.head 6 -  Window Handle: HWND
.head 4 +  Function: EnableMenuItem
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 +  Returns
.head 6 -  Boolean: BOOL
.head 5 +  Parameters
.head 6 -  Window Handle: HWND
.head 6 -  Number: UINT
.head 6 -  Number: UINT
.head 4 +  Function: GetMessagePos
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 +  Returns
.head 6 -  Number: DWORD
.head 5 -  Parameters
.head 4 +  Function: AppendMenuA
.head 5 -  Description:
.head 5 -  Export Ordinal: 0
.head 5 +  Returns
.head 6 -  Boolean: BOOL
.head 5 +  Parameters
.head 6 -  Window Handle: HWND
.head 6 -  Number: UINT
.head 6 -  Number: UINT
.head 6 -  String: LPCSTR
.head 2 +  Constants
.data CCDATA
0000: 3000000000000000 0000000000000000 00000000
.enddata
.data CCSIZE
0000: 1400
.enddata
.head 3 +  System
.head 4 -  Number: MTBL_ROW_HIDDEN =			0x00200000
.head 4 -  Number: MTBL_TREE_FLAG_AUTO_NORM_HIER =	0x00000100
.head 4 -  Number: WM_CANCELMODE = 0x001F
.head 4 -  Number: ITEM_FormFlag = 0x0001
.head 4 -  Number: WM_SHOWWINDOW=0x0018
.head 3 +  User
.head 4 -  !
.head 4 -  Number: RackIsFull= 200
.head 4 -  Number: RackIsEmpty= 201
.head 4 -  Number: RackIsVirtual = 203
.head 4 -  Number: RackIsChaos = 204
.head 4 -  Number: Rack_IsIntensiv = 205
.head 4 -  Number: Rack_NotNeedPrint = 206
.head 4 -  Number: Rack_IsCadaver = 207
.head 4 -  Number: Rack_OutgoingAdmServ = 208
.head 4 -  Number: Rack_IncomingAdmServ = 209
.head 4 -  Number: Rack_SlotNeedAssign = 210
.head 4 -  Number: CageIsFull = 300
.head 4 -  Number: CageIsEmpty = 301
.head 4 -  Number: CageIsOccupied = 302
.head 4 -  Number: CageWithRFID = 303
.head 4 -  Number: LitterInCage = 304
.head 4 -  Number: CageIsCadaver = 305
.head 4 -  Number: CageIsRoling = 306
.head 4 -  Number: Cage_LOCKScreen = 307
.head 4 -  Number: Cage_LOCKCurrScreen = 308
.head 4 -  Number: IsAlert = 102
.head 4 -  Number: IsServise = 103
.head 4 -  Number: AnimalIsPlugged = 401
.head 4 -  Number: AnimalIsLitter = 402
.head 4 -  Number: AnimalIsDead = 403
.head 4 -  Number: AnimalInPlanBew = 404
.head 4 -  Number: AnimalInMate = 405
.head 4 -  Number: StrainIsVas = 501
.head 4 -  Number: StrainIsGVO = 502
.head 4 -  !
.head 4 -  String: sOCCUPIED_BY = "Occupied by"
.head 4 -  String: sPLAN = "PLAN"
.head 4 -  String: sLOCKED = "LOCKED"
.head 4 -  Number: nTYPE_BEWEG = 1
.head 4 -  Number: nTYPE_PLAN = 0
.head 4 -  Number: nTYPE_LOCK = -1
.head 4 -  Number: nKHK_HAS_CHILD = 0x0001
.head 4 -  Number: nKHK_HAS_NO_CHILD = 0xFFFE
.head 4 -  Number: nKHK_POPULATED = 0x0002
.head 4 -  Number: nKHK_NO_POPULATED = 0xFFFD
.head 4 -  Number: nKHK_CHILD_CHECKED = 0x0004
.head 4 -  Number: nKHK_CHILD_NO_CHECKED = 0xFFFB
.head 4 -  !
.head 4 -  Number: KHEL_Einrichtung = 0
.head 4 -  Number: KHEL_Abteilung = 1
.head 4 -  Number: KHEL_Station = 2
.head 4 -  Number: KHEL_Gruppe = 3
.head 4 -  Number: KHEL_Bett = 4
.head 4 -  String: KHE_NAME = 'Hospital explorer library'
.head 4 -  String: KHE_VERSION = '3.0.1'
.head 4 -  Number: DIR_Up = 1
.head 4 -  Number: DIR_Down = 2
.head 4 -  Number: DIR_Left = 3
.head 4 -  Number: DIR_Right = 4
.head 4 -  Number: WM_FINISHMUVESIZE = 0x0232
.head 4 -  Number: WM_MOUSEWHEEL = 0x020A
.head 4 -  !
.head 4 -  Number: VK_Minus = 0xBD
.head 4 -  Number: VK_Plus = 0xBB
.head 3 -  Enumerations
.head 2 +  Resources
.head 3 +  Bitmap: INS
.head 4 -  File Name: KHEATLOP-I.BMP
.head 3 +  Bitmap: INSCL
.head 4 -  File Name: KHELFLCL-I.BMP
.head 3 +  Bitmap: ROOM
.head 4 -  File Name: KHELFLOP-R.BMP
.head 3 +  Bitmap: ROOMCL
.head 4 -  File Name: KHELFLCL-R.BMP
.head 3 +  Bitmap: DOOROP
.head 4 -  File Name: KHELFLOP-ROOM.BMP
.head 3 +  Bitmap: DOORCL
.head 4 -  File Name: KHELFLCL-ROOM.BMP
.head 3 +  Bitmap: STOJ
.head 4 -  File Name: KHELFLOP-S.BMP
.head 3 +  Bitmap: STOJG
.head 4 -  File Name: KHELFLOP-SG.BMP
.head 3 +  Bitmap: STOJCL
.head 4 -  File Name: KHELFLCL-S.BMP
.head 3 +  Bitmap: STOJCLG
.head 4 -  File Name: KHELFLCL-SG.BMP
.head 3 +  Bitmap: STOJvirt
.head 4 -  File Name: KHELFLOP-virt.BMP
.head 3 +  Bitmap: STOJCLvirt
.head 4 -  File Name: KHELFLCL-virt.BMP
.head 3 +  Bitmap: CELL
.head 4 -  File Name: KHELFLOP-C.BMP
.head 3 +  Bitmap: CELLG
.head 4 -  File Name: KHELFLOP-CG.BMP
.head 3 +  Bitmap: CELLCL
.head 4 -  File Name: KHELFLCL-C.BMP
.head 3 +  Bitmap: CELLCLG
.head 4 -  File Name: KHELFLCL-CG.BMP
.head 3 +  Bitmap: CELL_RF
.head 4 -  File Name: KHELFLOP-C-RF.BMP
.head 3 +  Bitmap: CELLG_RF
.head 4 -  File Name: KHELFLOP-CG-RF.BMP
.head 3 +  Bitmap: CELLCL_RF
.head 4 -  File Name: KHELFLCL-C-RF.BMP
.head 3 +  Bitmap: CELLCLG_RF
.head 4 -  File Name: KHELFLCL-CG-RF.BMP
.head 3 +  Bitmap: CELL_A
.head 4 -  File Name: KHELFLOP-C-A.BMP
.head 3 +  Bitmap: CELLG_A
.head 4 -  File Name: KHELFLOP-CG-A.BMP
.head 3 +  Bitmap: CELLCL_A
.head 4 -  File Name: KHELFLCL-C-A.BMP
.head 3 +  Bitmap: CELLCLG_A
.head 4 -  File Name: KHELFLCL-CG-A.BMP
.head 3 +  Bitmap: CELL_A_RF
.head 4 -  File Name: KHELFLOP-C-A-RF.BMP
.head 3 +  Bitmap: CELLG_A_RF
.head 4 -  File Name: KHELFLOP-CG-A-RF.BMP
.head 3 +  Bitmap: CELLCL_A_RF
.head 4 -  File Name: KHELFLCL-C-A-RF.BMP
.head 3 +  Bitmap: CELLCLG_A_RF
.head 4 -  File Name: KHELFLCL-CG-A-RF.BMP
.head 3 +  ! Bitmap: MOUSE_M_A
.head 4 -  File Name: KHEFLDUN-MM-A.BMP
.head 3 +  Bitmap: MOUSE_M_Select_A
.head 4 -  File Name: KHEFLDUN-MM_S-A.BMP
.head 3 +  ! Bitmap: MOUSE_F_A
.head 4 -  File Name: KHEFLDUN-MF-A.BMP
.head 3 +  Bitmap: MOUSE_F_Select_A
.head 4 -  File Name: KHEFLDUN-MF_S-A.BMP
.head 3 +  Bitmap: CELL_CCU
.head 4 -  File Name: KHELFLOP-C-CCU.BMP
.head 3 +  Bitmap: CELLG_CCU
.head 4 -  File Name: KHELFLOP-CG-CCU.BMP
.head 3 +  Bitmap: CELLCL_CCU
.head 4 -  File Name: KHELFLCL-C-CCU.BMP
.head 3 +  Bitmap: CELLCLG_CCU
.head 4 -  File Name: KHELFLCL-CG-CCU.BMP
.head 3 +  Bitmap: CELL_RF_CCU
.head 4 -  File Name: KHELFLOP-C-CCU-RF.BMP
.head 3 +  Bitmap: CELLG_RF_CCU
.head 4 -  File Name: KHELFLOP-CG-CCU-RF.BMP
.head 3 +  Bitmap: CELLCL_RF_CCU
.head 4 -  File Name: KHELFLCL-C-CCU-RF.BMP
.head 3 +  Bitmap: CELLCLG_RF_CCU
.head 4 -  File Name: KHELFLCL-CG-CCU-RF.BMP
.head 3 +  Bitmap: CELL_A_CCU
.head 4 -  File Name: KHELFLOP-C-CCU-A.BMP
.head 3 +  Bitmap: CELLG_A_CCU
.head 4 -  File Name: KHELFLOP-CG-CCU-A.BMP
.head 3 +  Bitmap: CELLCL_A_CCU
.head 4 -  File Name: KHELFLCL-C-CCU-A.BMP
.head 3 +  Bitmap: CELLCLG_A_CCU
.head 4 -  File Name: KHELFLCL-CG-CCU-A.BMP
.head 3 +  Bitmap: CELL_A_RF_CCU
.head 4 -  File Name: KHELFLOP-C-CCU-A-RF.BMP
.head 3 +  Bitmap: CELLG_A_RF_CCU
.head 4 -  File Name: KHELFLOP-CG-CCU-A-RF.BMP
.head 3 +  Bitmap: CELLCL_A_RF_CCU
.head 4 -  File Name: KHELFLCL-C-CCU-A-RF.BMP
.head 3 +  Bitmap: CELLCLG_A_RF_CCU
.head 4 -  File Name: KHELFLCL-CG-CCU-A-RF.BMP
.head 3 +  Bitmap: CELLG_CD
.head 4 -  File Name: KHELFLOP-CG_CD.BMP
.head 3 +  Bitmap: CELLCLG_CD
.head 4 -  File Name: KHELFLCL-CG_CD.BMP
.head 3 +  Bitmap: CELLG_RF_CD
.head 4 -  File Name: KHELFLOP-CG-RF_CD.BMP
.head 3 +  Bitmap: CELLCLG_RF_CD
.head 4 -  File Name: KHELFLCL-CG-RF_CD.BMP
.head 3 +  Bitmap: CELLG_A_CD
.head 4 -  File Name: KHELFLOP-CG-A_CD.BMP
.head 3 +  Bitmap: CELLG_A_RF_CD
.head 4 -  File Name: KHELFLOP-CG-A-RF_CD.BMP
.head 3 +  Bitmap: CELLCLG_A_RF_CD
.head 4 -  File Name: KHELFLCL-CG-A-RF_CD.BMP
.head 3 +  Bitmap: CELLCLG_A_CD
.head 4 -  File Name: KHELFLCL-CG-A_CD.BMP
.head 3 +  ! Bitmap: MOUSE_M
.head 4 -  File Name: KHEFLDUN-MM.BMP
.head 3 +  Bitmap: MOUSE_M_Select
.head 4 -  File Name: KHEFLDUN-MM_S.BMP
.head 3 +  ! Bitmap: MOUSE_F
.head 4 -  File Name: KHEFLDUN-MF.BMP
.head 3 +  Bitmap: MOUSE_F_Select
.head 4 -  File Name: KHEFLDUN-MF_S.BMP
.head 3 +  Bitmap: MOUSEG
.head 4 -  File Name: KHEFLDUN-MG.BMP
.head 3 +  Bitmap: MOUSEGS
.head 4 -  File Name: KHEFLDUN-MGS.BMP
.head 3 +  Bitmap: MOUSE_M_A_D
.head 4 -  File Name: KHEFLDUN-MM-A_D.BMP
.head 3 +  Bitmap: MOUSE_M_Select_A_D
.head 4 -  File Name: KHEFLDUN-MM_S-A_D.BMP
.head 3 +  Bitmap: MOUSE_F_A_D
.head 4 -  File Name: KHEFLDUN-MF-A_D.BMP
.head 3 +  Bitmap: MOUSE_F_Select_A_D
.head 4 -  File Name: KHEFLDUN-MF_S-A_D.BMP
.head 3 +  Bitmap: MOUSE_M_D
.head 4 -  File Name: KHEFLDUN-MM_D.BMP
.head 3 +  Bitmap: MOUSE_M_Select_D
.head 4 -  File Name: KHEFLDUN-MM_S_D.BMP
.head 3 +  Bitmap: MOUSE_F_D
.head 4 -  File Name: KHEFLDUN-MF_D.BMP
.head 3 +  Bitmap: MOUSE_F_Select_D
.head 4 -  File Name: KHEFLDUN-MF_S_D.BMP
.head 3 +  Bitmap: MOUSE_F_L
.head 4 -  File Name: KHEFLDUN-MF_L.BMP
.head 3 +  Bitmap: MOUSE_F_Select_L
.head 4 -  File Name: KHEFLDUN-MF_S_L.BMP
.head 3 +  Bitmap: MOUSE_F_A_L
.head 4 -  File Name: KHEFLDUN-MF-A_L.BMP
.head 3 +  Bitmap: MOUSE_F_Select_A_L
.head 4 -  File Name: KHEFLDUN-MF_S-A_L.BMP
.head 3 +  Bitmap: MOUSE_F_L_D
.head 4 -  File Name: KHEFLDUN-MF-L_D.BMP
.head 3 +  Bitmap: MOUSE_F_SL_D
.head 4 -  File Name: KHEFLDUN-MF-SL_D.BMP
.head 3 +  Bitmap: MOUSE_F_AL_D
.head 4 -  File Name: KHEFLDUN-MF-AL_D.BMP
.head 3 +  Bitmap: MOUSE_F_L_SD
.head 4 -  File Name: KHEFLDUN-MF-L_SD.BMP
.head 3 +  Bitmap: MOUSE_F_SL_SD
.head 4 -  File Name: KHEFLDUN-MF-SL_SD.BMP
.head 3 +  Bitmap: MOUSE_F_AL_SD
.head 4 -  File Name: KHEFLDUN-MF-AL_SD.BMP
.head 3 +  Bitmap: CELL_SR
.head 4 -  File Name: KHELFLOP-C-SR.BMP
.head 3 +  Bitmap: CELLG_SR
.head 4 -  File Name: KHELFLOP-CG-SR.BMP
.head 3 +  Bitmap: CELLCL_SR
.head 4 -  File Name: KHELFLCL-C-SR.BMP
.head 3 +  Bitmap: CELLCLG_SR
.head 4 -  File Name: KHELFLCL-CG-SR.BMP
.head 3 +  Bitmap: CELL_SR_RF
.head 4 -  File Name: KHELFLOP-C-SR-RF.BMP
.head 3 +  Bitmap: CELLG_SR_RF
.head 4 -  File Name: KHELFLOP-CG-SR-RF.BMP
.head 3 +  Bitmap: CELLCL_SR_RF
.head 4 -  File Name: KHELFLCL-C-SR-RF.BMP
.head 3 +  Bitmap: CELLCLG_SR_RF
.head 4 -  File Name: KHELFLCL-CG-SR-RF.BMP
.head 3 +  Bitmap: MOUSE_M_SR
.head 4 -  File Name: KHEFLDUN-MM-SR.BMP
.head 3 +  Bitmap: MOUSE_M_Select_SR
.head 4 -  File Name: KHEFLDUN-MM_S-SR.BMP
.head 3 +  Bitmap: MOUSE_F_SR
.head 4 -  File Name: KHEFLDUN-MF-SR.BMP
.head 3 +  Bitmap: MOUSE_F_Select_SR
.head 4 -  File Name: KHEFLDUN-MF_S-SR.BMP
.head 3 +  Bitmap: CELL_SR_CCU
.head 4 -  File Name: KHELFLOP-C-CCU-SR.BMP
.head 3 +  Bitmap: CELLG_SR_CCU
.head 4 -  File Name: KHELFLOP-CG-CCU-SR.BMP
.head 3 +  Bitmap: CELLCL_SR_CCU
.head 4 -  File Name: KHELFLCL-C-CCU-SR.BMP
.head 3 +  Bitmap: CELLCLG_SR_CCU
.head 4 -  File Name: KHELFLCL-CG-CCU-SR.BMP
.head 3 +  Bitmap: CELL_SR_RF_CCU
.head 4 -  File Name: KHELFLOP-C-CCU-SR-RF.BMP
.head 3 +  Bitmap: CELLG_SR_RF_CCU
.head 4 -  File Name: KHELFLOP-CG-CCU-SR-RF.BMP
.head 3 +  Bitmap: CELLCL_SR_RF_CCU
.head 4 -  File Name: KHELFLCL-C-CCU-SR-RF.BMP
.head 3 +  Bitmap: CELLCLG_SR_RF_CCU
.head 4 -  File Name: KHELFLCL-CG-CCU-SR-RF.BMP
.head 3 +  Bitmap: CELLG_SR_CD
.head 4 -  File Name: KHELFLOP-CG-SR_CD.BMP
.head 3 +  Bitmap: CELLG_SR_RF_CD
.head 4 -  File Name: KHELFLOP-CG-SR-RF_CD.BMP
.head 3 +  Bitmap: CELLCLG_SR_RF_CD
.head 4 -  File Name: KHELFLCL-CG-SR-RF_CD.BMP
.head 3 +  Bitmap: CELLCLG_SR_CD
.head 4 -  File Name: KHELFLCL-CG-SR_CD.BMP
.head 3 +  Bitmap: MOUSE_M_SR_D
.head 4 -  File Name: KHEFLDUN-MM-SR_D.BMP
.head 3 +  Bitmap: MOUSE_M_Select_SR_D
.head 4 -  File Name: KHEFLDUN-MM_S-SR_D.BMP
.head 3 +  Bitmap: MOUSE_F_SR_D
.head 4 -  File Name: KHEFLDUN-MF-SR_D.BMP
.head 3 +  Bitmap: MOUSE_F_Select_SR_D
.head 4 -  File Name: KHEFLDUN-MF_S-SR_D.BMP
.head 3 +  Bitmap: MOUSE_F_SR_L
.head 4 -  File Name: KHEFLDUN-MF-SR_L.BMP
.head 3 +  Bitmap: MOUSE_F_Select_SR_L
.head 4 -  File Name: KHEFLDUN-MF_S-SR_L.BMP
.head 3 +  Bitmap: CELL_ROL
.head 4 -  File Name: KHELFLOP-C-ROL.BMP
.head 3 +  Bitmap: CELLCL_ROL
.head 4 -  File Name: KHELFLCL-C-ROL.BMP
.head 3 +  Bitmap: CELL_ROL_RF
.head 4 -  File Name: KHELFLOP-C-ROL-RF.BMP
.head 3 +  Bitmap: CELLCL_ROL_RF
.head 4 -  File Name: KHELFLCL-C-ROL-RF.BMP
.head 3 +  Bitmap: CELL_ROL_A
.head 4 -  File Name: KHELFLOP-C-ROL-A.BMP
.head 3 +  Bitmap: CELLCL_ROL_A
.head 4 -  File Name: KHELFLCL-C-ROL-A.BMP
.head 3 +  Bitmap: CELL_ROL_A_RF
.head 4 -  File Name: KHELFLOP-C-ROL-A-RF.BMP
.head 3 +  Bitmap: CELLCL_ROL_A_RF
.head 4 -  File Name: KHELFLCL-C-ROL-A-RF.BMP
.head 3 +  Bitmap: CELL_ROL_SR
.head 4 -  File Name: KHELFLOP-C-ROL-SR.BMP
.head 3 +  Bitmap: CELLCL_ROL_SR
.head 4 -  File Name: KHELFLCL-C-ROL-SR.BMP
.head 3 +  Bitmap: CELL_ROL_SR_RF
.head 4 -  File Name: KHELFLOP-C-ROL-SR-RF.BMP
.head 3 +  Bitmap: CELLCL_ROL_SR_RF
.head 4 -  File Name: KHELFLCL-C-ROL-SR-RF.BMP
.head 3 -  !
.head 3 +  Bitmap: CELL_OC
.head 4 -  File Name: KHELFLCL-OCCUP.bmp
.head 3 +  ! Bitmap: KHEATLOP
.head 4 -  File Name: KHEATLOP.BMP
.head 3 +  ! Bitmap: KHEATLCL
.head 4 -  File Name: KHEATLCL.BMP
.head 3 +  ! Bitmap: KHELFLOP
.head 4 -  File Name: KHELFLOP.BMP
.head 3 +  Bitmap: KHEFLDCL
.head 4 -  File Name: PictureNull.bmp
.head 3 +  ! Bitmap: KHEFLDUN
.head 4 -  File Name: KHEFLDUN.BMP
.head 3 +  Bitmap: KHEFall
.head 4 -  File Name: KHEFall.BMP
.head 3 +  Bitmap: KHEMAIL
.head 4 -  File Name: KHEMAIL.BMP
.head 3 +  Bitmap: KHE!MAIL
.head 4 -  File Name: KHE!MAIL.BMP
.head 3 +  Bitmap: KHEBFREE
.head 4 -  File Name: PictureNull.bmp
.head 3 +  Bitmap: KHE_ClockW
.head 4 -  File Name: clock.bmp
.head 3 +  Bitmap: KHE_ClockR
.head 4 -  File Name: clock_red.bmp
.head 3 +  Bitmap: KHE_ClockY
.head 4 -  File Name: clock_yel.bmp
.head 3 -  !
.head 2 +  Variables
.data RESOURCE 0 0 1 3803623488
0000: 7C0000005D000000 0000000000000000 02000004000000F1 0200001019000000
0020: 017C05E054170000 0000730000000100 0000830A03000004 0500027C055517BA
0040: 000073D900010068 0E0300190009017C 0A0000006F730034 01000027035A0004
0060: 0003C07C050B0000 009B7300010D00
.enddata
.head 3 -  ! --- IK: Well, well, I know this su><...... but how can I pass proper gruppe handle otherwise....?
.head 3 -  Number: hKHK_GruppeThatMayBeEmpty
.head 3 -  Number: HandleToPlace[*,2]
.head 3 -  Number: HandleToTemp[*,2]
.head 3 -  ! Date/Time: dtKHK_RefreshTime
.head 3 -  ! Window Handle: hWL_Edit
.head 3 -  Window Handle: hWorkLstOpened
.head 3 -  String: sAbtKeyOld
.head 3 -  String: sRoomCage
.head 3 -  String: sScreen
.head 3 -  Boolean: bPOC
.head 3 -  Boolean: bPlanDate
.head 3 -  Window Handle: hQuestionDialog
.head 3 -  Window Handle: hDetailInfoAE
.head 3 -  Window Handle: hWndProgress
.head 2 +  Internal Functions
.head 3 +  Function: SetMassLicense
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Session Handle: hSession
.head 5 -  Number: npFall[*]
.head 5 -  String: sAbtKey
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sLicenseKey
.head 5 -  String: sLicenseRecord 
.head 5 -  Number: nBound
.head 5 -  Number: i
.head 5 -  String: sBackMsg
.head 5 -  Boolean: bOk
.head 5 -  Number: nFetch
.head 5 -  Number: nF
.head 5 -  Sql Handle: hSqlE
.head 5 -  Boolean: bFreeSession
.head 4 +  Actions
.head 5 -  Set bFreeSession = FALSE
.head 5 -  Call SalArrayGetUpperBound ( npFall, 1, nBound ) 
.head 5 +  If nBound = 0 and npFall[0] = 0 
.head 6 -  Return FALSE
.head 5 +  If hSession = hWndNULL 
.head 6 -  Call SqlCreateSession( hSession, "" )
.head 6 -  Set bFreeSession = TRUE
.head 5 -  Call SqlCreateStatement( hSession, hSqlE ) 
.head 5 -  Call SqlPrepareAndExecute(hSqlE,"select f.fall_key from EXP_SPECIES s, fall f, fall_experiment e
			where f.fall_key=:npFall[0] and f.fall_key=e.fall_key
			and e.experiment_key=s.experiment_key and end_date is null
			and s.ABT_KEY=:sAbtKey into :nF")
.head 5 +  If SqlFetchNext(hSqlE, nFetch)
.head 6 -  Call SqlDisconnect(hSqlE)
.head 6 +  If bFreeSession
.head 7 -  Call SqlFreeSession( hSession )
.head 6 -  Return TRUE
.head 5 -  Call SqlDisconnect(hSqlE)
.head 5 +  If bFreeSession
.head 6 -  Call SqlFreeSession( hSession )
.head 5 +  If Not Request_License( sLicenseKey, sLicenseRecord, sAbtKey ) ! and not bPlanningMode
.head 6 -  Return FALSE
.head 5 -  Set i=0
.head 5 +  While i <= nBound
.head 6 +  If npFall[i]  > 0
.head 7 -  If License_AddCaseMsg( sLicenseKey, sLicenseRecord, npFall[i], '', sBackMsg )
.head 6 -  Set i = i + 1
.head 5 -  Return TRUE
.head 3 -  ! move to dyna_request.apl which is locked for the times being
.head 3 +  ! Function: Requst_ListForCageCard
.head 4 -  Description: Shows a dialog with all cages in the rack. On confirmation internal table for cage card is prepared, which consists of selected cages.
Parameters:
	sRackKey		- Stat.Key
Returns:
	TRUE / FALSE	- User has selected cages and pressed Ok / User canceled the action
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 +  Parameters 
.head 5 -  FunctionalVar: cLocations[*]
.winattr class
.head 6 -  Class: clsLocation
.end
.head 5 -  String: sWinTitle
.head 5 -  Receive Boolean: bPrint
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nReturn
.head 5 -  String: sCagesToPrint[*]
.head 4 +  Actions 
.head 5 -  Set nReturn = SalModalDialog( dlgSelectCages, hWndForm, cLocations, sWinTitle )
.head 5 +  If nReturn = 0
.head 6 -  ! user canceled the action
.head 6 -  Return FALSE
.head 5 +  If nReturn = 1
.head 6 -  ! show cage card
.head 6 -  Set bPrint = FALSE
.head 5 +  If nReturn = 2
.head 6 -  ! print cage card
.head 6 -  Set bPrint = TRUE
.head 5 -  Return TRUE
.head 3 -  !
.head 3 +  ! Function: InsertService
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Number: ! 1 - successfully, 0 - don't successfully, WAIT_LITTERWIDGET and WAIT_WEANWIDGET  
.head 4 +  Parameters 
.head 5 -  String: sSrvKey
.head 5 -  String: sSrvName
.head 5 -  String: sTARIF_KEY
.head 5 -  Number: nFallKey
.head 5 -  Date/Time: dtDt
.head 5 -  String: sComment
.head 5 -  String: sAbtKey
.head 5 -  String: sStatKey
.head 5 -  String: sGrpKey
.head 5 -  Boolean: bDone
.head 5 -  Boolean: bCommit
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSql
.head 5 -  Sql Handle: hSqlMax
.head 5 -  Sql Handle: hSqlSample
.head 5 -  Sql Handle: hSqlPreis
.head 5 -  Sql Handle: hSqlLitter
.head 5 -  Boolean: bOK
.head 5 -  Number: nReturn
.head 5 -  String: sSQL
.head 5 -  Number: nNeedsSample
.head 5 -  Number: nNeedsConfirm
.head 5 -  Number: nNeedsLitterId
.head 5 -  Number: nAlertNeedMail
.head 5 -  Number: nMax
.head 5 -  Number: nSampleID
.head 5 -  Number: nLitterID
.head 5 -  String: sLA_KEY
.head 5 -  ! String: sTARIF_KEY
.head 5 -  Boolean: bAnyMail
.head 5 -  Number: nPreis
.head 5 -  String: sCurrKey
.head 5 -  Number: nFetch
.head 4 +  Actions 
.head 5 -  Set bOK = TRUE
.head 5 -  Set nReturn = 1
.head 5 +  If GalConnect(hSql) and GalConnect(hSqlMax) and GalConnect(hSqlSample) and GalConnect(hSqlPreis) and GalConnect(hSqlLitter) 
.head 6 +  ! If SqlPrepareAndExecute(hSql,"select LA_KEY, TARIF_KEY, @NULLVALUE(notify_email,0), @NULLVALUE(needs_med_sample,0), @NULLVALUE(NEEDS_CONFIRM,0) from LEISTUNG where LST_KEY = :sSrvKey into :sLA_KEY, :sTARIF_KEY, 
:nAlertNeedMail, :nNeedsSample, :nNeedsConfirm")
.head 7 -  Call SqlFetchNext(hSql, nTmp)
.head 6 +  If SqlPrepareAndExecute(hSql,"select LA_KEY,  @NULLVALUE(notify_email,0), @NULLVALUE(needs_med_sample,0), @NULLVALUE(NEEDS_CONFIRM,0),@if(@code(s.abr)-@code('U'),0,1) from LEISTUNG l , srv_limit s  where LST_KEY = :sSrvKey 
and s.id = @nullvalue(SRV_LMT_ID,0)  into :sLA_KEY, :nAlertNeedMail, :nNeedsSample, :nNeedsConfirm, :nNeedsLitterId ")
.head 7 -  Call SqlFetchNext(hSql, nTmp)
.head 6 +  Else 
.head 7 -  Set bOK = FALSE
.head 6 -  Set bOK = bOK and SqlPrepareAndExecute(hSqlMax, "select @NULLVALUE(MAX(LST_ERF_NR),0)+1 from LST_ERF where Einricht_ID = :nEinrichtId and Fall_Key = :nFallKey into :nMax")
.head 6 +  If bOK
.head 7 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 6 -  Set bOK = bOK and SqlPrepareAndExecute(hSqlPreis, "select PREIS, CURR_KEY from lst_preis
					         where TARIF_KEY = :sTARIF_KEY
      					            and LST_KEY= :sSrvKey
     					            and EINRICHT_ID = :nEinrichtId
      					            and PRICE_TARIF_KEY = 'INT' 
                                                                       into :nPreis , :sCurrKey")
.head 6 -  Set bOK = bOK and SqlPrepareAndExecute(hSqlLitter, "select @nullvalue(max(l.litter_id),0) from relship_fall rf, relship_rolle rr, litter l
					          where rf.fallrolle_key = rr.fallrolle_key
					             and rr.is_parent='J'
					            and l.FAMILY_relship_id = rf.relship_id
					            and rf.fall_key=:nFallKey
    					            and rf.einricht_id=:nEinrichtId

                                                                       into :nLitterID")
.head 6 +  If bOK
.head 7 -  Call SqlFetchNext(hSqlPreis, nTmp)
.head 6 -  Set bOK = bOK and SqlPrepare(hSqlSample, "Insert into MED_SAMPLE(Einricht_id, Med_Sample_ID ) values (:nEinrichtId, :nSampleID )")
.head 6 -  ! Set bOK = bOK and SqlPrepare(hSqlFilter, "select l.lst_key
  				from  leistung l, fall f, geschlecht g, srv_limit s
				      where l.lst_key=:sSrvKey
        					  and	f.EINRICHT_ID = :nEinrichtId
 					  and	f.FALL_KEY = :nFall
					  and g.geschl_key=f.geschl
                                                                                  and (l.SRV_LMT_ID is null 
                                                                                       or l.SRV_LMT_ID=0 
                                                                                        or (l.SRV_LMT_ID>0 and s.id=l.SRV_LMT_ID and g.geschl_abr=s.abr)) 
                                           
group by 1 ")
.head 6 -  Set sSQL = "insert into LST_ERF(LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR,
			         LST_ERF_VON, STORNIERT,IND_BEGR, GRUPPE_KEY,STAT_KEY, BENUTZER_ID, DONE, MENGE, LST_ERF_BIS, ERF_DATUM, PREIS, CURR_KEY, NACHBERECHNUNG , PRZ"
.head 6 +  If nNeedsSample
.head 7 -  Set sSQL = sSQL||", med_sample_id"
.head 6 +  If nNeedsLitterId
.head 7 -  Set sSQL = sSQL||", litter_id"
.head 6 -  Set sSQL = sSQL||")
values (:sLA_KEY, :sTARIF_KEY, :sSrvKey, :nFallKey, 'N', :nEinrichtId, :nMax, :dtDt, 'N', :sComment, :sGrpKey, :sStatKey, :nUserId, 0, 1, "
.head 6 -  Set sSQL = sSQL||"''"
.head 6 -  Set sSQL = sSQL||",:dtDt, :nPreis , :sCurrKey, 'N' , 100"
.head 6 +  If nNeedsSample
.head 7 -  Set sSQL = sSQL||",:nSampleID"
.head 7 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 7 -  Call SqlExecute(hSqlSample)
.head 6 +  If nNeedsLitterId
.head 7 -  Set sSQL = sSQL||",:nLitterID"
.head 7 -  Call SqlFetchNext( hSqlLitter, nFetch )
.head 6 -  Set sSQL = sSQL||")"
.head 6 -  Set bOK = bOK and SqlPrepareAndExecute(hSql, sSQL)
.head 6 -  ! If nNeedsSample
.head 6 -  ! Call SalArrayGetUpperBound (HandleToPlace, 1, nBound )
.head 6 +  ! If nBound <=0
.head 7 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(hWndKHE.clsKHExplorerLeft.nSelectedHandle, sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 7 +  If hWndKHE.clsKHExplorerLeft.nSelectedLevel=KHEL_Bett
.head 8 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 8 -  Set sGrpKey=""
.head 8 +  If SqlExecute(hSqlMax)
.head 9 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 9 +  If nNeedsSample
.head 10 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 10 -  Call SqlExecute(hSqlSample)
.head 9 +  If SqlExecute(hSql)
.head 10 -  Set bOk = TRUE
.head 10 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 11 -  ! try to prepare message
.head 11 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 7 +  Else 
.head 8 +  If cbApplyParents
.head 9 -  Set nCount = hWndKHE.clsExplorerLeft.EnumChildren( hWndKHE.clsExplorerLeft.nSelectedHandle, nFalls )
.head 9 -  Set bOk = FALSE
.head 9 +  While nCount>0
.head 10 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetFallKey_ByHandle(nFalls[nCount-1])
.head 10 +  If nFall
.head 11 +  If SqlExecute(hSqlMax) and (SqlExecute(hSqlFilter) and SqlFetchNext(hSqlFilter,nTmp))
.head 12 +  If SqlFetchNext(hSqlMax, nTmp)
.head 13 +  If nNeedsSample
.head 14 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 14 -  Call SqlExecute(hSqlSample)
.head 13 +  If SqlExecute(hSql)
.head 14 -  Set bOk = TRUE
.head 14 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 15 -  ! try to preparemessage
.head 15 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 10 -  Set nCount = nCount-1
.head 8 +  Else 
.head 9 -  Set sGrpKey = sGrpKeyStatic
.head 9 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 9 +  If SqlExecute(hSqlMax)
.head 10 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 10 +  If nNeedsSample
.head 11 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 11 -  Call SqlExecute(hSqlSample)
.head 10 +  If SqlExecute(hSql)
.head 11 -  Set bOk = TRUE
.head 11 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 12 -  ! try to preparemessage
.head 12 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 6 +  ! Else
.head 7 -  Set nI = 0
.head 7 +  While nI<= nBound
.head 8 -  Set nFall = HandleToPlace[nI,0]
.head 8 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(HandleToPlace[nI,1], sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 8 +  If nFall
.head 9 -  Set bOk = FALSE
.head 9 +  If SqlExecute(hSqlMax)
.head 10 +  If SqlFetchNext(hSqlMax, nTmp)
.head 11 +  If nNeedsSample
.head 12 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 12 -  Call SqlExecute(hSqlSample)
.head 11 +  If SqlExecute(hSql)
.head 12 -  Set bOk = TRUE
.head 12 -  Call hWndKHE.clsKHExplorerLeft.PopulateAndExpand(HandleToPlace[nI,1], TRUE)
.head 12 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 13 -  ! try to preparemessage
.head 13 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 8 -  Set nI=nI+1
.head 6 +  If bDone ! or Check_Medical_Records( nFallKey, nMax )
.head 7 -  Set nReturn = DoneService( sSrvKey, nFallKey, nMax, dtDt, bCommit )
.head 6 +  ! Else
.head 7 -  Set nReturn = 0
.head 6 +  If bOK ! 
.head 7 +  If bCommit
.head 8 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 7 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 8 -  ! try to preparemessage
.head 8 -  Set bAnyMail = PrepareAlertMail( nFallKey, sAbtKey, sStatKey, sGrpKey, sSrvKey,sSrvName, sComment, dtDt, hSql )or bAnyMail
.head 7 -  Set nReturn = 1
.head 6 +  Else 
.head 7 -  Call SqlPrepareAndExecute(hSql, "rollback")
.head 7 -  Set nReturn = 0
.head 6 -  Call SqlDisconnect(hSql)
.head 6 -  Call SqlDisconnect(hSqlMax)
.head 6 -  Call SqlDisconnect(hSqlSample)
.head 6 -  Call SqlDisconnect(hSqlPreis)
.head 6 -  Call SqlDisconnect(hSqlLitter)
.head 5 +  Else 
.head 6 -  Set nReturn = 0
.head 5 -  Return nReturn
.head 3 +  ! Function: DoneService
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Number: ! 1 - successfully, 0 - don't successfully, WAIT_LITTERWIDGET and WAIT_WEANWIDGET  
.head 4 +  Parameters 
.head 5 -  String: sLstKey
.head 5 -  Number: nFallKey
.head 5 -  Number: nLstErfNr
.head 5 -  Date/Time: dtDt
.head 5 -  Boolean: bCommit
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSql
.head 5 -  Number: nAct
.head 5 -  Number: nReturn
.head 4 +  Actions 
.head 5 -  Set nReturn = 1
.head 5 +  If not GalConnect(hSql)
.head 6 -  Set nReturn = 0
.head 5 +  If nReturn = 1
.head 6 -  Call SqlPrepare( hSql, "update lst_erf set done = 1, lst_erf_bis = :dtDt where lst_key = :sLstKey and fall_key = :nFallKey and lst_erf_nr = :nLstErfNr")
.head 6 -  Set nReturn = SalSendMsg( hWndStar2000, AM_AfterDoneService, 0, SalHStringToNumber ( SalNumberToStrX( nFallKey, 0 )  || ";" || SalNumberToStrX( nLstErfNr, 0 ) )  )
.head 6 +  If nReturn = 1 and Check_Medical_Records( nFallKey, nLstErfNr )
.head 7 -  ! Set nAct = SalMessageBox( "There are medical records left without contents. Do you want to open them before marking service as DONE ?", "MR for Services ?",  MB_YesNoCancel )
.head 7 -  ! If nAct = IDYES
.head 7 -  Call Show_Medical_Records( nFallKey, nLstErfNr )
.head 7 -  Set nReturn = 0
.head 7 +  ! Else If nAct = IDNO
.head 8 -  Call SqlExecute( hSql )
.head 8 -  Call SqlCommit( hSql )
.head 6 +  ! Else
.head 7 -  Call SqlExecute( hSql )
.head 7 -  Call SqlCommit( hSql )
.head 6 +  If nReturn = 1  ! or nReturn = 
.head 7 -  Call SqlExecute( hSql )
.head 7 +  If bCommit
.head 8 -  Call SqlCommit( hSql )
.head 6 -  Call SqlDisconnect(hSql)
.head 5 -  Return nReturn
.head 3 +  ! Function: PrepareAlertMail
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 +  Parameters 
.head 5 -  Number: nFall
.head 5 -  String: sAbt
.head 5 -  String: sRack
.head 5 -  String: sCage
.head 5 -  String: sServKey
.head 5 -  String: sSrvName
.head 5 -  String: sComment
.head 5 -  Date/Time: dtDt
.head 5 -  Receive Sql Handle: hSql
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nFetch
.head 5 -  Number: nMesID
.head 5 -  Boolean: bResult
.head 5 -  String: sRec
.head 5 -  String: sRecBox
.head 5 -  String: sRecStr
.head 5 -  String: sRecBoxStr
.head 5 -  String: sSubject
.head 5 -  Long String: sBody
.head 5 -  String: sOldChair
.head 4 +  Actions 
.head 5 -  Set sLogicalChain='E-MAIL'
.head 5 -  Set sRecStr = ""
.head 5 -  Set sRecBoxStr = ""
.head 5 +  If SqlPrepareAndExecute(hSql, "select a.name1, a.email
from fall_experiment e, exp_zus_adresse ea, adresse a
where 
e.fall_key = :nFall
and e.einricht_id = :nEinrichtId
and e.experiment_key = ea.experiment_key
and e.einricht_id = ea.einricht_id
and ea.adresse_id = a.adresse_id
and ea.takealerts = 1
and a.email is not null into :sRec, :sRecBox")
.head 6 +  While SqlFetchNext(hSql, nFetch)
.head 7 -  Set sRecStr = sRecStr||sRec||","
.head 7 -  Set sRecBoxStr = sRecBoxStr||sRecBox||","
.head 6 -  Call SqlPrepareAndExecute(hSql, "select email from abteilung where abt_key = :sAbt into :sRec")
.head 6 +  If SqlFetchNext(hSql, nFetch)
.head 7 -  Set sRecStr = ","||sRecStr
.head 7 -  Set sRecBoxStr = sRec||","||sRecBoxStr
.head 6 +  If sRecBoxStr
.head 7 -  Set sRecStr = SalStrLeftX(sRecStr, SalStrLength(sRecStr)-1)
.head 7 -  Set sRecBoxStr = SalStrLeftX(sRecBoxStr, SalStrLength(sRecBoxStr)-1)
.head 7 -  ! Call SqlPrepareAndExecute(hSql, "select max(id)+1 from email into :nMesID")
.head 7 -  ! Call SqlFetchNext(hSql, nFetch)
.head 7 -  Set nMesID=SalStrToNumber(GetNewKey( "EMAIL", "ID" ) )
.head 7 -  Set sLogicalChain=sOldChair
.head 7 +  If nMesID = NUMBER_Null 
.head 8 -  Set nMesID = 0
.head 7 -  Call SqlPrepareAndExecute(hSql, "select benutzer_name from benutzer where benutzer_id = :nUserId into :sRec")
.head 7 -  Call SqlFetchNext(hSql, nFetch)
.head 7 -  Set sSubject = sServKey ||" ALERT is setted for Fall "||SalNumberToStrX(nFall, 0)
.head 7 -  Call SalDateToStr(dtDt, sRecBox)
.head 7 -  Set sBody = sServKey ||" ("||sSrvName||")
Screen: "||sAbt||"
Rack: "||sRack||"
Cage: "||sCage||"
Raised by "||sRec||" at "||sRecBox||"
With comment: "||sComment
.head 7 +  If SqlPrepareAndExecute(hSql, "insert into email values (:nMesID, :sRecStr, :sRecBoxStr, :sSubject, :sBody, :nUserId, :dtDt, 0,0)")
.head 8 -  Set bResult = TRUE
.head 5 -  Return bResult
.head 3 +  ! Function: DoneServiceWithoutCheck
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 +  Parameters 
.head 5 -  String: sLstKey
.head 5 -  Number: nFallKey
.head 5 -  Number: nLstErfNr
.head 5 -  Date/Time: dtDt
.head 5 -  Boolean: bCommit
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSql
.head 5 -  Number: nAct
.head 5 -  Boolean: bOk
.head 4 +  Actions 
.head 5 -  Set bOk = TRUE
.head 5 +  If not GalConnect(hSql)
.head 6 -  Set bOk = FALSE
.head 5 +  If bOk
.head 6 -  Call SqlPrepareAndExecute( hSql, "update lst_erf set done = 1, lst_erf_bis = :dtDt where lst_key = :sLstKey and fall_key = :nFallKey and lst_erf_nr = :nLstErfNr")
.head 6 +  If Check_Medical_Records( nFallKey, nLstErfNr )
.head 7 -  ! Set nAct = SalMessageBox( "There are medical records left without contents. Do you want to open them before marking service as DONE ?", "MR for Services ?",  MB_YesNoCancel )
.head 7 -  ! If nAct = IDYES
.head 7 -  Call Show_Medical_Records( nFallKey, nLstErfNr )
.head 7 -  Set bOk = 0
.head 7 +  ! Else If nAct = IDNO
.head 8 -  Call SqlExecute( hSql )
.head 8 -  Call SqlCommit( hSql )
.head 6 +  If bOk
.head 7 -  Call SqlExecute( hSql )
.head 7 +  If bCommit
.head 8 -  Call SqlCommit( hSql )
.head 6 -  Call SqlDisconnect(hSql)
.head 5 -  Return bOk
.head 3 +  ! Function: OpenService
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 +  Parameters 
.head 5 -  Number: nFallKey
.head 5 -  Number: nLstErfNr
.head 5 -  Boolean: bCommit
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSql
.head 5 -  Boolean: bOk
.head 4 +  Actions 
.head 5 -  Set bOk = TRUE
.head 5 +  If not GalConnect(hSql)
.head 6 -  Set bOk = FALSE
.head 5 +  If bOk
.head 6 -  Call SqlPrepareAndExecute( hSql, "update lst_erf set done = 0, lst_erf_bis = null where  fall_key = :nFallKey and lst_erf_nr = :nLstErfNr")
.head 6 -  Call SqlExecute( hSql )
.head 6 +  If bCommit
.head 7 -  Call SqlCommit( hSql )
.head 6 -  Call SqlDisconnect(hSql)
.head 5 -  Return bOk
.head 3 +  ! Function: CancelService
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 +  Parameters 
.head 5 -  Number: nFallKey
.head 5 -  Number: nLstErfNr
.head 5 -  Boolean: bCommit
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSql
.head 5 -  Boolean: bOk
.head 4 +  Actions 
.head 5 -  Set bOk = TRUE
.head 5 +  If not GalConnect(hSql)
.head 6 -  Set bOk = FALSE
.head 5 +  If bOk
.head 6 -  Call SqlPrepareAndExecute( hSql, "update lst_erf set STORNIERT='Y' where  fall_key = :nFallKey and lst_erf_nr = :nLstErfNr")
.head 6 -  Call SqlExecute( hSql )
.head 6 +  If bCommit
.head 7 -  Call SqlCommit( hSql )
.head 6 -  Call SqlDisconnect(hSql)
.head 5 -  Return bOk
.head 2 +  Named Menus
.head 2 +  Class Definitions
.data RESOURCE 0 0 1 3691459312
0000: FA190000AC100000 0000000000000000 0200002D00FFFF01 00160000436C6173
0020: 73566172004F7574 6C696E6552006567 496E666F4A003C00 001163006C734B48
0040: 4578706C006F7265 724C65667400F400 0000080000000F19 00000001017C059E
0060: 0100000E00730000 00B4010000194100 0400000003A07C05 9F0100009B730001
0080: 0D001D0000009619 00017CE8A0010000 4673000100008336 000000040500027C
00A0: 059C1EB800000073 D9000100603A0000 0004008D029D1E00 6E0073003601003E
00C0: 00580000040002A3 9E1E00009B730001 0D0042000000D604 0002E89F1E000066
00E0: 7300010083460000 0004350002F223B8 00000073D9000100 0001801000000001
0100: 00210008636C4E65 007746457C000000 047B00046B000290 701500000073B300
0120: 0100CD0400041A00 02911500DD00736C 00010008B2000004 0046029215000037
0140: 7300011B000C0000 AC00040002D19315 0000CD7300010600 01807D0000000002
0160: 0000000D63520061 64696F4C69737400 426F789A00000005 78000000194B0001
0180: 7C06180000005E07 73A20000010000CD 1900191200017C07 0000F6005E680001
01A0: 000032B000000019 00A4017C0800003D 5E00011A00004B00 002C001900017C61
01C0: 090000005E8F0001 0006006400000019 4B00017C0AD80000 005EA30001000001
01E0: 0180680000000340 0000000C636C5300 716C48616E646C65 649A000005006F19
0200: 0049017C05000043 1E0B730000B40100 00195900040003DA 7C06009E1E00016D
0220: 001D00961900017C B607001E47000100 009B360019A50001 7C08ED001ED10001
0240: 0000604F00000019 0069017C09007B1E 0034010000018064 1900000400080F63
0260: 6C47656E65007261 6C4669656C644022 0000000100006F19 0069017C07006372
0280: 0B73003401000001 8064040000050008 12636C446174611C 466950726F207065
02A0: 72220000017A0000 044B00027C061B00 D20B73B300010021 01801D0000061200
02C0: 000C44465F004D75 746174696F6E4040 0000000200000F88 00000031077C0501
02E0: 00405648C20C7300 00B2010000045900 190001DA7C08001C C20C0001000D0001
0300: 809E001000000700 001463026C526163 6B32440056696577 4D616E6120676572
0320: F40000087B00044B 00027C051B00FC17 73A20000010000CD 0400045A00020600
0340: F600FC6C00010008 B3001900B0017C05 070039FC1700011A 00002100002C0019
0360: 00017C6C050800FC 8E1700010036003A 00190B00017C0509 9B00FC17A3000100
0380: 00C15300000019C2 00017C050AE600FC 1768000100006CB0 000000190080017C
03A0: 050B00000039FC17 00011A0000850000 2C001900017C6805 0C0000FC8E170001
03C0: 008600018036000C 00080016636C0950 726772657306736C 7565486F006C6465
03E0: 725E000000F40300 00161900017C0536 0500261844730000 0100009B190019A5
0400: 00017C06ED0026D1 0001000066320004 0069037C08007B26 0036010001804020
0420: 0000000900000E12 546F6F6C00626172 5365747469406E67 73140100087B0004
0440: 430001027C2DF800 00000F80010000FE 00CD0400041C0001 2E0000FE00938001
0460: 00007F0833000400 01872F000000FFE4 800100009F0C00CC 00040001E1300000
0480: 003F8001F9000027 100000046B000331 18000000321873A3 00010000C1140000
04A0: 00049A00033200F6 00326C00010018B0 0000000400860333 0000003D3200011B
04C0: 001C0000AC000400 03613400000032CF 0001860001800800 08000A000006636C
04E0: 41504F43400000F4 020000D604000336 0500B01B44730000 0100009B040004A5
0500: 00027C06ED00B0D9 0001000001809700 00000B0049000F50 4F50007265666572
0520: 656E63206573B002 001600BC000019A5 00017C078D00C81B 73D1000100006619
0540: 0004006D0209007B C800B601001D5900 040002DB0A009EC8 00016D0021009619
0560: 00017CB60B00C847 000100009B3A0004 B500020CED00C8D9 000100663E000400
0580: 0D030D0000007BC8 00B6010042590004 0003C30E0000009E C800016D00460096
05A0: 3A00077C08100001 5828C81B27000100 00934A00003A3500 071200FA0158C900
05C0: 010000604E000000 3A008D071400017E 5800320100005200 5800003A0007A316
05E0: 0001589F00010C00 0056000000D63A00 07E8180001582700 010000835A000000
0600: 3A3500071A00FA01 58C900010000645E 00003A008D071C00 017E580032010000
0620: 62005800003A0007 A31E0001589F0001 0C000066000000D6 3A0007E820000158
0640: 2700010000836A00 0000192500017C22 00ED00C8D1000100 0060830000003A00
0660: 8D072400017E5800 3201000087001800 003A000107827C26 0001005878000000
0680: 80F20100000F8B00 0000C63A00010760 2800010058009E00 8001FC0000838F00
06A0: 00003A310001072A 00B8010058002780 010000FF60930000 0004006D032D007B
06C0: C800360100018066 04000C00020F6650 6F696E74BC536567 402A000000010000
06E0: 6F21000C01071B00 0100E0B81C000000 C9800100003F0180 461D000D00006819
0700: 636C476505615461 626C650042726F77 73654D6110726B40 000002003D001900
0720: A500017C060D006E 217300D100010000 66190004006D0307 007B6E0036010001
0740: 804636000E00000E 114368696CB86454 614D135E00000300 BD0019A500017C0A
0760: 8D008C2173D10001 0000661900040069 037C0B007B8C00B6 01001D5900190001
0780: DA7C0D001E8C0001 000D000180320001 000F000000106302 6C446C6752657000
07A0: 6F7274576F726440 B200000200B71900 A4017C68000031FE 21730001DA000019
07C0: 2C001900017C6169 000000FE8F000100 C60001801D000010 0000000B636C0142
07E0: 61736963576ECC64 400002DE0004DA00 0305860044247300 680001000004B300
0800: 1900B4017C06003D 4400011A00000180 1D0300110000000A 0063436F6D626F48
0820: 65906C7040000002 BD0004B50003070D 00E0277300D10001 0000660400190069
0840: 017C08007BE00034 0100000180002900 0000120000001005 634461619A00D100
0860: 0500005B040003DB 050018FE27730001 006D000400D60400 03B60600FE670001
0880: 009B080004B50003 07ED00FED9000100 660C0004006D0308 007BFE00B6010010
08A0: 5900190001DA7C0A 001EFE0001008D00 0180048100130000 000B005363726565
08C0: 6E44611322000001 00BD0004B5000306 0D0016287300D900 0100980180040014
08E0: E000000963527C44 6100F4010000D604 0003370022286673 0001006301800400
0900: 24150000094361F2 674461D100010000 5B040003DF00982E 287300018D000180
0920: 190100160000000D 63126C53655F6E5F 48547265220000F4 010000961900017C
0940: F045000000467300 0100006301801900 80170000000E636C 01697A6572656449
0960: 2074656D22000001 7A0000194B00017C 061B00404073A200 00010000010180B2
0980: 000000184100000C 636C570046456C65 6D656E74488A0100 0D00006F19006901
09A0: 7C05004306477300 00B4010000195900 040002DA7C06009E 0600016D001D00D6
09C0: 040002B607000667 0001009B210019A5 00017C08ED0006D1 00010000663A0019
09E0: 0069017C09007B06 00B4010000535900 190001DA7C0A001E 060001006D006C00
0A00: D6040002B60B0006 6700010083700000 0019A500017C0CED 0006D10001000060
0A20: 8900000004006D03 16007B0600360100 8D00580000040003 D31700009E060001
0A40: 0D0091000000D604 0003B61800066700 0100839500000004 3500071900C20112
0A60: 470647C900010000 2099000000190000 69017C22007B0600 340100000180642D
0A80: 000019005A0B6C6F 6B00666C6F77B800 0000F4060000D604 0002B60700124673
0AA0: 000100009B040004 B500020CED0012D9 0001006608000400 6D020D007B120036
0AC0: 01000C0059000400 02DB09009E120001 6D001000D6040002 B60A001267000100
0AE0: 9B140019A500017C 08ED0012D1000100 0018018004001A00 0000000C6345696E
0B00: 720069636874756E 6722A20000010000 B70400B603060021 7049730000011B00
0B20: 01800403001B0000 00071C6353656E22 A20000010000B704 00BE0300317C4973
0B40: 00011B0001800433 001C00059C635222 00E800010000AD04 00036F0088CC4973
0B60: 0001C6000180044C 001D000543372200 017A000004EB0003 1B00944973B30001
0B80: 002101800C00001E 100000000546616C 886C5E00000300DE 0004F200037CC600
0BA0: A049736800010000 04B3000400B60307 003DA00001DB0008 AC000400036D0800
0BC0: A0CF0001C6000180 0840001F00000007 4D88617469674000 E800020000AD0400
0BE0: 036D0600AC8C4973 0001003600040004 6B000307DB00ACB3 0001003101800400
0C00: 2010000000074C69 7430746572220001 7A0000046B000306 1B00B84973B30001
0C20: 0021018066000021 13000E474D501A72 66656E63A3C60100 0FBD0019A500017C
0C40: 078D00D04973D100 0100006619000400 69027C09007BD000 B601001D59000400
0C60: 02DB0A009ED00001 6D00210096190001 7CB60B00D0470001 00009B3A0004B500
0C80: 020CED00D0D90001 00663E0004006D03 0D007BD000B60100 425900040003DB0E
0CA0: 009ED000016D0046 00963A00077C2A10 0158D04927000100 009B4A003AB50007
0CC0: 12FA0158C9000100 00664E003A00AD07 14017E5800B20100 005259003A0007AB
0CE0: 1601589F00016C00 005600D63A0007EA 1801582700010000 9B5A003AB500071A
0D00: FA0158C900010000 665E003A00AD071C 017E5800B2010000 6259003A0007AB1E
0D20: 01589F00018C0000 0180049100220000 0E326C46614372C0 6561746F7222E800
0D40: 010000AD04000369 4E0000CCC84A7300 0001C60001800408 0023000008635080
0D60: 69637475726522D1 000100005B040002 DB060090C84B7300 00018D0001800481
0D80: 00240000000A004D 44494F7074696F8D 22000100DE0004DA 000219DE00736C00
0DA0: 0100010C80040025 0000200006634669 6C64462200010000 6F0400AD07060140
0DC0: CC4D7C4C73000032 0100000180042500 00260000000C0D63 436F6C6C30656374
0DE0: 697C00D90004005B 040003DB050010BA 4D73000001006D00 0400D6040003B206
0E00: 0000BA6700010093 08000004B5000307 ED00BAD900010064 0C0000190061047C
0E20: 0508007BBA003601 0001800619002700 0000800C63475549 53658874696E7322
0E40: 00E8000100002D19 00017C6F00CC8D73 000100C600018036 48002800000B4700
0E60: 6C6F62616C566172 88735E000003009E 000400FA0002C600 D24D736800010000
0E80: 04B3001900B4017C 07003DD20001DA00 001D2C001900017C 6D0B00D28F000100
0EA0: 0600018013010009 2900000F63440065 736B746F704C691A 73424E0100E90B00
0EC0: 002D1900017C6D07 00DE885073000001 0036001900194B00 017C08DB00DEA300
0EE0: 010000C932000019 D200017C09F600DE 68000100004BB300 1900B4017C0A003D
0F00: DE0001DA0000642C 001900017C6D0B00 DE8F00010026007D 0000194B00017C0C
0F20: DB00DEA300010000 C19600000019D200 017C0DF600DE6800 010000AFB0000000
0F40: 1900B4017C0E003D DE00011A0000C800 002C001900017C69 0F0000DE8F000100
0F60: 0600E1000000194B 00017C10D90000DE A300010000C1FA00 0000199200017C11
0F80: 00F600DE68000100 000188806400002A 0000000B63446972 4C699F7C00EC0004
0FA0: 002D1900017C6D07 00F08C5073000100 36001900194B0001 7C08DB00F0A30001
0FC0: 0000CD320019D200 017C09F600F06800 0100004BB3001900 B4017C0A003DF000
0FE0: 011A000001804B02 00002B0000000F4F 5472657C4C695EB2 00000300B71900B4
1000: 017C070021025173 000001DA0000192C 001900017C6D0800 028F000100360032
1020: 00194B00017C09DB 0002A30001000021 0180AF00002C5000 00000C466CFC654C
1040: 40D6000000070000 6F190069017C0600 6326517300B40100 00195900190001DA
1060: 7C07001E26000100 6D00320096190001 7CB6080026470001 00009B4B0019A500
1080: 017C09ED0026D100 0100006664001900 69017C0A007B2600 B40100007D590019
10A0: 0001DA7C0B001E26 0001006D00960096 1900017CB60C0026 470001000003
.enddata
.head 3 +  Functional Class: clsSerialIterator
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Number: i
.head 4 +  Functions
.head 5 +  Function: Next
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set i = i + 1
.head 7 -  Return i
.head 5 +  Function: Current
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return i
.head 5 +  Function: Initialize
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: n
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set i = n
.head 7 -  Return TRUE
.head 3 +  List Box Class: clsExplorerLeft
.head 4 -  Window Location and Size
.head 5 -  Left:
.head 5 -  Top:
.head 5 -  Width:  1.2"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.833"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Multiple selection? Class Default
.head 4 -  Sorted? Class Default
.head 4 -  Vertical Scroll? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  List in Tool Palette? Yes
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cOutlineListBox
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Boolean: bAutoScan
.head 5 -  Boolean: bRealTimeMode
.head 5 -  Boolean: bRefreshParentPics
.head 5 -  FunctionalVar: oPosition
.head 6 -  Class: cPositionData
.head 5 -  !
.head 5 -  Number: nSelectedItem
.head 5 -  Number: nSelectedHandle
.head 5 -  Number: nSelectedLevel
.head 5 -  String: sSelectedAbtKey
.head 5 -  String: sSelectedStatKey
.head 5 -  String: sSelectedGrpKey
.head 5 -  String: sSelectedBettKey
.head 5 -  !
.head 5 -  Number: nColorM
.head 5 -  Number: nColorW
.head 5 -  !
.head 5 -  Number: hRoot
.head 5 -  Number: hResult
.head 5 -  Number: hMail
.head 5 -  !
.head 5 -  Number: nLoadPics
.head 5 -  Number: hPicKHEL_Einrichtung
.head 5 -  Number: hPicKHEL_EinrichtungCL
.head 5 -  Number: hPicKHEL_Abteilung
.head 5 -  Number: hPicKHEL_AbteilungCL
.head 5 -  Number: hPicKHEL_Station
.head 5 -  Number: hPicKHEL_StationCL
.head 5 -  Number: hPicKHEL_StationVirt
.head 5 -  Number: hPicKHEL_StationCLVirt
.head 5 -  Number: hPicKHEL_Gruppe
.head 5 -  Number: hPicKHEL_GruppeCL
.head 5 -  Number: hPicKHEL_StationG
.head 5 -  Number: hPicKHEL_StationCLG
.head 5 -  Number: hPicKHEL_GruppeG
.head 5 -  Number: hPicKHEL_GruppeCLG
.head 5 -  Number: hPicKHEL_Bett_M
.head 5 -  Number: hPicKHEL_Bett_F
.head 5 -  Number: hPicKHEL_Bett_M_Select
.head 5 -  Number: hPicKHEL_Bett_F_Select
.head 5 -  Number: hPicKHEL_BettGrey
.head 5 -  Number: hPicKHEL_BettGrey_Select
.head 5 -  !
.head 5 -  Number: hPicAtlantaExpanded
.head 5 -  Number: hPicAtlantaCollapsed
.head 5 -  Number: hPicFolderExpanded
.head 5 -  Number: hPicFolderCollapsed
.head 5 -  Number: hPicFolderFree
.head 5 -  Number: hPicFolderUnknown
.head 5 -  Number: hPicFall
.head 5 -  Number: hPicMail
.head 5 -  Number: hPicNewMail
.head 5 -  Number: hPicClockW
.head 5 -  Number: hPicClockR
.head 5 -  Number: hPicClockY
.head 5 -  Date/Time: dtTime
.head 5 -  Number: hPicKHEL_Gruppe_A
.head 5 -  Number: hPicKHEL_GruppeCL_A
.head 5 -  Number: hPicKHEL_GruppeG_A
.head 5 -  Number: hPicKHEL_GruppeCLG_A
.head 5 -  Number: hPicKHEL_Gruppe_A_RF
.head 5 -  Number: hPicKHEL_Bett_M_A
.head 5 -  Number: hPicKHEL_Bett_F_A
.head 5 -  Number: hPicKHEL_Bett_M_Select_A
.head 5 -  Number: hPicKHEL_Bett_F_Select_A
.head 5 -  Number: hPicKHEL_GruppeCL_A_RF
.head 5 -  Number: hPicKHEL_GruppeG_A_RF
.head 5 -  Number: hPicKHEL_GruppeCLG_A_RF
.head 5 -  Number: hPicKHEL_Gruppe_RF
.head 5 -  Number: hPicKHEL_GruppeCL_RF
.head 5 -  Number: hPicKHEL_GruppeG_RF
.head 5 -  Number: hPicKHEL_GruppeCLG_RF
.head 5 -  Number: hPicKHEL_Gruppe_A_CCU
.head 5 -  Number: hPicKHEL_GruppeCL_A_CCU
.head 5 -  Number: hPicKHEL_GruppeG_A_CCU
.head 5 -  Number: hPicKHEL_Gruppe_A_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeCLG_A_CCU
.head 5 -  Number: hPicKHEL_GruppeCL_A_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeCLG_A_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeG_A_RF_CCU
.head 5 -  Number: hPicKHEL_Gruppe_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeCL_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeG_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeCLG_RF_CCU
.head 5 -  Number: hPicKHEL_Gruppe_CCU
.head 5 -  Number: hPicKHEL_GruppeCL_CCU
.head 5 -  Number: hPicKHEL_GruppeG_CCU
.head 5 -  Number: hPicKHEL_GruppeCLG_CCU
.head 5 -  Number: hPicKHEL_Bett_M_D
.head 5 -  Number: hPicKHEL_Bett_F_D
.head 5 -  Number: hPicKHEL_Bett_M_Select_D
.head 5 -  Number: hPicKHEL_Bett_F_Select_D
.head 5 -  Number: hPicKHEL_Bett_M_A_D
.head 5 -  Number: hPicKHEL_Bett_F_A_D
.head 5 -  Number: hPicKHEL_Bett_M_Select_A_D
.head 5 -  Number: hPicKHEL_Bett_F_Select_A_D
.head 5 -  Number: hPicKHEL_Bett_F_L
.head 5 -  Number: hPicKHEL_Bett_F_Select_L
.head 5 -  Number: hPicKHEL_Bett_F_A_L
.head 5 -  Number: hPicKHEL_Bett_F_Select_A_L
.head 5 -  Number: hPicKHEL_Bett_F_D_L
.head 5 -  Number: hPicKHEL_Bett_F_Serv_D_L
.head 5 -  Number: hPicKHEL_Bett_F_Alert_D_L
.head 5 -  Number: hPicKHEL_Bett_F_D_SL
.head 5 -  Number: hPicKHEL_Bett_F_Serv_D_SL
.head 5 -  Number: hPicKHEL_Bett_F_Alert_D_SL
.head 5 -  Boolean: bShouPics
.head 5 -  Number: hPicKHEL_GruppeG_CD
.head 5 -  Number: hPicKHEL_GruppeCLG_CD
.head 5 -  Number: hPicKHEL_GruppeG_A_CD
.head 5 -  Number: hPicKHEL_GruppeCLG_A_CD
.head 5 -  Number: hPicKHEL_GruppeG_A_RF_CD
.head 5 -  Number: hPicKHEL_GruppeCLG_A_RF_CD
.head 5 -  Number: hPicKHEL_GruppeG_RF_CD
.head 5 -  Number: hPicKHEL_GruppeCLG_RF_CD
.head 5 -  Number: hPicKHEL_Gruppe_SR
.head 5 -  Number: hPicKHEL_GruppeCL_SR
.head 5 -  Number: hPicKHEL_GruppeG_SR
.head 5 -  Number: hPicKHEL_GruppeCLG_SR
.head 5 -  Number: hPicKHEL_Gruppe_SR_RF
.head 5 -  Number: hPicKHEL_Bett_M_SR
.head 5 -  Number: hPicKHEL_Bett_F_SR
.head 5 -  Number: hPicKHEL_Bett_M_Select_SR
.head 5 -  Number: hPicKHEL_Bett_F_Select_SR
.head 5 -  Number: hPicKHEL_GruppeCL_SR_RF
.head 5 -  Number: hPicKHEL_GruppeG_SR_RF
.head 5 -  Number: hPicKHEL_GruppeCLG_SR_RF
.head 5 -  Number: hPicKHEL_Gruppe_SR_CCU
.head 5 -  Number: hPicKHEL_GruppeCL_SR_CCU
.head 5 -  Number: hPicKHEL_GruppeG_SR_CCU
.head 5 -  Number: hPicKHEL_Gruppe_SR_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeCLG_SR_CCU
.head 5 -  Number: hPicKHEL_GruppeCL_SR_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeCLG_SR_RF_CCU
.head 5 -  Number: hPicKHEL_GruppeG_SR_RF_CCU
.head 5 -  Number: hPicKHEL_Bett_M_SR_D
.head 5 -  Number: hPicKHEL_Bett_F_SR_D
.head 5 -  Number: hPicKHEL_Bett_M_Select_SR_D
.head 5 -  Number: hPicKHEL_Bett_F_Select_SR_D
.head 5 -  Number: hPicKHEL_Bett_F_SR_L
.head 5 -  Number: hPicKHEL_Bett_F_Select_SR_L
.head 5 -  Number: hPicKHEL_GruppeG_SR_CD
.head 5 -  Number: hPicKHEL_GruppeCLG_SR_CD
.head 5 -  Number: hPicKHEL_GruppeG_SR_RF_CD
.head 5 -  Number: hPicKHEL_GruppeCLG_SR_RF_CD
.head 5 -  Number: hPicKHEL_GruppeOCCUP
.head 5 -  Number: hPicKHEL_Gruppe_ROL
.head 5 -  Number: hPicKHEL_GruppeCL_ROL
.head 5 -  Number: hPicKHEL_Gruppe_ROL_SR
.head 5 -  Number: hPicKHEL_GruppeCL_ROL_SR
.head 5 -  Number: hPicKHEL_Gruppe_ROL_SR_RF
.head 5 -  Number: hPicKHEL_GruppeCL_ROL_SR_RF
.head 5 -  Number: hPicKHEL_Gruppe_ROL_A
.head 5 -  Number: hPicKHEL_GruppeCL_ROL_A
.head 5 -  Number: hPicKHEL_Gruppe_ROL_A_RF
.head 5 -  Number: hPicKHEL_GruppeCL_ROL_A_RF
.head 5 -  Number: hPicKHEL_Gruppe_ROL_RF
.head 5 -  Number: hPicKHEL_GruppeCL_ROL_RF
.head 5 -  Sql Handle: hSqlQuantityEB
.head 5 -  Sql Handle: hSqlIsAlertCage
.head 5 -  Sql Handle: hSqlIsAlertBett
.head 5 -  Sql Handle: hSqlIsCadavers
.head 5 -  Sql Handle: hSqlIsDead
.head 5 -  Sql Handle: hSqlIsLitter
.head 5 -  Sql Handle: hSqlIsOccupied
.head 5 -  Sql Handle: hSqlIsRFID
.head 5 -  Number: nPrepareError
.head 5 -  FunctionalVar: cFilterRack
.head 6 -  Class: clsSF_FilterDialog
.head 5 -  Boolean: bMiniSolution
.head 5 -  Number: nSaveSelectedLevel
.head 5 -  !
.head 5 -  Number: hFontCommon
.head 5 -  Number: hFontRacks
.head 5 -  Number: hFontCages
.head 5 -  Number: hFontBetts
.head 5 -  Number: hFontBettsSummary
.head 5 -  !
.head 5 -  Number: hExpanded[*,2]
.head 4 +  Functions
.head 5 +  Function: KHEAddChild
.head 6 -  Description: Returns a Handle of the loaded child if successful, or zero if an error occurs
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hParent
.head 7 -  Number: hPicture
.head 7 -  String: sLabel
.head 7 -  Number: nFlags
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hChild
.head 6 +  Actions
.head 7 -  Set hChild =  LoadChild( hParent, hPicture, hPicture, sLabel, nFlags, 0)
.head 7 -  Return hChild
.head 5 -  !
.head 5 +  Function: KHEGetHasFall
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLevelLoc
.head 6 +  Actions
.head 7 +  If not KHE_IsOccupied_ByHandle( nSelectedHandle, DATETIME_Null)
.head 8 +  If GetLevel( hpItem )= KHEL_Bett
.head 9 -  Return SalStrScan( GetItemText( hpItem ), "-" ) >= 0      
.head 8 +  Else
.head 9 -  Return SalStrScan( GetItemText( hpItem ), "[+]" ) >= 0
.head 7 -  Return FALSE
.head 5 +  Function: KHEVirtual
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return SalStrScan( GetItemText( hpItem ), " [V]" ) >= 0
.head 5 +  Function: KHEGetHasFall_Sex
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLevelLoc
.head 6 +  Actions
.head 7 +  If GetLevel( hpItem )= KHEL_Bett
.head 8 -  Return SalStrScan( GetItemText( hpItem ), ", M," ) >= 0      
.head 7 +  Else
.head 8 -  Return SalStrScan( GetItemText( hpItem ), ", F," ) >= 0      
.head 5 +  Function: KHEBett_IsHasFall
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return SalStrScan( GetItemText( hpItem ), "-" ) >= 0      
.head 5 +  Function: KHESetHasFall
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  Boolean: bHas
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sLabel
.head 7 -  Number: hParent
.head 7 -  Number: nLevelLoc
.head 6 +  Actions
.head 7 -  Set sLabel = GetItemText( hpItem )
.head 7 +  If bHas
.head 8 -  Set nLevelLoc = GetLevel( hpItem )
.head 8 +  If nLevelLoc != KHEL_Bett
.head 9 +  If SalStrScan( sLabel, "[+]" ) < 0
.head 10 -  Call SetItemText( hpItem, sLabel || " [+] " )
.head 8 -  Set hParent = GetParent( hpItem )
.head 8 +  If hParent != hRoot
.head 9 -  Call KHESetHasFall( hParent, TRUE )
.head 7 +  Else
.head 8 +  If nLevelLoc != KHEL_Bett
.head 9 +  If SalStrScan(sLabel,"[+]") >= 0
.head 10 -  Call SetItemText( hpItem, VisStrSubstitute( sLabel, " [+] " ,"" ) )
.head 5 +  Function: KHESetChildChecked
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  Boolean: bKHE_IsChildChecked
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 6 +  Actions
.head 7 -  Set nValueLoc = GetItemValue( hpItem )
.head 7 +  If bKHE_IsChildChecked
.head 8 -  Set nValueLoc = nValueLoc | nKHK_CHILD_CHECKED
.head 7 +  Else
.head 8 -  Set nValueLoc = nValueLoc & nKHK_CHILD_NO_CHECKED
.head 7 -  Call SetItemValue( hpItem, nValueLoc )
.head 5 +  Function: KHESetPopulated
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  Boolean: bKHE_IsPopulated
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 6 +  Actions
.head 7 -  Set nValueLoc = GetItemValue( hpItem )
.head 7 +  If bKHE_IsPopulated
.head 8 -  Set nValueLoc = nValueLoc | nKHK_POPULATED
.head 8 -  ! If an item is KHE_IsPopulated then that means his childs are checked
.head 8 -  Set nValueLoc = nValueLoc | nKHK_CHILD_CHECKED
.head 7 +  Else
.head 8 -  Set nValueLoc = nValueLoc & nKHK_NO_POPULATED
.head 7 -  Call SetItemValue( hpItem, nValueLoc )
.head 5 +  Function: KHESetHasChild
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  Boolean: bKHE_HasChild
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 6 +  Actions
.head 7 -  Set nValueLoc = GetItemValue( hpItem )
.head 7 +  If bKHE_HasChild
.head 8 -  Set nValueLoc = nValueLoc | nKHK_HAS_CHILD
.head 7 +  Else
.head 8 -  Set nValueLoc = nValueLoc & nKHK_HAS_NO_CHILD
.head 7 -  Call SetItemValue( hpItem, nValueLoc )
.head 5 +  Function: KHESetColor
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 -  Actions
.head 5 -  ! !
.head 5 +  Function: KHE_IsChildChecked
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set nValueLoc = GetItemValue( hpItem )
.head 7 -  Set bOk = ( nValueLoc & nKHK_CHILD_CHECKED )
.head 7 -  Return bOk
.head 5 +  Function: KHE_HasChild
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set nValueLoc = GetItemValue( hpItem )
.head 7 -  Set bOk = ( nValueLoc & nKHK_HAS_CHILD )
.head 7 -  Return bOk
.head 5 +  Function: KHE_IsPopulated
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set nValueLoc = GetItemValue( hpItem )
.head 7 -  Set bOk = ( nValueLoc & nKHK_POPULATED )
.head 7 -  Return bOk
.head 5 +  Function: KHE_IsExpanded
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFlags
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set nFlags = GetItemFlags( hpItem )
.head 7 -  Set bOk = ( nFlags & ITEM_IsExpanded ) !=0
.head 7 -  Return bOk
.head 5 +  Function: KHE_IsFallSelected
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCurrentRoot
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 7 -  String: sLabel
.head 7 -  String: sFall
.head 7 -  Number: nFall
.head 6 +  Actions
.head 7 -  Set i=0
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 -  Set sLabel = GetItemText( hCurrentRoot ) 
.head 7 -  Set sFall= SalStrMidX( sLabel, SalStrScan( sLabel, '{' ) + 1, SalStrScan( sLabel, '}' ) - SalStrScan( sLabel, '{' ) - 1 )
.head 7 -  Set nFall= NumberX( sFall)
.head 7 +  While i<=  nBound
.head 8 +  If HandleToPlace[i,0]= nFall
.head 9 -  Return TRUE
.head 8 -  Set i=i+1
.head 7 -  Return FALSE
.head 5 -  !
.head 5 -  !
.head 5 +  ! Function: ExpandBranch
.head 6 -  Description: 
.head 6 -  Returns 
.head 6 +  Parameters 
.head 7 -  Number: nStartItem
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: n
.head 7 -  Number: i
.head 7 -  Number: nChildren[*]
.head 6 +  Actions 
.head 7 -  Set n = EnumChildren(GetItemHandle(nStartItem), nChildren)
.head 7 +  If n
.head 8 -  Call Expand(nStartItem)
.head 8 -  Set i = 0
.head 8 +  Loop 
.head 9 +  If i >= n
.head 10 -  Break 
.head 9 -  Call ExpandBranch(GetItemIndex(nChildren[i]))
.head 9 -  Set i = i + 1
.head 5 +  Function: FindChild
.head 6 -  Description: Searches for a child of hParent.
A substring of a child's label should be sSearch.
Returns Item Handle of found child or 0 if it was not found
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hParent
.head 7 -  String: sSearch
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nChild
.head 7 -  Number: i
.head 6 +  Actions
.head 7 +  If (sSearch !='In Cage:' or (bMiniSolution and sSearch !='Cage is used') or (bMiniSolution and sSearch !='Cage is not used') ) and sSearch != 'Empty Cages in Rack' and (SalStrScan(sSearch, '(' )=-1 and SalStrScan(sSearch, ')' )=-1)
.head 8 -  Set sSearch= '('||sSearch||')'
.head 7 -  Set nChild = EnumChildren( hParent, hChildren )
.head 7 +  If nChild
.head 8 -  Set i = 0
.head 8 +  Loop
.head 9 +  If i >= nChild
.head 10 -  Break
.head 9 -  Call GetItemData( hChildren[ i ], sText, nValueLoc, nFlags )
.head 9 +  If SalStrScan( SalStrUpperX( sText ), SalStrUpperX( sSearch ) ) > -1
.head 10 -  Return hChildren[ i ]
.head 9 -  Set i = i + 1
.head 7 -  Return 0
.head 5 +  Function: SearchFrom
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  String: sSearch
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nChild
.head 7 -  Number: i
.head 7 -  Number: hRet
.head 6 +  Actions
.head 7 +  If (sSearch !='In Cage:'  or (bMiniSolution and sSearch !='Cage is used') or (bMiniSolution and sSearch !='Cage is not used') ) and sSearch != 'Empty Cages in Rack' and (SalStrScan(sSearch, '(' )=-1 and SalStrScan(sSearch, ')' )=-1) and SalStrLength( 
sSearch ) <4
.head 8 -  Set sSearch= '('||sSearch||')'
.head 7 +  ! If sSearch != 'Empty Cages in Rack' and (SalStrScan(sSearch, '(' )=-1 and SalStrScan(sSearch, ')' )=-1)
.head 8 -  Set sSearch= '('||sSearch||')'
.head 7 -  Call GetItemData(hpItem, sText, nValueLoc, nFlags)
.head 7 +  If SalStrScan(SalStrUpperX(sText), SalStrUpperX(sSearch)) = -1
.head 8 -  Set nChild = EnumChildren (hpItem, hChildren)
.head 8 +  If nChild
.head 9 -  Set i = 0
.head 9 +  Loop
.head 10 +  If i >= nChild
.head 11 -  Break
.head 10 -  Set hRet=SearchFrom(hChildren[i], sSearch)
.head 10 +  If hRet >0
.head 11 -  Return hRet
.head 10 -  Set i = i + 1
.head 8 +  Else
.head 9 -  Return -1
.head 7 +  Else
.head 8 -  Set hResult=0
.head 8 -  Return hpItem
.head 5 +  Function: Search
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sSearch
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nF
.head 7 -  String: s
.head 6 +  Actions
.head 7 -  Call SearchFrom(GetItemHandle(SalListQuerySelection(hWndItem)), sSearch)
.head 7 +  If hResult != -1
.head 8 -  ! Call SalMessageBox(s, '!', 0)
.head 8 -  Call GetItemData (hResult, s, nI, nF)
.head 5 +  Function: KHE_IsAlert
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  Number: nLevelLoc
.head 7 -  String: sKey
.head 7 -  Date/Time: dtGetTime
.head 7 -  Boolean: bShowPB 
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bIsAlert
.head 7 -  Number: nFallKey
.head 7 -  String: sLabel
.head 7 -  String: sSQL
.head 7 -  ! Number: nAlertID
.head 7 -  Number: nAlertType
.head 7 -  ! Number: nMaxAlertType
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sPError
.head 6 +  Actions
.head 7 +  If hpItem>-1
.head 8 -  !
.head 8 +  If not dtTime
.head 9 -  Return FALSE
.head 8 -  Set dtGetTime = dtTime
.head 8 -  Set nLevelLoc = GetLevel( hpItem )
.head 8 -  Call GetPosition( hpItem, sAbtKey, sStatKey, sGrpKey, sBettKey)
.head 8 +  If nLevelLoc= KHEL_Gruppe
.head 9 -  !
.head 9 -  ! Set sLabel = GetItemText( hpItem )
.head 9 -  ! Set sKey= SalStrMidX( sLabel, SalStrScan( sLabel, '(' ) + 1, SalStrScan( sLabel, ')' ) - SalStrScan( sLabel, '(' ) - 1 )
.head 9 -  Set sKey= sGrpKey
.head 8 +  Else If nLevelLoc=KHEL_Bett
.head 9 -  !
.head 9 -  Set sLabel = GetItemText( hpItem )
.head 9 -  Set sKey= SalStrMidX( sLabel, SalStrScan( sLabel, '{' ) + 1, SalStrScan( sLabel, '}' ) - SalStrScan( sLabel, '{' ) - 1 )
.head 9 -  ! Set sKey=sBettKey
.head 8 +  Else
.head 9 -  Return FALSE
.head 7 +  Else If hpItem<-1 and ( not nLevelLoc or not sKey or not dtGetTime)
.head 8 -  Return FALSE
.head 7 -  Set nAlertType = 0
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Return FALSE
.head 8 +  Case KHEL_Abteilung
.head 9 -  Return FALSE
.head 8 +  Case KHEL_Station
.head 9 -  Return FALSE
.head 8 +  Case KHEL_Gruppe
.head 9 -  !
.head 9 +  If bShowPB 
.head 10 -  Set sSQL = "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and  l.stat_key=g.stat_key
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by lst.lst_key
order by 2 desc
into :sAbtKey, :nAlertType"
.head 9 +  Else
.head 10 +  If bRealTimeMode
.head 11 -  Set sSQL = "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and l.stat_key=g.stat_key
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

union

select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from	sysadm.FALL f, sysadm.lst_erf l, sysadm.leistung lst
	where	f.EINRICHT_ID = :nEinrichtId
       and 	f.last_gruppe_key = :sKey
       and   f.last_stat_key= :sStatKey
       and	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 and lst.lst_key = l.lst_key 
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
   and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

order by 2 desc
into :sAbtKey, :nAlertType"
.head 10 +  Else
.head 11 -  Set sSQL = "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and l.stat_key=g.stat_key
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

union

select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from	sysadm.FALL f, sysadm.BEWEGUNG b, sysadm.lst_erf l, sysadm.leistung lst
	where  b.EINRICHT_ID = :nEinrichtId
and 	b.ABT_KEY = :sAbtKey
and   	b.stat_key= :sStatKey
and 	b.gruppe_key =  :sKey
and	@nullvalue( b.GELOESCHT, 'N' ) = 'N'
and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
and	:dtGetTime >= b.BEW_ZEIT
and	( :dtGetTime <= b.BEW_ZEIT_BIS or ( b.BEW_ZEIT_BIS is NULL) )
and	f.EINRICHT_ID = b.EINRICHT_ID
and	f.FALL_KEY = b.FALL_KEY
and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and lst.einricht_id=f.einricht_id
and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
group by 1

order by 2 desc
into :sAbtKey, :nAlertType"
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  Set nFallKey =SalStrToNumber(sKey)
.head 9 -  Set sSQL = "select  lst.lst_key, @NULLVALUE(max(lst.isAlert), 0)+1
from  sysadm.LST_ERF l, sysadm.leistung lst
where  l.FALL_KEY= :nFallKey
and	l.done= 0
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and @NULLVALUE(l.storniert, 'N') = 'N'
and 	l.LST_ERF_VON<:dtGetTime
group by lst.lst_key
order by 2 desc
into :sAbtKey, :nAlertType"
.head 9 -  Break
.head 8 +  Default
.head 9 -  Return FALSE
.head 7 +  If sSQL and GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, sSQL)
.head 8 +  Call SqlFetchNext(hSql, nFetch)
.head 9 +  ! If Hier_ItemIsActive(nAlertID, "alerts")
.head 10 -  ! Break
.head 9 +  ! If nAlertType>nMaxAlertType
.head 10 -  Set nMaxAlertType = nAlertType
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Return nAlertType
.head 5 +  ! Function: KHE_IsAlert
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Number: 
.head 6 +  Parameters 
.head 7 -  Number: hpItem
.head 7 -  Number: nLevelLoc
.head 7 -  String: sKey
.head 7 -  Date/Time: dtGetTime
.head 7 -  Boolean: bShowPB 
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Boolean: bIsAlert
.head 7 -  Number: nFallKey
.head 7 -  String: sLabel
.head 7 -  String: sSQL
.head 7 -  Number: nAlertID
.head 7 -  Number: nAlertType
.head 7 -  Number: nMaxAlertType
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 6 +  Actions 
.head 7 +  If hpItem>-1
.head 8 -  !
.head 8 +  If not dtTime
.head 9 -  Return FALSE
.head 8 -  Set dtGetTime = dtTime
.head 8 -  Set nLevelLoc = GetLevel( hpItem )
.head 8 -  Call GetPosition( hpItem, sAbtKey, sStatKey, sGrpKey, sBettKey)
.head 8 +  If nLevelLoc= KHEL_Gruppe
.head 9 -  !
.head 9 -  ! Set sLabel = GetItemText( hpItem )
.head 9 -  ! Set sKey= SalStrMidX( sLabel, SalStrScan( sLabel, '(' ) + 1, SalStrScan( sLabel, ')' ) - SalStrScan( sLabel, '(' ) - 1 )
.head 9 -  Set sKey= sGrpKey
.head 8 +  Else If nLevelLoc=KHEL_Bett
.head 9 -  !
.head 9 -  Set sLabel = GetItemText( hpItem )
.head 9 -  Set sKey= SalStrMidX( sLabel, SalStrScan( sLabel, '{' ) + 1, SalStrScan( sLabel, '}' ) - SalStrScan( sLabel, '{' ) - 1 )
.head 9 -  ! Set sKey=sBettKey
.head 8 +  Else 
.head 9 -  Return FALSE
.head 7 +  Else If hpItem<-1 and ( not nLevelLoc or not sKey or not dtGetTime)
.head 8 -  Return FALSE
.head 7 -  Set nMaxAlertType = 0
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Return FALSE
.head 8 +  Case KHEL_Abteilung
.head 9 -  Return FALSE
.head 8 +  Case KHEL_Station
.head 9 -  Return FALSE
.head 8 +  Case KHEL_Gruppe
.head 9 -  !
.head 9 +  If bShowPB 
.head 10 -  Set sSQL = "select a.id, @NULLVALUE(a.isalert,0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.mlhalerts_view a
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and  l.stat_key=g.stat_key
and a.origin = l.lst_key
and l.done != 1
and l.lst_erf_von<=:dtGetTime
and a.origin = l.lst_key
and a.parent>-1
group by 1,2
into :nAlertID, :nAlertType"
.head 9 +  Else 
.head 10 +  If bRealTimeMode
.head 11 -  Set sSQL = "select a.id, @NULLVALUE(a.isalert,0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.mlhalerts_view a
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and l.stat_key=g.stat_key
and a.origin = l.lst_key
and l.done != 1
and l.lst_erf_von<=:dtGetTime
and a.origin = l.lst_key
and a.parent>-1
group by 1,2

union

select	a.id, @NULLVALUE(a.isalert,0)+1
from	sysadm.FALL f, sysadm.lst_erf l, sysadm.mlhalerts_view a
	where	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
       and 	f.last_gruppe_key = :sKey
       and   f.last_stat_key= :sStatKey
   and l.fall_key = f.fall_key
and l.done != 1
and l.lst_erf_von<=:dtGetTime
and a.origin = l.lst_key
and a.parent>-1
group by 1,2
into :nAlertID, :nAlertType"
.head 10 +  Else 
.head 11 -  Set sSQL = "select a.id, @NULLVALUE(a.isalert,0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.mlhalerts_view a
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and l.stat_key=g.stat_key
and a.origin = l.lst_key
and l.done != 1
and l.lst_erf_von<=:dtGetTime
and a.origin = l.lst_key
and a.parent>-1
group by 1,2

union

select	a.id, @NULLVALUE(a.isalert,0)+1
from	sysadm.FALL f, sysadm.BEWEGUNG b, sysadm.lst_erf l, sysadm.mlhalerts_view a
	where	@nullvalue( b.GELOESCHT, 'N' ) = 'N'
        and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
        and	:dtGetTime >= b.BEW_ZEIT
        and	( :dtGetTime <= b.BEW_ZEIT_BIS or ( b.BEW_ZEIT_BIS is NULL) )
       and	f.EINRICHT_ID = b.EINRICHT_ID
       and	f.FALL_KEY = b.FALL_KEY
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
       and 	b.gruppe_key = :sKey
       and   b.stat_key= :sStatKey
   and l.fall_key = f.fall_key
and l.done != 1
and l.lst_erf_von<=:dtGetTime
and a.origin = l.lst_key
and a.parent>-1
group by 1,2
into :nAlertID, :nAlertType"
.head 9 -  Break 
.head 8 +  Case KHEL_Bett
.head 9 -  Set nFallKey =SalStrToNumber(sKey)
.head 9 -  Set sSQL = "select  a.id, @NULLVALUE(a.isAlert, 0)+1
from  LST_ERF l,  sysadm.mlhalerts_view A
where  l.FALL_KEY= :nFallKey

and	l.done= 0
and 	l.LST_ERF_VON<:dtGetTime
and A.origin = l.lst_key
        and A.parent >-1
into :nAlertID, :nAlertType"
.head 9 -  Break 
.head 8 +  Default 
.head 9 -  Return FALSE
.head 7 +  If sSQL and GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, sSQL)
.head 8 +  While SqlFetchNext(hSql, nFetch)
.head 9 +  ! If Hier_ItemIsActive(nAlertID, "alerts")
.head 10 -  ! Break
.head 9 +  If nAlertType>nMaxAlertType
.head 10 -  Set nMaxAlertType = nAlertType
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Return nMaxAlertType
.head 5 +  Function: KHEReAssignPics
.head 6 -  Description: This is a modification of MS function, made by IK
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCurrentRoot
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildrenItem[*]
.head 7 -  Number: nChildren
.head 7 -  Number: i
.head 7 -  Number: hPic
.head 7 -  Number: nLevelLoc
.head 7 -  Boolean: bExpanded
.head 7 -  String: sKey
.head 7 -  Boolean: bRFID
.head 7 -  String: sMaska
.head 7 -  Number: nType
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: nAlert
.head 7 -  Boolean: bRoling
.head 6 +  Actions
.head 7 +  If not bShouPics
.head 8 -  Return FALSE
.head 7 -  Set sMaska=''
.head 7 -  Set nLevelLoc = GetLevel( hCurrentRoot )
.head 7 -  Set bExpanded = KHE_IsExpanded( hCurrentRoot )
.head 7 -  ! ! !!        Chenge by SS+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Einrichtung')
.head 9 -  Call SetItemFont(hCurrentRoot, hFontCommon)
.head 9 -  Set sMaska='E'
.head 9 +  If bExpanded
.head 10 -  Set sMaska=sMaska ||'O'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'C'
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Abteilung' )
.head 9 -  Call SetItemFont(hCurrentRoot, hFontCommon)
.head 9 -  Set sMaska='A'
.head 9 +  If bExpanded
.head 10 -  Set sMaska=sMaska ||'O'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'C'
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Station' )
.head 9 -  Call SetItemFont(hCurrentRoot, hFontRacks)
.head 9 -  Set sMaska='S'
.head 9 +  If bExpanded
.head 10 -  Set sMaska=sMaska ||'O'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'C'
.head 9 +  If KHEVirtual (hCurrentRoot )
.head 10 -  Set sMaska=sMaska ||'V'
.head 10 -  Break
.head 9 +  If KHEGetHasFall (hCurrentRoot )
.head 10 -  Set sMaska=sMaska ||'F'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'E'
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set bRefreshParentPics = TRUE
.head 9 -  Call KHEReAssignPics( GetParent( hCurrentRoot ) )
.head 9 -  Call SetItemFont(hCurrentRoot, hFontCages)
.head 9 -  Set sMaska='G'
.head 9 -  ! Set sKey = GetItemText( hCurrentRoot )
.head 9 -  ! Set sKey= SalStrMidX( sKey, SalStrScan( sKey, '(' ) + 1, SalStrScan( sKey, ')' ) - SalStrScan( sKey, '(' ) - 1 )
.head 9 -  Call GetPosition( hCurrentRoot, sScreen, sRack, sKey, sBett )
.head 9 -  ! Call SalStatusSetText( hWndForm, 'ReAssignPics Cage: '||sKey  )
.head 9 +  If KHE_IsOccupied( sScreen, sRack, sKey, sBett, dtTime )
.head 10 -  Set sMaska=sMaska||'OCCUP'
.head 10 -  Break
.head 9 -  Set nType= KHE_IsCadavers(sScreen, sRack, sKey)
.head 9 -  Set bRoling = KHE_IsCageInRolingMatings(sScreen, sRack, sKey)
.head 9 -  ! Call SqlExists("select RFID from sysadm.gruppe where stat_key=:sRack and gruppe_key=:sKey and RFID is not null", bRFID)
.head 9 -  Set nAlert=KHE_IsAlert(hCurrentRoot, -1, '', dtTime,FALSE)
.head 9 +  If bExpanded
.head 10 -  Set sMaska=sMaska ||'O'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'C'
.head 9 +  If KHEGetHasFall (hCurrentRoot )
.head 10 -  Set sMaska=sMaska ||'F'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'E'
.head 9 +  If bRoling
.head 10 -  Set sMaska=sMaska ||'ROL'
.head 9 +  If nAlert=2
.head 10 -  Set sMaska=sMaska ||'A'
.head 9 +  Else If nAlert=1
.head 10 -  Set sMaska=sMaska ||'SR'
.head 9 +  ! If bRFID
.head 10 -  Set sMaska=sMaska ||'R'
.head 9 +  If KHE_IsRFID( sScreen, sRack, sKey ) or KHE_IsBarCode(sScreen, sRack, sKey)
.head 10 -  Set sMaska=sMaska ||'R'
.head 9 +  If nType = 2
.head 10 -  Set sMaska=sMaska ||'CC'
.head 9 +  If nType = 1
.head 10 -  Set sMaska=sMaska ||'CD'
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  ! Call SalStatusSetText( hWndForm, 'ReAssignPics Bett' )
.head 9 +  If BettIsSummaryX( hCurrentRoot )
.head 10 -  Call SalStatusSetText( hWndForm, '' )
.head 10 -  Return TRUE
.head 9 -  Call SetItemFont(hCurrentRoot, hFontBetts)
.head 9 -  Set sMaska='B'
.head 9 -  Set nAlert=KHE_IsAlert(hCurrentRoot, -1, '', dtTime,FALSE)
.head 9 +  If not KHEGetHasFall (hCurrentRoot ) or bMiniSolution
.head 10 -  Set sMaska=sMaska ||'G'
.head 10 +  If bMiniSolution and KHE_IsFallSelected(hCurrentRoot)
.head 11 -  Set sMaska=sMaska ||'S'
.head 10 -  Break
.head 9 +  If KHEGetHasFall_Sex (hCurrentRoot )
.head 10 -  Set sMaska=sMaska ||'M'
.head 9 +  Else
.head 10 -  Set sMaska=sMaska ||'F'
.head 9 +  If KHE_IsFallSelected(hCurrentRoot)
.head 10 -  Set sMaska=sMaska ||'S'
.head 9 +  If nAlert=2
.head 10 -  Set sMaska=sMaska ||'A'
.head 9 +  Else If nAlert=1
.head 10 -  Set sMaska=sMaska ||'SR'
.head 9 +  If KHE_IsDead(hCurrentRoot, dtTime)
.head 10 -  Set sMaska=sMaska ||'D'
.head 9 +  If KHE_IsLitter(hCurrentRoot, dtTime)
.head 10 -  Set sMaska=sMaska ||'L'
.head 9 -  Break
.head 7 +  If sMaska='EO'
.head 8 -  Set hPic= hPicKHEL_Einrichtung
.head 7 +  Else If sMaska='EC'
.head 8 -  Set hPic= hPicKHEL_EinrichtungCL
.head 7 +  Else If sMaska='AO'
.head 8 -  Set hPic= hPicKHEL_Abteilung
.head 7 +  Else If sMaska='AC'
.head 8 -  Set hPic=  hPicKHEL_AbteilungCL
.head 7 +  Else If sMaska='SOV'
.head 8 -  Set hPic= hPicKHEL_StationVirt
.head 7 +  Else If sMaska='SOF'
.head 8 -  Set hPic= hPicKHEL_Station
.head 7 +  Else If sMaska='SOE'
.head 8 -  Set hPic= hPicKHEL_StationG
.head 7 +  Else If sMaska='SCV'
.head 8 -  Set hPic= hPicKHEL_StationCLVirt
.head 7 +  Else If sMaska='SCF'
.head 8 -  Set hPic= hPicKHEL_StationCL
.head 7 +  Else If sMaska='SCE'
.head 8 -  Set hPic= hPicKHEL_StationCLG
.head 7 +  Else If sMaska='GOF'
.head 8 -  Set hPic = hPicKHEL_Gruppe
.head 7 +  Else If sMaska='GOFA'
.head 8 -  Set hPic = hPicKHEL_Gruppe_A
.head 7 +  Else If sMaska='GOFR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_RF
.head 7 +  Else If sMaska='GOFAR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_A_RF
.head 7 +  Else If sMaska='GOE'
.head 8 -  Set hPic = hPicKHEL_GruppeG
.head 7 +  Else If sMaska='GOEA'
.head 8 -  Set hPic = hPicKHEL_GruppeG_A
.head 7 +  Else If sMaska='GOER'
.head 8 -  Set hPic = hPicKHEL_GruppeG_RF
.head 7 +  Else If sMaska='GOEAR'
.head 8 -  Set hPic = hPicKHEL_GruppeG_A_RF
.head 7 +  Else If sMaska='GCF'
.head 8 -  Set hPic = hPicKHEL_GruppeCL
.head 7 +  Else If sMaska='GCFA'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_A
.head 7 +  Else If sMaska='GCFR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_RF
.head 7 +  Else If sMaska='GCFAR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_A_RF
.head 7 +  Else If sMaska='GCE'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG
.head 7 +  Else If sMaska='GCEA'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_A
.head 7 +  Else If sMaska='GCER'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_RF
.head 7 +  Else If sMaska='GCEAR'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_A_RF
.head 7 +  Else If sMaska='BG'
.head 8 -  Set hPic= hPicKHEL_BettGrey
.head 7 +  Else If sMaska='BGS'
.head 8 -  Set hPic= hPicKHEL_BettGrey_Select
.head 7 +  Else If sMaska='BM'
.head 8 -  Set hPic= hPicKHEL_Bett_M
.head 7 +  Else If sMaska='BMSA'
.head 8 -  Set hPic= hPicKHEL_Bett_M_Select_A
.head 7 +  Else If sMaska='BMA'
.head 8 -  Set hPic= hPicKHEL_Bett_M_A
.head 7 +  Else If sMaska='BMS'
.head 8 -  Set hPic= hPicKHEL_Bett_M_Select
.head 7 +  Else If sMaska='BF'
.head 8 -  Set hPic= hPicKHEL_Bett_F
.head 7 +  Else If sMaska='BFSA'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_A
.head 7 +  Else If sMaska='BFA'
.head 8 -  Set hPic= hPicKHEL_Bett_F_A
.head 7 +  Else If sMaska='BFS'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select
.head 7 +  Else If sMaska='GOFCC'
.head 8 -  Set hPic = hPicKHEL_Gruppe_CCU
.head 7 +  Else If sMaska='GOFACC'
.head 8 -  Set hPic = hPicKHEL_Gruppe_A_CCU
.head 7 +  Else If sMaska='GOFRCC'
.head 8 -  Set hPic = hPicKHEL_Gruppe_RF_CCU
.head 7 +  Else If sMaska='GOFARCC'
.head 8 -  Set hPic = hPicKHEL_Gruppe_A_RF_CCU
.head 7 +  Else If sMaska='GOECC'
.head 8 -  Set hPic = hPicKHEL_GruppeG_CCU
.head 7 +  Else If sMaska='GOEACC'
.head 8 -  Set hPic = hPicKHEL_GruppeG_A_CCU
.head 7 +  Else If sMaska='GOERCC'
.head 8 -  Set hPic = hPicKHEL_GruppeG_RF_CCU
.head 7 +  Else If sMaska='GOEARCC'
.head 8 -  Set hPic = hPicKHEL_GruppeG_A_RF_CCU
.head 7 +  Else If sMaska='GCFCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_CCU
.head 7 +  Else If sMaska='GCFACC'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_A_CCU
.head 7 +  Else If sMaska='GCFRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_RF_CCU
.head 7 +  Else If sMaska='GCFARCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_A_RF_CCU
.head 7 +  Else If sMaska='GCECC'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_CCU
.head 7 +  Else If sMaska='GCEACC'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_A_CCU
.head 7 +  Else If sMaska='GCERCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_RF_CCU
.head 7 +  Else If sMaska='GCEARCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_A_RF_CCU
.head 7 +  Else If sMaska='BMD'
.head 8 -  Set hPic= hPicKHEL_Bett_M_D
.head 7 +  Else If sMaska='BMSAD'
.head 8 -  Set hPic= hPicKHEL_Bett_M_Select_A_D
.head 7 +  Else If sMaska='BMAD'
.head 8 -  Set hPic= hPicKHEL_Bett_M_A_D
.head 7 +  Else If sMaska='BMSD'
.head 8 -  Set hPic= hPicKHEL_Bett_M_Select_D
.head 7 +  Else If sMaska='BFD'
.head 8 -  Set hPic= hPicKHEL_Bett_F_D
.head 7 +  Else If sMaska='BFSAD'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_A_D
.head 7 +  Else If sMaska='BFAD'
.head 8 -  Set hPic= hPicKHEL_Bett_F_A_D
.head 7 +  Else If sMaska='BFSD'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_D
.head 7 +  Else If sMaska='BFL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_L
.head 7 +  Else If sMaska='BFSAL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_A_L
.head 7 +  Else If sMaska='BFAL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_A_L
.head 7 +  Else If sMaska='BFSL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_L
.head 7 +  Else If sMaska='BFSDL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_D_SL
.head 7 +  Else If sMaska='BFSSRDL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Serv_D_SL
.head 7 +  Else If sMaska='BFSADL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Alert_D_SL
.head 7 +  Else If sMaska='BFDL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_D_L
.head 7 +  Else If sMaska='BFSRDL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Serv_D_L
.head 7 +  Else If sMaska='BFADL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Alert_D_L
.head 7 +  Else If sMaska='GOECD'
.head 8 -  Set hPic = hPicKHEL_GruppeG_CD
.head 7 +  Else If sMaska='GOEACD'
.head 8 -  Set hPic = hPicKHEL_GruppeG_A_CD
.head 7 +  Else If sMaska='GOERCD'
.head 8 -  Set hPic = hPicKHEL_GruppeG_RF_CD
.head 7 +  Else If sMaska='GOEARCD'
.head 8 -  Set hPic = hPicKHEL_GruppeG_A_RF_CD
.head 7 +  Else If sMaska='GCECD'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_CD
.head 7 +  Else If sMaska='GCEACD'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_A_CD
.head 7 +  Else If sMaska='GCERCD'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_RF_CD
.head 7 +  Else If sMaska='GCEARCD'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_A_RF_CD
.head 7 +  Else If sMaska='GOFSR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_SR
.head 7 +  Else If sMaska='GOFSRR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_SR_RF
.head 7 +  Else If sMaska='GOESR'
.head 8 -  Set hPic = hPicKHEL_GruppeG_SR
.head 7 +  Else If sMaska='GOESRR'
.head 8 -  Set hPic = hPicKHEL_GruppeG_SR_RF
.head 7 +  Else If sMaska='GCFSR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_SR
.head 7 +  Else If sMaska='GCFSRR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_SR_RF
.head 7 +  Else If sMaska='GCESR'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_SR
.head 7 +  Else If sMaska='GCESRR'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_SR_RF
.head 7 +  Else If sMaska='BMSSR'
.head 8 -  Set hPic= hPicKHEL_Bett_M_Select_SR
.head 7 +  Else If sMaska='BMSR'
.head 8 -  Set hPic= hPicKHEL_Bett_M_SR
.head 7 +  Else If sMaska='BFSSR'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_SR
.head 7 +  Else If sMaska='BFSR'
.head 8 -  Set hPic= hPicKHEL_Bett_F_SR
.head 7 +  Else If sMaska='GOFSRCC'
.head 8 -  Set hPic = hPicKHEL_Gruppe_SR_CCU
.head 7 +  Else If sMaska='GOFSRRCC'
.head 8 -  Set hPic = hPicKHEL_Gruppe_SR_RF_CCU
.head 7 +  Else If sMaska='GOESRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeG_SR_CCU
.head 7 +  Else If sMaska='GOESRRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeG_SR_RF_CCU
.head 7 +  Else If sMaska='GCFSRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_SR_CCU
.head 7 +  Else If sMaska='GCFSRRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_SR_RF_CCU
.head 7 +  Else If sMaska='GCESRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_SR_CCU
.head 7 +  Else If sMaska='GCESRRCC'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_SR_RF_CCU
.head 7 +  Else If sMaska='BMSSRD'
.head 8 -  Set hPic= hPicKHEL_Bett_M_Select_SR_D
.head 7 +  Else If sMaska='BMSRD'
.head 8 -  Set hPic= hPicKHEL_Bett_M_SR_D
.head 7 +  Else If sMaska='BFSSRD'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_SR_D
.head 7 +  Else If sMaska='BFSRD'
.head 8 -  Set hPic= hPicKHEL_Bett_F_SR_D
.head 7 +  Else If sMaska='BFSSRL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_Select_SR_L
.head 7 +  Else If sMaska='BFSRL'
.head 8 -  Set hPic= hPicKHEL_Bett_F_SR_L
.head 7 +  Else If sMaska='GOESRCD'
.head 8 -  Set hPic = hPicKHEL_GruppeG_SR_CD
.head 7 +  Else If sMaska='GOESRRCD'
.head 8 -  Set hPic = hPicKHEL_GruppeG_SR_RF_CD
.head 7 +  Else If sMaska='GCESRCD'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_SR_CD
.head 7 +  Else If sMaska='GCESRRCD'
.head 8 -  Set hPic = hPicKHEL_GruppeCLG_SR_RF_CD
.head 7 +  Else If sMaska='GOCCUP'
.head 8 -  Set hPic = hPicKHEL_GruppeOCCUP
.head 7 +  Else If sMaska='GOFROL'
.head 8 -  Set hPic = hPicKHEL_Gruppe_ROL
.head 7 +  Else If sMaska='GOFROLA'
.head 8 -  Set hPic = hPicKHEL_Gruppe_ROL_A
.head 7 +  Else If sMaska='GOFROLR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_ROL_RF
.head 7 +  Else If sMaska='GOFROLAR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_ROL_A_RF
.head 7 +  Else If sMaska='GCFROL'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_ROL
.head 7 +  Else If sMaska='GCFROLA'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_ROL_A
.head 7 +  Else If sMaska='GCFROLR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_ROL_RF
.head 7 +  Else If sMaska='GCFROLAR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_ROL_A_RF
.head 7 +  Else If sMaska='GOFROLSR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_ROL_SR
.head 7 +  Else If sMaska='GOFROLSRR'
.head 8 -  Set hPic = hPicKHEL_Gruppe_ROL_SR_RF
.head 7 +  Else If sMaska='GCFROLSR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_ROL_SR
.head 7 +  Else If sMaska='GCFROLSRR'
.head 8 -  Set hPic = hPicKHEL_GruppeCL_ROL_SR_RF
.head 7 -  ! ! !!       END+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call SetItemPicture( hCurrentRoot, hPic, hPic )
.head 7 -  ! Call SalStatusSetText( hWndForm, '' )
.head 7 -  ! !
.head 7 +  If bExpanded  and not bRefreshParentPics
.head 8 -  Set nChildren = EnumChildren (hCurrentRoot, nChildrenItem)
.head 8 +  If nChildren
.head 9 -  Set i = 0
.head 9 -  ! ------- Processing all children
.head 9 +  While i < nChildren
.head 10 -  Call KHEReAssignPics( nChildrenItem[ i ] )
.head 10 -  Set i = i + 1
.head 7 -  Set bRefreshParentPics = FALSE
.head 7 -  Return TRUE
.head 5 +  Function: GetPosition
.head 6 -  Description: gets Abt, Stat, Gruppe, Bett
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: hCurrent
.head 7 -  Receive String: sAbt
.head 7 -  Receive String: sStat
.head 7 -  Receive String: sGrp
.head 7 -  Receive String: sBett
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLevelLoc
.head 7 -  Number: hAbt
.head 7 -  Number: hStat
.head 7 -  Number: hGrp
.head 7 -  String: sResult
.head 6 +  Actions
.head 7 +  ! If hCurrent = oPosition.nActHandel and nSaveSelectedLevel = hCurrent
.head 8 -  Set sAbt = oPosition.sScreen
.head 8 -  Set sStat = oPosition.sRack
.head 8 -  Set sGrp = oPosition.sCage
.head 8 -  Set sBett = oPosition.sBett
.head 7 +  ! Else
.head 8 -  Set nLevelLoc = GetLevel(hCurrent)
.head 8 -  Set sAbt = ""
.head 8 -  Set sStat = ""
.head 8 -  Set sGrp = ""
.head 8 -  Set sBett = ""
.head 8 +  Select Case nLevelLoc
.head 9 +  Case KHEL_Abteilung
.head 10 -  Set sAbt = GetKey_ByHandle( hCurrent )
.head 10 -  Break 
.head 9 +  Case KHEL_Station
.head 10 -  Set sStat = GetKey_ByHandle( hCurrent )
.head 10 -  Set hAbt = GetParent( hCurrent )
.head 10 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 10 -  Break 
.head 9 +  Case KHEL_Gruppe
.head 10 -  Set sGrp = GetKey_ByHandle( hCurrent )
.head 10 -  Set hStat = GetParent( hCurrent )
.head 10 -  Set sStat = GetKey_ByHandle( hStat )
.head 10 -  Set hAbt = GetParent( hStat )
.head 10 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 10 -  Break 
.head 9 +  Case KHEL_Bett
.head 10 -  Set sBett = GetKey_ByHandle( hCurrent )
.head 10 -  Set hGrp = GetParent( hCurrent )
.head 10 -  Set sGrp = GetKey_ByHandle( hGrp )
.head 10 -  Set hStat = GetParent( hGrp )
.head 10 -  Set sStat = GetKey_ByHandle( hStat )
.head 10 -  Set hAbt = GetParent( hStat )
.head 10 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 10 -  Break 
.head 9 +  Default 
.head 10 -  Set sResult = ""
.head 10 -  Break 
.head 7 -  Set nLevelLoc = GetLevel(hCurrent)
.head 7 -  Set sAbt = ""
.head 7 -  Set sStat = ""
.head 7 -  Set sGrp = ""
.head 7 -  Set sBett = ""
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set sAbt = GetKey_ByHandle( hCurrent )
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set sStat = GetKey_ByHandle( hCurrent )
.head 9 -  Set hAbt = GetParent( hCurrent )
.head 9 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set sGrp = GetKey_ByHandle( hCurrent )
.head 9 -  Set hStat = GetParent( hCurrent )
.head 9 -  Set sStat = GetKey_ByHandle( hStat )
.head 9 -  Set hAbt = GetParent( hStat )
.head 9 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  Set sBett = GetKey_ByHandle( hCurrent )
.head 9 -  Set hGrp = GetParent( hCurrent )
.head 9 -  Set sGrp = GetKey_ByHandle( hGrp )
.head 9 -  Set hStat = GetParent( hGrp )
.head 9 -  Set sStat = GetKey_ByHandle( hStat )
.head 9 -  Set hAbt = GetParent( hStat )
.head 9 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set sResult = ""
.head 9 -  Break
.head 7 +  If sAbt
.head 8 -  Set sResult = sAbt || ',' || sStat || ',' || sGrp || ',' || sBett
.head 7 -  Return sResult
.head 5 +  Function: GetPositionID
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCurrent
.head 7 -  Receive Number: nScrID
.head 7 -  Receive Number: nRackId
.head 7 -  Receive Number: nCageID
.head 7 -  Receive Number: nPosID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  ! If hCurrent = oPosition.nActHandel and nSaveSelectedLevel = hCurrent
.head 8 -  Set nScrID = oPosition.nScreenID
.head 8 -  Set nRackId = oPosition.nRackID
.head 8 -  Set nCageID = oPosition.nCageID
.head 8 -  Set nPosID = oPosition.nPosID
.head 8 -  Set bOk = TRUE
.head 7 +  ! Else
.head 8 -  Set bOk = GalConnect( hSql )
.head 8 +  If bOk
.head 9 -  Call GetPosition( hCurrent, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 9 -  Set nScrID = -1
.head 9 -  Set nRackId = -1
.head 9 -  Set nCageID = -1
.head 9 -  Set nPosID = -1
.head 9 +  If SqlPrepareAndExecute(hSql , "select a.id , s.id, g.id, b.id
from abteilung a
 left join station s on(s.einricht_id=a.einricht_id and s.stat_key=:sStatKey )
 left join gruppe g on (g.rack_id = s.id and g.gruppe_key=:sGrpKey )
 left join bett b on (b.cage_id=g.id and b.bett_key=:sBettKey)
 where a.einricht_id=:nEinrichtId and a.abt_key=:sAbtKey
into :nScrID, :nRackId, :nCageID, :nPosID ")
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 9 -  Call SqlDisconnect( hSql )
.head 7 -  Set bOk = GalConnect( hSql )
.head 7 +  If bOk
.head 8 -  Call GetPosition( hCurrent, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Set nScrID = -1
.head 8 -  Set nRackId = -1
.head 8 -  Set nCageID = -1
.head 8 -  Set nPosID = -1
.head 8 +  If SqlPrepareAndExecute(hSql , "select a.id , s.id, g.id, b.id
from abteilung a
 left join station s on(s.einricht_id=a.einricht_id and s.stat_key=:sStatKey )
 left join gruppe g on (g.rack_id = s.id and g.gruppe_key=:sGrpKey )
 left join bett b on (b.cage_id=g.id and b.bett_key=:sBettKey)
 where a.einricht_id=:nEinrichtId and a.abt_key=:sAbtKey
into :nScrID, :nRackId, :nCageID, :nPosID ")
.head 9 -  Call SqlFetchNext( hSql, nFetch )
.head 8 -  Call SqlDisconnect( hSql )
.head 7 -  Return bOk
.head 5 +  Function: _GetPositionID
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCurrent
.head 7 -  FunctionalVar: oPosInfo
.head 8 -  Class: cPositionData
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  If hCurrent = oPosition.nActHandel
.head 8 -  ! Set nScrID = oPosition.nScreenID
.head 8 -  ! Set nRackId = oPosition.nRackID
.head 8 -  ! Set nCageID = oPosition.nCageID
.head 8 -  ! Set nPosID = oPosition.nPosID
.head 8 -  ! Set oPosInfo = oPosition
.head 8 -  Set oPosInfo.nActHandel = oPosition.nActHandel
.head 8 -  Set oPosInfo.nCageID = oPosition.nCageID
.head 8 -  Set oPosInfo.nPosID = oPosition.nPosID
.head 8 -  Set oPosInfo.nRackID = oPosition.nRackID
.head 8 -  Set oPosInfo.nScreenID = oPosition.nScreenID
.head 8 -  Set oPosInfo.sBett = oPosition.sBett
.head 8 -  Set oPosInfo.sCage = oPosition.sCage
.head 8 -  Set oPosInfo.sRack = oPosition.sRack
.head 8 -  Set oPosInfo.sScreen = oPosition.sScreen
.head 8 -  Set bOk = TRUE
.head 7 +  Else
.head 8 -  Set bOk = GalConnect( hSql )
.head 8 +  If bOk
.head 9 -  Call GetPosition( hCurrent, oPosInfo.sScreen, oPosInfo.sRack, oPosInfo.sCage, oPosInfo.sBett )
.head 9 -  Set oPosInfo.nScreenID = -1
.head 9 -  Set oPosInfo.nRackID = -1
.head 9 -  Set oPosInfo.nCageID = -1
.head 9 -  Set oPosInfo.nPosID = -1
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSql , "select a.id , s.id, g.id, b.id
from sysadm.abteilung a
 left join sysadm.station s on(s.einricht_id=a.einricht_id and s.stat_key=:oPosInfo.sRack )
 left join sysadm.gruppe g on (g.rack_id = s.id and g.gruppe_key=:oPosInfo.sCage )
 left join sysadm.bett b on (b.cage_id=g.id and b.bett_key=:oPosInfo.sBett)
 where a.einricht_id=:nEinrichtId and a.abt_key=:oPosInfo.sScreen
into :oPosInfo.nScreenID, :oPosInfo.nRackID, :oPosInfo.nCageID, :oPosInfo.nPosID ")
.head 9 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 9 -  Call SqlDisconnect( hSql )
.head 7 +  If not bOk
.head 8 -  Set oPosInfo = OBJ_Null
.head 7 -  Return bOk
.head 5 +  Function: ActivatePosition
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( nHandle, oPosition.sScreen, oPosition.sRack, oPosition.sCage, oPosition.sBett )
.head 7 -  ! Set nScrID = -1
.head 7 -  ! Set nRackId = -1
.head 7 -  ! Set nCageID = -1
.head 7 -  ! Set nPosID = -1
.head 7 +  If SqlPrepareAndExecute(hSql , "select a.id , s.id, g.id, b.id
from abteilung a
 left join station s on(s.einricht_id=a.einricht_id and s.stat_key=:oPosition.sRack )
 left join gruppe g on (g.rack_id = s.id and g.gruppe_key=:oPosition.sCage)
 left join bett b on (b.cage_id=g.id and b.bett_key=:oPosition.sBett)
 where a.einricht_id=:nEinrichtId and a.abt_key=:oPosition.sScreen  
into :oPosition.nScreenID, :oPosition.nRackID, :oPosition.nCageID, :oPosition.nPosID ")
.head 8 +  If SqlFetchNext( hSql, nFetch )
.head 9 -  Set oPosition.nActHandel = nHandle
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  Return TRUE
.head 5 +  Function: GetKey_FromLable			! -- operates with string
.head 6 -  Description: We suppose that a Key is a substring between '(' and ')'
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sLabel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sKey
.head 6 +  Actions
.head 7 +  If SalStrScan( sLabel, 'Empty Cages in Rack')>0
.head 8 -  Set sKey= 'Empty Cages in Rack'
.head 8 -  Return sKey
.head 7 +  If SalStrScan( sLabel, 'In Cages:')>0
.head 8 -  Set sKey= 'In Cages:'
.head 8 -  Return sKey
.head 7 -  Set sKey = SalStrMidX( sLabel, SalStrScan( sLabel, '(' ) + 1, SalStrScan( sLabel, ')' ) - SalStrScan( sLabel, '(' ) - 1 )
.head 7 -  Return sKey
.head 5 +  Function: GetKey_ByHandle			! -- operates with handle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sLabel
.head 7 -  String: sKey
.head 6 +  Actions
.head 7 -  Set sLabel =  GetItemText( nHandle )
.head 7 -  Set sKey = GetKey_FromLable( sLabel )
.head 7 -  Return sKey
.head 5 +  Function: KHE_IsCadavers
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nType
.head 7 -  String: sCadavers
.head 7 -  Number: nFetch
.head 7 -  String: sPError
.head 6 +  Actions
.head 7 -  Set sCadavers= "  select Type
		from sysadm.cadavers c
		where  c.rack='"||sRack||"'
		and c.cage='"||sCage||"'
		into :nType
		"
.head 7 -  Call GalConnect(  hSqlIsCadavers )
.head 7 -  Call SqlPrepareAndExecute( hSqlIsCadavers, sCadavers )
.head 7 -  ! Call SqlExists(sCadavers,  bOk)
.head 7 +  ! If not SqlGetCommandText(hSqlIsCadavers ,sPError) or not sPError
.head 8 -  Call PrepareGlobalSql(  )
.head 7 -  ! Call SqlExecute(hSqlIsCadavers)
.head 7 -  Set bOk=SqlFetchNext(hSqlIsCadavers, nFetch)
.head 7 -  Call SqlDisconnect( hSqlIsCadavers )
.head 7 -  Return nType
.head 5 +  Function: KHE_IsCadavers_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 +  If not hCage
.head 8 -  Return 0
.head 7 -  Call GetPosition( hCage, sScreen, sRack, sCage, sBett )
.head 7 +  If sScreen and sRack and sCage
.head 8 -  Return KHE_IsCadavers(sScreen, sRack, sCage)
.head 7 +  Else
.head 8 -  Return 0
.head 5 +  Function: KHE_IsDead
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hMouse
.head 7 -  Date/Time: dtEEMouse
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sLabel
.head 7 -  String: sKey
.head 7 -  String: sMouse
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  String: sPError
.head 6 +  Actions
.head 7 -  Set sLabel = GetItemText( hMouse )
.head 7 -  Set sKey= SalStrMidX( sLabel, SalStrScan( sLabel, '{' ) + 1, SalStrScan( sLabel, '}' ) - SalStrScan( sLabel, '{' ) - 1 )
.head 7 -  Set sMouse= "  select l.Le_ID
		from sysadm.Fall f, sysadm.LE l
		where f.Fall_Key='"||sKey||"'
		and f.Le_ID=l.Le_Id
		and (l.TOD_DATUM<=:dtEEMouse and l.TOD_DATUM is not NULL)
		
		"
.head 7 -  ! Call SqlExists(sMouse,  bOk)  
.head 7 -  Call GalConnect( hSqlIsDead )
.head 7 -  Call SqlPrepareAndExecute( hSqlIsDead, sMouse )
.head 7 +  ! If not SqlGetCommandText(hSqlIsDead ,sPError) or not sPError
.head 8 -  Call PrepareGlobalSql(  )
.head 7 -  ! Call SqlExecute(hSqlIsDead)
.head 7 -  Set bOk=SqlFetchNext(hSqlIsDead, nFetch)
.head 7 -  Call SqlDisconnect( hSqlIsDead )
.head 7 -  Return bOk 
.head 5 +  Function: KHE_IsLitter
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hMouse
.head 7 -  Date/Time: dtMouse
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  String: sLabel
.head 7 -  String: sKey
.head 7 -  String: sLitter
.head 7 -  Number: nFetch
.head 7 -  String: sPError
.head 6 +  Actions
.head 7 -  Set sLabel = GetItemText( hMouse )
.head 7 -  Set sKey= SalStrMidX( sLabel, SalStrScan( sLabel, '{' ) + 1, SalStrScan( sLabel, '}' ) - SalStrScan( sLabel, '{' ) - 1 )
.head 7 -  Set sLitter="select  rf.fall_key
from  sysadm.relship_fall rf, sysadm.litter l, sysadm.Fall F
where  rf.EINRICHT_ID = :nEinrichtId
and rf.fall_key ='"||sKey||"'
and rf.fallrolle_key = 'PARENT'
and rf.EINRICHT_ID = f.EINRICHT_ID
and rf.fall_key=f.fall_key
and f.geschl='W'				
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0
				
and :dtMouse >= @NULLVALUE(l.geb_datum, 12-31-2199)

and (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id))
"
.head 7 -  ! Call SqlExists(sLitter,  bOk)  
.head 7 +  ! If not SqlGetCommandText(hSqlIsLitter ,sPError) or not sPError
.head 8 -  Call PrepareGlobalSql(  )
.head 7 -  ! Call SqlExecute(hSqlIsLitter)
.head 7 -  Call GalConnect( hSqlIsLitter)
.head 7 -  Call SqlPrepareAndExecute( hSqlIsLitter, sLitter )
.head 7 -  Set bOk=SqlFetchNext(hSqlIsLitter, nFetch)
.head 7 -  Call SqlDisconnect( hSqlIsLitter )
.head 7 -  Return bOk  
.head 5 +  Function: CageIsTemp
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spStat
.head 7 -  String: spGrp
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  String: sSqlTemp
.head 6 +  Actions
.head 7 -  ! Set sSqlTemp= "
select	g.GRUPPE_KEY
from 	sysadm.GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || spStat || "'
   and	g.GRUPPE_KEY = '" || spGrp || "'
   and	g.TEMP_CAGE=1

"
.head 7 -  ! Call SqlExists( sSqlTemp, bOk )
.head 7 -  Return bOk
.head 5 +  Function: KHE_IsExpandedLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spScreen
.head 7 -  String: spRack
.head 7 -  String: spCage
.head 7 -  Number: npLevel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hItem
.head 6 +  Actions
.head 7 +  Select Case npLevel
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set hItem= hRoot
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set hItem = SearchFrom( hRoot , "("||spScreen ||")" )
.head 8 +  Case KHEL_Station
.head 9 -  Set hItem = SearchFrom( hRoot , "("||spScreen ||")" )
.head 9 -  Set hItem = SearchFrom( hItem , "("||spRack ||")" )
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set hItem = SearchFrom( hRoot , "("||spScreen ||")" )
.head 9 -  Set hItem = SearchFrom( hItem , "("||spRack ||")" )
.head 9 -  Set hItem = SearchFrom( hItem , "("||spCage ||")" )
.head 7 -  Return KHE_IsExpanded(hItem)
.head 5 +  Function: KHE_IsOccupied
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sABT
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Date/Time: dtDate
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sSql
.head 7 -  Sql Handle: hSql
.head 7 -  String: sABTRow
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOccup
.head 7 -  String: sPError
.head 6 +  Actions
.head 7 -  Set bOccup= FALSE
.head 7 +  If sCage and sBett=STRING_Null
.head 8 -  Call GalConnect( hSql )
.head 8 +  If bRealTimeMode
.head 9 -  Set sSql="select f.LAST_ABT_KEY 
from sysadm.FALL f
where f.LAST_STAT_KEY='"||sRack||"'
and 	f.LAST_GRUPPE_KEY='"||sCage||"'
and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
  group by 1
into :sABTRow"
.head 8 +  Else
.head 9 -  Set sSql="select b.ABT_KEY 
from sysadm.bewegung b, sysadm.FALL f
where b.STAT_KEY='"||sRack||"'
and b.GRUPPE_KEY='"||sCage||"'
and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and      b. BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
and 	b.fall_key=f.fall_key
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
and      b. bew_zeit <=:dtDate
and       @nullvalue(b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtDate
  group by 1
into :sABTRow"
.head 8 -  Call SqlPrepareAndExecute( hSql, sSql )
.head 8 +  While SqlFetchNext(hSql, nFetch)
.head 9 +  If sABTRow = sABT
.head 10 -  ! Call SqlDisconnect( hSql )
.head 10 -  ! Return FALSE
.head 10 -  Set bOccup= FALSE
.head 9 +  Else
.head 10 -  ! Set bOccup= TRUE
.head 10 -  Call SqlDisconnect( hSql )
.head 10 -  Return TRUE
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  ! Call SalMessageBox( ' KHE_IsOccupied ', SalNumberToStrX(SalWindowHandleToNumber(hSqlIsOccupied),0), 0 )
.head 8 +  ! If not SqlGetCommandText(hSqlIsOccupied ,sPError) or not sPError
.head 9 -  Call PrepareGlobalSql(  )
.head 8 -  ! Call SqlExecute( hSqlIsOccupied )
.head 8 +  ! While SqlFetchNext(hSqlIsOccupied, nFetch)
.head 9 +  If sABTRow = sABT
.head 10 -  ! Call SqlDisconnect( hSql )
.head 10 -  ! Return FALSE
.head 10 -  Set bOccup= FALSE
.head 9 +  Else 
.head 10 -  ! Set bOccup= TRUE
.head 10 -  ! Call SqlDisconnect( hSql )
.head 10 -  Return TRUE
.head 7 +  ! ! If sCage and sBett
.head 8 -  Call GalConnect( hSql )
.head 8 -  Set sSql="select b.ABT_KEY
from sysadm.bewegung b, sysadm.FALL f
where b.STAT_KEY='"||sRack||"'
and b.GRUPPE_KEY='"||sCage||"'
and	b.BETT_KEY='"||sBett||"'
and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and      b. BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
and 	b.fall_key=f.fall_key
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
and      b. bew_zeit <=:dtDate
and       @nullvalue(b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtDate
  group by 1
into :sABTRow"
.head 8 -  Call SqlPrepareAndExecute( hSql, sSql )
.head 8 +  While SqlFetchNext(hSql, nFetch)
.head 9 +  If sABTRow = sABT
.head 10 -  Call SqlDisconnect( hSql )
.head 10 -  Return FALSE
.head 9 +  Else
.head 10 -  Set bOccup= TRUE
.head 8 -  Call SqlDisconnect( hSql )
.head 7 -  Return bOccup
.head 5 +  Function: KHE_IsOccupied_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hHendl
.head 7 -  Date/Time: dtDate
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sABT
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 +  If dtDate=DATETIME_Null
.head 8 -  Set dtDate= SalDateCurrent(  )
.head 7 -  Call GetPosition( hHendl, sABT, sRack, sCage, sBett )
.head 7 -  Return KHE_IsOccupied(sABT, sRack, sCage, sBett, dtDate)
.head 5 +  Function: KHE_IsRFID
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sABT
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFetch
.head 7 -  String: sRFID
.head 7 -  String: sPError
.head 6 +  Actions
.head 7 +  ! If not SqlGetCommandText(hSqlIsRFID ,sPError) or not sPError
.head 8 -  Call PrepareGlobalSql(  )
.head 7 -  Call GalConnect( hSqlIsRFID )
.head 7 -  Call SqlPrepareAndExecute( hSqlIsRFID, "select RFID 
from sysadm.gruppe
where stat_key=:sRack 
and gruppe_key=:sCage 
and RFID is not null
into :sRFID
")
.head 7 -  ! Call SqlExecute(hSqlIsRFID)
.head 7 -  Call SqlFetchNext(hSqlIsRFID, nFetch)
.head 7 -  Call SqlDisconnect( hSqlIsRFID )
.head 7 +  If sRFID
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: KHE_IsBarCode
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sABT
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFetch
.head 7 -  String: sBC
.head 6 +  Actions
.head 7 -  Call GalConnect( hSqlIsRFID )
.head 7 -  Call SqlPrepareAndExecute( hSqlIsRFID, "select s.id_label
from sysadm.gruppe g , sysadm.smart_labels s
where g.stat_key=:sRack
and g.gruppe_key=:sCage
and s.cageuniqnr = g.uniq_nr
into :sBC
")
.head 7 -  Call SqlFetchNext(hSqlIsRFID, nFetch)
.head 7 -  Call SqlDisconnect( hSqlIsRFID )
.head 7 +  If sBC
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: PrepareGlobalSql
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sPError
.head 7 -  Boolean: bb
.head 6 +  Actions
.head 7 +  If bRealTimeMode
.head 8 -  Call SqlPrepare(hSqlIsAlertCage, "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and l.stat_key=g.stat_key
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

union

select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from	sysadm.FALL f, sysadm.lst_erf l, sysadm.leistung lst
	where	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
       and 	f.last_gruppe_key = :sKey
       and   f.last_stat_key= :sStatKey
 and lst.lst_key = l.lst_key
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
   and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

order by 2 desc
into :sAbtKey, :nAlertType")
.head 8 -  Call SqlPrepare(hSqlIsOccupied,"select f.LAST_ABT_KEY
from sysadm.FALL f
where f.LAST_STAT_KEY=:sRack
and 	f.LAST_GRUPPE_KEY=:sCage
and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
  group by 1
into :sABTRow
")
.head 8 -  ! Call GalConnect( hSqlQuantityEB )
.head 7 +  Else
.head 8 -  Call SqlPrepare(hSqlIsAlertCage, "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.gruppe_key = :sKey
and g.stat_key=:sStatKey
and l.gruppe_key = g.gruppe_key
and l.stat_key=g.stat_key
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

union

select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from	sysadm.FALL f, sysadm.BEWEGUNG b, sysadm.lst_erf l, sysadm.leistung lst
	where	@nullvalue( b.GELOESCHT, 'N' ) = 'N'
        and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
        and	:dtGetTime >= b.BEW_ZEIT
        and	( :dtGetTime <= b.BEW_ZEIT_BIS or ( b.BEW_ZEIT_BIS is NULL) )
       and	f.EINRICHT_ID = b.EINRICHT_ID
       and	f.FALL_KEY = b.FALL_KEY
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
       and 	b.gruppe_key = :sKey
       and   b.stat_key= :sStatKey
 and lst.lst_key = l.lst_key
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
 and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=:dtGetTime
group by 1

order by 2 desc
into :sAbtKey, :nAlertType")
.head 8 -  Call SqlPrepare(hSqlIsOccupied,"select b.ABT_KEY
from sysadm.bewegung b, sysadm.FALL f
where b.STAT_KEY=:sRack
and b.GRUPPE_KEY=:sCage
and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and      b. BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
and 	b.fall_key=f.fall_key
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
and      b. bew_zeit <=:dtDate
and       @nullvalue(b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtDate
  group by 1
into :sABTRow
")
.head 7 -  Call SqlPrepare (hSqlIsAlertBett, "select  lst.lst_key, @NULLVALUE(max(lst.isAlert), 0)+1
from  sysadm.LST_ERF l, sysadm.leistung lst
where  l.FALL_KEY= :nFallKey
and	l.done= 0
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and @NULLVALUE(l.storniert, 'N') = 'N'
and 	l.LST_ERF_VON<:dtGetTime
group by lst.lst_key
order by 2 desc
into :sAbtKey, :nAlertType
")
.head 7 -  Call SqlPrepare(hSqlIsCadavers,"select Type
		from sysadm.cadavers c
		where  c.rack=:sRack
		and c.cage=:sCage
		into :nType
")
.head 7 -  Call SqlPrepare(hSqlIsDead,"select l.Le_ID
		from sysadm.Fall f, sysadm.LE l
		where f.Fall_Key=:sKey
		and f.Le_ID=l.Le_Id
		and (l.TOD_DATUM<=:dtEEMouse and l.TOD_DATUM is not NULL)
")
.head 7 -  Call SqlPrepare(hSqlIsLitter,"select  rf.fall_key
from  sysadm.relship_fall rf, sysadm.litter l, sysadm.Fall F
where rf.fall_key =:sKey
 and rf.fallrolle_key = 'PARENT'
and rf.fall_key=f.fall_key
and f.geschl='W'
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0
				
and :dtMouse >= @NULLVALUE(l.geb_datum, 12-31-2199)

and (exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id
	 and fall_key is null
	and dead = 0) or not exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id))
")
.head 7 -  Set bb = SqlGetCommandText(hSqlIsRFID ,sPError) 
.head 7 -  Call SqlPrepare( hSqlIsRFID, "select RFID 
from sysadm.gruppe
where stat_key=:sRack 
and gruppe_key=:sCage 
and RFID is not null
into :sRFID
")
.head 7 -  Set bb = SqlGetCommandText(hSqlIsRFID ,sPError) 
.head 7 -  Call SqlSetParameter(hSqlIsAlertCage, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Call SqlSetParameter(hSqlIsAlertBett, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Call SqlSetParameter(hSqlIsCadavers, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Call SqlSetParameter(hSqlIsDead, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Call SqlSetParameter(hSqlIsLitter, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Call SqlSetParameter(hSqlIsOccupied, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Call SqlSetParameter(hSqlIsRFID, DBP_PRESERVE, TRUE, STRING_Null)
.head 7 -  Set bb = SqlGetCommandText(hSqlIsRFID ,sPError) 
.head 7 -  Set nPrepareError = nPrepareError + 1
.head 5 +  Function: BettIsSummaryX
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hSummary
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  If GetLevel( hSummary ) = KHEL_Bett
.head 8 -  Set sText =  GetItemText( hSummary )
.head 8 +  ! If SalStrScan( sText, 'In Cage:')>0
.head 9 -  Return TRUE
.head 8 +  If sText = ''
.head 9 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: BettIsSummary
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  If nSelectedLevel = KHEL_Bett
.head 8 -  Set sText =  GetItemText( nSelectedHandle )
.head 8 +  ! If SalStrScan( sText, 'In Cage:')>0
.head 9 -  Return TRUE
.head 8 +  If sText = ''
.head 9 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: LoadPics
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bPics
.head 7 -  Number: nMPic
.head 7 -  Number: nFontSizeb
.head 6 +  Actions
.head 7 -  Set bPics = GalGetProfileBooleanX( "KHE", "LoadPics", FALSE, sUserINIFileName )
.head 7 +  If ((nLoadPics = 1) and (NOT bPics)) or ((nLoadPics = 2) and bPics)
.head 8 -  Return 0 
.head 7 +  If not bPics
.head 8 -  ! Bett
.head 8 -  Set hPicKHEL_Bett_F_Select = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_D', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_L', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_A', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_SR', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_A_D', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_A_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_A_L', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_SR_D', '')
.head 8 -  Set hPicKHEL_Bett_F_Select_SR_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_SR_L', '')
.head 8 -  Set hPicKHEL_Bett_F = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F', '')
.head 8 -  Set hPicKHEL_Bett_F_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_L', '')
.head 8 -  Set hPicKHEL_Bett_F_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_D', '')
.head 8 -  Set hPicKHEL_Bett_F_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_A', '')
.head 8 -  Set hPicKHEL_Bett_F_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SR', '')
.head 8 -  Set hPicKHEL_Bett_F_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_A_D', '')
.head 8 -  Set hPicKHEL_Bett_F_A_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_A_L', '')
.head 8 -  Set hPicKHEL_Bett_F_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SR_D', '')
.head 8 -  Set hPicKHEL_Bett_F_SR_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SR_L', '')
.head 8 -  !
.head 8 -  Set hPicKHEL_Bett_M_Select = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select', '')
.head 8 -  Set hPicKHEL_Bett_M_Select_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_D', '')
.head 8 -  Set hPicKHEL_Bett_M_Select_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_A', '')
.head 8 -  Set hPicKHEL_Bett_M_Select_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_A_D', '')
.head 8 -  Set hPicKHEL_Bett_M_Select_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_SR', '')
.head 8 -  Set hPicKHEL_Bett_M_Select_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_SR_D', '')
.head 8 -  Set hPicKHEL_Bett_M = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M', '')
.head 8 -  Set hPicKHEL_Bett_M_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_D', '')
.head 8 -  Set hPicKHEL_Bett_M_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_A', '')
.head 8 -  Set hPicKHEL_Bett_M_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_A_D', '')
.head 8 -  Set hPicKHEL_Bett_M_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_SR', '')
.head 8 -  Set hPicKHEL_Bett_M_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_SR_D', '')
.head 8 -  Set hPicKHEL_Bett_F_D_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_L_D', '')
.head 8 -  Set hPicKHEL_Bett_F_Serv_D_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SL_D', '')
.head 8 -  Set hPicKHEL_Bett_F_Alert_D_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_AL_D', '')
.head 8 -  Set hPicKHEL_Bett_F_D_SL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_L_SD', '')
.head 8 -  Set hPicKHEL_Bett_F_Serv_D_SL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SL_SD', '')
.head 8 -  Set hPicKHEL_Bett_F_Alert_D_SL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_AL_SD', '')
.head 8 -  Set hPicKHEL_Gruppe_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A_CCU', '')
.head 8 -  !
.head 8 -  Set hPicKHEL_BettGrey = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSEG', '')
.head 8 -  Set hPicKHEL_BettGrey_Select = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSEGS', '')
.head 8 -  ! Cage
.head 8 -  Set hPicKHEL_GruppeCL_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A', '')
.head 8 -  Set hPicKHEL_GruppeCL_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A_RF', '')
.head 8 -  Set hPicKHEL_GruppeCL_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCL_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCL_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCL_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCL_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCL_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_CD', '')
.head 8 -  Set hPicKHEL_GruppeCLG_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A', '')
.head 8 -  Set hPicKHEL_GruppeCLG_A_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_CD', '')
.head 8 -  Set hPicKHEL_GruppeCLG_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_RF', '')
.head 8 -  Set hPicKHEL_GruppeCLG_A_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_RF_CD', '')
.head 8 -  Set hPicKHEL_GruppeCLG_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeCLG_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_RF', '')
.head 8 -  Set hPicKHEL_GruppeCLG_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_RF_CD', '')
.head 8 -  Set hPicKHEL_GruppeCLG_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR', '')
.head 8 -  Set hPicKHEL_GruppeCLG_SR_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_CD', '')
.head 8 -  Set hPicKHEL_GruppeCLG_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_RF', '')
.head 8 -  Set hPicKHEL_GruppeCLG_SR_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_RF_CD', '')
.head 8 -  Set hPicKHEL_GruppeCL_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_RF', '')
.head 8 -  Set hPicKHEL_GruppeCL_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR', '')
.head 8 -  Set hPicKHEL_GruppeCL_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR_RF', '')
.head 8 -  Set hPicKHEL_Gruppe = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL', '')
.head 8 -  Set hPicKHEL_Gruppe_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A', '')
.head 8 -  Set hPicKHEL_Gruppe_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A_RF', '')
.head 8 -  Set hPicKHEL_Gruppe_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_CCU', '')
.head 8 -  Set hPicKHEL_Gruppe_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A_RF_CCU', '')
.head 8 -  Set hPicKHEL_Gruppe_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_RF_CCU', '')
.head 8 -  Set hPicKHEL_Gruppe_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR_CCU', '')
.head 8 -  Set hPicKHEL_Gruppe_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG', '')
.head 8 -  Set hPicKHEL_GruppeG_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_CD', '')
.head 8 -  Set hPicKHEL_GruppeG_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A', '')
.head 8 -  Set hPicKHEL_GruppeG_A_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_CD', '')
.head 8 -  Set hPicKHEL_GruppeG_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_RF', '')
.head 8 -  Set hPicKHEL_GruppeG_A_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_RF_CD', '')
.head 8 -  Set hPicKHEL_GruppeG_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_RF_CCU', '')
.head 8 -  Set hPicKHEL_GruppeG_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_RF', '')
.head 8 -  Set hPicKHEL_GruppeG_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_RF_CD', '')
.head 8 -  Set hPicKHEL_GruppeG_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR', '')
.head 8 -  Set hPicKHEL_GruppeG_SR_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_CD', '')
.head 8 -  Set hPicKHEL_GruppeG_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_RF', '')
.head 8 -  Set hPicKHEL_GruppeG_SR_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_RF_CD', '')
.head 8 -  Set hPicKHEL_Gruppe_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR', '')
.head 8 -  Set hPicKHEL_Gruppe_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_RF', '')
.head 8 -  Set hPicKHEL_Gruppe_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR_RF', '')
.head 8 -  Set hPicKHEL_GruppeOCCUP = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_OC', '')
.head 8 -  Set hPicKHEL_GruppeCL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL', '')
.head 8 -  Set hPicKHEL_GruppeCLG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG', '')
.head 8 -  Set hPicKHEL_GruppeCL_ROL_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_ROL_A', '')
.head 8 -  Set hPicKHEL_GruppeCL_ROL_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_ROL_A_RF', '')
.head 8 -  Set hPicKHEL_GruppeCL_ROL_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_ROL_RF', '')
.head 8 -  Set hPicKHEL_GruppeCL_ROL_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_ROL_SR', '')
.head 8 -  Set hPicKHEL_GruppeCL_ROL_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_ROL_SR_RF', '')
.head 8 -  Set hPicKHEL_Gruppe_ROL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_ROL', '')
.head 8 -  Set hPicKHEL_Gruppe_ROL_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_ROL_A', '')
.head 8 -  Set hPicKHEL_Gruppe_ROL_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_ROL_A_RF', '')
.head 8 -  Set hPicKHEL_Gruppe_ROL_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_ROL_SR', '')
.head 8 -  Set hPicKHEL_Gruppe_ROL_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_ROL_RF', '')
.head 8 -  Set hPicKHEL_Gruppe_ROL_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_ROL_SR_RF', '')
.head 8 -  Set hPicKHEL_GruppeCL_ROL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_ROL', '')
.head 8 -  ! Rack
.head 8 -  Set hPicKHEL_Station = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJ', '')
.head 8 -  Set hPicKHEL_StationG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJG', '')
.head 8 -  Set hPicKHEL_StationVirt = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJvirt', '')
.head 8 -  Set hPicKHEL_StationCLVirt = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJCLvirt', '')
.head 8 -  Set hPicKHEL_StationCL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJCL', '')
.head 8 -  Set hPicKHEL_StationCLG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJCLG', '')
.head 8 -  Set nLoadPics = 1
.head 7 +  Else
.head 8 -  ! Bett
.head 8 -  Set nFontSizeb = GalGetProfileNumberX( "KHE", "Font_Size_Betts", 10, sUserINIFileName )
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s_l.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_L = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s-a_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_A_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s-a_l.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_A_L = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s-sr_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_SR_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_s-sr_l.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select_SR_L = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-s.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_Select = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf_l.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_L = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-a_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_A_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-a_l.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_A_L = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-sr_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_SR_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf-sr_l.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F_SR_L = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_F = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm_s_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_Select_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm_s-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_Select_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm_s-a_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_Select_A_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm_s-s.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_Select_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm_s-sr_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_Select_SR_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm-a_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_A_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm-sr_d.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_SR_D = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mm-s.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Bett_M_Select = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khefldun-mg.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_BettGrey = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  ! Cage
.head 8 -  Set nFontSizeb = GalGetProfileNumberX( "KHE", "Font_Size_Cages", 10, sUserINIFileName )
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_A_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-ccu.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-ccu-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_A_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-ccu-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_A_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-ccu-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-ccu-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_SR_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-ccu-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_SR_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-a_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_A_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_A_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-a-rf_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_A_RF_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-ccu.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-ccu-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_A_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-ccu-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_A_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-ccu-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-ccu-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_SR_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-ccu-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_SR_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-rf_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_RF_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-sr_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_SR_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_SR_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg-sr-rf_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG_SR_RF_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL_SR_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_A_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-ccu.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-ccu-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_A_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-ccu-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_A_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-ccu-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-ccu-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_SR_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-ccu-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_SR_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_A = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-a_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_A_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_A_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-a-rf_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_A_RF_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-ccu.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-ccu-a.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_A_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-ccu-a-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_A_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-ccu-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-ccu-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_SR_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-ccu-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_SR_RF_CCU = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-rf_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_RF_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-sr_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_SR_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_SR_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-cg-sr-rf_cd.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeG_SR_RF_CD = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_SR = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-sr.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-c-sr-rf.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*6, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Gruppe_SR_RF = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('KHELFLCL-OCCUP.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeOCCUP = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-c.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCL = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflcl-cg.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_GruppeCLG = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  ! Rack
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-s.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_Station = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-sg.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_StationG = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('khelflop-virt.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_StationVirt = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('KHELFLCL-VIRT.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_StationCLVirt = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('KHELFLCL-S.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_StationCL = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  !
.head 8 -  Set nMPic = MImgLoadFromFile('KHELFLCL-SG.gif', MIMG_TYPE_UNKNOWN, 0)
.head 8 -  Call MImgResample( nMPic, nFontSizeb*4, nFontSizeb*2, MIMG_RESAMPLE_BIL )
.head 8 -  Set hPicKHEL_StationCLG = MImgCreateVisPic( nMPic, MIMG_TYPE_BMP )
.head 8 -  Call MImgDelete(nMPic)
.head 8 -  Set nLoadPics = 2
.head 5 +  Function: KHE_IsFallInRolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: npFallKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bExists
.head 6 +  Actions
.head 7 -  Call SqlExists( "select fall_key from roling_fall where fall_key = :npFallKey and status=0 ", bExists )
.head 7 -  Return bExists
.head 5 +  Function: KHE_IsCageInRolingMatings_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 +  If not hCage
.head 8 -  Return 0
.head 7 -  Call GetPosition( hCage, sScreen, sRack, sCage, sBett )
.head 7 +  If sScreen and sRack and sCage
.head 8 -  Return KHE_IsCageInRolingMatings(sScreen, sRack, sCage)
.head 7 +  Else
.head 8 -  Return 0
.head 5 +  Function: KHE_IsCageInRolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sSql
.head 7 -  Boolean: bExists
.head 6 +  Actions
.head 7 +  If bRealTimeMode
.head 8 -  Set sSql="select f.Fall_KEY
from sysadm.FALL f, sysadm.roling_fall r
where f.LAST_STAT_KEY='"||sRack||"'
and 	f.LAST_GRUPPE_KEY='"||sCage||"'
and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
and   f.Fall_KEY = r.fall_key
and   r.status=0
  group by 1
"
.head 7 +  Else
.head 8 -  Set sSql="select f.Fall_KEY
from sysadm.bewegung b, sysadm.FALL f , sysadm.roling_fall r
where b.STAT_KEY='"||sRack||"'
and b.GRUPPE_KEY='"||sCage||"'
and	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
and      b. BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
and 	b.fall_key=f.fall_key
and	@nullvalue(f.GELOESCHT, 'N' ) != 'J'
and      b. bew_zeit <=@now
and       @nullvalue(b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >@now

and   f.Fall_KEY = r.fall_key
and   r.status=0
  group by 1
"
.head 7 -  Call SqlExists( sSql, bExists )
.head 7 -  Return bExists
.head 5 +  Function: CleanupPictures
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  ! Cleanup pictures
.head 7 -  Call VisPicFree( hPicKHEL_Einrichtung )
.head 7 -  Call VisPicFree( hPicKHEL_EinrichtungCL )
.head 7 -  Call VisPicFree( hPicKHEL_Abteilung )
.head 7 -  Call VisPicFree( hPicKHEL_AbteilungCL )
.head 7 -  Call VisPicFree( hPicKHEL_Gruppe )
.head 7 -  Call VisPicFree( hPicKHEL_GruppeCL )
.head 7 -  Call VisPicFree( hPicKHEL_GruppeG )
.head 7 -  Call VisPicFree( hPicKHEL_GruppeCLG )
.head 7 -  Call VisPicFree( hPicKHEL_Station)
.head 7 -  Call VisPicFree( hPicKHEL_StationCL )
.head 7 -  Call VisPicFree( hPicKHEL_StationG)
.head 7 -  Call VisPicFree( hPicKHEL_StationCLG )
.head 7 -  Call VisPicFree( hPicKHEL_StationVirt)
.head 7 -  Call VisPicFree( hPicKHEL_StationCLVirt)
.head 7 -  Call VisPicFree( hPicKHEL_Bett_M )
.head 7 -  Call VisPicFree( hPicKHEL_Bett_F )
.head 7 -  Call VisPicFree( hPicKHEL_Bett_M_Select )
.head 7 -  Call VisPicFree( hPicKHEL_Bett_F_Select )
.head 7 -  Call VisPicFree( hPicKHEL_BettGrey  )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree( hPicAtlantaExpanded )
.head 7 -  Call VisPicFree(  hPicAtlantaCollapsed )
.head 7 -  Call VisPicFree(  hPicFolderExpanded )
.head 7 -  Call VisPicFree(  hPicFolderCollapsed )
.head 7 -  Call VisPicFree(  hPicFolderFree )
.head 7 -  Call VisPicFree(  hPicFolderUnknown )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_A )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_A )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_A )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_A)
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_Select_A )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_A )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_A )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_A )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_A_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_A_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_A_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_A_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_RF )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_A_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_A_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_A_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_A_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_A_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_A_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_A_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_A_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_RF_CCU )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_A_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_A_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_A_RF_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_A_RF_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_RF_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_RF_CD )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_Select_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_Select_A_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_A_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_A_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_A_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_L )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_L )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_A_L )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_A_L )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_Select_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_SR )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_SR)
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_SR_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_SR_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_SR_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_SR_RF )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_SR_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_SR_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_SR_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_SR_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_Gruppe_SR_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCL_SR_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_SR_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_SR_RF_CCU )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_SR_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_SR_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeG_SR_RF_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeCLG_SR_RF_CD )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_Select_SR_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_M_SR_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_SR_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_SR_D )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_Select_SR_L )
.head 7 -  Call VisPicFree(  hPicKHEL_Bett_F_SR_L )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree(  hPicKHEL_GruppeOCCUP )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  Call VisPicFree( hPicFall )
.head 7 -  Call VisPicFree( hPicMail )
.head 7 -  Call VisPicFree( hPicNewMail )
.head 7 -  Call VisPicFree( hPicClockW )
.head 7 -  Call VisPicFree( hPicClockR )
.head 5 +  Function: KHE_SaveLevel
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hItem
.head 7 -  Receive Number: nNextInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hChild[*]
.head 7 -  Number: nCount
.head 7 -  Number: nI
.head 7 -  Number: nFlags
.head 6 +  Actions
.head 7 -  Set nCount = EnumChildren( hItem, hChild )
.head 7 -  Set nI = 0
.head 7 +  While nI < nCount
.head 8 +  If KHE_IsExpanded(hChild[nI])
.head 9 -  Set hExpanded[nNextInd,0] = hChild[nI]
.head 9 -  Set hExpanded[nNextInd,1] = GetLevel( hChild[nI] )
.head 9 -  Set nNextInd = nNextInd + 1
.head 9 -  Call KHE_SaveLevel(hChild[nI],nNextInd)
.head 8 -  Set nI = nI + 1
.head 5 +  Function: KHE_SortExpand
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nM
.head 7 -  Number: nTemp[2]
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 -  Call SalArrayGetUpperBound( hExpanded, 2, nM )
.head 7 +  While nI < nM
.head 8 +  If hExpanded[nI+1,1] < hExpanded[nI,1]
.head 9 -  Set nTemp[0] = hExpanded[nI,0]
.head 9 -  Set nTemp[1] = hExpanded[nI,1]
.head 9 -  Set hExpanded[nI,0] = hExpanded[nI+1,0]
.head 9 -  Set hExpanded[nI,1] = hExpanded[nI+1,1]
.head 9 -  Set hExpanded[nI+1,0] = nTemp[0]
.head 9 -  Set hExpanded[nI+1,1] = nTemp[1]
.head 8 -  Set nI = nI + 1
.head 4 -  List Initialization
.head 4 +  Message Actions
.head 5 +  ! On SAM_Create
.head 6 -  ! Set hWndKHE = hWndItem
.head 6 -  ! !!        Chenge by SS+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  Set hPicKHEL_Einrichtung=  VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'INS', '')
.head 6 -  Set hPicKHEL_EinrichtungCL=  VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'INSCL', '')
.head 6 +  If GalGetProfileBooleanX( "KHE", "ShowPicDoor", FALSE, sUserINIFileName )
.head 7 -  Set hPicKHEL_Abteilung = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'DOOROP', '')
.head 7 -  Set hPicKHEL_AbteilungCL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'DOORCL', '')
.head 6 +  Else 
.head 7 -  Set hPicKHEL_Abteilung = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'ROOM', '')
.head 7 -  Set hPicKHEL_AbteilungCL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'ROOMCL', '')
.head 6 -  ! Set hPicKHEL_Station = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJ', '')
.head 6 -  ! Set hPicKHEL_StationCL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJCL', '')
.head 6 -  ! Set hPicKHEL_Gruppe = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL', '')
.head 6 -  ! Set hPicKHEL_GruppeCL = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL', '')
.head 6 -  ! Set hPicKHEL_StationG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJG', '')
.head 6 -  ! Set hPicKHEL_StationCLG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJCLG', '')
.head 6 -  ! Set hPicKHEL_StationVirt = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJvirt', '')
.head 6 -  ! Set hPicKHEL_StationCLVirt = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'STOJCLvirt', '')
.head 6 -  ! Set hPicKHEL_GruppeG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG', '')
.head 6 -  ! Set hPicKHEL_Bett_M_Select = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select', '')
.head 6 -  ! Set hPicKHEL_Bett_M = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select', '')
.head 6 -  ! Set hPicKHEL_Bett_F = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F', '')
.head 6 -  ! Set hPicKHEL_BettGrey = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSEG', '')
.head 6 -  Set hPicAtlantaExpanded = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEATLOP', '')
.head 6 -  Set hPicAtlantaCollapsed = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEATLCL', '')
.head 6 -  Set hPicFolderExpanded = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHELFLOP', '')
.head 6 -  Set hPicFolderCollapsed = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEFLDCL', '')
.head 6 -  Set hPicFolderFree = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEBFREE', '')
.head 6 -  Set hPicFolderUnknown = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEFLDUN', '')
.head 6 -  ! Set hPicKHEL_Gruppe_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A', '')
.head 6 -  ! Set hPicKHEL_GruppeG_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A', '')
.head 6 -  ! Set hPicKHEL_Bett_M_Select_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_A', '')
.head 6 -  ! Set hPicKHEL_Bett_M_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_A', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_A', '')
.head 6 -  ! Set hPicKHEL_Bett_F_A = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_A', '')
.head 6 -  ! Set hPicKHEL_Gruppe_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeG_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_A_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_RF', '')
.head 6 -  ! Set hPicKHEL_Gruppe_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeG_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_RF', '')
.head 6 -  ! ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  ! Set hPicKHEL_Gruppe_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_CCU', '')
.head 6 -  ! Set hPicKHEL_Gruppe_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_A_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_CCU', '')
.head 6 -  ! Set hPicKHEL_Gruppe_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_A_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_A_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_A_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_Gruppe_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_RF_CCU', '')
.head 6 -  ! ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  ! Set hPicKHEL_GruppeG_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeG_A_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_A_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeG_A_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_A_RF_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_A_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_A_RF_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeG_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_RF_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_RF_CD', '')
.head 6 -  ! ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  ! Set hPicKHEL_Bett_M_Select_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_D', '')
.head 6 -  ! Set hPicKHEL_Bett_M_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_D', '')
.head 6 -  ! Set hPicKHEL_Bett_M_Select_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_A_D', '')
.head 6 -  ! Set hPicKHEL_Bett_M_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_A_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_A_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_A_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_A_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_L', '')
.head 6 -  ! Set hPicKHEL_Bett_F_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_L', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_A_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_A_L', '')
.head 6 -  ! Set hPicKHEL_Bett_F_A_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_A_L', '')
.head 6 -  ! ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  ! Set hPicKHEL_Gruppe_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR', '')
.head 6 -  ! Set hPicKHEL_GruppeG_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR', '')
.head 6 -  ! Set hPicKHEL_Bett_M_Select_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_SR', '')
.head 6 -  ! Set hPicKHEL_Bett_M_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_SR', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_SR', '')
.head 6 -  ! Set hPicKHEL_Bett_F_SR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SR', '')
.head 6 -  ! Set hPicKHEL_Gruppe_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeG_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_RF', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_SR_RF = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_RF', '')
.head 6 -  ! Set hPicKHEL_Gruppe_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_SR_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_CCU', '')
.head 6 -  ! Set hPicKHEL_Gruppe_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_SR_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCL_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCL_SR_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_SR_RF_CCU = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_RF_CCU', '')
.head 6 -  ! Set hPicKHEL_GruppeG_SR_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_SR_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeG_SR_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLG_SR_RF_CD', '')
.head 6 -  ! Set hPicKHEL_GruppeCLG_SR_RF_CD = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELLCLG_SR_RF_CD', '')
.head 6 -  ! Set hPicKHEL_Bett_M_Select_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_Select_SR_D', '')
.head 6 -  ! Set hPicKHEL_Bett_M_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_M_SR_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_SR_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_SR_D = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SR_D', '')
.head 6 -  ! Set hPicKHEL_Bett_F_Select_SR_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_Select_SR_L', '')
.head 6 -  ! Set hPicKHEL_Bett_F_SR_L = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'MOUSE_F_SR_L', '')
.head 6 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  ! Set hPicKHEL_GruppeOCCUP = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'CELL_OC', '')
.head 6 -  ! ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  ! !!    END++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 6 -  Set hPicFall = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEFall', '')
.head 6 -  Set hPicMail = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHEMAIL', '')
.head 6 -  Set hPicNewMail = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHE!MAIL', '')
.head 6 -  !
.head 6 -  Set hPicClockW = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHE_ClockW', '')
.head 6 -  Set hPicClockR = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHE_ClockR', '')
.head 6 -  Set hPicClockY = VisPicLoad(PIC_FormatBitmap | PIC_LoadSWinRes, 'KHE_ClockY', '')
.head 6 -  !
.head 6 -  !
.head 6 -  Set nColorM = GalGetProfileNumberX(  'Bettendispo',  'Color10' , COLOR_Black,  sUserINIFileName )
.head 6 -  Set nColorW = GalGetProfileNumberX(  'Bettendispo',  'Color11' , COLOR_Black,  sUserINIFileName )
.head 6 -  ! Set nColorW = SalGetProfileInt (  'Bettendispo',  'Color11' , COLOR_DarkBlue,  sUserINIFileName )
.head 6 -  ! Call GalConnect( hSqlQuantityEB )
.head 6 -  ! Call GalConnect( hSqlIsAlertCage )
.head 6 -  ! Call GalConnect( hSqlIsAlertBett )
.head 6 -  ! Call GalConnect( hSqlIsCadavers )
.head 6 -  ! Call GalConnect( hSqlIsDead )
.head 6 -  ! Call GalConnect( hSqlIsLitter )
.head 6 -  ! Call GalConnect( hSqlIsOccupied ) 
.head 6 -  ! Call GalConnect( hSqlIsRFID)
.head 6 -  Set hRoot = KHEAddChild( GetRoot(  ), hPicAtlantaCollapsed, '', 0 )
.head 6 -  ! Call ShowOutline( SHOW_AllLevels )
.head 6 -  !
.head 6 -  Call SetStyle (LBS_ShowSelectText | LBS_ShowNoTree)
.head 6 -  Call cFilterRack.Initialize(
	"hWndNULL, Room, s.CURRNUM",
	TRUE,
	"tblPos", "Filter", cfgUSER,
	FALSE
)
.head 6 -  ! Call SetStyle (LBS_ShowSelectText)
.head 6 -  Set nPrepareError = 0
.head 5 +  ! On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click, wParam, lParam)
.head 6 -  ! Set nSelectedItem  = SalListQuerySelection( hWndItem )
.head 6 -  ! Set nSelectedHandle = GetItemHandle( nSelectedItem )
.head 6 -  ! Set nSelectedLevel = GetLevel( nSelectedHandle )
.head 6 -  ! Call SalSendMsg( hWndForm, AM_Refresh, 0,0)
.head 5 +  ! On SAM_Destroy
.head 6 -  Call CleanupPictures()
.head 6 +  ! commented out
.head 7 -  ! Call VisPicFree( hPicKHEL_Einrichtung )
.head 7 -  ! Call VisPicFree( hPicKHEL_EinrichtungCL )
.head 7 -  ! Call VisPicFree( hPicKHEL_Abteilung )
.head 7 -  ! Call VisPicFree( hPicKHEL_AbteilungCL )
.head 7 -  ! Call VisPicFree( hPicKHEL_Gruppe )
.head 7 -  ! Call VisPicFree( hPicKHEL_GruppeCL )
.head 7 -  ! Call VisPicFree( hPicKHEL_GruppeG )
.head 7 -  ! Call VisPicFree( hPicKHEL_GruppeCLG )
.head 7 -  ! Call VisPicFree( hPicKHEL_Station)
.head 7 -  ! Call VisPicFree( hPicKHEL_StationCL )
.head 7 -  ! Call VisPicFree( hPicKHEL_StationG)
.head 7 -  ! Call VisPicFree( hPicKHEL_StationCLG )
.head 7 -  ! Call VisPicFree( hPicKHEL_StationVirt)
.head 7 -  ! Call VisPicFree( hPicKHEL_StationCLVirt)
.head 7 -  ! Call VisPicFree( hPicKHEL_Bett_M )
.head 7 -  ! Call VisPicFree( hPicKHEL_Bett_F )
.head 7 -  ! Call VisPicFree( hPicKHEL_Bett_M_Select )
.head 7 -  ! Call VisPicFree( hPicKHEL_Bett_F_Select )
.head 7 -  ! Call VisPicFree( hPicKHEL_BettGrey  )
.head 7 -  ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree( hPicAtlantaExpanded )
.head 7 -  ! Call VisPicFree(  hPicAtlantaCollapsed )
.head 7 -  ! Call VisPicFree(  hPicFolderExpanded )
.head 7 -  ! Call VisPicFree(  hPicFolderCollapsed )
.head 7 -  ! Call VisPicFree(  hPicFolderFree )
.head 7 -  ! Call VisPicFree(  hPicFolderUnknown )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_A)
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_Select_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_A )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_A_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_A_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_A_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_A_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_RF )
.head 7 -  ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_A_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_A_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_A_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_A_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_A_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_A_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_A_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_A_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_RF_CCU )
.head 7 -  ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_A_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_A_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_A_RF_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_A_RF_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_RF_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_RF_CD )
.head 7 -  ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_Select_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_Select_A_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_A_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_A_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_A_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_L )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_L )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_A_L )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_A_L )
.head 7 -  ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_Select_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_SR )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_SR)
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_SR_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_SR_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_SR_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_SR_RF )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_SR_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_SR_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_SR_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_SR_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Gruppe_SR_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCL_SR_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_SR_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_SR_RF_CCU )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_SR_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_SR_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeG_SR_RF_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeCLG_SR_RF_CD )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_Select_SR_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_M_SR_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_SR_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_SR_D )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_Select_SR_L )
.head 7 -  ! Call VisPicFree(  hPicKHEL_Bett_F_SR_L )
.head 7 -  ! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree(  hPicKHEL_GruppeOCCUP )
.head 7 -  ! ! !!    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
.head 7 -  ! Call VisPicFree( hPicAtlantaExpanded )
.head 7 -  ! Call VisPicFree( hPicAtlantaCollapsed )
.head 7 -  ! Call VisPicFree( hPicFolderExpanded )
.head 7 -  ! Call VisPicFree( hPicFolderCollapsed )
.head 7 -  ! Call VisPicFree( hPicFolderFree )
.head 7 -  ! Call VisPicFree( hPicFall )
.head 7 -  ! Call VisPicFree( hPicMail )
.head 7 -  ! Call VisPicFree( hPicNewMail )
.head 7 -  ! Call VisPicFree( hPicClockW )
.head 7 -  ! Call VisPicFree( hPicClockR )
.head 7 -  ! Call SqlDisconnect( hSqlQuantityEB )
.head 7 -  ! Call SqlDisconnect( hSqlIsAlertCage )
.head 7 -  ! Call SqlDisconnect( hSqlIsAlertBett )
.head 7 -  ! Call SqlDisconnect( hSqlIsCadavers )
.head 7 -  ! Call SqlDisconnect( hSqlIsDead )
.head 7 -  ! Call SqlDisconnect( hSqlIsLitter )
.head 7 -  ! Call SqlDisconnect( hSqlIsOccupied )
.head 7 -  ! Call SqlDisconnect( hSqlIsRFID)
.head 7 -  ! Call GalSetProfileNumber( "KHE", "PrepareError", nPrepareError, sUserINIFileName )
.head 6 -  Set hWndKHE = hWndNULL
.head 3 +  List Box Class: clsKHExplorerLeft
.head 4 -  Window Location and Size
.head 5 -  Left:
.head 5 -  Top:
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Multiple selection? Class Default
.head 4 -  Sorted? Class Default
.head 4 -  Vertical Scroll? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  List in Tool Palette? Yes
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: clsExplorerLeft
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Boolean: bPlanningMode
.head 5 -  Boolean: bMatingMode
.head 5 -  Boolean: bMaleIsExist
.head 5 -  Boolean: bFemaleIsExist
.head 5 -  Boolean: bInternalRequestMode
.head 5 -  Date/Time: dtPlan_Started
.head 5 -  String: sPlan_Experiment
.head 5 -  String: sCageForMating
.head 5 -  Number: nPlan_Fall_Key
.head 5 -  Number: nPlan_LstErfNr
.head 5 -  !
.head 5 -  Boolean: bShowAllAbtStat
.head 5 -  Boolean: bUseCurrentTime
.head 5 -  Boolean: bShowDateTimeInKHE
.head 5 -  Boolean: bShowOnlyRealBew
.head 5 -  Date/Time: dtTimerStart
.head 5 -  Date/Time: dtTimerBase
.head 5 -  !
.head 5 -  String: sSelectedKeyLocal
.head 5 -  !
.head 5 -  Number: hCurrentBett
.head 5 -  Boolean: bCurrentBettHasFall
.head 5 -  Boolean: bCurrentBettLegalAbteilung
.head 5 -  Number: nFallKey_OnCurrentBett
.head 5 -  !
.head 5 -  Window Handle: hwndToolBar
.head 5 -  Window Handle: hWnd_pbSetTime
.head 5 -  Window Handle: hWnd_IRServices
.head 5 -  Window Handle: hWnd_EarTags
.head 5 -  Window Handle: hWnd_POC
.head 5 -  !
.head 5 -  Number: hMove_Source
.head 5 -  Boolean: bMove_SingleBett
.head 5 -  Number: bMove_HasInClipboard
.head 5 -  !
.head 5 -  Boolean: bBedIsFree
.head 5 -  Boolean: bGrpNeedsRefresh
.head 5 -  Boolean: bPastingMovement
.head 5 -  String: sOpenKHKItemOnScan
.head 5 -  Boolean: bShowMenuOnClosingCage
.head 5 -  !
.head 5 -  Number: nLocationsCount
.head 5 -  FunctionalVar: oLocations[*]
.head 6 -  Class: clsLocation
.head 5 -  String: sLocation
.head 5 -  !
.head 5 -  Boolean: bInternalRequestIsNeeded
.head 5 -  Number: nInternalRequestOrderId
.head 5 -  Number: nFallsQuantity
.head 5 -  Number: nInternalRequestOrderPosNr
.head 5 -  Number: nInternalRequestLstErfNr
.head 5 -  Number: nInternalRequestCount
.head 5 -  String: sFallsAvailableForCurrentIR[*]
.head 5 -  !
.head 5 -  Boolean: bMenuCutFallNrX
.head 5 -  String: sFallSex
.head 5 -  String: sCagesFrom2D[*,2]
.head 5 -  Number: nCagesFrom2DNr
.head 5 -  Boolean: bShowOnlyOpenCages
.head 5 -  Number: nPlan_AEBewNr
.head 5 -  String: sPlan_TarifKey
.head 5 -  String: sPlan_LstKey
.head 5 -  Boolean: bColorStrain
.head 5 -  Boolean: bMoveFlag
.head 5 -  String: sMoveScreen
.head 5 -  String: sAbtKeySrc
.head 5 -  String: sAbtKeyTmp
.head 5 -  String: sStatKeyTmp
.head 5 -  String: sGrpKeyTmp
.head 5 -  String: sBettKeyTmp
.head 5 -  Boolean: bOpenOnDblClick
.head 5 -  Boolean: bShowPlacesWithContent
.head 5 -  Boolean: bShowWithContent
.head 5 -  Boolean: bShowPlannedCages
.head 5 -  Boolean: bMassMating
.head 5 -  Boolean: bDistribution
.head 5 -  Window Handle: hWndRules
.head 5 -  Boolean: bUseEmail
.head 5 -  Boolean: bOpenTempCage
.head 5 -  Boolean: bDeadInCage
.head 5 -  Boolean: bDischargeDead
.head 5 -  Boolean: bSelectDead
.head 5 -  Boolean: bAskForLicense
.head 5 -  Boolean: bMatingActive
.head 5 -  Boolean: bMoveToVirt
.head 5 -  Boolean: bStudMailActive
.head 5 -  Number: hCageInVirt
.head 5 -  Boolean: bMatingCage
.head 5 -  !
.head 5 -  Boolean: bRackCreationInProcess
.head 5 -  Boolean: bShowCageUniqNr
.head 5 -  Boolean: bShowCageName
.head 5 -  String: sTemp
.head 5 -  String: asTemp[*]
.head 5 -  Number: nTemp
.head 5 -  !
.head 5 -  Number: nTransferredFalls[*]
.head 5 -  Number: nTransferredBetts[*]
.head 5 -  String: asTransferredCage[*]
.head 5 -  String: asTransferredRack[*]
.head 5 -  ! String: snTransferredCages[*]
.head 5 -  Number: nCCSrv
.head 5 -  Number: nFallDeadHandle[*]
.head 5 -  Number: nCountDead
.head 5 -  String: sMsgParam[*]
.head 5 -  Session Handle: hActiveSession
.head 5 -  Number: nBGColor
.head 4 +  Functions
.head 5 -  ! -- Init
.head 5 +  Function: SetWindowForRefresh
.head 6 -  Description: On SAM_Click we'll send AM_Refresh to the given window
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Window Handle: _hwndToolBar
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set hwndToolBar = _hwndToolBar
.head 5 +  Function: SetAutoMode
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: _bAuto
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set bAutoScan = _bAuto
.head 7 -  Return TRUE
.head 5 +  Function: Set_hWnd_pbSetTime
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Window Handle: hWnd2Set
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set hWnd_pbSetTime = hWnd2Set
.head 5 +  Function: IsSetTimeAvelable
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return SalIsWindowEnabled( hWnd_pbSetTime )
.head 5 +  Function: KHE_Options
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bPlanningMode_New
.head 7 -  Boolean: bMatingMode_New
.head 7 -  Boolean: bUseCurrentTime_New
.head 7 -  Boolean: bShowDateTimeInKHE_New
.head 7 -  Boolean: bShowOnlyRealBew_New
.head 7 -  Boolean: bOk
.head 7 -  Date/Time: dtRefreshDateTime_New
.head 7 -  String: sStore_Abt
.head 7 -  String: sStore_Stat
.head 7 -  String: sStore_Grp
.head 7 -  String: sStore_Bett
.head 6 +  Actions
.head 7 +  If Not LicenseExt_IsModuleEnabled_DI(  )
.head 8 -  Call SalMessageBox( GetMessageFromSection( 'KHE', 100, "'Disposition' is a new functionality which is not allowed for you !"), GetMessageX( 201, "Warning !" ), MB_IconExclamation )
.head 8 -  Return 0
.head 7 -  Set dtRefreshDateTime_New = dtKHK_RefreshTime
.head 7 -  Set bUseCurrentTime_New = bUseCurrentTime
.head 7 -  Set bShowDateTimeInKHE_New = bShowDateTimeInKHE
.head 7 -  Set bPlanningMode_New = bPlanningMode
.head 7 -  Set bMatingMode_New = bMatingMode
.head 7 -  Set bShowOnlyRealBew_New = bShowOnlyRealBew
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Call GetCurrentPosition( sStore_Abt, sStore_Stat, sStore_Grp, sStore_Bett )
.head 7 +  If SalModalDialog(	dlgKHE_DateOptions, hWndForm, 
		bPlanningMode_New, bMatingMode_New, dtRefreshDateTime_New, bUseCurrentTime_New, 
		bShowDateTimeInKHE_New, bShowOnlyRealBew_New, 
		dtPlan_Started, sPlan_Experiment, nPlan_Fall_Key, nPlan_LstErfNr, nPlan_AEBewNr, sPlan_TarifKey, sPlan_LstKey )
.head 8 -  Set bPlanningMode = bPlanningMode_New
.head 8 -  Set bMatingMode = bMatingMode_New
.head 8 -  Set bUseCurrentTime = bUseCurrentTime_New
.head 8 -  Set bShowDateTimeInKHE = bShowDateTimeInKHE_New
.head 8 -  Set bShowOnlyRealBew = bShowOnlyRealBew_New
.head 8 -  ! Call IsCageInLicense ()
.head 8 +  If bPlanningMode_New
.head 9 -  Call CollapseRoot()
.head 8 -  Call PopulateAndExpand(hRoot, bAutoScan )
.head 8 +  If bPlanningMode and bMatingMode 
.head 9 -  Set bMaleIsExist = FALSE
.head 9 -  Set bFemaleIsExist = FALSE
.head 9 -  Set sCageForMating = ''
.head 8 -  !
.head 8 +  If bPlanningMode
.head 9 -  Set bOk = SalPicSet( hWnd_pbSetTime, KHE_ClockR, PIC_FormatBitmap )
.head 9 -  Call SetTime4Refresh( dtRefreshDateTime_New )
.head 9 -  Call SalSendMsg(hWndGM, UM_ChangeMode, A_Change_FE_DT_Plan, 0)
.head 8 +  Else
.head 9 +  If bShowOnlyRealBew
.head 10 -  Set bOk = SalPicSet( hWnd_pbSetTime, KHE_ClockW, PIC_FormatBitmap )
.head 10 -  Call SalSendMsg(hWndGM, UM_ChangeMode, A_Change_FE_DT_Part, 0)
.head 9 +  Else
.head 10 -  Set bOk = SalPicSet( hWnd_pbSetTime, KHE_ClockY, PIC_FormatBitmap )
.head 10 -  Call SalSendMsg(hWndGM, UM_ChangeMode, A_Change_FE_DT, 0)
.head 9 -  !
.head 9 +  If bUseCurrentTime
.head 10 -  Call GetTime4Refresh(  )
.head 9 +  Else
.head 10 -  Call SetTime4Refresh( dtRefreshDateTime_New )
.head 8 +  If not bPlanningMode
.head 9 -  ! Call PopulateEinrichtung( bAutoScan )
.head 9 -  ! Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshTimeChanged, 0 )
.head 9 -  Call hWndKHE.clsKHExplorerLeft.KHE_RefreshAllCages()
.head 9 -  ! If sStore_Abt
.head 9 -  ! Set bOk = GoToAbt( sStore_Abt )
.head 9 +  ! If sStore_Stat And bOk
.head 10 -  Set bOk = GoToStat( sStore_Abt, sStore_Stat, bAutoScan )
.head 9 +  ! If sStore_Grp
.head 10 -  Set bOk = GotoGruppe( sStore_Abt, sStore_Stat, sStore_Grp, bAutoScan )
.head 9 +  ! If sStore_Bett
.head 10 -  Set bOk = GotoBett( sStore_Abt, sStore_Stat, sStore_Grp, sStore_Bett, bAutoScan )
.head 8 -  !
.head 8 -  ! Call PopulateEinrichtung( bAutoScan )
.head 8 +  ! If sStore_Abt
.head 9 -  Set bOk = GoToAbt( sStore_Abt )
.head 8 +  ! If sStore_Stat And bOk
.head 9 -  Set bOk = GoToStat( sStore_Abt, sStore_Stat, bAutoScan )
.head 8 +  ! If sStore_Grp
.head 9 -  Set bOk = GotoGruppe( sStore_Abt, sStore_Stat, sStore_Grp, bAutoScan )
.head 8 +  ! If sStore_Bett
.head 9 -  Set bOk = GotoBett( sStore_Abt, sStore_Stat, sStore_Grp, sStore_Bett, bAutoScan )
.head 5 +  Function: LoadSettings
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sFontName
.head 7 -  Number: nFontSize
.head 7 -  Number: nFontEnh
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sTmp
.head 7 -  String: sBGColor
.head 6 +  Actions
.head 7 -  Set sFontName = GalGetProfileStringX( "KHE", "Font_Name_Common", 'Courier New', sUserINIFileName )
.head 7 -  Set nFontSize = GalGetProfileNumberX( "KHE", "Font_Size_Common", 10, sUserINIFileName )
.head 7 -  Set nFontEnh = GalGetProfileNumberX( "KHE", "Font_Enh_Common", 0, sUserINIFileName )
.head 7 -  !
.head 7 +  If hFontCommon
.head 8 -  Call VisFontFree(hFontCommon)
.head 7 -  Set hFontCommon = VisFontLoad(sFontName, nFontSize, nFontEnh)
.head 7 -  ! Call SalFontSet(hWndItem,sFontName, nFontSize, nFontEnh)
.head 7 -  Set sFontName = GalGetProfileStringX( "KHE", "Font_Name_Racks", 'Courier New', sUserINIFileName )
.head 7 -  Set nFontSize = GalGetProfileNumberX( "KHE", "Font_Size_Racks", 10, sUserINIFileName )
.head 7 -  Set nFontEnh = GalGetProfileNumberX( "KHE", "Font_Enh_Racks", 0, sUserINIFileName )
.head 7 +  If hFontRacks
.head 8 -  Call VisFontFree(hFontRacks)
.head 7 -  Set hFontRacks = VisFontLoad(sFontName, nFontSize, nFontEnh)
.head 7 -  Set sFontName = GalGetProfileStringX( "KHE", "Font_Name_Cages", 'Courier New', sUserINIFileName )
.head 7 -  Set nFontSize = GalGetProfileNumberX( "KHE", "Font_Size_Cages", 10, sUserINIFileName )
.head 7 -  Set nFontEnh = GalGetProfileNumberX( "KHE", "Font_Enh_Cages", 0, sUserINIFileName )
.head 7 +  If hFontCages
.head 8 -  Call VisFontFree(hFontCages)
.head 7 -  Set hFontCages = VisFontLoad(sFontName, nFontSize, nFontEnh)
.head 7 -  Set sFontName = GalGetProfileStringX( "KHE", "Font_Name_Betts", 'Courier New', sUserINIFileName )
.head 7 -  Set nFontSize = GalGetProfileNumberX( "KHE", "Font_Size_Betts", 10, sUserINIFileName )
.head 7 -  Set nFontEnh = GalGetProfileNumberX( "KHE", "Font_Enh_Betts", 0, sUserINIFileName )
.head 7 +  If hFontBetts
.head 8 -  Call VisFontFree(hFontBetts)
.head 7 -  Set hFontBetts = VisFontLoad(sFontName, nFontSize, nFontEnh)
.head 7 +  If hFontBettsSummary
.head 8 -  Call VisFontFree(hFontBettsSummary)
.head 7 -  Set hFontBettsSummary = VisFontLoad(sFontName, nFontSize/2, nFontEnh)

.head 7 -  Set bMassMating=  GalGetProfileBooleanX( "KHE", "MassMating", TRUE, sUserINIFileName )
.head 7 -  Set bDistribution=  GalGetProfileBooleanX( "KHE", "Use_Distribution", TRUE, sUserINIFileName )
.head 7 -  Set bShowOnlyOpenCages = GalGetProfileBooleanX( "KHE", "ShowOnlyOpenCages", TRUE, sUserINIFileName )
.head 7 -  Set bShowMenuOnClosingCage = GalGetProfileBooleanX( "KHE", "ShowMenuOnClosingCage", FALSE, sUserINIFileName )
.head 7 -  Set bShowDateTimeInKHE = GalConfig_GetBool( "KHE", "ShowTime", FALSE, cfgUSER )
.head 7 -  Set bColorStrain = GalGetProfileBooleanX('Values','ColorStrain',FALSE, sGHSini_FileName )
.head 7 -  Call SetAutoMode( GalGetProfileBooleanX("KHE", "AutoMode", TRUE, sGHSini_FileName ) )
.head 7 -  ! Call GalSetProfileBoolean( 'Settings', 'AskForFamilyName', TRUE, sGHSini_FileName)
.head 7 -  Set sOpenKHKItemOnScan = GalGetProfileStringX("Settings", "OpenKHKItemOnScan" ,"Yes", ATLANTA_INI)
.head 7 -  ! Set bShowOnlyOpenCages = GalGetProfileBooleanX( "KHE", "ShowOnlyOpenCages", FALSE, sUserINIFileName )
.head 7 -  Set bShowMenuOnClosingCage = GalGetProfileBooleanX( "KHE", "ShowMenuOnClosingCage", FALSE, sUserINIFileName )
.head 7 -  Set bOpenOnDblClick = GalGetProfileBooleanX( "KHE", "OpenOnDblClick", TRUE, sUserINIFileName )
.head 7 -  Set bShowPlacesWithContent = GalGetProfileBooleanX('KHE','ShowOnlyPlacesWithContent', TRUE, sUserINIFileName )
.head 7 -  Set bShowWithContent = GalGetProfileBooleanX('KHE','ShowOnlyCagesWithContent', FALSE, sUserINIFileName )
.head 7 -  Set bShowPlannedCages = GalGetProfileBooleanX( "KHE", "ShowPlannedCages", FALSE, sUserINIFileName )
.head 7 -  Set bShouPics= GalGetProfileBooleanX( "KHE", "ShowPicsInKHE", TRUE, sUserINIFileName )
.head 7 -  Set bRealTimeMode = GalGetProfileBooleanX( "KHE", "RealTimeMode", TRUE, sUserINIFileName )
.head 7 -  Set bDischargeDead = GalGetProfileBooleanX( "KHE", "DisCulledAinmals", TRUE, sUserINIFileName )
.head 7 -  Set bSelectDead = GalGetProfileBooleanX( "KHE", "SelectDisCulledAinmals", TRUE, sUserINIFileName )
.head 7 -  Set bAskForLicense = GalGetProfileBooleanX( "Settings", "AskForLicense", FALSE, sGHSini_FileName )
.head 7 -  Set bMoveToVirt = GalGetProfileBooleanX( "KHE", "MoveToVirtualOnOpen", FALSE, sUserINIFileName )
.head 7 -  Set bMiniSolution = GalGetProfileBooleanX( "System", "MiniSolution", FALSE, sGHSini_FileName )
.head 7 -  Set bShowCageName = GalGetProfileBooleanX( "KHE", "ShowCageName", TRUE, sUserINIFileName )
.head 7 -  Set bShowCageUniqNr = GalGetProfileBooleanX( "KHE", "ShowCageUniqNr", TRUE, sUserINIFileName )
.head 7 -  Set bAutoShowTableSevices = GalGetProfileBooleanX( "KHE", "ShowSevicesAndMR", FALSE, sUserINIFileName )
.head 7 -  Set sQuestionOnShowTableServices = SalStrUpperX( GalGetProfileStringX(  "KHE", "AutoStartService", "ASK", sUserINIFileName) )
.head 7 -  Call LoadPics()
.head 7 +  If GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select value from settings where section = 'EMail' and name = 'Email notification' into :sTmp")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select value from settings where section = 'DEFAULT' and name = 'FacilityColor' into :sBGColor ")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Set nBGColor = SalStrToNumber(sBGColor)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select id from sysadm.leistung where lst_key = 'CCH' into :nCCSrv")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlDisconnect(hSql)
.head 7 +  If sTmp = "On"
.head 8 -  Set bUseEmail = TRUE
.head 7 +  Else
.head 8 -  Set bUseEmail = FALSE
.head 7 -  ! Call PrepareGlobalSql(  )
.head 7 -  ! Set nPrepareError = nPrepareError - 1
.head 7 -  Call GalSetProfileString("Settings", "AddRelshipDef", "YES", sGHSini_FileName)
.head 7 -  Call ReFont()
.head 5 +  Function: ReFont
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCount
.head 7 -  Number: nCurrent
.head 7 -  Number: nHandle
.head 6 +  Actions
.head 7 -  Set nCount = SalListQueryCount(hWndItem)
.head 7 -  Set nCurrent = 0
.head 7 +  While nCurrent < nCount
.head 8 -  Set nHandle = GetItemHandle(nCurrent)
.head 8 +  If nHandle 
.head 9 -  Call KHEReAssignPics(nHandle)
.head 8 -  Set nCurrent = nCurrent + 1
.head 5 -  !
.head 5 +  Function: IsFallInPlanExperiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKey2Test
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Boolean: bExist
.head 6 +  Actions
.head 7 +  If bPlanningMode and nFallKey2Test and sPlan_Experiment
.head 8 +  If not GalConnect( hSql )
.head 9 -  Return FALSE
.head 8 +  If SqlPrepareAndExecute( hSql, "
select EXPERIMENT_KEY from FALL_EXPERIMENT 
where	EINRICHT_ID = :nEinrichtId
  and	FALL_KEY = :nFallKey2Test
  and	EXPERIMENT_KEY = :sPlan_Experiment
  and	( START_DATE is null or START_DATE <= :dtKHK_RefreshTime )
  and	( END_DATE is NULL or END_DATE > :dtKHK_RefreshTime )
" )
.head 9 -  Set bExist = SqlFetchNext( hSql, nFetch )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bExist
.head 5 +  Function: IsFallHavePlanBew
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKey2Test
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Boolean: bExist
.head 6 +  Actions
.head 7 +  If nFallKey2Test
.head 8 +  If not GalConnect( hSql )
.head 9 -  Return FALSE
.head 8 +  If SqlPrepareAndExecute( hSql, "
select FALL_KEY from BEWEGUNG_PLAN
where	EINRICHT_ID = :nEinrichtId
and	FALL_KEY = :nFallKey2Test" )
.head 9 -  Set bExist = SqlFetchNext( hSql, nFetch )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bExist
.head 5 +  Function: HasHandlePlanExpFall
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKey
.head 6 +  Actions
.head 7 -  Return IsFallInPlanExperiment( GetFallKey_ByHandle( nHandle ) )
.head 5 +  Function: IsCageInLicense
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sGrp
.head 7 -  String: sStat
.head 7 -  String: sAbt
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  Number: hState
.head 7 -  Number: hAbt
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  Number: nGroupe
.head 7 -  Number: nGrp
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nFlags1
.head 7 -  Number: nBet
.head 7 -  Number: nStat
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags2
.head 7 -  Number: l
.head 7 -  Number: k
.head 7 -  Number: i
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBet[*]
.head 6 +  Actions
.head 7 +  If bPlanningMode
.head 8 +  If nSelectedLevel != KHEL_Gruppe
.head 9 -  Return FALSE
.head 8 -  Set sGrp = GetKey_ByHandle( nSelectedHandle )
.head 8 -  Set hState = GetParent( nSelectedHandle )
.head 8 -  Set sStat = GetKey_ByHandle( hState  )
.head 8 -  Set hAbt = GetParent( hState  )
.head 8 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 8 -  Set nStat = EnumChildren( hAbt, hStat )
.head 8 +  If nStat
.head 9 -  Set i = 0
.head 9 +  Loop
.head 10 +  If i >= nStat
.head 11 -  Break
.head 10 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 10 -  Set sStat = GetKey_FromLable (sText)
.head 10 -  Set nGroupe = EnumChildren( hStat[ i ], hGrp )
.head 10 +  If nGroupe
.head 11 -  Set k = 0
.head 11 +  Loop
.head 12 +  If k >= nGroupe
.head 13 -  Break
.head 12 -  Call GetItemData( hGrp[ k ], sText1, nValueLoc1, nFlags1 )
.head 12 -  Set sGrp = GetKey_FromLable (sText1)
.head 12 -  Call PopulateGruppe (hGrp[ k ], TRUE)
.head 12 -  Set nBet = EnumChildren( hGrp[ k ], hBet )
.head 12 +  If nBet
.head 13 -  Set l = 0
.head 13 +  Loop
.head 14 +  If l>= nBet
.head 15 -  Break
.head 14 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 14 +  If SalStrScan(sText2, 'Not in')>0
.head 15 -  Call CloseGruppe (sAbt, sStat, sGrp)
.head 14 -  Set l= l + 1
.head 12 -  Set k = k + 1
.head 10 -  Set i = i + 1
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 -  !
.head 5 +  Function: GetTime4Refresh
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Date/Time:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! Date/Time: dtKHK_RefreshTime_Prev
.head 7 -  ! Number: nOneSecond
.head 6 +  Actions
.head 7 -  ! Set dtKHK_RefreshTime_Prev = dtKHK_RefreshTime
.head 7 -  ! Set nOneSecond = SalDateConstruct( 2000, 1, 1, 0, 0, 1 ) - SalDateConstruct( 2000, 1, 1, 0, 0, 0 )
.head 7 +  ! If Not dtKHK_RefreshTime_Prev
.head 8 -  Set dtKHK_RefreshTime_Prev = SalDateConstruct( 1900, 1, 1, 0, 0, 0 )
.head 7 +  If bUseCurrentTime
.head 8 -  Set dtKHK_RefreshTime = SalDateCurrent(  )
.head 7 +  Else
.head 8 +  If Not dtTimerStart
.head 9 -  Set dtTimerStart = SalDateCurrent(  )
.head 8 +  If not dtTimerBase
.head 9 -  Set dtTimerBase = dtKHK_RefreshTime
.head 8 -  ! AH 13.10.04:
.head 8 -  Set dtKHK_RefreshTime = dtTimerBase + ( SalDateCurrent(  ) - dtTimerStart )
.head 8 -  ! was before:
.head 8 +  ! If dtKHK_RefreshTime
.head 9 -  Set dtKHK_RefreshTime = dtKHK_RefreshTime + ( SalDateCurrent(  ) - dtTimerStart )
.head 8 +  ! Else
.head 9 -  Set dtKHK_RefreshTime = dtTimerStart
.head 7 -  Return dtKHK_RefreshTime
.head 5 +  Function: SetTime4Refresh
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Date/Time: dtpRefreshDateTime
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set dtKHK_RefreshTime = dtpRefreshDateTime
.head 7 -  Set dtTimerBase = dtpRefreshDateTime
.head 7 -  Set dtTimerStart = SalDateCurrent(  )
.head 7 -  Call Rack2DView_RefreshOnTimeChanged( )
.head 5 +  Function: CheckPL
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLitter_idTemp
.head 7 -  Boolean: bOk
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Sql Handle: hSql
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If KHE_IsOccupied( sAbtKey, sStatKey, sGrpKey, sBettKey, GetTime4Refresh(  ) )
.head 8 -  Return FALSE
.head 7 -  Return CheckPL_Param(sAbtKey, sStatKey, sGrpKey)
.head 5 +  Function: CheckPL_Param
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 6 +  Static Variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nLitter_idTemp
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  ! If GalConnect( hSql )
.head 8 -  ! Set bOk = SqlPrepareAndExecute( hSql, "
select 1
from FALL f, relship_fall rf,  gruppe g, litter l
where 1=1
and f.LAST_stat_Key= :sStatKey
and f.last_cage_nr=g.uniq_nr
and g.gruppe_key= :sGrpKey
and f.EE_DATUM is null
and f.geschl='W'
and rf.fall_key=f.fall_KEY
and rf.FALLROLLE_KEY='PARENT'
and l.family_relship_id=rf.relship_id
and (Not exists(select lc.litter_id from litter_child lc where lc.litter_id=l.litter_id )
 or exists(select lc.litter_id from litter_child lc where lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0))
    into :nLitter_idTemp
")
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
select 
                      l.litter_id
                 from
                    bewegung b, fall f, relship_fall rf, 
                    litter l                
                 where
          	           b.einricht_id = :nEinrichtId
	    and b.abt_key=:sAbtKey
                    and b.stat_key = :sStatKey
                    and b.gruppe_key = :sGrpKey
	   and  b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' ) and b.GELOESCHT ='N'
                    and @NOW between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
                    and f.einricht_id = b.einricht_id
                    and f.fall_key = b.fall_key
                    and f.geloescht = 'N'
                    and f.geschl = 'W'
	    and rf.einricht_id = f.einricht_id
                    and rf.fall_key = f.fall_key 
	    and rf.fallrolle_key = 'PARENT'
                    and l.family_relship_id = rf.relship_id
	    and @NULLVALUE(l.miss,0) = 0
                    and (Not exists(select lc.litter_id from litter_child lc where lc.litter_id=l.litter_id and lc.einricht_id=b.einricht_id)
                            or exists(select lc1.litter_id from litter_child lc1 where lc1.einricht_id=b.einricht_id and lc1.litter_id=l.litter_id and lc1.fall_key is null and lc1.dead=0))
                    and ((l.geb_datum<=@NOW))
    into :nLitter_idTemp
")
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
select 
                      l.litter_id
                 from
                    bewegung b, fall f, relship_fall rf, 
                    litter l                
                 where
          	           b.einricht_id = :nEinrichtId
	    and b.abt_key=:sAbtKey
                    and b.stat_key = :sStatKey
                    and b.gruppe_key = :sGrpKey
	   and  b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' ) and b.GELOESCHT ='N'
                    and @NOW between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
                    and f.einricht_id = b.einricht_id
                    and f.fall_key = b.fall_key
                    and f.geloescht = 'N'
                    and f.geschl = 'W'
	    and rf.einricht_id = f.einricht_id
                    and rf.fall_key = f.fall_key 
	    and rf.fallrolle_key = 'PARENT'
                    and l.family_relship_id = rf.relship_id
	    and @NULLVALUE(l.miss,0) = 0
                    and (Not exists(select lc.litter_id from litter_child lc where lc.litter_id=l.litter_id and lc.einricht_id=b.einricht_id)
                            or exists(select lc1.litter_id from litter_child lc1 where lc1.einricht_id=b.einricht_id and lc1.litter_id=l.litter_id and lc1.fall_key is null and lc1.dead=0))
                    and ((l.geb_datum<=@NOW))
    into :nLitter_idTemp
")
.head 8 -  Set bOk= SqlFetchNext( hSql, nLitter_idTemp )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bOk
.head 7 +  If GalConnect( hSql )
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
select
                      l.litter_id
                 from
                    bewegung b, fall f, relship_fall rf,
                    litter l
                 where
          	           b.einricht_id = :nEinrichtId
	    and b.abt_key=:sAbtKey
                    and b.stat_key = :sStatKey
                    and b.gruppe_key = :sGrpKey
	   and  b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' ) and b.GELOESCHT ='N'
                    and @NOW between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
                    and f.einricht_id = b.einricht_id
                    and f.fall_key = b.fall_key
                    and f.geloescht = 'N'
                    and f.geschl = 'W'
	    and rf.einricht_id = f.einricht_id
                    and rf.fall_key = f.fall_key
	    and rf.fallrolle_key = 'PARENT'
                    and l.family_relship_id = rf.relship_id
	    and @NULLVALUE(l.miss,0) = 0
                    and ((l.geb_datum<=@NOW))
           and ( exists(select lc1.litter_id from litter_child lc1 where  lc1.litter_id=l.litter_id and lc1.fall_key is null and lc1.dead=0)
                      or not exists(select lc2.litter_id from litter_child lc2 where  lc2.litter_id=l.litter_id) )
    into :nLitter_idTemp
")
.head 8 -  Set bOk= SqlFetchNext( hSql, nLitter_idTemp )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bOk
.head 5 +  Function: OpenPL
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLitter_idTemp
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call PL_Check_Add ( sStatKey, sGrpKey, 0)
.head 5 +  Function: WeanLitter
.head 6 -  Description: Changed by SS 09.01.2008
	Wean Litter from cage with unwean litter to All open Cage and Room 
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLitter_idTemp
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: hStation[*]
.head 7 -  Number: hGroope[*]
.head 7 -  Number: nGrp
.head 7 -  Number: nStat
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: hCurrent
.head 7 -  String: sGrp
.head 7 -  String: sStat
.head 7 -  String: sAbt
.head 7 -  ! String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  ! String: sBettKey
.head 7 -  String: sRoom
.head 7 -  String: sCage
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql
.head 7 -  Number: hAbt
.head 7 -  Number: hStat
.head 7 -  String: sScreen
.head 6 +  Actions
.head 7 -  Call frmAtlantaMain.OpenDLForLitter()
.head 7 -  ! If bDistribution
.head 7 +  ! Else
.head 8 -  Set sLitterId= ''
.head 8 -  Set sRoomCage=''
.head 8 -  Set sAbt = ""
.head 8 -  Set sStat = ""
.head 8 -  Set sGrp = ""
.head 8 -  Set sStatKey = ""
.head 8 -  Set sGrpKey = ""
.head 8 +  If nSelectedLevel = KHEL_Bett
.head 9 -  Set i = GetParent(nSelectedHandle)
.head 8 +  Else 
.head 9 -  Set i = nSelectedHandle
.head 8 -  Set sGrp = GetKey_ByHandle( i )
.head 8 -  Set hStat = GetParent( i )
.head 8 -  Set sStat = GetKey_ByHandle( hStat )
.head 8 -  Set hAbt = GetParent( hStat )
.head 8 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 8 -  Set nStat = EnumChildren( hAbt, hStation )
.head 8 +  If nStat
.head 9 -  Set i = 0
.head 9 +  Loop 
.head 10 +  If i >= nStat
.head 11 -  Break 
.head 10 -  Call GetItemData( hStation[ i ], sText, nValueLoc, nFlags )
.head 10 -  Set sStatKey = GetKey_FromLable (sText)
.head 10 -  Set nGrp = EnumChildren( hStation[ i ], hGroope )
.head 10 +  If nGrp
.head 11 -  Set k = 0
.head 11 +  Loop 
.head 12 +  If k >= nGrp
.head 13 -  Break 
.head 12 -  Call GetItemData( hGroope[ k ], sText1, nValueLoc1, nFlags1 )
.head 12 -  Set sGrpKey = GetKey_FromLable (sText1)
.head 12 +  If Not CheckPL_Param(sStatKey, sGrpKey)
.head 13 -  Set sRoomCage= sRoomCage || sStatKey||','||sGrpKey||','
.head 13 -  Set sScreen= sAbt
.head 12 -  Set k = k + 1
.head 10 -  Set i = i + 1
.head 8 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Call PL_Add_Litter ( sStat, sGrp, 0)
.head 8 -  Call StartSeparateEXEx( 'mice_imp.exe', '/litter_id=' || sLitterId || ' /RoomCage=' || sRoomCage || ' /Screen=' || sScreen )
.head 5 +  Function: AutoMiceImp
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nSex
.head 7 -  Boolean: bCheckOnly
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sStatKey
.head 7 -  String: sCage
.head 7 -  String: sSex
.head 7 -  String: sScreen
.head 7 -  String: sQaunt
.head 7 -  Number: hAbt
.head 7 -  Number: hRack
.head 7 -  String: sRoomCage
.head 7 -  Number: nQuantity
.head 7 -  Number: nCountCage
.head 7 -  Boolean: bBulkImp
.head 7 -  String: sRule[*]
.head 7 -  Number: k
.head 7 -  String: sSource[*]
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 -  !
.head 7 -  Call SalSendMsg(hWndStar2000, AM_OpenDL, 0, nSex+1)
.head 7 -  ! Set sCage = ''
.head 7 -  ! Set sCage = GetKey_ByHandle( nSelectedHandle )
.head 7 -  ! Set hRack = GetParent( nSelectedHandle )
.head 7 -  ! Set hAbt = GetParent( hRack )
.head 7 -  ! ! Set sAbt = GetKey_ByHandle( hAbt )
.head 7 -  ! Call GetOpenEmptyCage(hAbt,sScreen,sRoomCage,nQuantity, FALSE)
.head 7 -  ! Set bBulkImp= TRUE
.head 7 -  ! Call GetOpenCage(hAbt,sScreen,sRoomCage,nCountCage,nQuantity,bBulkImp,FALSE)
.head 7 -  ! Set sSex=  SalNumberToStrX(nSex,0)
.head 7 -  ! Set sQaunt= SalNumberToStrX(nQuantity,0)
.head 7 +  ! If not bCheckOnly
.head 8 +  ! If nCountCage>1
.head 9 -  ! Call Rules('')
.head 9 -  Call SalStrTokenize(sRoomCage,'',',', sSource)
.head 9 -  Call SalArrayGetUpperBound(sSource,1,nBound)
.head 9 -  Set sRule[0]=sScreen||','||SalNumberToStrX(nSex,0)
.head 9 -  Set k=0
.head 9 +  While (3*k+2)<=nBound
.head 10 -  Set sRule[k+1]=(sSource[3*k]||','||sSource[3*k+1]||', ,'||sSource[3*k+2])
.head 10 -  ! Call SalMessageBox(sRule[k+1],'',0) 
.head 10 -  Set k=k+1
.head 9 +  If VisWinIsWindow( hWndRules )
.head 10 -  Call SalSendMsg(hWndRules, AM_Refresh, wParam, lParam )
.head 10 -  Call SalBringWindowToTop( hWndRules )
.head 9 +  Else 
.head 10 -  Set hWndRules = SalCreateWindow( frmUnweanRules, hWndStar2000,sRule)
.head 8 -  Call StartSeparateEXEx( 'mice_imp.exe',
 ' /RoomCage=' || sRoomCage || ' /Screen=' || sScreen || ' /Sex=' || sSex || ' /Quantity=' || sQaunt  )
.head 8 +  ! Else
.head 9 -  Call StartSeparateEXEx( 'mice_imp.exe', 
 ' /RoomCage=' || sRoomCage || ' /Screen=' || sScreen || ' /Sex=' || sSex || ' /Quantity=' || sQaunt  )
.head 7 +  ! Else
.head 8 -  Return nQuantity
.head 7 -  !
.head 5 +  Function: AutoMiceImpExtDelivery
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nOrder_Id
.head 7 -  Number: nPos_Nr
.head 7 -  String: sScreen
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hScreen
.head 7 -  Number: nQuantity
.head 7 -  Number: nCountCage
.head 7 -  String: sQaunt
.head 7 -  String: sDelivery
.head 6 +  Actions
.head 7 -  Set hScreen= FindH_4Abteilung(sScreen)
.head 7 -  ! Call GetOpenEmptyCage(hScreen,sScreen,sRoomCage,nQuantity, FALSE)
.head 7 -  Call GetOpenCage(hScreen,sScreen,sRoomCage,nCountCage, nQuantity,FALSE, FALSE)
.head 7 -  Set sQaunt= SalNumberToStrX(nQuantity,0)
.head 7 +  If bDistribution
.head 8 -  ! Set sDelivery= sScreen||','||SalNumberToStrX( nOrder_Id,0 )||','||SalNumberToStrX( nPos_Nr,0 )
.head 8 -  ! Call Rules(sDelivery)
.head 8 -  ! Call StartDL(nOrder_Id, nPos_Nr, sScreen)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_OpenDL, -1, SalHStringToNumber("0,"||SalNumberToStrX(nOrder_Id, 0)||","||SalNumberToStrX(nPos_Nr,0)||","||sScreen))
.head 7 +  Else
.head 8 -  Call StartSeparateEXEx( 'mice_imp.exe', ' /ERId=' || SalNumberToStrX( nOrder_Id,0 ) || ' /ERPosNr=' || SalNumberToStrX( nPos_Nr,0 ) ||' /RoomCage=' || sRoomCage || ' /Screen=' || sScreen )
.head 7 -  ! Call SalMessageBox(' /ERId=' || SalNumberToStrX( nOrder_Id,0 ) || ' /ERPosNr=' || SalNumberToStrX( nPos_Nr,0 ) ||' /RoomCage=' || sRoomCage || ' /Screen=' || sScreen,'',0 )
.head 7 -  !
.head 5 +  Function: Rules
.head 6 -  Description: if start for Wean Litter parametr is ''
if start from ExternalDelivery parametr is sDelivery= sScreen nOrder_Id nPos_Nr
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sDelivery
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! Window Handle: hWndRules
.head 7 -  String: sRule[*]
.head 6 +  Actions
.head 7 -  Call SalSendMsg(hWndStar2000, AM_OpenDL, -1, 0)
.head 7 +  ! If Not GetSexQuantForRoomCage(sRule)
.head 8 +  If IDYES= SalMessageBox('No cages selected, do You want start Mice Import directly','',MB_YesNo)
.head 9 -  Call StartSeparateEXEx( 'mice_imp.exe', '/litter_id=' || sLitterId)
.head 8 +  Else 
.head 9 -  Return FALSE
.head 7 +  ! Else
.head 8 +  If sDelivery
.head 9 -  Set sRule[0]= sDelivery
.head 8 +  If VisWinIsWindow( hWndRules )
.head 9 -  Call SalSendMsg(hWndRules, AM_Refresh, wParam, lParam )
.head 9 -  Call SalBringWindowToTop( hWndRules )
.head 8 +  Else 
.head 9 -  Set hWndRules = SalCreateWindow( frmUnweanRules, hWndStar2000,sRule)
.head 5 +  ! Function: GetSexQuantForRoomCage
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Receive String: sRule[*]
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  String: sRCTemp
.head 7 -  String: sAbt
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sRackSource
.head 7 -  String: sCageSource
.head 7 -  String: sGrpKey
.head 7 -  String: sBetKey
.head 7 -  String: sSex
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  String: sRoomCageHandle
.head 7 -  String: sHandle
.head 7 -  String: sBett_Key
.head 7 -  String: sMaleFall
.head 7 -  String: sFemaleFall
.head 7 -  Number: hAbt
.head 7 -  Number: hRack
.head 7 -  Number: hCage
.head 7 -  Number: hCageSource
.head 7 -  Number: nBet
.head 7 -  Number: hBet[*]
.head 7 -  Number: nEmptyPlace
.head 7 -  Number: nCountCage
.head 7 -  Number: l
.head 7 -  Number: q
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: nLevelLoc
.head 7 -  Number: nMTT
.head 7 -  Number: nFalls[*]
.head 7 -  Number: hBett
.head 7 -  Number: i
.head 7 -  Number: ParamForBulkImp
.head 7 -  ! String: sRule[*]
.head 6 +  Actions 
.head 7 -  Set sGrpKey = ""
.head 7 -  Set sLitterId= ''
.head 7 -  Set nEmptyPlace=0
.head 7 -  Set nLevelLoc = GetLevel(nSelectedHandle)
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set hAbt =nSelectedHandle
.head 9 -  Set sAbt = GetKey_ByHandle( nSelectedHandle )
.head 9 -  Break 
.head 8 +  Case KHEL_Station
.head 9 -  Set sRackSource = GetKey_ByHandle( nSelectedHandle )
.head 9 -  Set hAbt = GetParent( nSelectedHandle )
.head 9 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 9 -  Break 
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set sCageSource = GetKey_ByHandle( nSelectedHandle )
.head 9 -  Set hRack = GetParent( nSelectedHandle )
.head 9 -  Set sRackSource = GetKey_ByHandle( hRack )
.head 9 -  Set hAbt = GetParent( hRack )
.head 9 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 9 -  Break 
.head 8 +  Case KHEL_Bett
.head 9 -  Set hCageSource = GetParent( nSelectedHandle )
.head 9 -  Set sCageSource = GetKey_ByHandle( hCageSource )
.head 9 -  Set hRack = GetParent( hCageSource )
.head 9 -  Set sRackSource = GetKey_ByHandle( hRack )
.head 9 -  Set hAbt = GetParent( hRack )
.head 9 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 9 -  Break 
.head 7 -  Call PL_Add_Litter (sRackSource, sCageSource, 0)
.head 7 -  Call GetOpenCage(hAbt,sAbt,sRoomCageHandle,nCountCage, ParamForBulkImp,FALSE, TRUE)
.head 7 +  If nCountCage=1
.head 8 -  Return FALSE
.head 7 -  Set q=0
.head 7 -  Set nMTT=0
.head 7 +  While q<=nCountCage-1
.head 8 -  Set sRack= SalStrLeftX(sRoomCageHandle, SalStrScan(sRoomCageHandle, ','))
.head 8 -  Set sRoomCageHandle= SalStrReplaceX(sRoomCageHandle, 0, SalStrLength(sRack)+1, '' )
.head 8 -  Set sCage= SalStrLeftX(sRoomCageHandle, SalStrScan(sRoomCageHandle, ','))
.head 8 -  Set sRoomCageHandle= SalStrReplaceX(sRoomCageHandle, 0, SalStrLength(sCage)+1, '' )
.head 8 -  Set sHandle= SalStrLeftX(sRoomCageHandle, SalStrScan(sRoomCageHandle, ','))
.head 8 -  Set sRoomCageHandle= SalStrReplaceX(sRoomCageHandle, 0, SalStrLength(sHandle)+1, '' )
.head 8 +  If sRack= sRackSource and sCage= sCageSource 
.head 9 -  Call GetFallsInGruppe(SalStrToNumber(sHandle),nFalls)
.head 9 -  Set i=0
.head 9 -  Call SalArrayGetUpperBound(nFalls,1,i)
.head 9 +  While i>=0
.head 10 -  Set sBett_Key = SalNumberToStrX(nFalls[i],0)
.head 10 -  ! Set hBett = FindChild( SalStrToNumber(sHandle),"(" || sBett_Key || ")" )
.head 10 -  Set hBett= SearchFrom(SalStrToNumber(sHandle),sBett_Key )
.head 10 +  If GetSex_ByHandle(hBett)>0
.head 11 -  Set sMaleFall=sBett_Key
.head 10 +  Else 
.head 11 -  Set sFemaleFall=sBett_Key
.head 10 -  Set i=i-1
.head 9 -  Set sRule[0]= sAbt||','||sRackSource||','||sCageSource||','||sMaleFall||','||sFemaleFall
.head 9 -  Set nCountCage=nCountCage-1
.head 8 -  !
.head 8 +  Else 
.head 9 -  ! Set hRack= FindH_4Station(hAbt,sRack,TRUE)
.head 9 -  ! Set hCage= FindH_4Gruppe(hRack, sCage,TRUE )
.head 9 -  Set hCage= SalStrToNumber(sHandle)
.head 9 -  !
.head 9 -  Call GetItemData( hCage, sText1, nValueLoc1, nFlags1 )
.head 9 -  Set sGrpKey = GetKey_FromLable (sText1)
.head 9 +  If SalStrScan(sText1, "MTT")>0
.head 10 -  Set q=q+1
.head 10 -  Set nMTT=nMTT+1
.head 9 +  Else 
.head 10 -  Set sSex=''
.head 10 -  Set nBet = EnumChildren( hCage, hBet )
.head 10 -  ! Check Cage for bett sex and count of empty place
.head 10 +  If nBet
.head 11 -  Set l = 0
.head 11 +  Loop 
.head 12 +  If l >= nBet
.head 13 -  Break 
.head 12 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 12 -  Set sBetKey = GetKey_FromLable (sText2)
.head 12 +  If SalStrScan(sText2,"{") > 0
.head 13 +  If Not SalStrScan(sText2,"PB")>0
.head 14 +  If SalStrScan(sText2, ", F,")>0 and sSex!="F"
.head 15 -  Set sSex=sSex||"F"
.head 14 +  If SalStrScan(sText2, ", M,")>0 and sSex!="M"
.head 15 -  Set sSex=sSex||"M"
.head 12 +  Else 
.head 13 +  If SalStrLength(sSex)<2
.head 14 -  Set nEmptyPlace=nEmptyPlace+1
.head 12 -  Set l = l + 1
.head 10 +  ! If SalStrLength(sSex)>=2
.head 11 -  Call PL_Add_Litter (sRack, sCage, 0)
.head 11 -  Call SalMessageBox(sRack||','||sCage,'',0)
.head 11 -  Set sRule[0]= sAbt||','||sRack||","||sCage||","||sLitterId
.head 11 -  ! Call SalMessageBox(sRule[0],'',0)
.head 10 +  If bShowPlacesWithContent
.head 11 -  Set nEmptyPlace=0
.head 11 -  Set nEmptyPlace=QuantityOfEmptyBett(hCage)
.head 10 -  Set q=q+1
.head 10 -  Set sRule[q-nMTT]= sRack||","||sCage||","||sSex||","||SalNumberToStrX(nEmptyPlace,0)
.head 10 -  ! Call SalMessageBox(sRule[q],'',0)
.head 9 -  Set nEmptyPlace=0
.head 9 -  ! Set q=q+1
.head 7 -  Return TRUE
.head 5 -  !
.head 5 +  ! Function: GetOpenCage
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Number: hScreen
.head 7 -  Receive String: sScreen
.head 7 -  Receive String: sRoomCageHandle
.head 7 -  Receive Number: nCountCage
.head 7 -  Boolean: bHandle
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  String: sAbt
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  Number: hAbt
.head 7 -  Number: nSelLev
.head 7 -  Number: nStat
.head 7 -  Number: i
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGroppe[*]
.head 7 -  Number: nGroppe
.head 7 -  Number: k
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nFlags1
.head 7 -  ! Number: hScreen
.head 6 +  Actions 
.head 7 -  Set sRoomCage=''
.head 7 -  Set sAbt = ""
.head 7 -  Set sStatKey = ""
.head 7 -  Set sGrpKey = ""
.head 7 -  Set hAbt=hScreen
.head 7 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 7 -  Set nStat = EnumChildren( hAbt, hStat)
.head 7 -  ! ! Find all open Stations
.head 7 +  If nStat
.head 8 -  Set i = 0
.head 8 +  Loop 
.head 9 +  If i >= nStat
.head 10 -  Break 
.head 9 +  If Not GetIsRackVirtual_ByHandle(hStat[i])
.head 10 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 10 -  Set sStatKey = GetKey_FromLable (sText)
.head 10 -  ! Find all open Groppe
.head 10 -  Set nGroppe = EnumChildren( hStat[ i ], hGroppe )
.head 10 +  If nGroppe
.head 11 -  Set k = 0
.head 11 +  Loop 
.head 12 +  If k >= nGroppe
.head 13 -  Set nCountCage=nCountCage + k
.head 13 -  Break 
.head 12 -  Call GetItemData( hGroppe[ k ], sText1, nValueLoc1, nFlags1 )
.head 12 +  If bHandle
.head 13 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText1) ||','||SalNumberToStrX(hGroppe[ k ],0)||','
.head 12 +  Else 
.head 13 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText1) ||','
.head 12 -  Set k = k + 1
.head 9 -  Set i = i + 1
.head 7 -  Return TRUE
.head 5 +  Function: GetOpenCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hScreen
.head 7 -  Receive String: sScreen
.head 7 -  Receive String: sRoomCageHandle
.head 7 -  Receive Number: nCountCage
.head 7 -  Receive Number: nQuantity
.head 7 -  Boolean: bBulk
.head 7 -  Boolean: bHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  !
.head 7 -  Number: hAbt
.head 7 -  Number: hStatKey
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hStat[*]
.head 7 -  Number: hRoom[*]
.head 7 -  Number: hGroppe[*]
.head 7 -  Number: hBett[*]
.head 7 -  Number: nGroppe
.head 7 -  Number: nRoom
.head 7 -  Number: nStat
.head 7 -  Number: nBet
.head 7 -  Number: nBett
.head 7 -  Number: b
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: hCurrent
.head 7 -  Number: nLitter_idTemp
.head 7 -  Number: nSelLev
.head 7 -  Boolean: bFem
.head 7 -  Boolean: bMale
.head 7 -  Boolean: bGetero
.head 7 -  Boolean: bMatingCage
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql
.head 6 +  Actions
.head 7 -  Set sRoomCage=''
.head 7 -  Set sAbt = ""
.head 7 -  Set sStatKey = ""
.head 7 -  Set sGrpKey = ""
.head 7 -  Set hAbt=hScreen
.head 7 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 7 -  Set nStat = EnumChildren( hAbt, hStat)
.head 7 -  ! ! Find all open Stations
.head 7 +  If nStat
.head 8 -  Set i = 0
.head 8 +  Loop
.head 9 +  If i >= nStat
.head 10 -  Break
.head 9 +  If TRUE ! Not GetIsRackVirtual_ByHandle(hStat[i])
.head 10 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 10 -  Set sStatKey = GetKey_FromLable (sText)
.head 10 -  ! Find all open Empty Groppe
.head 10 -  Set nGroppe = EnumChildren( hStat[ i ], hGroppe )
.head 10 +  If nGroppe
.head 11 -  Set k = 0
.head 11 +  Loop
.head 12 +  If k >= nGroppe
.head 13 -  Set nCountCage=nCountCage + k
.head 13 -  Break
.head 12 -  ! Call GetItemData( hGroppe[ k ], sText1, nValueLoc1, nFlags1 )
.head 12 +  ! If SalStrScan(sText1, '[+]')>0
.head 13 -  ! Set nBet= EnumChildren( hGroppe[ k ], hBet)
.head 12 -  Set nBett = EnumChildren( hGroppe[ k ], hBett )
.head 12 +  If nBett
.head 13 -  Set b=0
.head 13 -  Set bFem=FALSE
.head 13 -  Set bMale=FALSE
.head 13 -  Set bGetero=FALSE
.head 13 -  Set bMatingCage=FALSE
.head 13 +  Loop
.head 14 +  If b>=nBett
.head 15 +  If Not bGetero and Not bMatingCage
.head 16 -  Call GetItemData( hGroppe[ k ], sText2, nValueLoc2, nFlags2 )
.head 16 +  If bBulk
.head 17 -  Set nBet= QuantityOfEmptyBett( hGroppe[ k ])
.head 17 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText2) ||','||SalNumberToStrX(nBet,0)||','  
.head 16 +  Else If bHandle
.head 17 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText2) ||','||SalNumberToStrX(hGroppe[ k ],0)||','
.head 16 +  Else
.head 17 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText2) ||','
.head 16 -  Set nBet= QuantityOfEmptyBett( hGroppe[ k ])
.head 16 -  Set sScreen= sAbt
.head 15 -  Break
.head 14 -  Call GetItemData( hBett[ b ], sText1, nValueLoc1, nFlags1 )
.head 14 +  If SalStrScan(sText1,', F,')>0
.head 15 -  Set bFem=TRUE
.head 14 +  If SalStrScan(sText1,', M,')>0
.head 15 -  Set bMale=TRUE
.head 14 +  If bFem and bMale and Not bGetero and Not bMatingCage
.head 15 -  Set sGrpKey=GetKey_FromLable (sText2)
.head 15 -  Call GetItemData( hGroppe[ k ], sText2, nValueLoc2, nFlags2 )
.head 15 +  If GalConnect( hSql )
.head 16 -  Set bOk = SqlPrepareAndExecute( hSql, "
select 1
from FALL f, relship_fall rf, relationship r, gruppe g
where 1=1
and f.LAST_stat_Key= :sStatKey
and f.last_cage_nr=g.uniq_nr
and g.gruppe_key= :sGrpKey
and r.RS_EINRICHT_ID= :nEinrichtId
and f.EE_DATUM is null
and f.geschl='W'
and rf.fall_key=f.fall_KEY
and rf.FALLROLLE_KEY='MATE'
and r.relship_id=rf.relship_id
into :nLitter_idTemp
")
.head 16 -  Set bOk= SqlFetchNext( hSql, nLitter_idTemp )
.head 16 -  Call SqlDisconnect( hSql )
.head 16 +  If Not bOk
.head 17 -  ! Call GetItemData( hGroppe[ k ], sText2, nValueLoc2, nFlags2 )
.head 17 -  Set nBet= QuantityOfEmptyBett( hGroppe[ k ])
.head 17 +  If bBulk
.head 18 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText2) ||','||SalNumberToStrX(nBet,0)||','  
.head 17 +  Else If bHandle
.head 18 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText2) ||','||SalNumberToStrX(hGroppe[ k ],0)||','
.head 17 +  Else
.head 18 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText2) ||','
.head 17 -  Set bGetero=TRUE
.head 17 -  Set sScreen= sAbt
.head 16 +  Else
.head 17 -  Set bMatingCage=TRUE
.head 17 -  Break
.head 14 -  Set b=b+1
.head 12 -  Set k = k + 1
.head 12 -  Set nQuantity= nQuantity+ nBet
.head 12 -  Set nBet=0
.head 9 -  Set i = i + 1
.head 7 -  Return TRUE
.head 5 +  Function: GetOpenEmptyCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hScreen
.head 7 -  Receive String: sScreen
.head 7 -  Receive String: sRoomCageHandle
.head 7 -  Receive Number: nQuantity
.head 7 -  Boolean: bHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  !
.head 7 -  Number: hAbt
.head 7 -  Number: hStatKey
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hStat[*]
.head 7 -  Number: hRoom[*]
.head 7 -  Number: hGroppe[*]
.head 7 -  Number: hBet[*]
.head 7 -  Number: nGroppe
.head 7 -  Number: nRoom
.head 7 -  Number: nStat
.head 7 -  Number: nBet
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: hCurrent
.head 7 -  Number: nSelLev
.head 6 +  Actions
.head 7 -  Set sRoomCage=''
.head 7 -  Set sAbt = ""
.head 7 -  Set sStatKey = ""
.head 7 -  Set sGrpKey = ""
.head 7 -  Set hAbt=hScreen
.head 7 -  Set sAbt = GetKey_ByHandle( hAbt )
.head 7 -  Set nStat = EnumChildren( hAbt, hStat)
.head 7 -  ! ! Find all open Stations
.head 7 +  If nStat
.head 8 -  Set i = 0
.head 8 +  Loop
.head 9 +  If i >= nStat
.head 10 -  Break
.head 9 +  If Not GetIsRackVirtual_ByHandle(hStat[i])
.head 10 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 10 -  Set sStatKey = GetKey_FromLable (sText)
.head 10 -  ! Find all open Empty Groppe
.head 10 -  Set nGroppe = EnumChildren( hStat[ i ], hGroppe )
.head 10 +  If nGroppe
.head 11 -  Set k = 0
.head 11 +  Loop
.head 12 +  If k >= nGroppe
.head 13 -  Break
.head 12 -  Call GetItemData( hGroppe[ k ], sText1, nValueLoc1, nFlags1 )
.head 12 +  If SalStrScan(sText1, '[+]')<0
.head 13 +  If bHandle
.head 14 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText1) ||','||SalNumberToStrX(hGroppe[ k ],0)||','
.head 13 +  Else
.head 14 -  Set sRoomCageHandle= sRoomCageHandle || sStatKey||','|| GetKey_FromLable (sText1) ||','
.head 13 -  Set sScreen= sAbt
.head 13 -  ! Set nBet= EnumChildren( hGroppe[ k ], hBet)
.head 13 -  Set nBet= QuantityOfEmptyBett( hGroppe[ k ])
.head 12 -  Set k = k + 1
.head 12 -  Set nQuantity= nQuantity+ nBet
.head 12 -  Set nBet=0
.head 9 -  Set i = i + 1
.head 7 -  Return TRUE
.head 5 -  !
.head 5 +  Function: MoveToTop
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Number: nTop
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  ! ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	MAX(TOP)
into 	:nTop
from 	user_screen
where	USER_ID= " || StrX( nUserId ) || "
" )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 7 -  Set nTop=nTop+1
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
Update user_screen
Set 	TOP= :nTop
where	USER_ID= " || StrX( nUserId ) || "
   and 	SCR_ID= " || StrX( oPos.nScreenID )  )
.head 7 -  Call SqlDisconnect( hSql )
.head 7 +  If bOk
.head 8 -  Call PopulateEinrichtung( bAutoScan )
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 -  !
.head 5 +  Function: ActivateSelectedItem
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sLab
.head 7 -  String: sSelectedAbtKey_Res
.head 7 -  String: sSelectedStatKey_Res
.head 6 +  Actions
.head 7 -  Set nSelectedItem  = SalListQuerySelection( hWndItem )
.head 7 -  Set sSelectedAbtKey_Res = sSelectedAbtKey
.head 7 -  Set sSelectedStatKey_Res = sSelectedStatKey
.head 7 -  Call GetPosition( GetItemHandle( nSelectedItem ), sSelectedAbtKey, sSelectedStatKey, sSelectedGrpKey, sSelectedBettKey )
.head 7 -  Set nSelectedHandle = GetItemHandle( nSelectedItem )
.head 7 -  Set nSaveSelectedLevel = nSelectedHandle
.head 7 -  Call ActivatePosition(  nSelectedHandle )
.head 7 -  Set sSelectedKeyLocal = GetKey_ByHandle( nSelectedHandle )
.head 7 -  Set nSelectedLevel = GetLevel( nSelectedHandle )
.head 7 +  If sSelectedKeyLocal ='Empty Cages in Rack'
.head 8 -  ! Set sSelectedKeyLocal=''
.head 8 -  Call Rack2DView_SetButtonFocus( nSelectedHandle )
.head 8 -  Return FALSE
.head 7 -  Set sSelectedKey = sSelectedKeyLocal
.head 7 +  If nSelectedLevel = KHEL_Bett
.head 8 -  Set sLab = GetItemText( nSelectedHandle )
.head 8 -  Set hCurrentBett = nSelectedHandle
.head 8 +  If SalStrScan( sLab,"{") > 0
.head 9 -  Set nFallKey_OnCurrentBett = GetFallKey_FromLable( sLab )
.head 9 -  Set bCurrentBettLegalAbteilung = ( SalStrScan( sLab, sOCCUPIED_BY ) < 0 )
.head 9 +  If nFallKey_OnCurrentBett > 0
.head 10 -  Set bCurrentBettHasFall = TRUE
.head 9 +  Else
.head 10 -  Set bCurrentBettHasFall = FALSE
.head 10 -  Set nFallKey_OnCurrentBett = 0
.head 8 +  Else
.head 9 -  Set bCurrentBettHasFall = FALSE
.head 9 -  Set nFallKey_OnCurrentBett = 0
.head 9 -  Set bCurrentBettLegalAbteilung = FALSE
.head 7 +  Else
.head 8 -  Set bCurrentBettHasFall = FALSE
.head 8 -  Set nFallKey_OnCurrentBett = 0
.head 8 -  Set bCurrentBettLegalAbteilung = FALSE
.head 7 +  If nSelectedLevel = KHEL_Gruppe  and hWndBreedingBook
.head 8 -  Call SalPostMsg( hWndBreedingBook, AM_Breeding_Focus, GetCageNR_ByHandle( nSelectedHandle ), 0 )
.head 7 -  Call Rack2DView_CheckState( FALSE )
.head 7 -  Call Rack2DView_SetButtonFocus( nSelectedHandle )
.head 7 +  If (nSelectedLevel = KHEL_Station) and ((sSelectedAbtKey != sSelectedAbtKey_Res) or (sSelectedStatKey != sSelectedStatKey_Res))
.head 8 -  Call SalSendMsg(hWndStar2000, AM_Automate, 0, SalHStringToNumber(sSelectedAbtKey||";"||sSelectedStatKey))
.head 7 +  ! If nSelectedLevel = KHEL_Station and Not KHE_IsExpanded( nSelectedHandle ) and SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call frmKHE2DView._CloseAllCages () 
.head 7 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 7 +  If (nSelectedLevel = KHEL_Gruppe or nSelectedLevel = KHEL_Bett)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_SetFocusDL, SalHStringToNumber(sSelectedStatKey), SalHStringToNumber(sSelectedGrpKey))
.head 5 +  Function: ExpandSelectedItem
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call Expand( GetItemIndex( hRoot ) )
.head 5 -  !
.head 5 +  Function: FindH_4Abteilung
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sAbt_Key
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hAbt
.head 6 +  Actions
.head 7 -  Call Expand( GetItemIndex( hRoot ) )
.head 7 -  Set hAbt = FindChild( hRoot,"(" || sAbt_Key || ")" )
.head 7 -  Return hAbt
.head 5 +  Function: FindH_4Station
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hAbt
.head 7 -  String: sStatKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hStat
.head 6 +  Actions
.head 7 +  If hAbt = 0
.head 8 -  Return 0
.head 7 +  ! AS 11.11.2004
.head 8 -  ! Call Expand( GetItemIndex( hAbt ) )
.head 7 +  If Not PopulateAndExpand( hAbt, bForceScan )
.head 8 -  Return 0
.head 7 -  Set hStat = FindChild( hAbt,"(" || sStatKey || ")" )
.head 7 -  Return hStat
.head 5 +  Function: FindH_4Gruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hStat
.head 7 -  String: sGruppe_Key
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGruppe
.head 6 +  Actions
.head 7 +  ! AS 11.11.2004
.head 8 +  ! If Not PopulateStation( hStat, FALSE )
.head 9 -  Return 0
.head 8 -  ! Call Expand( GetItemIndex( hStat ) )
.head 7 +  If Not PopulateAndExpand( hStat, bForceScan )
.head 8 -  Return 0
.head 7 -  Set hGruppe = FindChild( hStat,"(" || sGruppe_Key || ")" )
.head 7 -  Return hGruppe
.head 5 +  Function: FindH_4Bett
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hGrp
.head 7 -  String: sBett_Key
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hBett
.head 6 +  Actions
.head 7 +  ! AS 11.11.2004
.head 8 +  ! If Not PopulateStation( hStat, FALSE )
.head 9 -  Return 0
.head 8 -  ! Call Expand( GetItemIndex( hStat ) )
.head 7 +  If Not PopulateAndExpand( hGrp, bForceScan )
.head 8 -  Return 0
.head 7 -  Set hBett = FindChild( hGrp,"(" || sBett_Key || ")" )
.head 7 -  Return hBett
.head 5 -  !
.head 5 -  ! -- Get Key functions:
.head 5 +  Function: ExtractPlaceFromString
.head 6 -  Description: sPlace param should be ABT_KEY;STAT_KEY;GRUPPE_KEY;BETT_KEY
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sPlace
.head 7 -  Receive String: sAbt_Key_Res
.head 7 -  Receive String: sStat_Key_Res
.head 7 -  Receive String: sGruppe_Key_Res
.head 7 -  Receive String: sBett_Key_Res
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sTokens[*]
.head 7 -  Number: nTokens
.head 6 +  Actions
.head 7 -  Set sAbt_Key_Res = ''
.head 7 -  Set sStat_Key_Res = ''
.head 7 -  Set sGruppe_Key_Res = ''
.head 7 -  Set sBett_Key_Res = ''
.head 7 -  !
.head 7 -  Set nTokens = SalStrTokenize( sPlace, '', ';', sTokens )
.head 7 -  !
.head 7 +  If nTokens >= 1
.head 8 -  Set sAbt_Key_Res = sTokens[ 0 ]
.head 7 +  If nTokens >= 2
.head 8 -  Set sStat_Key_Res = sTokens[ 1 ]
.head 7 +  If nTokens >= 3
.head 8 -  Set sGruppe_Key_Res = sTokens[ 2 ]
.head 7 +  If nTokens >= 4
.head 8 -  Set sBett_Key_Res = sTokens[ 3 ]
.head 7 -  Return nTokens
.head 5 +  Function: GetFallKey_FromLable		! -- operates with string 
.head 6 -  Description: We suppose that a Key is a substring between '{' and '}'
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sLabel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sFall_Key_Loc
.head 7 -  Number: nFall_Key_Loc
.head 6 +  Actions
.head 7 -  Set sFall_Key_Loc = SalStrMidX( sLabel, SalStrScan( sLabel, '{' ) + 1, SalStrScan( sLabel, '}' ) - SalStrScan( sLabel, '{' ) - 1 )
.head 7 -  Set nFall_Key_Loc = NumberX( sFall_Key_Loc )
.head 7 -  Return nFall_Key_Loc
.head 5 +  Function: GetName1_FromLable		! -- operates with string 
.head 6 -  Description: We suppose that a Name1 is a substring between '}' and the followed ','
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sLabel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sName1_Loc
.head 7 -  Number: nPos
.head 6 +  Actions
.head 7 -  Set nPos = SalStrScan( sLabel, '}' ) + 1
.head 7 +  If nPos = 0
.head 8 -  Return ''
.head 7 -  Set sLabel = SalStrTrimX( SalStrRightX( sLabel, SalStrLength( sLabel ) - nPos ) )
.head 7 -  Set nPos = SalStrScan( sLabel, ',' )
.head 7 +  If nPos <= 0
.head 8 -  Return ''
.head 7 -  Set sName1_Loc = SalStrLeftX( sLabel, nPos )
.head 7 -  Return sName1_Loc
.head 5 +  Function: GetFallKey_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Date/Time: dtDate
.head 7 -  Number: nFallKey
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  ! Return GetFallKey_FromLable( GetItemText( nHandle ) )
.head 7 +  If GetLevel( nHandle ) != KHEL_Bett
.head 8 -  Return 0
.head 7 -  Call GetPosition( nHandle, sAbt, sStat, sCage, sBett )
.head 7 -  Set dtDate = GetTime4Refresh(  )
.head 7 +  If bPlanningMode
.head 8 -  Call SqlExists("
select	 bew.FALL_KEY
from BEWEGUNG bew,  fall f
where	      bew.STAT_KEY = '" || sStat || "'
	 and       bew.GRUPPE_KEY = '" || sCage || "'
	 and 	bew.BETT_KEY= '" || sBett || "'
	 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	 and       bew.bew_zeit <=:dtDate
   	 and       (bew.bew_zeit_bis>:dtDate or bew.bew_zeit_bis is null  )
   	 and	bew.Fall_KEY = f.Fall_KEY
	 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   	 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   	 and	bew.Fall_KEY not in (select	 bl.PLANBEW_FALL
				from  BETT_LOCKS bl
   				where	      bew.Fall_KEY=bl.PLANBEW_FALL
   					 and       (bl.bis>:dtDate or bl.bis is null  ))
into	:nFallKey", bOk)
.head 8 +  If nFallKey<=0
.head 9 -  Call SqlExists("
select	 bl.PLANBEW_FALL
					from  BETT_LOCKS bl
   					where	      bl.STAT_KEY = '" || sStat || "'
  						 and       bl.GRUPPE_KEY = '" || sCage || "'
						and	bl.BETT_KEY = '" || sBett || "'
						 and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
						 and       bl.VON <= :dtDate
   						 and       (bl.bis>:dtDate or bl.bis is null  )
into	:nFallKey" , bOk)
.head 7 +  Else
.head 8 +  If bRealTimeMode
.head 9 -  Call SqlExists( "select FALL_KEY
from FALL
where EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	LAST_ABT_KEY = '" || sAbt || "'
   and	LAST_STAT_KEY = '" || sStat || "'
   and	LAST_GRUPPE_KEY = '" || sCage || "'
   and	LAST_BETT_KEY = '" || sBett || "'
   and	LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and 	@nullvalue( GELOESCHT, 'N' ) != 'J'

into	:nFallKey", bOk )
.head 8 +  Else
.head 9 -  Call SqlExists( "select bew.Fall_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = '" || sStat || "'
					and	bew.EINRICHT_ID =" || StrX( nEinrichtId ) || "
  					 and       bew.GRUPPE_KEY = '" || sCage || "'
					 and 	bew.BETT_KEY= '" || sBett || "'
   					
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtDate
   					and       (bew.bew_zeit_bis>:dtDate or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'

into	:nFallKey", bOk )
.head 7 -  Return nFallKey
.head 5 +  Function: GetTypeOfMove_FromLable		! -- operates with string 
.head 6 -  Description: We suppose that a Key is a substring between '[' and ']'
Returns -1 / 0 / 1 for LOCK / PLAN / REAL
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sLabel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sType_Loc
.head 7 -  Number: nType_Loc
.head 7 -  Number: nBrk_Begin
.head 7 -  Number: nBrk_End
.head 6 +  Actions
.head 7 -  Set nType_Loc = 1
.head 7 -  !
.head 7 -  Set nBrk_Begin = SalStrScan( sLabel, '[' )
.head 7 -  Set nBrk_End = SalStrScan( sLabel, ']' )
.head 7 +  If nBrk_Begin >=0 
.head 8 -  Set sType_Loc = SalStrMidX( sLabel, nBrk_Begin + 1, nBrk_End - nBrk_Begin - 1 )
.head 8 +  If sType_Loc = sPLAN
.head 9 -  Set nType_Loc = 0
.head 8 +  Else If sType_Loc = sLOCKED
.head 9 -  Set nType_Loc = -1
.head 7 -  Return nType_Loc
.head 5 +  Function: GetTypeOfMove_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return GetTypeOfMove_FromLable( GetItemText( nHandle ) )
.head 5 +  Function: GetSex_ByHandle
.head 6 -  Description: Return 1-  if Male, 0- female	
.head 6 +  Returns
.head 7 -  Number: nSex
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nSex
.head 6 +  Actions
.head 7 +  If SalStrScan( GetItemText( nHandle ), ", M," ) > 0
.head 8 -  Return 1
.head 7 +  If SalStrScan( GetItemText( nHandle ), ", F," ) > 0
.head 8 -  Return 0
.head 5 +  Function: GetIsRackVirtual_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCurrent
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bV
.head 7 -  Number: nLevelLoc
.head 6 +  Actions
.head 7 -  Set bV=FALSE
.head 7 -  Set nLevelLoc = GetLevel(hCurrent)
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Abteilung
.head 9 -  Return FALSE
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 +  If SalStrScan( GetItemText( hCurrent ), '[V]' )>=0 
.head 10 -  Set bV=TRUE
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 +  If SalStrScan( GetItemText( GetParent( hCurrent ) ), '[V]' )>=0 
.head 10 -  Set bV=TRUE
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 +  If SalStrScan( GetItemText( GetParent( GetParent( hCurrent ) ) ), '[V]' )>=0 
.head 10 -  Set bV=TRUE
.head 9 -  Break
.head 7 -  Return bV
.head 5 +  Function: GetCurrentPosition
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Receive String: sAbt
.head 7 -  Receive String: sStat
.head 7 -  Receive String: sGrp
.head 7 -  Receive String: sBett
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! Number: hCurrent
.head 7 -  ! Number: nSelectedLevel
.head 6 +  Actions
.head 7 -  Return GetPosition( nSelectedHandle, sAbt, sStat, sGrp, sBett)
.head 5 +  Function: GetCurrentLevelKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nLevelLoc ! KHEL_*
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Abteilung
.head 9 -  Return sAbt
.head 8 +  Case KHEL_Station
.head 9 -  Return sStat
.head 8 +  Case KHEL_Gruppe
.head 9 -  Return sGrp
.head 8 +  Case KHEL_Bett
.head 9 -  Return sBett
.head 5 +  Function: GetBedsFromHandleToPlace
.head 6 -  Description: Returne amount and handle from array HandleToPlace
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Receive Number: hBeds[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: q
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 -  Set q=0
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  While q<= nBound
.head 8 -  Set hBeds[q]= HandleToPlace[q,1]
.head 8 -  Set q=q+1
.head 7 -  Return nBound
.head 5 +  Function: GetCagesFromHandleToPlace
.head 6 -  Description: Returne amount of cages in which HandleToPlace
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Receive Number: hSourceCages[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: q
.head 7 -  Number: w
.head 7 -  Number: hSource
.head 7 -  Number: nBound
.head 7 -  Number: nBound1
.head 6 +  Actions
.head 7 -  Set q=0
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  While q<= nBound
.head 8 -  Set w=0
.head 8 -  Set hSource=0
.head 8 -  Set hSource= GetParent( HandleToPlace[q,1] )
.head 8 -  Call SalArrayGetUpperBound ( hSourceCages, 1, nBound1 ) 
.head 8 +  While w<= nBound1
.head 9 +  If hSourceCages[w]=hSource
.head 10 -  Break
.head 9 -  Set w=w+1
.head 8 +  If w-1=nBound1
.head 9 -  Set hSourceCages[w-1]= hSource
.head 9 -  Call SalArraySetUpperBound ( hSourceCages, 1, w ) 
.head 8 -  Set q=q+1
.head 7 -  Call SalArrayGetUpperBound ( hSourceCages, 1, nBound1 ) 
.head 7 -  Return nBound1
.head 5 +  Function: GetFreeBedsInGruppe
.head 6 -  Description: scans tree, not DB
.head 6 +  Returns
.head 7 -  Number: ! amount of beds
.head 6 +  Parameters
.head 7 -  Number: hSourceGrp
.head 7 -  Receive Number: hpBeds[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBedsFound
.head 7 -  Number: nBedAmount
.head 7 -  Number: hBeds[*]
.head 7 -  Number: nInd
.head 6 +  Actions
.head 7 +  If GetLevel( hSourceGrp ) != KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 +  If not KHE_IsPopulated(hSourceGrp)
.head 8 -  Call PopulateGruppe( hSourceGrp, FALSE )
.head 7 -  ! Call PopulateGruppe( hSourceGrp, FALSE )
.head 7 -  !
.head 7 -  Set nBedAmount = EnumChildren( hSourceGrp, hBeds )
.head 7 -  Set nInd = 0
.head 7 -  Set nBedsFound = 0
.head 7 +  While nInd < nBedAmount 
.head 8 +  If not GetFallKey_ByHandle( hBeds[nInd] ) or bMoveFlag
.head 9 -  Set hpBeds[nBedsFound] = hBeds[nInd]
.head 9 -  Set nBedsFound = nBedsFound + 1
.head 8 -  Set nInd = nInd + 1
.head 7 -  Return nBedsFound
.head 5 +  Function: GetFallsInGruppe
.head 6 -  Description: scans tree, not DB
.head 6 +  Returns
.head 7 -  Number: ! amount of Falls
.head 6 +  Parameters
.head 7 -  Number: hSourceGrp
.head 7 -  Receive Number: nFalls[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallsFound
.head 7 -  Number: nBedAmount
.head 7 -  Number: hBeds[*]
.head 7 -  Number: nInd
.head 7 -  Number: nFallKey
.head 6 +  Actions
.head 7 +  If GetLevel( hSourceGrp ) != KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 +  If not KHE_IsPopulated(hSourceGrp)
.head 8 -  Call PopulateGruppe( hSourceGrp, FALSE )
.head 7 -  !
.head 7 -  Set nBedAmount = EnumChildren( hSourceGrp, hBeds )
.head 7 -  Set nInd = 0
.head 7 -  Set nFallsFound = 0
.head 7 +  While nInd < nBedAmount 
.head 8 -  Set nFallKey = GetFallKey_ByHandle( hBeds[nInd] )
.head 8 +  If nFallKey
.head 9 -  Set nFalls[nFallsFound] = nFallKey
.head 9 -  Set nFallsFound = nFallsFound + 1
.head 8 -  Set nInd = nInd + 1
.head 7 -  Return nFallsFound
.head 5 -  !
.head 5 +  Function: KHE_DeleteDescendents
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hNode
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 7 -  Number: nRes
.head 7 -  Number: hSrcBranch
.head 6 +  Actions
.head 7 +  If hNode
.head 8 +  If bMove_HasInClipboard
.head 9 -  Set hSrcBranch = hMove_Source
.head 9 +  While hSrcBranch
.head 10 +  If hSrcBranch = hNode
.head 11 -  Set bMove_HasInClipboard = FALSE
.head 11 -  Set hMove_Source = 0
.head 11 -  Break
.head 10 -  Set hSrcBranch = GetParent( hSrcBranch )
.head 8 -  Set nIndex = GetItemIndex( hNode )
.head 8 -  Set nRes = DeleteDescendents( nIndex )
.head 7 -  Return nRes
.head 5 -  ! -- Populate Functions:
.head 5 +  Function: RefreshStartData
.head 6 -  Description: Repopulats the Einrichtung
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return PopulateEinrichtung( bAutoScan )
.head 5 +  Function: PopulateEinrichtung
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlAbt
.head 7 -  String: sSql2Get_AbtKey
.head 7 -  String: sAbtKey
.head 7 -  String: sAbtBez
.head 7 -  String: sAbtLabel
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Number: hAbt
.head 7 -  Number: nStatAmount
.head 7 -  Number: nAbtCount
.head 7 -  Number: nTop
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nLE_Id
.head 7 -  String: sTitle
.head 7 -  Boolean: bUserViewsUsed
.head 6 +  Actions
.head 7 +  If KHE_IsPopulated( hRoot )
.head 8 -  Return TRUE
.head 7 +  If Not DoImmediate("
select	 A.NAME1, A.NAME2
from 	EINRICHTUNG E, ADRESSE a
where	E.ADRESSE_ID = A.ADRESSE_ID
   and	E.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into	:s[0], :s[1] ")
.head 8 -  Return FALSE
.head 7 +  If Not GalConnect( hSqlAbt )
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Set sTitle = '(' || strEinrichtKey || ')' || s[0] || ' ' || s[1] 
.head 7 -  Call SetItemText( hRoot, sTitle )
.head 7 -  !
.head 7 -  Call Reload_sUsers_AbtStatSet(  )
.head 7 +  !
.head 8 -  ! Set sSql2Get_AbtKey = "
select	a.ABT_BEZ, a.ABT_KEY, count( a_s.STAT_KEY )
into	:sAbtBez, :sAbtKey, :nStatAmount
from 	ABTEILUNG a, ABT_STAT a_s
where	a.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	a_s.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	a_s.ABT_KEY = a.ABT_KEY
 "
.head 7 -  Set sSql2Get_AbtKey = "
select	a.ABT_BEZ, a.ABT_KEY,@NULLVALUE (b.TOP, 0)
into	:sAbtBez, :sAbtKey, :nTop
from 	ABTEILUNG a, BEN_ABTEILUNG b
where	a.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	BENUTZER_ID= " || StrX( nUserId ) || "
   and 	b.ABT_KEY = a.ABT_KEY
 "
.head 7 +  If Not UserRights_IsSet( bUserViewsUsed )
.head 8 -  Return FALSE
.head 7 +  ! If ( Not bShowAllAbtStat ) And ( Not bUserViewsUsed )
.head 8 +  If sUsers_AbtSet != '*'
.head 9 -  Set sSql2Get_AbtKey = sSql2Get_AbtKey || "
   and	a.ABT_KEY in ( " || sUsers_AbtSet_Quated || " ) "
.head 7 -  Set sSql2Get_AbtKey = sSql2Get_AbtKey || "
group by	a.ABT_BEZ, a.ABT_KEY, b.TOP
order by	b.TOP DESC "
.head 7 -  !
.head 7 -  Call KHE_DeleteDescendents( hRoot )
.head 7 -  Set bMove_HasInClipboard = FALSE
.head 7 -  ! Call GetTime4Refresh(  )
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Set bOk  = SqlPrepareAndExecute( hSqlAbt, sSql2Get_AbtKey )
.head 7 +  While bOk and SqlFetchNext( hSqlAbt, nFetch )
.head 8 -  Call SalStatusSetText( hWndForm, sAbtKey )
.head 8 -  Set sAbtLabel = '(' || sAbtKey || ')' || sAbtBez 
.head 8 +  If bShouPics 
.head 9 -  Set hAbt = KHEAddChild( hRoot, hPicFolderCollapsed, sAbtLabel, 0 )
.head 8 +  Else
.head 9 -  Set hAbt = KHEAddChild( hRoot, hPicNull, sAbtLabel, 0 )
.head 8 +  If hAbt = 0
.head 9 -  Set bOk = FALSE
.head 9 -  Break
.head 8 -  Set nAbtCount = nAbtCount + 1
.head 8 +  If nStatAmount > 0
.head 9 -  Call KHESetHasChild( hAbt, TRUE )
.head 9 -  ! AS 11.11.2004 Uncommented
.head 9 +  If bForceScan
.head 10 -  ! Set sStatKey = ''
.head 10 -  ! Set sGrpKey = ''
.head 10 -  ! Set sBettKey = ''
.head 10 +  ! If GetFall_InPlaceOnDate( dtKHK_RefreshTime, sAbtKey, sStatKey, sGrpKey, sBettKey, nLE_Id )
.head 11 -  Call KHESetHasFall( hAbt, TRUE )
.head 10 -  Call Refresh_HasFallX( hAbt, dtKHK_RefreshTime, TRUE )
.head 8 -  Call KHESetChildChecked( hAbt, TRUE )
.head 7 -  Call SqlDisconnect( hSqlAbt )
.head 7 -  !
.head 7 -  Call KHESetPopulated( hRoot, bOk )
.head 7 +  If nAbtCount
.head 8 -  Call KHESetHasChild( hRoot, TRUE )
.head 7 -  Call ShowOutline( 1 )
.head 7 -  Call KHEReAssignPics( hRoot )
.head 7 -  ! zeroing array
.head 7 -  Call SalArraySetUpperBound ( HandleToPlace, 0, -1 )
.head 7 -  Call SalArraySetUpperBound ( HandleToPlace, 1, -1 )
.head 7 -  !
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Return bOk
.head 5 +  Function: PopulateAbteilung
.head 6 -  Description: Reloads the Abteilung's contents
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpAbt
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sSql2Get_StatKey
.head 7 -  Sql Handle: hSqlStat
.head 7 -  Number: nFetch
.head 7 -  String: sStatLabel
.head 7 -  String: sStatBez
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sVirtual
.head 7 -  Number: hStat
.head 7 -  String: sCurrnum
.head 7 -  Number: nStatCount
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  String: sStatusTextA
.head 7 -  String: sStatusTextS
.head 7 -  Number: nGruppeAmount
.head 7 -  Number: nLE_Id
.head 7 -  Boolean: bUserViewsUsed
.head 7 -  Date/Time: dtGetTime
.head 7 -  String: sPosition
.head 7 -  Number: nScrID
.head 6 +  Actions
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If hpAbt <= 0
.head 8 -  Return FALSE
.head 7 +  If KHE_IsPopulated( hpAbt )
.head 8 -  Return PopulateAbteilungLight( hpAbt, bForceScan )
.head 7 -  !
.head 7 -  Set sAbtKey = GetKey_ByHandle( hpAbt )
.head 7 +  If Not sAbtKey
.head 8 -  Return FALSE
.head 7 +  If Not GalConnect( hSqlStat )
.head 8 -  Return FALSE
.head 7 +  If SqlPrepareAndExecute( hSqlStat, ' select id from abteilung where einricht_id=:nEinrichtId and abt_key=:sAbtKey into :nScrID ' )
.head 8 -  Call SqlFetchNext( hSqlStat, nFetch )
.head 7 -  !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  !
.head 7 -  Call Reload_sUsers_AbtStatSet(  )
.head 7 -  !
.head 7 -  Call KHE_DeleteDescendents( hpAbt )
.head 7 -  Set sStatusTextA = 'Populate: ' || sAbtKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextA )
.head 7 -  ! Set sSql2Get_StatKey = "
select	s.STAT_KEY, s.STAT_BEZ, count( g.GRUPPE_KEY ), s.Virtual, s.CURRNUM, s.POSITION
into	:sStatKey, :sStatBez, :nGruppeAmount, :sVirtual, :sCurrnum, :sPosition
from 	STATION s, ABT_STAT a, GRUPPE g
where	s.CANCELED = 'N'
   and	s.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	a.STAT_KEY = s.STAT_KEY
   and	a.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	a.ABT_KEY = '" || sAbtKey || "'
   and	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	g.STAT_KEY = s.STAT_KEY
   and 	g.CANCELED = 'N'
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= :dtGetTime)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= :dtGetTime)
 "
.head 7 -  Set sSql2Get_StatKey = "
select	s.STAT_KEY, s.STAT_BEZ, count( g.GRUPPE_KEY ), s.Virtual, s.CURRNUM, s.POSITION,@nullvalue(t.top,0)
into	:sStatKey, :sStatBez, :nGruppeAmount, :sVirtual, :sCurrnum, :sPosition
 from ABT_STAT a
left join user_rack u1 on (u1.rack_id=a.rack_id)
left join tree t on (t.user_id=:nUserId and t.id_parent=a.scr_id and id_child=a.rack_id)
join gruppe g on (g.rack_id=a.rack_id  and 	g.CANCELED = 'N')
join station s on (s.id=a.rack_id)

where	a.scr_id = :nScrID
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= :dtGetTime)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= :dtGetTime)
 
 "
.head 7 +  If Not UserRights_IsSet( bUserViewsUsed )
.head 8 -  Return FALSE
.head 7 +  ! If ( Not bShowAllAbtStat ) And ( Not bUserViewsUsed )
.head 8 +  If sUsers_StatSet != '*'
.head 9 -  ! Set sSql2Get_StatKey = sSql2Get_StatKey || "
   and	s.STAT_KEY in ( " || sUsers_StatSet_Quated || " ) "
.head 9 -  ! Set sSql2Get_StatKey = sSql2Get_StatKey || "
     and      s.id in (select rack_id from user_rack where user_id=:nUserId)    "
.head 9 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
     and    u1.user_id=:nUserId    "
.head 7 -  Set sSql2Get_StatKey = sSql2Get_StatKey || cFilterRack.FilterString( )
.head 7 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	s.STAT_KEY, s.STAT_BEZ, s.CURRNUM, s.Virtual, s.POSITION,t.top
order by 7 DESC 
"
.head 7 -  ! Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	s.STAT_KEY, s.STAT_BEZ, s.CURRNUM, s.Virtual, s.POSITION
order by	 s.CURRNUM, s.STAT_KEY
"
.head 7 -  !
.head 7 -  ! !! 	L O A D I N G     S T A T I O N E N
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Set nStatCount = 0
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlStat, sSql2Get_StatKey )	
.head 7 +  While bOk and SqlFetchNext( hSqlStat, nFetch )
.head 8 -  Set sStatLabel = '('|| sStatKey ||')'
.head 8 +  If sCurrnum != ''
.head 9 -  Set sStatLabel = sStatLabel || ' Room:'|| sCurrnum
.head 8 +  If sPosition != ''
.head 9 -  Set sStatLabel = sStatLabel || ', Position:'|| sPosition 
.head 8 +  If sCurrnum != '' or sPosition != ''
.head 9 -  Set sStatLabel = sStatLabel || ','
.head 8 -  Set sStatLabel = sStatLabel || ' ' || sStatBez
.head 8 +  If sVirtual= 'J'
.head 9 -  Set sStatLabel = sStatLabel || ' [V]'
.head 8 +  ! If sVirtual= 'J'
.head 9 +  If sCurrnum = ''
.head 10 -  Set sStatLabel = '('|| sStatKey ||')'|| sStatBez || ' [V]'
.head 9 +  Else 
.head 10 -  Set sStatLabel = '('|| sStatKey ||') Room:'|| sCurrnum || ', Position:'|| sPosition || ','  || sStatBez || ' [V]'
.head 8 +  ! Else
.head 9 +  If sCurrnum = ''
.head 10 -  Set sStatLabel = '('|| sStatKey ||')'|| sStatBez
.head 9 +  Else 
.head 10 -  Set sStatLabel = '(' || sStatKey ||') Room:'|| sCurrnum ||', Position:'|| sPosition || ',' || sStatBez
.head 8 -  Set sStatusTextS = sStatusTextA || '/' || sStatKey
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextS )
.head 8 +  If bShouPics 
.head 9 -  Set hStat = KHEAddChild( hpAbt, hPicFolderCollapsed, sStatLabel, 0)
.head 8 +  Else
.head 9 -  Set hStat = KHEAddChild( hpAbt, hPicNull, sStatLabel, 0)
.head 8 -  Call SetItemFont(hStat, hFontRacks)
.head 8 +  If hStat = 0
.head 9 -  Set bOk = FALSE
.head 9 -  Break
.head 8 -  !
.head 8 +  If nGruppeAmount > 0
.head 9 -  Call KHESetHasChild( hStat, TRUE )
.head 9 +  If bForceScan Or bAutoScan
.head 10 -  Call SalStatusSetText( hWndForm, sStatusTextS || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 10 -  Set sGrpKey = ''
.head 10 -  Set sBettKey = ''
.head 10 -  Call Refresh_HasFallX( hStat, dtKHK_RefreshTime, TRUE )
.head 8 -  Call KHESetChildChecked( hStat, TRUE )
.head 8 -  Set nStatCount = nStatCount + 1
.head 7 -  Call SqlDisconnect( hSqlStat )
.head 7 -  !
.head 7 -  Call KHESetPopulated( hpAbt, bOk )
.head 7 +  If bOk
.head 8 +  If nStatCount > 0
.head 9 -  Call KHESetHasChild( hpAbt, TRUE )
.head 7 +  Else
.head 8 -  Set nStatCount = 0
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 -  Return bOk
.head 5 +  Function: PopulateAbteilungLight
.head 6 -  Description: ReScan the Abteilung's contents
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpAbt
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Number: hStat[*]
.head 7 -  Number: nStatAmount
.head 7 -  Number: nStat
.head 7 -  Boolean: bOk
.head 7 -  ! Boolean: bExists
.head 7 -  String: sStatusTextA
.head 7 -  String: sStatusTextS
.head 7 -  Number: nLE_Id
.head 6 +  Actions
.head 7 +  If Not bForceScan
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  Set sAbtKey = GetKey_ByHandle( hpAbt )
.head 7 +  If Not sAbtKey
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Set sStatusTextA = 'Scan: ' || sAbtKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextA )
.head 7 +  If bForceScan
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextA || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 8 -  Set sStatKey = ''
.head 8 -  Set sGrpKey = ''
.head 8 -  Set sBettKey = ''
.head 8 -  Call Refresh_HasFallX( hpAbt, dtKHK_RefreshTime, FALSE )
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextA )
.head 7 -  !
.head 7 -  ! !! 	SCAN     STATIONS
.head 7 -  Set nStatAmount = EnumChildren( hpAbt, hStat )
.head 7 -  Set nStat = 0
.head 7 +  While nStat < nStatAmount
.head 8 -  Set sStatKey = GetKey_ByHandle( hStat[ nStat ] )
.head 8 -  Set sStatusTextS = sStatusTextA || '/' || sStatKey
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextS )
.head 8 +  If KHE_HasChild( hStat[ nStat ] )
.head 9 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 9 -  Set sGrpKey = ''
.head 9 -  Set sBettKey = ''
.head 9 -  Call Refresh_HasFallX( hStat[ nStat ], dtKHK_RefreshTime, FALSE )
.head 8 -  Set nStat = nStat + 1
.head 7 -  !
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Return TRUE
.head 5 +  Function: PopulateStation
.head 6 -  Description: Reloads the Station's contents
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpStation
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bAnyGruppe
.head 7 -  Boolean: bGrpBez
.head 7 -  Sql Handle: hSqlGruppe
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nFetch
.head 7 -  Number: nColor
.head 7 -  Number: hGruppe
.head 7 -  Number: nBettAmount
.head 7 -  String: sPurposeKey
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sGrpKey
.head 7 -  String: sGrpBez
.head 7 -  String: sBettKey
.head 7 -  String: sGrpLabel
.head 7 -  String: sStatusTextS
.head 7 -  String: sStatusTextG
.head 7 -  Number: nFallKeyInGrp
.head 7 -  Number: nLE_Id
.head 7 -  Number: nCounter
.head 7 -  ! Number: nLengthTemp
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: hStation111
.head 7 -  String: sSqlPlanGruppe
.head 7 -  ! Boolean: bPlannedMode
.head 7 -  String: sPlannedExp
.head 7 -  Boolean: bIsAlert
.head 7 -  Number: nIsAlert
.head 7 -  Number: nUniq_Nr
.head 7 -  !
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 6 +  Actions
.head 7 +  If hpStation <= 0
.head 8 -  Return FALSE
.head 7 +  If KHE_IsPopulated( hpStation )
.head 8 -  Return PopulateStationLight( hpStation, bForceScan )
.head 7 -  ! !
.head 7 -  Call GetPosition( hpStation, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call GetPositionID( hpStation, nScrID, nRackID, nCageID, nPosID )
.head 7 +  If Not sStatKey or nRackID<0
.head 8 -  Return FALSE
.head 7 +  If Not GalConnect( hSqlGruppe )
.head 8 -  Return FALSE
.head 7 -  ! !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Call KHE_DeleteDescendents( hpStation )
.head 7 -  ! !
.head 7 -  Set sStatusTextS = 'Populate: ' || sAbtKey || '/' || sStatKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextS )
.head 7 -  ! ! !! SQL for Select Cages
.head 7 -  ! ! Set bShowWithContent = GalGetProfileBooleanX('KHE','ShowOnlyCagesWithContent', FALSE, sUserINIFileName )
.head 7 -  ! ! Set bShowPlannedCages = GalGetProfileBooleanX( "KHE", "ShowPlannedCages", FALSE, sUserINIFileName )
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If not bShowWithContent
.head 8 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
from 	GRUPPE g, BETT b
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	b.EINRICHT_ID = g.EINRICHT_ID
   and 	b.STAT_KEY = g.STAT_KEY
   and	b.GRUPPE_KEY = g.GRUPPE_KEY
   and	b.CANCELED = 'N'
   
group by	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 8 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
from 	GRUPPE g, BETT b
where	
                g.rack_id = :nRackID
   and	g.CANCELED = 'N'
   and 	b.cage_id = g.id
   and	b.CANCELED = 'N'
   
group by	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 7 +  ! ! Else
.head 8 -  Set dtGetTime = GetTime4Refresh(  )
.head 8 -  Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.GRUPPE_BEZ,
              g.PURPOSE_KEY, g.COLOR,'1'
from      GRUPPE g, BEWEGUNG bew
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY ='" || sStatKey || "'
   and     g.CANCELED = 'N'
    and       bew.abt_key ='" || sAbtKey || "'
   and       bew.STAT_KEY =g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )

group by     g.GRUPPE_KEY, g.GRUPPE_BEZ,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount "
.head 7 +  Else
.head 8 -  ! Set bPlannedMode = GalGetProfileBooleanX( "Rack 2D View", "PlannedMode", FALSE, sUserINIFileName )
.head 8 +  If bPlanningMode
.head 9 -  Set sPlannedExp = GalGetProfileStringX( "Rack 2D View", "PlannedExp", 'Asc', sUserINIFileName )
.head 9 -  ! Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from       FALL_EXPERIMENT fe, GRUPPE g, BEWEGUNG bew
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY ='" || sStatKey || "'
   and     g.CANCELED = 'N'
   
   and       bew.STAT_KEY =g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <=:dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   and	bew.FALL_KEY = fe.FALL_KEY
   and	fe.END_DATE is null
   and	 not  exists (select bew1.GRUPPE_KEY
							from        BEWEGUNG bew1
							where bew1.stat_key = g.STAT_KEY
  								 and       bew1.GRUPPE_KEY = g.GRUPPE_KEY
	 							 and       bew1.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
								 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
								 and       bew1.bew_zeit <=:dtGetTime
 	  							 and       (bew1.bew_zeit_bis>:dtGetTime or bew1.bew_zeit_bis is null  )
								 and bew1.fall_key not in   (select f1.FALL_KEY
					  								from       FALL_EXPERIMENT f1
					  														))
   and	fe.EXPERIMENT_KEY is not null
  
   and	not  exists ( select b.GRUPPE_KEY
				 from FALL_EXPERIMENT f,  BEWEGUNG b
				 where b.FALL_KEY = f.FALL_KEY
		 			  and 	b.GRUPPE_KEY = g.GRUPPE_KEY
					  and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
					 and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
   					  and       b.bew_zeit <=:dtGetTime
  					  and       (b.bew_zeit_bis>:dtGetTime or b.bew_zeit_bis is null  )
		 			  and		f.END_DATE is null
		 			  and     	f.EXPERIMENT_KEY != 'new')
group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 9 -  ! Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from       FALL_EXPERIMENT fe, GRUPPE g, BEWEGUNG bew
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY =''" || sStatKey || "'
   and     g.CANCELED = 'N'
   and	bew.EINRICHT_ID = g.EINRICHT_ID
   and       bew.STAT_KEY =g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <=:dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   and	bew.FALL_KEY = fe.FALL_KEY
   and	fe.END_DATE is null
   and	 not  exists (select bew1.GRUPPE_KEY
							from        BEWEGUNG bew1
							where
  								 	bew1.EINRICHT_ID = g.EINRICHT_ID
								 and	bew1.stat_key = g.STAT_KEY
  								 and       bew1.GRUPPE_KEY = g.GRUPPE_KEY
	 							 and       bew1.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
								 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
								 and       bew1.bew_zeit <=:dtGetTime
 	  							 and       (bew1.bew_zeit_bis>:dtGetTime or bew1.bew_zeit_bis is null  )
								 and bew1.fall_key not in   (select f1.FALL_KEY
					  								from       FALL_EXPERIMENT f1
					  														))
   and	fe.EXPERIMENT_KEY is not null
  
   and	not  exists ( select b.GRUPPE_KEY
				 from FALL_EXPERIMENT f,  BEWEGUNG b
				 where
						b.EINRICHT_ID = g.EINRICHT_ID
					and	b.stat_key = g.STAT_KEY
		 			  and 	b.GRUPPE_KEY = g.GRUPPE_KEY
					  and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
					 and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
   					  and       b.bew_zeit <=:dtGetTime
  					  and       (b.bew_zeit_bis>:dtGetTime or b.bew_zeit_bis is null  )
					and		b.EINRICHT_ID = f.EINRICHT_ID
					and 		f.FALL_KEY = b.FALL_KEY
		 			  and		f.END_DATE is null
		 			  and     	f.EXPERIMENT_KEY != 'new')
group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 9 -  Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from       FALL_EXPERIMENT fe, GRUPPE g, BEWEGUNG bew
where     
             g.RACK_ID =:nRackID
   and     g.CANCELED = 'N'
   and       bew.CAGE_ID = g.ID
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <=:dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   and	bew.FALL_KEY = fe.FALL_KEY
   and	fe.END_DATE is null
   and	 not  exists (select bew1.GRUPPE_KEY
							from        BEWEGUNG bew1
							where
  								 	     bew1.CAGE_ID = g.ID
	 							 and       bew1.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
								 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
								 and       bew1.bew_zeit <=:dtGetTime
 	  							 and       (bew1.bew_zeit_bis>:dtGetTime or bew1.bew_zeit_bis is null  )
								 and bew1.fall_key not in   (select f1.FALL_KEY
					  								from       FALL_EXPERIMENT f1
					  														))
   and	fe.EXPERIMENT_KEY is not null
  
   and	not  exists ( select b.GRUPPE_KEY
				 from FALL_EXPERIMENT f,  BEWEGUNG b
				 where
						      b.CAGE_ID = g.ID
					  and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
					 and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
   					  and       b.bew_zeit <=:dtGetTime
  					  and       (b.bew_zeit_bis>:dtGetTime or b.bew_zeit_bis is null  )
					and		f.EINRICHT_ID = b.EINRICHT_ID
					and 		f.FALL_KEY = b.FALL_KEY
		 			  and		f.END_DATE is null
		 			  and     	f.EXPERIMENT_KEY != 'new')
group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 8 +  Else
.head 9 -  !
.head 9 +  If bRealTimeMode
.head 10 -  ! Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from      GRUPPE g, FALL f
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY ='" || sStatKey || "'
   and     g.CANCELED = 'N'
    and       f.LAST_abt_key ='" || sAbtKey || "'
   and       f.LAST_STAT_KEY =g.STAT_KEY
   and       f.LAST_GRUPPE_KEY = g.GRUPPE_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )

group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 10 -  Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from      GRUPPE g, FALL f
where   
       g.rack_id =:nRackID
   and     g.CANCELED = 'N'
    and       f.LAST_SCR_ID =:nScrID
   and       f.LAST_cage_id = g.id
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )

group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 9 +  Else
.head 10 -  ! Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from      GRUPPE g, BEWEGUNG bew
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY ='" || sStatKey || "'
   and     g.CANCELED = 'N'
   and	bew.EINRICHT_ID=g.EINRICHT_ID
    and       bew.abt_key ='" || sAbtKey || "'
   and       bew.STAT_KEY =g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )

group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL


into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 10 -  Set sSqlGruppe = "
select     g.GRUPPE_KEY, g.CageNName,
              g.PURPOSE_KEY, g.COLOR,'1', g.UNIQ_NR
from      GRUPPE g, BEWEGUNG bew
where      g.rack_id =:nRackID
   and     g.CANCELED = 'N'

    and       bew.scr_id =:nScrID

   and       bew.cage_id = g.id
 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= @now
   and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )

group by     g.GRUPPE_KEY, g.CageNName,
     g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL

into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 7 +  ! ! If TRUE
.head 8 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY)
from 	GRUPPE g, BETT b
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY = '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = g.GRUPPE_KEY
   and	b.CANCELED = 'N'
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount "
.head 7 -  ! !
.head 7 -  ! ! ! 	L O A D I N G     G R U P P E N
.head 7 -  Set bAnyGruppe = FALSE
.head 7 -  ! Call GetTime4Refresh(  )
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 7 -  Set bGrpBez = FALSE
.head 7 -  ! ! Set bGrpBez = GalGetProfileBooleanX( "KHE", "GrpBez", FALSE, sUserINIFileName )
.head 7 +  ! ! If not bShowOnlyOpenCages
.head 8 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 9 +  If bGrpBez
.head 10 -  Set sGrpLabel = '('|| sGrpKey || ')'|| sGrpBez
.head 9 +  Else
.head 10 -  Set sGrpLabel = '('|| sGrpKey || ')'|| sGrpBez
.head 9 +  ! ! L O A D I N G                L A B L E                    G R O U P E N
.head 10 +  ! Else
.head 11 -  Set sGrpLabel = sGrpBez || ' (' || sGrpKey || ') '
.head 9 -  Set sStatusTextG = sStatusTextS || '/' || sGrpKey
.head 9 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 9 +  If sPurposeKey
.head 10 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 11 -  Set sGrpLabel = sGrpLabel || ", " || sPurposeKey
.head 9 -  Set bAnyGruppe = TRUE
.head 9 -  Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, sGrpLabel, 0 )
.head 9 +  If hGruppe <= 0
.head 10 -  Set bOk = FALSE
.head 10 -  Break
.head 9 -  !
.head 9 +  If nColor
.head 10 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 11 -  Call SetItemColor( hGruppe, nColor )
.head 9 -  !
.head 9 +  If nBettAmount > 0
.head 10 -  Call KHESetHasChild( hGruppe, TRUE )
.head 10 +  If bForceScan Or bAutoScan
.head 11 -  Call SalStatusSetText( hWndForm, sStatusTextG || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 11 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 11 -  Set sBettKey = ''
.head 11 -  Call Refresh_HasFallX( hGruppe, dtKHK_RefreshTime, TRUE )
.head 9 -  Call KHESetChildChecked( hGruppe, TRUE )
.head 8 +  ! If bShowWithContent
.head 9 -  Call AddStrNotFallGrup( hpStation )
.head 8 +  If bShowWithContent and not SearchFrom( hpStation, "Empty Cages in Rack")
.head 9 +  If bShowPlannedCages
.head 10 -  Set sSqlPlanGruppe = "
select  g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY)
				     from BETT_LOCKS b, GRUPPE g
				     where b.STAT_KEY= '" || sStatKey || "'
				     and b.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     and 	g.STAT_KEY =  b.STAT_KEY
				     and 	b.GRUPPE_KEY = g.GRUPPE_KEY
  				     and	g.CANCELED = 'N'
				     and       @nullvalue( b.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount "
.head 10 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlPlanGruppe )
.head 10 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 11 -  Set hStation111 = SearchFrom( hpStation, sGrpKey )
.head 11 +  If hStation111 = 0
.head 12 -  ! Call OpenGruppe(sAbtKey, sStatKey, sGrpKey, TRUE)
.head 12 +  If bGrpBez
.head 13 -  Set sGrpLabel = '('|| sGrpKey || ')'|| sGrpBez
.head 12 +  Else
.head 13 -  Set sGrpLabel = '('|| sGrpKey || ')'|| sGrpBez
.head 12 +  ! ! L O A D I N G                L A B L E                    G R O U P E N
.head 13 +  ! Else
.head 14 -  Set sGrpLabel = sGrpBez || ' (' || sGrpKey || ') '
.head 12 -  Set sStatusTextG = sStatusTextS || '/' || sGrpKey
.head 12 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 12 +  If sPurposeKey
.head 13 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 14 -  Set sGrpLabel = sGrpLabel || ", " || sPurposeKey
.head 12 -  Set bAnyGruppe = TRUE
.head 12 -  Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, sGrpLabel, 0 )
.head 12 +  If hGruppe <= 0
.head 13 -  Set bOk = FALSE
.head 13 -  Break
.head 12 -  !
.head 12 +  If nColor
.head 13 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 14 -  Call SetItemColor( hGruppe, nColor )
.head 12 -  !
.head 12 +  If nBettAmount > 0
.head 13 -  Call KHESetHasChild( hGruppe, TRUE )
.head 13 +  If bForceScan Or bAutoScan
.head 14 -  Call SalStatusSetText( hWndForm, sStatusTextG || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 14 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 14 -  Set sBettKey = ''
.head 14 -  Call Refresh_HasFallX( hGruppe, dtKHK_RefreshTime, TRUE )
.head 12 -  Call KHESetChildChecked( hGruppe, TRUE )
.head 12 -  ! Call AddGruppeToStation (hpStation, sAbtKey, sStatKey, sGrpKey, bForceScan)
.head 9 -  Call AddStrNotFallGrup( hpStation )
.head 7 +  If not bShowOnlyOpenCages
.head 8 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 9 -  ! Call SqlExists( "
select  leg.ISALERT
from  LST_ERF l, LEISTUNG leg
where  l.GRUPPE_KEY= :sGrpKey
and 	l.LST_KEY=leg.LST_KEY
and	l.DONE=0
and 	l.LST_ERF_VON<:dtGetTime
and 	(l.LST_ERF_BIS>:dtGetTime or l.LST_ERF_BIS is null)
into	:nIsAlert
", bIsAlert )
.head 9 -  Set sGrpLabel = ''
.head 9 +  ! If bIsAlert
.head 10 -  Set sGrpLabel = '!!!  '
.head 9 -  Set sGrpLabel = sGrpLabel ||'('|| sGrpKey || ') '
.head 9 +  ! If sGrpBez
.head 10 -  Set sGrpLabel = sGrpLabel ||'Cage Nr '|| sGrpBez
.head 9 +  If bShowCageName and sGrpBez
.head 10 -  Set sGrpLabel = sGrpLabel ||' Cage Nr: '|| sGrpBez
.head 9 +  If bShowCageUniqNr and nUniq_Nr > 0 and CageIsEmpty(sStatKey, sGrpKey, dtGetTime, TRUE)
.head 10 -  Set sGrpLabel = sGrpLabel ||' Card Nr: '||SalNumberToStrX(nUniq_Nr, 0)
.head 9 +  ! ! L O A D I N G                L A B L E                    G R O U P E N
.head 10 +  ! Else
.head 11 -  Set sGrpLabel = sGrpBez || ' (' || sGrpKey || ') '
.head 9 -  Set sStatusTextG = sStatusTextS || '/' || sGrpKey
.head 9 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 9 +  If sPurposeKey
.head 10 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 11 -  Set sGrpLabel = sGrpLabel || ", " || sPurposeKey
.head 9 -  Set bAnyGruppe = TRUE
.head 9 +  ! If bPlannedMode and (sExpKey != sPlannedExp)
.head 10 -  Call acCageItems[i].SetOccupied("Another License")
.head 9 +  If bShouPics
.head 10 -  Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, sGrpLabel, 0 )
.head 9 +  Else
.head 10 -  Set hGruppe = KHEAddChild( hpStation, hPicNull , sGrpLabel, 0 )
.head 9 -  Call SetItemFont(hGruppe, hFontCages)
.head 9 +  If hGruppe <= 0
.head 10 -  Set bOk = FALSE
.head 10 -  Break
.head 9 -  !
.head 9 +  If nColor
.head 10 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 11 -  Call SetItemColor( hGruppe, nColor )
.head 9 -  !
.head 9 +  If nBettAmount > 0
.head 10 -  Call KHESetHasChild( hGruppe, TRUE )
.head 10 +  If bForceScan Or bAutoScan
.head 11 -  Call SalStatusSetText( hWndForm, sStatusTextG || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 11 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 11 -  Set sBettKey = ''
.head 11 +  If bShowWithContent
.head 12 -  Call KHESetHasFall( hGruppe, TRUE )
.head 11 +  Else
.head 12 -  Call Refresh_HasFallX( hGruppe, dtKHK_RefreshTime, TRUE )
.head 9 -  Call KHESetChildChecked( hGruppe, TRUE )
.head 8 +  If bShowWithContent
.head 9 +  If bShowPlannedCages
.head 10 +  If bPlanningMode
.head 11 -  ! Set sSqlPlanGruppe = "
select  g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
				     from  BETT_LOCKS b, GRUPPE g
				     where b.STAT_KEY= '" || sStatKey || "'
				     and b.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     and 	g.STAT_KEY =  b.STAT_KEY
				     and 	b.GRUPPE_KEY = g.GRUPPE_KEY
  				     and	g.CANCELED = 'N'
				     and       @nullvalue( b.BIS, @datevalue('2222-12-31')) >:dtGetTime
 				     and	 not  exists ( select bl.GRUPPE_KEY
								from FALL_EXPERIMENT f,  BETT_LOCKS bl
								where bl.PLANBEW_FALL = f.FALL_KEY
									 and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
									 and	f.END_DATE is null
				    					 and     f.EXPERIMENT_KEY != '" || sPlannedExp || "')
			                     group by	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr"
.head 11 -  Set sSqlPlanGruppe = "
select  g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
				     from  BETT_LOCKS b, GRUPPE g , bett p
				     where g.rack_id=:nRackID
					and	g.CANCELED = 'N'
					and p.cage_id = g.id
					and b.pos_id = p.id

				     and       @nullvalue( b.BIS, @datevalue('2222-12-31')) >:dtGetTime
 				     and	 not  exists ( select bl.GRUPPE_KEY
								from FALL_EXPERIMENT f,  BETT_LOCKS bl
								where bl.PLANBEW_FALL = f.FALL_KEY
									 and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
									 and	f.END_DATE is null
				    					 and     f.EXPERIMENT_KEY != '" || sPlannedExp || "')
			                     group by	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr"
.head 10 +  Else
.head 11 -  ! Set sSqlPlanGruppe = "
select  g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
				     from BETT_LOCKS b, GRUPPE g
				     where b.STAT_KEY= '" || sStatKey || "'
				     and b.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     and 	g.STAT_KEY =  b.STAT_KEY
				     and 	b.GRUPPE_KEY = g.GRUPPE_KEY
  				     and	g.CANCELED = 'N'
				     and       @nullvalue( b.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     group by	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 11 -  Set sSqlPlanGruppe = "
select  g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
				     from BETT_LOCKS b, GRUPPE g, BETT p
				     where g.rack_id = :nRackID
					and	g.CANCELED = 'N'
					and p.cage_id = g.id
					and b.pos_id = p.id
				  				    
				     and       @nullvalue( b.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     group by	g.GRUPPE_KEY, g.CageNName,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr "
.head 10 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlPlanGruppe )
.head 10 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 11 -  Set hStation111 = SearchFrom( hpStation,  sGrpKey  )
.head 11 +  If hStation111 = 0
.head 12 -  ! Call OpenGruppe(sAbtKey, sStatKey, sGrpKey, TRUE)
.head 12 -  ! Call SqlExists( "
select  leg.ISALERT
from  LST_ERF l, LEISTUNG leg
where  l.GRUPPE_KEY= :sGrpKey
and 	l.LST_KEY=leg.LST_KEY
and	l.DONE=0
and 	l.LST_ERF_VON<:dtGetTime
and 	(l.LST_ERF_BIS>:dtGetTime or l.LST_ERF_BIS is null)
into	:nIsAlert
", bIsAlert )
.head 12 -  Set sGrpLabel = '('|| sGrpKey || ') '
.head 12 -  ! If bIsAlert
.head 12 +  ! Else
.head 13 -  Set sGrpLabel = '('|| sGrpKey || ')'|| sGrpBez
.head 12 +  ! If sGrpBez
.head 13 -  Set sGrpLabel = sGrpLabel ||'Cage Nr '||sGrpBez
.head 12 +  If bShowCageName and sGrpBez
.head 13 -  Set sGrpLabel = sGrpLabel ||' Cage Nr: '|| sGrpBez
.head 12 +  If bShowCageUniqNr and nUniq_Nr > 0 and CageIsEmpty(sStatKey, sGrpKey, dtGetTime, TRUE)
.head 13 -  Set sGrpLabel = sGrpLabel ||' Card Nr: '||SalNumberToStrX(nUniq_Nr, 0)
.head 12 +  ! ! L O A D I N G                L A B L E                    G R O U P E N
.head 13 +  ! Else
.head 14 -  Set sGrpLabel = sGrpBez || ' (' || sGrpKey || ') '
.head 12 -  Set sStatusTextG = sStatusTextS || '/' || sGrpKey
.head 12 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 12 +  If sPurposeKey
.head 13 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 14 -  Set sGrpLabel = sGrpLabel || ", " || sPurposeKey
.head 12 -  Set bAnyGruppe = TRUE
.head 12 +  If bShouPics
.head 13 -  Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, sGrpLabel, 0 )
.head 12 +  Else
.head 13 -  Set hGruppe = KHEAddChild( hpStation, hPicNull , sGrpLabel, 0 )
.head 12 -  Call SetItemFont(hGruppe, hFontCages)
.head 12 +  If hGruppe <= 0
.head 13 -  Set bOk = FALSE
.head 13 -  Break
.head 12 -  !
.head 12 +  If nColor
.head 13 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 14 -  Call SetItemColor( hGruppe, nColor )
.head 12 -  !
.head 12 +  If nBettAmount > 0
.head 13 -  Call KHESetHasChild( hGruppe, TRUE )
.head 13 +  If bForceScan Or bAutoScan
.head 14 -  Call SalStatusSetText( hWndForm, sStatusTextG || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 14 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 14 -  Set sBettKey = ''
.head 14 -  Call Refresh_HasFallX( hGruppe, dtKHK_RefreshTime, TRUE )
.head 12 -  Call KHESetChildChecked( hGruppe, TRUE )
.head 12 -  ! Call AddGruppeToStation (hpStation, sAbtKey, sStatKey, sGrpKey, bForceScan)
.head 9 +  If SearchFrom( hpStation, "Empty Cages in Rack") < 1
.head 10 -  !
.head 10 -  Call AddStrNotFallGrup( hpStation )
.head 7 -  Call SqlDisconnect( hSqlGruppe )
.head 7 -  ! !
.head 7 -  Call KHESetPopulated( hpStation, bOk )
.head 7 -  ! Call SetItemFont(hpStation, hFontRacks)
.head 7 +  If bAnyGruppe
.head 8 -  Call KHESetHasChild( hpStation, TRUE )
.head 7 +  ! Else
.head 8 -  Call SetItemFont(hpStation, hFontCommon)
.head 7 -  ! !
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Return bOk
.head 5 +  Function: AddGruppeToStation
.head 6 -  Description: Reloads the Station's contents
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpStation
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bAnyGruppe
.head 7 -  Boolean: bGrpBez
.head 7 -  Sql Handle: hSqlGruppe
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nFetch
.head 7 -  Number: nColor
.head 7 -  Number: hGruppe
.head 7 -  Number: nBettAmount
.head 7 -  String: sPurposeKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sGrpKey
.head 7 -  String: sGrpBez
.head 7 -  String: sBettKey
.head 7 -  String: sGrpLabel
.head 7 -  String: sStatusTextS
.head 7 -  String: sStatusTextG
.head 7 -  Number: nFallKeyInGrp
.head 7 -  Number: nLE_Id
.head 7 -  Number: nCounter
.head 7 -  ! Number: hpStation
.head 7 -  ! Number: nLengthTemp
.head 7 -  Date/Time: dtGetTime
.head 7 -  Boolean: bIsAlert
.head 7 -  Number: nIsAlert
.head 7 -  Number: nUniq_Nr
.head 7 -  Number: nCageID
.head 6 +  Actions
.head 7 -  ! Set hpStation = FindH_4Station( FindH_4Abteilung( sAbtKeyParm ), sStatKeyParm, bForceScan )
.head 7 +  If hpStation <= 0
.head 8 -  Return FALSE
.head 7 +  If FindChild( hpStation, sGrpKey )
.head 8 -  Return FALSE
.head 7 +  ! If KHE_IsPopulated( hpStation ) and not bShowOnlyOpenCages
.head 8 -  Return PopulateStationLight( hpStation, bForceScan )
.head 7 -  !
.head 7 -  ! Call GetPosition( hpStation, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If Not sStatKey
.head 8 -  Return FALSE
.head 7 +  If Not GalConnect( hSqlGruppe )
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  ! Call KHE_DeleteDescendents( hpStation )
.head 7 -  !
.head 7 -  Set sStatusTextS = 'Populate: ' || sAbtKey || '/' || sStatKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextS )
.head 7 -  ! !! SQL for Select Cages
.head 7 +  If TRUE    
.head 8 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ, 
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
from 	sysadm.GRUPPE g, sysadm.BETT b
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY = '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and	b.GRUPPE_KEY = g.GRUPPE_KEY
   and	b.CANCELED = 'N'
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ, 
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr  "
.head 8 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ, 
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR
from 	sysadm.GRUPPE g, sysadm.BETT b
where	g.ID = :nCageID
     and	g.CANCELED = 'N'
     and	b.CAGE_ID = g.ID
     and	b.CANCELED = 'N'
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ, 
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr  "
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, "select id from gruppe where EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY = '" || sStatKey || "' and GRUPPE_KEY = '" || sGrpKey || "' into :nCageID" )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 7 -  !
.head 7 -  ! ! 	L O A D I N G     G R U P P E N
.head 7 -  Set bAnyGruppe = FALSE
.head 7 -  Set dtGetTime=GetTime4Refresh(  )
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 7 -  Set bGrpBez = FALSE
.head 7 -  ! Set bGrpBez = GalGetProfileBooleanX( "KHE", "GrpBez", FALSE, sUserINIFileName )
.head 7 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 8 -  ! Call SqlExists( "
select  leg.ISALERT
from  LST_ERF l, LEISTUNG leg
where  l.GRUPPE_KEY= :sGrpKey
and 	l.LST_KEY=leg.LST_KEY
and	l.DONE=0
and 	l.LST_ERF_VON<:dtGetTime
and 	(l.LST_ERF_BIS>:dtGetTime or l.LST_ERF_BIS is null)
into	:nIsAlert
", bIsAlert )
.head 8 +  If bIsAlert
.head 9 -  Set sGrpLabel = '('|| sGrpKey ||')'|| sGrpBez 
.head 8 +  Else
.head 9 -  Set sGrpLabel = '('|| sGrpKey ||')'|| sGrpBez 
.head 8 +  If nUniq_Nr > 0 and CageIsEmpty(sStatKey, sGrpKey, dtGetTime, TRUE)
.head 9 -  Set sGrpLabel = sGrpLabel ||'    Cage Nr '||SalNumberToStrX(nUniq_Nr, 0)
.head 8 +  ! ! L O A D I N G                L A B L E                    G R O U P E N
.head 9 +  ! Else
.head 10 -  Set sGrpLabel = sGrpBez || ' (' || sGrpKey || ') '
.head 8 -  Set sStatusTextG = sStatusTextS || '/' || sGrpKey
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 8 +  If sPurposeKey
.head 9 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 10 -  Set sGrpLabel = sGrpLabel || ", " || sPurposeKey
.head 8 -  Set bAnyGruppe = TRUE
.head 8 -  ! Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, sGrpLabel, 0 )
.head 8 -  Call SetItemFont(hGruppe, hFontCages)
.head 8 +  If bShouPics 
.head 9 -  Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, sGrpLabel, 0 )
.head 8 +  Else
.head 9 -  Set hGruppe = KHEAddChild( hpStation, hPicNull , sGrpLabel, 0 )
.head 8 +  If hGruppe <= 0
.head 9 -  Set bOk = FALSE
.head 9 -  Break
.head 8 -  !
.head 8 +  If nColor
.head 9 +  If nBettAmount > 0 Or Not bUseCurrentTime
.head 10 -  Call SetItemColor( hGruppe, nColor )
.head 8 -  !
.head 8 +  If nBettAmount > 0
.head 9 -  Call KHESetHasChild( hGruppe, TRUE )
.head 9 +  If bForceScan Or bAutoScan
.head 10 -  Call SalStatusSetText( hWndForm, sStatusTextG || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 10 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 10 -  Set sBettKey = ''
.head 10 -  Call Refresh_HasFallX( hGruppe, dtKHK_RefreshTime, TRUE )
.head 8 -  Call KHESetChildChecked( hGruppe, TRUE )
.head 7 +  If bShowWithContent
.head 8 -  Call AddStrNotFallGrup( hpStation )
.head 8 -  ! Set hGruppe = KHEAddChild( hpStation, hPicFolderCollapsed, SalNumberToStrX(nColor,0) || '  #', 0 )
.head 8 -  ! Call KHESetChildChecked( hGruppe, TRUE )
.head 7 -  Call SqlDisconnect( hSqlGruppe )
.head 7 -  !
.head 7 -  Call KHESetPopulated( hpStation, bOk )
.head 7 +  If bAnyGruppe
.head 8 -  Call KHESetHasChild( hpStation, TRUE )
.head 7 -  !
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Return bOk
.head 5 +  Function: DeleteGruppeFromStation
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hGruppeHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 -  Set nIndex = GetItemIndex( hGruppeHandle )
.head 7 -  Call SalListDelete( hWndItem, nIndex )
.head 7 -  Call DeleteChild(hGruppeHandle)
.head 5 +  Function: PopulateStationLight
.head 6 -  Description: ReScan the Station's contents
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpStat
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Number: hGrp[*]
.head 7 -  Number: nGrpAmount
.head 7 -  Number: nGrp
.head 7 -  Boolean: bOk
.head 7 -  ! Boolean: bExists
.head 7 -  String: sStatusTextG
.head 7 -  String: sStatusTextS
.head 7 -  Number: nLE_Id
.head 6 +  Actions
.head 7 +  If Not bForceScan
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  Set sStatKey = GetKey_ByHandle( hpStat )
.head 7 +  If Not sStatKey
.head 8 -  Return FALSE
.head 7 -  Set sAbtKey = GetKey_ByHandle( GetParent( hpStat ) )
.head 7 -  !
.head 7 -  Set sStatusTextS = 'Scan: ' || sAbtKey || '/' || sStatKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextS )
.head 7 -  Call GetTime4Refresh(  )
.head 7 +  If bForceScan
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextS || ' - ' || GetMessageFromSection( 'KHE', 30, 'Scan for cases...' ) )
.head 8 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 8 -  Set sGrpKey = ''
.head 8 -  Set sBettKey = ''
.head 8 -  Call Refresh_HasFallX( hpStat, dtKHK_RefreshTime, FALSE )
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextS )
.head 7 -  !
.head 7 -  ! !! 	SCAN     STATIONS
.head 7 -  Set nGrpAmount = EnumChildren( hpStat, hGrp )
.head 7 -  Set nGrp = 0
.head 7 -  ! Call SetItemFont(hpStat, hFontCommon)
.head 7 +  While nGrp < nGrpAmount
.head 8 -  Set sGrpKey = GetKey_ByHandle( hGrp[ nGrp ] )
.head 8 -  Set sStatusTextG = sStatusTextS || '/' || sGrpKey
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 8 +  If KHE_HasChild( hGrp[ nGrp ] )
.head 9 -  Set sAbtKey = ''	! May be we do not need this line, but having it we always will see
.head 9 -  Set sBettKey = ''
.head 9 -  Call Refresh_HasFallX( hGrp[ nGrp ], dtKHK_RefreshTime, FALSE )
.head 9 -  Call SetItemFont(hpStat, hFontRacks)
.head 8 -  Set nGrp = nGrp + 1
.head 7 -  !
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Return TRUE
.head 5 +  Function: PopulateGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nFetch
.head 7 -  Number: hBett
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bAnyBett
.head 7 -  Boolean: bAnyFall
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sBettLabel
.head 7 -  String: sStatusTextG
.head 7 -  Number: nFallKeyOnBed
.head 7 -  Date/Time: dtGetTime
.head 7 -  String: sBett111
.head 7 -  String: sSex
.head 7 -  Number: nSexM
.head 7 -  Number: nSexF
.head 7 -  !
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 7 -  Date/Time: dtGebDatum
.head 7 -  Date/Time: dtTodDatum
.head 7 -  String: sItemText
.head 7 -  String: sForeignID
.head 7 -  String: sSV_Nr
.head 7 -  String: sLE_Info
.head 7 -  String: sName1
.head 7 -  Number: nTypeOfResult
.head 7 -  Number: nItemColor
.head 7 -  String: sGeschlKey
.head 7 -  String: sGeschlAbr
.head 7 -  Number: nStrainColor
.head 7 -  String: sBatch
.head 7 -  String: sColor
.head 7 -  String: sPhenoType
.head 7 -  String: sGenoType
.head 7 -  String: sTelefaxOrigin
.head 7 -  String: sName3
.head 7 -  Number: hTemp
.head 7 -  Boolean: bPlugged
.head 6 +  Actions
.head 7 +  If hpGruppe <= 0
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( hpGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call GetPositionID(  hpGruppe, nScrID, nRackID, nCageID, nPosID )
.head 7 +  If sGrpKey = "Empty Cages in Rack"
.head 8 -  Return TRUE
.head 7 +  If KHE_IsPopulated( hpGruppe )
.head 8 +  If bShowPlacesWithContent
.head 9 -  Call PopulateGruppeLight( hpGruppe, bForceScan )
.head 9 +  ! If not BettIsSummary() and (GetItemIndex(SearchFrom( hpGruppe,  'In Cage:'))>0 or (bMiniSolution and GetItemIndex(SearchFrom( hpGruppe,  'Cage is used'))>0) or (bMiniSolution and GetItemIndex(SearchFrom( hpGruppe,  'Cage is not used'))>0 ))
.head 10 -  Return PopulateGruppeLight( hpGruppe, bForceScan )
.head 8 +  Else
.head 9 -  Return PopulateGruppeLight( hpGruppe, bForceScan )
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  ! ! ! !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Set bAnyBett = FALSE
.head 7 -  Set bAnyFall = FALSE
.head 7 -  Call KHE_DeleteDescendents( hpGruppe )
.head 7 -  ! ! Set bShowWithContent = GalGetProfileBooleanX('KHE','ShowOnlyCagesWithContent', FALSE, sUserINIFileName )
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set dtTime  = dtGetTime
.head 7 +  If not bShowPlacesWithContent
.head 8 -  ! Set sSqlGruppe = "
select	'('|| b.BETT_KEY ||')'|| b.BETT_BEZ , b.BETT_KEY
from 	BETT b
where	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
order 	by b.BETT_KEY
into	:sBettLabel, :sBettKey "
.head 8 -  Set sSqlGruppe = "
select	'('|| b.BETT_KEY ||')'|| b.BETT_BEZ , b.BETT_KEY
from 	BETT b
where	b.cage_id = :nCageID
   and 	b.CANCELED = 'N'
order 	by b.BETT_KEY
into	:sBettLabel, :sBettKey "
.head 7 +  Else
.head 8 -  ! Set sSqlGruppe = "
select	'('|| b.BETT_KEY ||')'|| b.BETT_BEZ , b.BETT_KEY
from 	BETT b, BEWEGUNG bew, fall f
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'

   and	b.BETT_KEY=bew.BETT_KEY
   and       bew.STAT_KEY = b.STAT_KEY
   and       bew.GRUPPE_KEY = b.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by b.BETT_KEY
into	:sBettLabel, :sBettKey "
.head 8 +  If bPlanningMode
.head 9 -  ! Set sSqlGruppe = "
select	 bew.BETT_KEY, f.GESCHL
from BEWEGUNG bew,  fall f
where	      bew.STAT_KEY = '" || sStatKey || "'
	 and       bew.GRUPPE_KEY = '" || sGrpKey || "'
	 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	 and       bew.bew_zeit <=:dtGetTime
   	 and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   	 and	bew.Fall_KEY = f.Fall_KEY
	 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   	 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   	 and	bew.Fall_KEY not in (select	 bl.PLANBEW_FALL
				from  BETT_LOCKS bl
   				where	      bew.Fall_KEY=bl.PLANBEW_FALL
   					 and       (bl.bis>:dtGetTime or bl.bis is null  ))
   					
	
order 	by bew.BETT_KEY
into	 :sBettKey, :sSex "
.head 9 -  ! Set sSqlGruppe = "
select	 bew.BETT_KEY, f.GESCHL
from BEWEGUNG bew,  fall f
where	      bew.STAT_KEY = '" || sStatKey || "'
	 and       bew.GRUPPE_KEY = '" || sGrpKey || "'
	 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	 and       bew.bew_zeit <=:dtGetTime
   	 and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   	 and	bew.Fall_KEY = f.Fall_KEY
	 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   	 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   	 and	bew.Fall_KEY not in (select	 bl.PLANBEW_FALL
				from  BETT_LOCKS bl
   				where	      bew.Fall_KEY=bl.PLANBEW_FALL
   					 and       (bl.bis>:dtGetTime or bl.bis is null  ))
   					
	
order 	by bew.BETT_KEY
into	 :sBettKey, :sSex "
.head 9 -  Set sSqlGruppe = "
select	 bew.BETT_KEY, f.Fall_key,
 	f.NAME1, s.STRAIN_KEY,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,
	l.PHENOTYPE, l.INFO,
	'', l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR
from BEWEGUNG bew,  fall f, LE l, STRAIN_N s
where	      bew.cage_id =:nCageID
	 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	 and       bew.bew_zeit <= :dtGetTime 
   	 and       (bew.bew_zeit_bis>:dtGetTime  or bew.bew_zeit_bis is null  )
   	 and	bew.Fall_KEY = f.Fall_KEY
	 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   	 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
    and      f.le_id = l.LE_ID
    and	s.ID = l.id_strain
   	 and	bew.Fall_KEY not in (select	 bl.PLANBEW_FALL
				from  BETT_LOCKS bl
   				where	      bew.Fall_KEY=bl.PLANBEW_FALL
   					 and       (bl.bis>:dtGetTime  or bl.bis is null  ))
   					
	
order 	by bew.BETT_KEY
into	 :sBettKey, :nFallKeyOnBed,
	:sName1, :sName3,
	:dtGebDatum, :dtTodDatum,
	:sSV_Nr,  :sGeschlKey,
	:sPhenoType,:sLE_Info,
	:sTelefaxOrigin, :sColor, :sBatch, :sForeignID,
	:sGenoType, :nStrainColor  "
.head 8 +  Else
.head 9 +  ! If bRealTimeMode
.head 10 -  ! Set sSqlGruppe = "
select	f.LAST_BETT_KEY, f.GESCHL
from 	 fall f
where	f.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	f.LAST_STAT_KEY = '" || sStatKey || "'
   and	f.LAST_GRUPPE_KEY = '" || sGrpKey || "'
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by f.LAST_BETT_KEY
into	 :sBettKey, :sSex "
.head 10 -  Set sSqlGruppe = "
select	f.LAST_BETT_KEY, f.GESCHL
from 	 fall f
where
 		f.LAST_CAGE_ID = :nCageID
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by f.LAST_BETT_KEY
into	 :sBettKey, :sSex "
.head 9 +  ! Else
.head 10 -  ! Set sSqlGruppe = "
select	bew.BETT_KEY, f.GESCHL
from 	 BEWEGUNG bew, fall f
where	bew.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	bew.STAT_KEY = '" || sStatKey || "'
   and	bew.GRUPPE_KEY = '" || sGrpKey || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtGetTime
   and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
order 	by bew.BETT_KEY
into	 :sBettKey, :sSex "
.head 10 -  Set sSqlGruppe = "
select	bew.BETT_KEY, f.GESCHL
from 	 BEWEGUNG bew, fall f
where       bew.cage_id = :nCageID
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= @now
   and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
order 	by bew.BETT_KEY
into	 :sBettKey, :sSex "
.head 9 +  If bRealTimeMode
.head 10 -  Set sSqlGruppe = "
select	f.LAST_BETT_KEY,  f.Fall_key,
 	f.NAME1, s.STRAIN_KEY,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,
	l.PHENOTYPE, l.INFO,
	'', l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR
from 	 fall f, LE l, STRAIN_N s
where
 		f.LAST_CAGE_ID = :nCageID
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
    and      f.le_id = l.LE_ID
    and	s.ID = l.id_strain
order 	by f.LAST_BETT_KEY
into	 :sBettKey,  :nFallKeyOnBed,
	:sName1, :sName3,
	:dtGebDatum, :dtTodDatum,
	:sSV_Nr,  :sGeschlKey,
	:sPhenoType,:sLE_Info,
	:sTelefaxOrigin, :sColor, :sBatch, :sForeignID,
	:sGenoType, :nStrainColor"
.head 9 +  Else
.head 10 -  Set sSqlGruppe = "
select	bew.BETT_KEY, f.Fall_key,
 	f.NAME1, s.STRAIN_KEY,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,
	l.PHENOTYPE, l.INFO,
	'', l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR
from 	 BEWEGUNG bew, fall f, LE l, STRAIN_N s
where       bew.cage_id = :nCageID
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= @now
   and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
    and      f.le_id = l.LE_ID
    and	s.ID = l.id_strain
order 	by bew.BETT_KEY
into	 :sBettKey,   :nFallKeyOnBed,
	:sName1, :sName3,
	:dtGebDatum, :dtTodDatum,
	:sSV_Nr,  :sGeschlKey,
	:sPhenoType,:sLE_Info,
	:sTelefaxOrigin, :sColor, :sBatch, :sForeignID,
	:sGenoType, :nStrainColor "
.head 7 -  Set sStatusTextG = 'Populate: ' || sAbtKey || '/' || sStatKey || '/' || sGrpKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 7 -  ! ! ! ! !
.head 7 -  ! ! Call GetTime4Refresh(  )
.head 7 +  ! If bForceScan Or bAutoScan
.head 8 -  Call RefreshSingleGruppeLabel( hpGruppe, sGrpKey, sStatKey )
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, sSqlGruppe )
.head 7 -  ! Set bOk = TRUE
.head 7 -  Set nSexM=0
.head 7 -  Set nSexF=0
.head 7 +  While bOk and SqlFetchNext( hSql, nFetch )
.head 8 -  Set bAnyBett = TRUE
.head 8 -  Set sGeschlAbr = Sex_GetAbr( sGeschlKey )
.head 8 -  Call SqlExists( "select * from relship_fall
 where fall_key=:nFallKeyOnBed and plugged is not null ", bPlugged )
.head 8 +  If bPlugged 
.head 9 -  Set sItemText = "* " 
.head 8 +  Else
.head 9 -  Set sItemText = ""
.head 8 +  If TRUE
.head 9 -  Set sItemText = sItemText || '('||sBettKey||')'
.head 9 +  If nFallKeyOnBed
.head 10 -  Set sItemText = sItemText || ' - '
.head 9 +  If dtTodDatum And dtTodDatum <= dtKHK_RefreshTime
.head 10 -  Set sItemText = sItemText || 'K '
.head 10 -  ! Set bDeadInCage = TRUE
.head 10 +  ! If bSelectDead
.head 11 -  Set hTemp = nSelectedHandle
.head 11 -  Set nSelectedHandle = hBett
.head 11 -  Call MultiSelect(  )
.head 11 -  Set nSelectedHandle = hTemp
.head 10 +  ! Else
.head 11 -  Set nCountDead = nCountDead +1
.head 11 -  Set nFallDeadHandle[nCountDead] = hBett
.head 9 -  Set sItemText = sItemText || '{' || StrX( nFallKeyOnBed ) || '} ' || sForeignID|| ' , ' || sName1 || ', '
.head 9 +  If IsFallHavePlanBew( nFallKeyOnBed )
.head 10 -  Set sItemText = sItemText || ' (PB) ,'
.head 9 -  Set sItemText = sItemText  || sSV_Nr || ' , ' || sName3 || ', ' || sGeschlAbr || ', ' ||
	SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy') || ', ' || sBatch ||', '||sTelefaxOrigin || ', ' || sPhenoType || ',  ' || sGenoType || ',  ' || sColor
.head 9 -  Set sItemText = sItemText || ', HS: ' || StrX( HelStat_Get4Fall( nFallKeyOnBed, dtKHK_RefreshTime ) )
.head 9 +  If sLE_Info
.head 10 -  Set sItemText = sItemText || ' *'
.head 9 -  ! color:
.head 9 +  If bColorStrain
.head 10 -  Set nItemColor = nStrainColor
.head 9 +  Else
.head 10 +  If sGeschlKey = 'M'
.head 11 -  Set nItemColor = nColorM
.head 10 +  Else
.head 11 -  Set nItemColor = nColorW
.head 9 -  ! If nTypeOfResult = 1
.head 9 +  ! Else
.head 10 -  Set sItemText = sItemText || ' [' || sPLAN || ']'
.head 10 -  Set nItemColor = COLOR_DarkRed
.head 9 +  If bPlanningMode
.head 10 +  If IsFallInPlanExperiment( nFallKeyOnBed )
.head 11 -  Set sItemText = sItemText || ' (Exp.:' || sPlan_Experiment || ')'
.head 10 +  Else
.head 11 -  Set sItemText = sItemText || ' (Not in Exp.:' || sPlan_Experiment || ')'
.head 11 -  Set nItemColor = COLOR_Gray
.head 8 -  ! Call SalStatusSetText( hWndForm, sStatusTextG || '/' || sBettKey )
.head 8 -  ! Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, sBettLabel, 0 )
.head 8 -  ! Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, '('||sBettKey||')', 0 )
.head 8 +  If bShouPics
.head 9 -  ! Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, '('||sBettKey||')', 0 )
.head 9 -  Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, sItemText, 0 )
.head 8 +  Else
.head 9 -  ! Set hBett = KHEAddChild( hpGruppe, hPicNull, '('||sBettKey||')', 0 )
.head 9 -  Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, sItemText, 0 )
.head 8 +  If dtTodDatum And dtTodDatum <= dtKHK_RefreshTime
.head 9 +  If not bDeadInCage
.head 10 -  Call UnSelect(  )
.head 9 -  Set bDeadInCage = TRUE
.head 9 +  If bSelectDead
.head 10 -  Set hTemp = nSelectedHandle
.head 10 -  Set nSelectedHandle = hBett
.head 10 -  Call MultiSelect(  )
.head 10 -  Set nSelectedHandle = hTemp
.head 9 +  Else
.head 10 -  Set nCountDead = nCountDead +1
.head 10 -  Set nFallDeadHandle[nCountDead] = hBett
.head 8 -  Call SetItemFont(hBett, hFontBetts)
.head 8 -  Call SetItemColor( hBett, nItemColor )
.head 8 -  ! Set sBett111 = sBett111|| '/' || sBettLabel
.head 8 +  If bForceScan Or bAutoScan
.head 9 -  ! Set bOk = PopulateBett( hBett, sBettKey, sBettLabel, nFallKeyOnBed )
.head 9 -  ! Set bOk = PopulateBett( hBett, sBettKey, '('||sBettKey||')', nFallKeyOnBed )
.head 9 +  If nFallKeyOnBed
.head 10 -  Set bAnyFall = TRUE
.head 8 +  If sGeschlAbr ='M'
.head 9 -  Set nSexM=nSexM+1
.head 8 +  Else
.head 9 -  Set nSexF=nSexF+1
.head 7 +  If bShowPlacesWithContent and bPlanningMode
.head 8 -  Set sSqlGruppe = "
select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	      bl.STAT_KEY = '" || sStatKey || "'
  						 and       bl.GRUPPE_KEY = '" || sGrpKey || "'
						 and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
						 and       bl.VON <= :dtGetTime
   						 and       (bl.bis>:dtGetTime or bl.bis is null  )
   					
	
order 	by bl.BETT_KEY
into	 :sBettKey"
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSql, nFetch )
.head 9 -  Set bAnyBett = TRUE
.head 9 -  Call SalStatusSetText( hWndForm, sStatusTextG || '/' || sBettKey )
.head 9 -  ! Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, sBettLabel, 0 )
.head 9 -  ! Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, '('||sBettKey||')', 0 )
.head 9 +  If bShouPics
.head 10 -  Set hBett = KHEAddChild( hpGruppe, hPicFolderFree, '('||sBettKey||')', 0 )
.head 9 +  Else
.head 10 -  Set hBett = KHEAddChild( hpGruppe, hPicNull, '('||sBettKey||')', 0 )
.head 9 -  Call SetItemFont(hBett, hFontBetts)
.head 9 -  ! Set sBett111 = sBett111|| '/' || sBettLabel
.head 9 +  If bForceScan Or bAutoScan
.head 10 -  ! Set bOk = PopulateBett( hBett, sBettKey, sBettLabel, nFallKeyOnBed )
.head 10 -  Set bOk = PopulateBett( hBett, sBettKey, '('||sBettKey||')', nFallKeyOnBed )
.head 10 +  If nFallKeyOnBed
.head 11 -  Set bAnyFall = TRUE
.head 9 +  ! If sSex ='M'
.head 10 -  Set nSexM=nSexM+1
.head 9 +  ! Else
.head 10 -  Set nSexF=nSexF+1
.head 7 +  If bShowPlacesWithContent  !!!!and not bMiniSolution
.head 8 -  Call AddStrBettX(hpGruppe, nSexM, nSexF) ! aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  ! !
.head 7 -  Call KHESetPopulated( hpGruppe, bOk )
.head 7 +  If bOk
.head 8 -  Call KHESetHasChild( hpGruppe, bAnyBett )
.head 8 +  If bForceScan
.head 9 -  Call KHESetHasFall( hpGruppe, bAnyFall )
.head 8 +  ! If bAnyFall
.head 9 -  Call SetItemFont(hpGruppe, hFontCages)
.head 8 +  ! Else
.head 9 -  Call SetItemFont(hpGruppe, hFontCommon)
.head 7 -  ! Call clsExplorerLeft.KHEReAssignPics(hpGruppe)
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Return bOk
.head 5 +  Function: PopulateGruppeLight
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hBett[*]
.head 7 -  Number: nBedAmount
.head 7 -  Number: nBed
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bAnyFall
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sBettLabel
.head 7 -  String: sStatusTextG
.head 7 -  Number: nFallKeyOnBed
.head 7 -  String: aaa
.head 6 +  Actions
.head 7 +  If Not bForceScan
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  Call GetPosition( hpGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If Not sStatKey
.head 8 -  Return FALSE
.head 7 +  If Not sGrpKey
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Set sStatusTextG = 'Scan: ' || sAbtKey || '/' || sStatKey || '/' || sGrpKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 7 -  !
.head 7 -  Call RefreshSingleGruppeLabel( hpGruppe, sGrpKey, sStatKey )
.head 7 -  Set bAnyFall = FALSE
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 +  If bShowPlacesWithContent
.head 8 -  ! Call KHE_RefreshGruppe(hpGruppe)
.head 8 -  Set bAnyFall =  CageIsEmpty(sStatKey, sGrpKey, dtTime, bShowOnlyRealBew)
.head 7 +  Else
.head 8 -  !
.head 8 -  Set nBedAmount = EnumChildren( hpGruppe, hBett )
.head 8 -  Set nBed = 0
.head 8 +  While nBed < nBedAmount
.head 9 -  Set sBettKey = GetKey_ByHandle( hBett[ nBed ] )
.head 9 +  If sBettKey = ''
.head 10 -  Set sBettKey= GetItemText( hBett[ nBed ] )
.head 10 +  ! If SalStrScan( sBettKey, 'In Cage:')>0
.head 11 -  ! Call SetItemText( hBett[ nBed ] , '[ '||SalNumberToStrX(QuantityOfEmptyBett(GetParent(hBett[ nBed ])) ,0)||' ]' || '  Empty Places in Cage' )
.head 11 -  Call AddStrBett(hBett[ nBed ] )
.head 9 +  Else
.head 10 -  !
.head 10 -  Call SalStatusSetText( hWndForm, sStatusTextG || '/' || sBettKey )
.head 10 -  Set bOk = PopulateBett( hBett[ nBed ], sBettKey, '', nFallKeyOnBed )
.head 10 +  If nFallKeyOnBed
.head 11 -  Set bAnyFall = TRUE
.head 9 -  ! Call SalStatusSetText( hWndForm, sStatusTextG || '/' || sBettKey )
.head 9 -  ! Set bOk = PopulateBett( hBett[ nBed ], sBettKey, '', nFallKeyOnBed )
.head 9 +  ! If nFallKeyOnBed
.head 10 -  Set bAnyFall = TRUE
.head 9 -  Set nBed = nBed + 1
.head 8 -  Call KHESetHasFall( hpGruppe, bAnyFall )
.head 7 -  !
.head 7 -  Call KHESetHasFall( hpGruppe, bAnyFall )
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Call clsExplorerLeft.KHEReAssignPics(hpGruppe)
.head 7 +  ! If bAnyFall
.head 8 -  Call SetItemFont(hpGruppe, hFontCages)
.head 7 +  ! Else
.head 8 -  Call SetItemFont(hpGruppe, hFontCommon)
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Return bOk
.head 5 +  Function: PopulateBett
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hBett
.head 7 -  String: spBettKey
.head 7 -  String: sBettLabel
.head 7 -  Receive Number: nFallKeyOnBed
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sTemp
.head 7 -  Sql Handle: hSql
.head 7 -  String: sItemText
.head 7 -  Number: nItemColor
.head 7 -  !
.head 7 -  Number: nBewNr_LockId
.head 7 -  Date/Time: dtBewNr_LockId_Zeit
.head 7 -  Number: nTypeOfResult
.head 7 -  String: sAbtKeyOfFall
.head 7 -  String: sName1
.head 7 -  String: sName3
.head 7 -  Date/Time: dtGebDatum
.head 7 -  Date/Time: dtTodDatum
.head 7 -  String: sSV_Nr
.head 7 -  String: sGeschlAbr
.head 7 -  String: sGeschlKey
.head 7 -  String: sPhenoType
.head 7 -  String: sGenoType
.head 7 -  String: sColor
.head 7 -  String: sLE_Info
.head 7 -  String: sTelefaxOrigin
.head 7 -  String: sStatusTextB
.head 7 -  Number: nLE_Id
.head 7 -  Number: nLock_Id
.head 7 -  Number: nStrainColor
.head 7 -  String: sBatch
.head 7 -  Boolean: bIsAlert
.head 7 -  Number: nIsAlert
.head 7 -  Number: hTemp
.head 7 -  String: sForeignID
.head 7 -  !
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 7 -  !
.head 7 -  Boolean: bPlugged
.head 6 +  Actions
.head 7 -  Set nFallKeyOnBed = 0
.head 7 +  If not CheckDBVersion( 5.64 )
.head 8 -  Return FALSE
.head 7 +  If hBett = 0
.head 8 +  If nSelectedLevel = KHEL_Bett
.head 9 -  Set hBett = nSelectedHandle
.head 8 +  Else
.head 9 -  Return FALSE
.head 7 -  !
.head 7 -  Call GetPosition( hBett, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call GetPositionID( hBett, nScrID, nRackID, nCageID, nPosID )
.head 7 +  If spBettKey
.head 8 -  Set sBettKey = spBettKey
.head 7 -  Set sStatusTextB = 'Populate: ' || sAbtKey || '/' || sStatKey || '/' || sGrpKey || '/' || sBettKey
.head 7 -  Call SalStatusSetText( hWndForm, sStatusTextB )
.head 7 +  If sBettLabel = ""
.head 8 -  Set s[3]=""
.head 8 -  ! Call DoImmediate("
select	b.BETT_BEZ
from 	BETT b
where	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	b.STAT_KEY = '"|| sStatKey ||"'
and 	b.GRUPPE_KEY = '"|| sGrpKey ||"'
and	b.BETT_KEY = '"|| sBettKey ||"'
into	:s[3]
")
.head 8 -  Call DoImmediate("
select	b.BETT_BEZ
from 	BETT b
where	b.ID=" || SalNumberToStrX(nPosID,0) || "
into	:s[3]
")
.head 8 -  Set sBettLabel = '('|| sBettKey ||')'
.head 7 +  Else
.head 8 -  Set sBettLabel = '('|| sBettKey ||')'
.head 7 +  If bShowDateTimeInKHE
.head 8 -  Set sBettLabel = sBettLabel || ' <' || SalFmtFormatDateTime( dtKHK_RefreshTime, 'dd.MM.yyyy hhhh:mm:ss' ) || '>'
.head 7 +  !
.head 8 -  ! ! - VM-19.07.2002- @datevalue() added in @nullvalue(...) for DB compatibility
.head 8 -  ! MouseID, EarTag, Strain, Line, Sex; Birth, Genotype, Phenotype
.head 8 -  ! !--VM--03.10.2002-- Commented. Added MDB_GetServerType() for DB compatibility
.head 8 +  ! !If TRUE  --- "If DoImmediate(....)"
.head 9 +  If DoImmediate("
select	'{' || f.FALL_KEY || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE,
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc
into	:s[1], :s[2], :s[3], :s[4]
")
.head 10 -  ! Set sFallLabel = s1
.head 10 -  ! old:
select 	f.NAME1 || ', ' || f.NAME3 || ', ' || l.GEBURTSNAME || ', ' || gs.GESCHL_ABR || ', ' || @datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ',  ' || f.FALLART_KEY || ',  ' || f.STATUS || ',  ' || b.BA_KEY || '  {' || f.FALL_KEY || '} ',
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and         l.LE_ID = f.LE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc

.head 8 -  !
.head 8 +  ! AS 06.10.2003: use only one unique SQL for all DB
.head 9 -  ! AD@18.08.03 : added branch for Sybase
.head 9 +  ! Select Case MDB_GetServerType()
.head 10 +  ! Case nMDB_SQLBASE
.head 11 +  If DoImmediate("
select	'{' || f.FALL_KEY || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE,
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc
into	:s[1], :s[2], :s[3], :s[4]
")
.head 12 -  ! Set sFallLabel = s1
.head 12 -  ! old:
select 	f.NAME1 || ', ' || f.NAME3 || ', ' || l.GEBURTSNAME || ', ' || gs.GESCHL_ABR || ', ' || @datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ',  ' || f.FALLART_KEY || ',  ' || f.STATUS || ',  ' || b.BA_KEY || '  {' || f.FALL_KEY || '} ',
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and         l.LE_ID = f.LE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc

.head 11 -  Break
.head 10 +  Case nMDB_ORACLE
.head 11 +  If DoImmediate("
select	SUBSTR( '{' || f.FALL_KEY || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE, 1, 254),
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} ', l.TOD_DATUM
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	f.GELOESCHT = 'N'
nd 	b.GELOESCHT = 'N'
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc
into	:s[1], :s[2], :s[3], :s[4], :dt[1]
")
.head 12 -  ! Set sFallLabel = s1
.head 12 -  ! old:
select 	f.NAME1 || ', ' || f.NAME3 || ', ' || l.GEBURTSNAME || ', ' || gs.GESCHL_ABR || ', ' || @datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ',  ' || f.FALLART_KEY || ',  ' || f.STATUS || ',  ' || b.BA_KEY || '  {' || f.FALL_KEY || '} ',
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and         l.LE_ID = f.LE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc

.head 11 -  Break
.head 10 +  Case nMDB_SYBASE
.head 11 -  ! AD@18.08.03 : added substring()
.head 11 +  If DoImmediate("
select	substring( '{' || @string( f.FALL_KEY, 0 ) || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE, 1, 254 ),
	l.GESCHL, b.ABT_KEY, '  {' || @string( f.FALL_KEY, 0 ) || '} ', l.TOD_DATUM, l.INFO
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	f.GELOESCHT = 'N'
and 	b.GELOESCHT = 'N'
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc
into	:s[1], :s[2], :s[3], :s[4], :dt[1], :s[5]
")
.head 12 -  ! Set sFallLabel = s1
.head 12 -  ! old:
select 	f.NAME1 || ', ' || f.NAME3 || ', ' || l.GEBURTSNAME || ', ' || gs.GESCHL_ABR || ', ' || @datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ',  ' || f.FALLART_KEY || ',  ' || f.STATUS || ',  ' || b.BA_KEY || '  {' || f.FALL_KEY || '} ',
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and         l.LE_ID = f.LE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc

.head 11 -  Break
.head 10 +  Default
.head 11 +  ! AD@01.07.03 : f.FALL_KEY -> @string( f.FALL_KEY, 0 )
.head 12 +  ! original
.head 13 +  ! If DoImmediate("
select	'{' || f.FALL_KEY || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE,
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} ', l.TOD_DATUM
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc
into	:s[1], :s[2], :s[3], :s[4], :dt[1]
")
.head 14 -  ! Set sFallLabel = s1
.head 14 -  ! old:
select 	f.NAME1 || ', ' || f.NAME3 || ', ' || l.GEBURTSNAME || ', ' || gs.GESCHL_ABR || ', ' || @datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ',  ' || f.FALLART_KEY || ',  ' || f.STATUS || ',  ' || b.BA_KEY || '  {' || f.FALL_KEY || '} ',
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and         l.LE_ID = f.LE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc

.head 11 +  If DoImmediate("
select	@substring( '{' || @string( f.FALL_KEY, 0 ) || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE, 0, 254 ),
	l.GESCHL, b.ABT_KEY, '  {' || @string( f.FALL_KEY, 0 ) || '} ', l.TOD_DATUM, l.INFO
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY = f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	f.GELOESCHT = 'N'
and 	b.GELOESCHT = 'N'
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc
into	:s[1], :s[2], :s[3], :s[4], :dt[1], :s[5]
")
.head 12 -  ! Set sFallLabel = s1
.head 12 +  ! old:
.head 13 -  ! 
select 	f.NAME1 || ', ' || f.NAME3 || ', ' || l.GEBURTSNAME || ', ' || gs.GESCHL_ABR || ', ' || @datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ',  ' || f.FALLART_KEY || ',  ' || f.STATUS || ',  ' || b.BA_KEY || '  {' || f.FALL_KEY || '} ',
	l.GESCHL, b.ABT_KEY, '  {' || f.FALL_KEY || '} '
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs
where	b.BETT_KEY= '" || sBettKey || "'
and	b.GRUPPE_KEY = '" || sGrpKey || "'
and	b.STAT_KEY = '" || sStatKey || "'
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and         l.LE_ID = f.LE_ID
and         gs.GESCHL_KEY = l.GESCHL
order by b.bew_zeit desc

.head 8 -  ! AS 06.10.2003: added condition " f.STATUS = 'A' " - only real cases have to be shown !!!
.head 8 -  ! AS 09.01.2004: replaced '@now' by ':dtKHK_RefreshTime'
.head 7 -  Set sAbtKeyOfFall = ''
.head 7 -  Set nBewNr_LockId = Bew_GetFall_InPlaceOnDateX(
		bShowOnlyRealBew, dtKHK_RefreshTime,
		sAbtKeyOfFall, sStatKey, sGrpKey, sBettKey,
		nLE_Id, nFallKeyOnBed, nTypeOfResult, dtBewNr_LockId_Zeit )
.head 7 -  Set sItemText = sBettLabel
.head 7 +  If nBewNr_LockId
.head 8 -  Set sItemText = sItemText || ' - '
.head 8 +  If nFallKeyOnBed
.head 9 -  Call SalStatusSetText( hWndForm, sStatusTextB || ' -> ' || StrX( nFallKeyOnBed ) )
.head 9 +  If bMiniSolution
.head 10 -  Set sItemText = sItemText || '{' || StrX( nFallKeyOnBed ) || '} '
.head 9 +  Else
.head 10 +  If sAbtKeyOfFall = sAbtKey
.head 11 +  If TRUE	! Get FALL data
.head 12 -  Set n[1] = 0
.head 12 -  Set n[2] = 0
.head 12 -  Set s[1] = ""
.head 12 -  Set n[3] = 0
.head 12 -  Set s[2] = ""
.head 12 -  Set s[11] = ""
.head 12 -  Set s[3] = ""
.head 12 -  Set s[4] = ""
.head 12 -  Set s[5] = ""
.head 12 -  Set s[6] = ""
.head 12 -  Set s[7] = ""
.head 12 -  Set s[8] = ""
.head 12 -  Set s[9] = ""
.head 12 -  Set s[10] = ""
.head 12 -  Set s[12] = ""
.head 12 -  Set dt[1] = DATETIME_Null
.head 12 -  Set dt[2] = DATETIME_Null
.head 12 +  ! If Not DoImmediate("
select	a.NAME1, s.STRAIN_KEY,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,
	l.PHENOTYPE, l.INFO,
	a.TELEFAX, l.COLOR, l.batch, f.geburtsname
from	LE l, ADRESSE a, STRAIN_N s, fall f
where	l.LE_ID = " || StrX( nLE_Id ) || "
   and	a.ADRESSE_ID = l.ADRESSE_ID
    and	a.ID_STRAIN = s.ID
    and      f.le_id = l.LE_ID
into	:s[1], :s[2],
	:dt[1], :dt[2],
	:s[4],  :s[5],
	:s[6],:s[8],
	:s[9], :s[10], :s[11], :s[12];

select	st.MUTATION1||' '|| l.GENOTYPE ||','|| st.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| st.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| st.MUTATION4 ||' '||l.GENOTYPE4,
	st.STRAIN_COLOR
from	LE l, ADRESSE a, STRAIN_N st
where	l.LE_ID = " || StrX( nLE_Id ) || "
   and	a.ADRESSE_ID = l.ADRESSE_ID
   and	a.ID_STRAIN=st.ID
into	:s[7], :n[3]
	")
.head 13 -  Return FALSE
.head 12 +  If Not DoImmediate("
select	f.NAME1, s.STRAIN_KEY,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,
	l.PHENOTYPE, l.INFO,
	'', l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR
from	LE l, STRAIN_N s, fall f
where f.einricht_id = " || StrX(nEinrichtId) || "
and f.fall_key = " || StrX(nFallKeyOnBed) || "
    and      f.le_id = l.LE_ID
    and	s.ID = l.id_strain
into	:s[1], :s[2],
	:dt[1], :dt[2],
	:s[4],  :s[5],
	:s[6],:s[8],
	:s[9], :s[10], :s[11], :s[12],
	:s[7], :n[3]
	")
.head 13 -  Return FALSE
.head 12 -  Set sName1 = s[1]
.head 12 -  Set sName3 = s[2]
.head 12 -  Set dtGebDatum = dt[1]
.head 12 -  Set dtTodDatum = dt[2]
.head 12 -  Set sSV_Nr = s[4]
.head 12 -  Set sGeschlKey= s[5]
.head 12 -  Set sPhenoType = s[6]
.head 12 -  Set sGenoType = s[7]
.head 12 -  Set sLE_Info = s[8]
.head 12 -  Set sTelefaxOrigin = s[9]
.head 12 -  Set sColor = s[10]
.head 12 -  Set sBatch = s[11]
.head 12 -  ! Set sGeschlAbr = s[10]
.head 12 -  Set nStrainColor=n[3]
.head 12 -  Set sGeschlAbr = Sex_GetAbr( sGeschlKey )
.head 12 -  Set sForeignID = s[12]
.head 12 -  Call SqlExists( "select * from relship_fall
 where fall_key=:nFallKeyOnBed and plugged is not null ", bPlugged )
.head 12 +  If bPlugged 
.head 13 -  Set sItemText = "* " || sItemText
.head 11 -  !
.head 11 +  ! If bIsAlert
.head 12 -  Set sItemText = sItemText || '!!! '
.head 11 +  If dtTodDatum And dtTodDatum <= dtKHK_RefreshTime
.head 12 -  Set sItemText = sItemText || 'K '
.head 12 -  Set bDeadInCage = TRUE
.head 12 +  If bSelectDead
.head 13 -  Set hTemp = nSelectedHandle
.head 13 -  Set nSelectedHandle = hBett
.head 13 -  Call MultiSelect(  )
.head 13 -  Set nSelectedHandle = hTemp
.head 12 +  Else
.head 13 -  Set nCountDead = nCountDead +1
.head 13 -  Set nFallDeadHandle[nCountDead] = hBett
.head 11 -  Set sItemText = sItemText || '{' || StrX( nFallKeyOnBed ) || '} ' || sForeignID|| ' , ' || sName1 || ', '
.head 11 +  If IsFallHavePlanBew( nFallKeyOnBed )
.head 12 -  Set sItemText = sItemText || ' (PB) ,'
.head 11 -  Set sItemText = sItemText  || sSV_Nr || ' , ' || sName3 || ', ' || sGeschlAbr || ', ' ||
	SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy') || ', ' || sBatch ||', '||sTelefaxOrigin || ', ' || sPhenoType || ',  ' || sGenoType || ',  ' || sColor
.head 11 -  Set sItemText = sItemText || ', HS: ' || StrX( HelStat_Get4Fall( nFallKeyOnBed, dtKHK_RefreshTime ) )
.head 11 +  If sLE_Info
.head 12 -  Set sItemText = sItemText || ' *'
.head 11 -  ! color:
.head 11 +  If nTypeOfResult = 1
.head 12 +  If bColorStrain
.head 13 -  Set nItemColor = nStrainColor
.head 12 +  Else
.head 13 +  If sGeschlKey = 'M'
.head 14 -  Set nItemColor = nColorM
.head 13 +  Else
.head 14 -  Set nItemColor = nColorW
.head 11 +  Else
.head 12 -  Set sItemText = sItemText || ' [' || sPLAN || ']'
.head 12 -  Set nItemColor = COLOR_DarkRed
.head 11 +  If bPlanningMode
.head 12 +  If IsFallInPlanExperiment( nFallKeyOnBed )
.head 13 -  Set sItemText = sItemText || ' (Exp.:' || sPlan_Experiment || ')'
.head 12 +  Else
.head 13 -  Set sItemText = sItemText || ' (Not in Exp.:' || sPlan_Experiment || ')'
.head 13 -  Set nItemColor = COLOR_Gray
.head 11 -  !
.head 11 -  Call KHESetHasFall( hBett, TRUE )
.head 10 +  Else
.head 11 -  Set sItemText = sItemText || sOCCUPIED_BY || ' ' || sAbtKeyOfFall || ' {' || StrX( nFallKeyOnBed ) || '} '
.head 11 -  Set nItemColor = COLOR_DarkGray
.head 9 -  ! Call SqlExists( "
select  leg.ISALERT
from  LST_ERF l, LEISTUNG leg
where  l.FALL_KEY= :nFallKeyOnBed
and 	l.LST_KEY=leg.LST_KEY
and	l.done= 0
and 	l.LST_ERF_VON<:dtKHK_RefreshTime
and 	(l.LST_ERF_BIS>:dtKHK_RefreshTime or l.LST_ERF_BIS is null)
into	:nIsAlert
", bIsAlert )
.head 9 +  !
.head 10 -  ! select	@substring( '{' || @string( f.FALL_KEY, 0 ) || '} ' || f.NAME1 || ', ' || l.SV_NR || ', ' || f.NAME3 || ', ' || gs.GESCHL_ABR || ', ' ||
	@datetochar(f.GEB_DATUM, 'DD.MM.YYYY') || ', ' || a.TELEFAX || ', ' || l.PHENOTYPE || ',  ' || l.GENOTYPE, 0, 254 ),
	l.GESCHL,
	b.ABT_KEY,
	'  {' || @string( f.FALL_KEY, 0 ) || '} ',
	l.TOD_DATUM,
	l.INFO
into	:s[1], :s[2], :s[3], :s[4], :dt[1], :s[5]
.head 9 -  ! Set sItemText = sItemText || ' <- '
.head 9 +  ! If sAbtKeyOfFall = sAbtKey
.head 10 +  If TRUE	! Get FALL data
.head 11 -  Set n[1] = 0
.head 11 -  Set n[2] = 0
.head 11 -  Set s[1] = ""
.head 11 -  Set n[3] = 0
.head 11 -  Set s[2] = ""
.head 11 -  Set s[11] = ""
.head 11 -  Set s[3] = ""
.head 11 -  Set s[4] = ""
.head 11 -  Set s[5] = ""
.head 11 -  Set s[6] = ""
.head 11 -  Set s[7] = ""
.head 11 -  Set s[8] = ""
.head 11 -  Set s[9] = ""
.head 11 -  Set s[10] = ""
.head 11 -  Set dt[1] = DATETIME_Null
.head 11 -  Set dt[2] = DATETIME_Null
.head 11 +  If Not DoImmediate("
select	a.NAME1, a.NAME3,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,
	l.PHENOTYPE, l.INFO,
	a.TELEFAX, l.COLOR, l.batch
from	LE l, ADRESSE a
where	l.LE_ID = " || StrX( nLE_Id ) || "
   and	a.ADRESSE_ID = l.ADRESSE_ID
into	:s[1], :s[2],
	:dt[1], :dt[2],
	:s[4],  :s[5],
	:s[6],:s[8],
	:s[9], :s[10], :s[11];

select	st.MUTATION1||' '|| l.GENOTYPE ||','|| st.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| st.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| st.MUTATION4 ||' '||l.GENOTYPE4,
	st.STRAIN_COLOR
from	LE l, ADRESSE a, STRAIN st
where	l.LE_ID = " || StrX( nLE_Id ) || "
   and	a.ADRESSE_ID = l.ADRESSE_ID
   and	a.NAME3=st.STRAIN_KEY
into	:s[7], :n[3]
	")
.head 12 -  Return FALSE
.head 11 -  Set sName1 = s[1]
.head 11 -  Set sName3 = s[2]
.head 11 -  Set dtGebDatum = dt[1]
.head 11 -  Set dtTodDatum = dt[2]
.head 11 -  Set sSV_Nr = s[4]
.head 11 -  Set sGeschlKey= s[5]
.head 11 -  Set sPhenoType = s[6]
.head 11 -  Set sGenoType = s[7]
.head 11 -  Set sLE_Info = s[8]
.head 11 -  Set sTelefaxOrigin = s[9]
.head 11 -  Set sColor = s[10]
.head 11 -  Set sBatch = s[11]
.head 11 -  ! Set sGeschlAbr = s[10]
.head 11 -  Set nStrainColor=n[3]
.head 11 -  Set sGeschlAbr = Sex_GetAbr( sGeschlKey )
.head 10 -  !
.head 10 +  ! If bIsAlert
.head 11 -  Set sItemText = sItemText || '!!! '
.head 10 +  If dtTodDatum And dtTodDatum <= dtKHK_RefreshTime
.head 11 -  Set sItemText = sItemText || 'T '
.head 11 +  If bSelectDead
.head 12 -  Set bDeadInCage = TRUE
.head 12 -  Set hTemp = nSelectedHandle
.head 12 -  Set nSelectedHandle = hBett
.head 12 -  Call MultiSelect(  )
.head 12 -  Set nSelectedHandle = hTemp
.head 10 -  Set sItemText = sItemText || '{' || StrX( nFallKeyOnBed ) || '} ' || sName1 || ', ' || sSV_Nr || ', ' || sName3 || ', ' || sGeschlAbr || ', ' ||
	SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy') || ', ' || sBatch ||', '||sTelefaxOrigin || ', ' || sPhenoType || ',  ' || sGenoType || ',  ' || sColor
.head 10 -  Set sItemText = sItemText || ', HS: ' || StrX( HelStat_Get4Fall( nFallKeyOnBed, dtKHK_RefreshTime ) )
.head 10 +  If sLE_Info
.head 11 -  Set sItemText = sItemText || ' *'
.head 10 -  ! color:
.head 10 +  If nTypeOfResult = 1
.head 11 +  If bColorStrain
.head 12 -  Set nItemColor = nStrainColor
.head 11 +  Else
.head 12 +  If sGeschlKey = 'M'
.head 13 -  Set nItemColor = nColorM
.head 12 +  Else
.head 13 -  Set nItemColor = nColorW
.head 10 +  Else
.head 11 -  Set sItemText = sItemText || ' [' || sPLAN || ']'
.head 11 -  Set nItemColor = COLOR_DarkRed
.head 10 +  If bPlanningMode
.head 11 +  If IsFallInPlanExperiment( nFallKeyOnBed )
.head 12 -  Set sItemText = sItemText || ' (Exp.:' || sPlan_Experiment || ')'
.head 11 +  Else
.head 12 -  Set sItemText = sItemText || ' (Not in Exp.:' || sPlan_Experiment || ')'
.head 12 -  Set nItemColor = COLOR_Gray
.head 10 +  If IsFallHavePlanBew( nFallKeyOnBed )
.head 11 -  Set sItemText = sItemText || ' (PB) '
.head 10 -  !
.head 10 -  Call KHESetHasFall( hBett, TRUE )
.head 9 +  ! Else
.head 10 -  Set sItemText = sItemText || sOCCUPIED_BY || ' ' || sAbtKeyOfFall || ' {' || StrX( nFallKeyOnBed ) || '} '
.head 10 -  Set nItemColor = COLOR_DarkGray
.head 8 +  Else
.head 9 -  Set sItemText = sItemText || ' [' || sLOCKED || ']'
.head 9 -  Set nItemColor = COLOR_DarkRed
.head 7 +  Else
.head 8 -  Set nItemColor = COLOR_Black
.head 7 -  !
.head 7 -  Call SetItemText( hBett, sItemText )
.head 7 -  Call SetItemColor( hBett, nItemColor )
.head 7 +  ! If nFallKeyOnBed
.head 8 -  Call SetItemFont(hBett, hFontBetts)
.head 7 +  ! Else
.head 8 -  Call SetItemFont(hBett, hFontCommon)
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Call clsExplorerLeft.KHEReAssignPics(hBett)
.head 7 -  Call KHESetPopulated( hBett, TRUE )
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Return TRUE
.head 5 -  !
.head 5 +  Function: ForcedPopulateCurrent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call PopulateAndExpand( nSelectedHandle, TRUE )
.head 7 -  Return TRUE
.head 5 +  Function: PopulateAndExpand
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hNode
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nIndex
.head 7 -  Number: nChild
.head 7 -  Number: hChildren[*]
.head 6 +  Actions
.head 7 -  Set nIndex = GetItemIndex( hNode )
.head 7 +  If not bForceScan or not KHE_IsExpanded(hNode) or (GetLevel( hNode ) = KHEL_Gruppe and bShowPlacesWithContent)
.head 8 -  Set dtTime  = GetTime4Refresh(  )
.head 8 -  Set bForceScan  = TRUE
.head 8 -  ! Set bOk = Collapse( nIndex )
.head 8 +  If not KHE_IsOccupied_ByHandle( hNode, dtTime )
.head 9 +  If Not PopulateItem( hNode, bForceScan )
.head 10 -  Return FALSE
.head 9 +  If Not Expand( nIndex )
.head 10 -  Return FALSE
.head 8 -  Call KHEReAssignPics( hNode )
.head 8 +  If GetLevel( hNode ) = KHEL_Gruppe
.head 9 -  Call SortGroup( hNode )
.head 9 -  Set nChild = EnumChildren (hNode, hChildren)
.head 9 +  If nChild>0 and GetItemIndex( hChildren[0] ) >0
.head 10 -  Call SetItemFont(hNode, hFontCages)
.head 9 +  ! Else
.head 10 -  Call SetItemFont(hNode, hFontCommon)
.head 8 +  If GetLevel( hNode ) = KHEL_Einrichtung
.head 9 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 9 +  ! If not ( hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView ) )
.head 10 -  Call hWndRack2DView.frmKHE2DView._UnpressAllButtons ()
.head 9 +  ! If not ( hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt ) )
.head 10 -  Call hWndRack2DViewVirt.frmKHE2DViewVirt._UnpressAllButtons ()
.head 7 -  Return TRUE
.head 5 +  Function: PopulateSelectedItem
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return PopulateItem( nSelectedHandle, bForceScan )
.head 5 +  Function: PopulateItem
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hForPopulate
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nLevelLoc
.head 7 -  Number: nFallKeyOnBed
.head 6 +  Actions
.head 7 -  Set nLevelLoc = GetLevel( hForPopulate )
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Bett
.head 9 -  Call GetTime4Refresh(  )
.head 9 -  Set bOk = PopulateBett( hForPopulate, "", "", nFallKeyOnBed )
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set bOk = PopulateGruppe( hForPopulate, bForceScan )
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set bOk = PopulateStation( hForPopulate, bForceScan )
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set bOk =  PopulateAbteilung( hForPopulate, bForceScan )
.head 9 -  Break
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set bOk = PopulateEinrichtung( bForceScan )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set bOk = FALSE
.head 9 -  Break
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: OnDoubleClick
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: wParam
.head 7 -  Number: lParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 7 -  Boolean: bDClickShouldDoExpand
.head 7 -  FunctionalVar: oPosition
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oPositionTmp
.head 8 -  Class: cPositionData
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sLabel
.head 7 -  Number: i
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 +  If bShowWithContent
.head 8 -  Set sLabel =  GetItemText( nSelectedHandle )
.head 8 +  If SalStrScan( sLabel, 'Empty Cages in Rack')>0
.head 9 -  Call AddWonNotFallGrup (nSelectedHandle, sAbtKey, sStatKey,sGrpKey)
.head 9 -  Return FALSE
.head 7 +  If bShowPlacesWithContent
.head 8 -  ! Set sLabel =  GetItemText( nSelectedHandle )
.head 8 +  ! If SalStrScan( sLabel, 'In Cage:')>0
.head 9 -  Return FALSE
.head 8 +  If BettIsSummary()
.head 9 -  Return FALSE
.head 7 +  ! If nSelectedLevel = KHEL_Gruppe
.head 8 +  If KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  ) )
.head 9 -  ! Return FALSE
.head 9 -  Set bDClickShouldDoExpand=FALSE
.head 7 +  If nSelectedLevel = KHEL_Bett
.head 8 +  If Not KHE_IsPopulated( nSelectedHandle )
.head 9 -  Call PopulateAndExpand( nSelectedHandle, FALSE )
.head 8 +  If not bOpenOnDblClick
.head 9 -  Call SalSendMsg( hWndItem, AM_OpenFall, 0, 0 )
.head 8 +  Else
.head 9 +  If not KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  ) )
.head 10 -  Call MultiSelect()
.head 7 +  Else
.head 8 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Call _GetPositionID( nSelectedHandle, oPosition )
.head 8 +  If nSelectedLevel = KHEL_Gruppe and CageIsTemp(oPosition.sRack, oPosition.sCage)
.head 9 -  Return FALSE
.head 8 +  If KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  ) )
.head 9 -  Set bDClickShouldDoExpand=FALSE
.head 8 +  Else
.head 9 -  Set bDClickShouldDoExpand = Not KHE_IsExpanded( nSelectedHandle )
.head 8 +  If bOpenTempCage
.head 9 +  If nSelectedLevel = KHEL_Gruppe and not bDClickShouldDoExpand
.head 10 -  Call SalArrayGetUpperBound ( HandleToTemp, 1, nBound )
.head 10 -  Set i=0
.head 10 +  While i <= nBound
.head 11 +  If HandleToTemp[i,0]= nSelectedHandle
.head 12 +  If not CloseCageTemp (nSelectedHandle, GetTime4Refresh(  ))
.head 13 -  Return FALSE
.head 12 -  Break
.head 11 -  Set i=i+1
.head 8 -  Call SalSendClassMessage(SAM_DoubleClick, wParam, lParam)
.head 8 +  If bDClickShouldDoExpand
.head 9 -  Call PopulateAndExpand( nSelectedHandle, FALSE )
.head 9 +  ! If nSelectedLevel = KHEL_Station
.head 10 -  Call Rack2DView_OnRackCollapsed( )
.head 8 +  Else
.head 9 -  Call Refresh_HandleToPlace ()
.head 9 +  If oPosition != OBJ_Null
.head 10 +  If oPosition.nCageID = 0
.head 11 -  Call PrintCardsOnClose( oPosition.nScreenID, oPosition.nRackID )
.head 9 +  If hWnd_POC
.head 10 +  If VisWinIsWindow ( hWnd_POC )
.head 11 -  ! Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 11 -  Call _GetPositionID( nSelectedHandle, oPositionTmp )
.head 11 +  If oPositionTmp != OBJ_Null
.head 12 -  Call frmPOC.CloseCageFromKHE( oPositionTmp.sScreen, oPositionTmp.sRack, oPositionTmp.sCage )
.head 11 -  ! Call frmPOC.CloseCageFromKHE( sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Call KHE_DeleteDescendents (nSelectedHandle)
.head 9 -  Call KHESetPopulated( nSelectedHandle, FALSE )
.head 9 -  ! Call SetItemFont(nSelectedHandle, hFontCommon)
.head 9 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 9 +  ! If not ( hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt ) )  and nSelectedLevel != KHEL_Gruppe
.head 10 -  Call hWndRack2DViewVirt.frmKHE2DViewVirt._UnpressAllButtons ()
.head 9 +  ! If not ( hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView ) )  and nSelectedLevel != KHEL_Gruppe
.head 10 -  Call hWndRack2DView.frmKHE2DView._UnpressAllButtons ()
.head 9 +  If hWndRack2DView and VisWinIsWindow(hWndRack2DView) and (nSelectedLevel < KHEL_Gruppe)
.head 10 -  Call SalSendMsg(hWndRack2DView, AM_CloseAllCages, 0, 0)
.head 10 -  Call SalHideWindow(hWndRack2DView)
.head 9 +  If hWndRack2DViewVirt and VisWinIsWindow(hWndRack2DViewVirt) and (nSelectedLevel < KHEL_Gruppe)
.head 10 -  Call SalSendMsg(hWndRack2DViewVirt, AM_CloseAllCages, 0, 0)
.head 10 -  Call SalHideWindow(hWndRack2DViewVirt)
.head 9 -  ! !!!!!
.head 9 +  If nSelectedLevel = KHEL_Gruppe and bShowOnlyOpenCages
.head 10 -  Call Rack2DView_SetButtonState( nSelectedHandle )
.head 10 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 10 -  ! Call CloseGruppe (sAbtKey, sStatKey, sGrpKey)
.head 10 -  Call CloseGruppe (oPosition.sScreen, oPosition.sRack, oPosition.sCage)
.head 10 -  ! Call DeleteGruppeFromStation (nSelectedHandle)
.head 10 -  ! Set nIndex = GetItemIndex( nSelectedHandle )
.head 10 -  ! Call SalListDelete( hWndItem, nIndex )
.head 10 -  ! Call DeleteChild(nSelectedHandle)
.head 9 +  If nSelectedLevel = KHEL_Gruppe and bShowWithContent
.head 10 -  ! Call Rack2DView_SetButtonState( nSelectedHandle )
.head 10 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 10 -  ! Call CloseGruppe (sAbtKey, sStatKey, sGrpKey)
.head 10 -  Call CloseGruppe (oPosition.sScreen, oPosition.sRack, oPosition.sCage)
.head 9 +  Else
.head 10 -  Set dtTime  = GetTime4Refresh(  )
.head 10 -  Call KHEReAssignPics( nSelectedHandle )
.head 8 -  Call Rack2DView_SetButtonState( nSelectedHandle )
.head 5 -  !
.head 5 -  ! -- Expand/Collapse levels functions
.head 5 +  Function: PopulateAndExpandChildren
.head 6 -  Description: Recursive function
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hParent
.head 7 -  Number: nOffsetLevel
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildren
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nIndex
.head 7 -  Number: hChild
.head 7 -  Number: nSelectedLevel
.head 6 +  Actions
.head 7 +  If nOffsetLevel <= 0
.head 8 -  Return 0
.head 7 -  Set nChildren =  EnumChildren( hParent, hChildren )
.head 7 -  Set nIndex = 0
.head 7 +  While nIndex < nChildren
.head 8 -  Set hChild = hChildren[ nIndex ]
.head 8 -  Call PopulateAndExpand( hChild, bForceScan )
.head 8 +  If nOffsetLevel > 1
.head 9 +  If KHE_HasChild( hChild )
.head 10 -  Call PopulateAndExpandChildren( hChild, nOffsetLevel - 1, bForceScan )
.head 8 -  Set nIndex = nIndex + 1
.head 7 -  Return nChildren
.head 5 +  Function: ExpandToLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nDestinationLevel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hNode
.head 7 -  Number: nNodeLevel
.head 7 -  Number: nAdditionalyExpandLevels
.head 6 +  Actions
.head 7 -  Set hNode  = GetItemHandle( SalListQuerySelection( hWndItem ) )
.head 7 -  Set nNodeLevel = GetLevel( hNode )
.head 7 +  Select Case nNodeLevel
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set nAdditionalyExpandLevels = nDestinationLevel
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set nAdditionalyExpandLevels = nDestinationLevel - 1
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set nAdditionalyExpandLevels = nDestinationLevel - 2
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set nAdditionalyExpandLevels = nDestinationLevel - 3
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set nAdditionalyExpandLevels = nDestinationLevel - 4
.head 9 -  Break
.head 7 -  !
.head 7 -  Call Collapse( hNode )
.head 7 +  If nDestinationLevel >= 0
.head 8 -  Call PopulateAndExpand( hNode, FALSE )
.head 8 +  If nDestinationLevel > 0
.head 9 -  Call PopulateAndExpandChildren( hNode, nAdditionalyExpandLevels, FALSE )
.head 7 -  Return TRUE
.head 5 +  Function: CollapseRoot
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 9 -  Call frmPOC.CloseCageFromKHE( sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp )
.head 7 +  If not ( hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView ) )  
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_CloseAllCages,0 ,0)
.head 8 +  If SalIsWindowVisible( hWndRack2DView )
.head 9 -  Call SalHideWindow( hWndRack2DView )
.head 7 +  If not ( hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt ) )
.head 8 -  Call SalSendMsg(hWndRack2DViewVirt, AM_CloseAllCages,0 ,0)
.head 8 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 9 -  Call SalHideWindow( hWndRack2DViewVirt )
.head 7 -  ! !! 
.head 7 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalHideWindow( hWndRack2DView )
.head 7 +  ! If SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Call SalHideWindow( hWndRack2DViewVirt )
.head 7 -  Call KHE_DeleteDescendents( hRoot )
.head 7 -  Call ShowOutline( 0 )
.head 7 -  Call SalListSetSelect(hWndItem,0)
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Call KHEReAssignPics(hRoot)
.head 7 -  Set nSelectedItem  = KHEL_Abteilung
.head 7 -  Set nSelectedHandle = hRoot
.head 7 -  Set nSelectedLevel  = KHEL_Einrichtung
.head 7 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )
.head 7 -  Return TRUE
.head 5 +  Function: ExpandAbtLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nAbt
.head 7 -  Number: hAbt[*]
.head 6 +  Actions
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 9 -  Call frmPOC.CloseCageFromKHE( sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp )
.head 7 +  If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalHideWindow( hWndRack2DView )
.head 7 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Call SalHideWindow( hWndRack2DViewVirt )
.head 7 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 7 +  ! If not ( hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView ) )
.head 8 -  Call hWndRack2DView.frmKHE2DView._UnpressAllButtons () 
.head 7 +  ! If not ( hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt ) )
.head 8 -  Call hWndRack2DViewVirt.frmKHE2DViewVirt._UnpressAllButtons () 
.head 7 -  ! !!!!!
.head 7 +  If bShowOnlyOpenCages
.head 8 -  Set i=0
.head 8 -  Set nAbt = EnumChildren( hRoot, hAbt)
.head 8 +  While i<nAbt
.head 9 -  ! Call DeleteChild(hAbt[i])
.head 9 -  Call KHE_DeleteDescendents( hAbt[i] )
.head 9 -  Set i=i+1
.head 7 -  Call ShowOutline( 1 )
.head 7 -  Call SalListSetSelect( hWndItem, 0 )
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Call KHEReAssignPics( hRoot )
.head 7 -  Set nSelectedItem  = KHEL_Abteilung
.head 7 -  Set nSelectedHandle = hRoot
.head 7 -  Set nSelectedLevel  = KHEL_Abteilung
.head 7 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 7 -  Return TRUE
.head 5 +  Function: ExpandStatLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 9 -  Call frmPOC.CloseCageFromKHE( sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp )
.head 7 -  Return ExpandToLevel( 1 )
.head 5 +  Function: ExpandGrpLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 9 -  Call frmPOC.CloseCageFromKHE( sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp )
.head 7 -  Return ExpandToLevel( 2 )
.head 5 +  Function: ExpandBettLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return ExpandToLevel( 3 )
.head 5 +  Function: CollapseNode
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hNode
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 -  Set nIndex = GetItemIndex( hNode )
.head 7 +  If Not Collapse( nIndex )
.head 8 -  Return FALSE
.head 7 +  If Not bShowOnlyOpenCages
.head 8 -  Set dtTime  = GetTime4Refresh(  )
.head 8 -  Call KHEReAssignPics( hNode )
.head 7 -  Return TRUE
.head 5 -  !
.head 5 +  Function: SortGroup
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hGruppe
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCount
.head 7 -  Number: hBeds[*]
.head 7 -  Number: nLastIndexWithFall
.head 7 -  Number: nCountStart
.head 6 +  Actions
.head 7 +  If Not bBreedingIsON
.head 8 -  Return TRUE
.head 7 -  !
.head 7 +  If Not KHE_IsExpanded( hGruppe )
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  Set nCount = EnumChildren( hGruppe, hBeds )
.head 7 -  Set nCountStart=nCount
.head 7 +  While nCount
.head 8 -  Set nCount = nCount - 1
.head 8 +  If GetFallKey_ByHandle( hBeds[nCount] ) and SalStrScan( GetItemText( hBeds[nCount] ), ", F," ) > 0
.head 9 +  If not nLastIndexWithFall
.head 10 -  Set nLastIndexWithFall = nCount
.head 8 +  Else
.head 9 +  If nLastIndexWithFall
.head 10 +  If MoveItem( hBeds[nCount], nLastIndexWithFall - nCount  )
.head 11 -  Set nLastIndexWithFall = nLastIndexWithFall - 1
.head 7 -  Set nCount = nCountStart
.head 7 +  While nCount
.head 8 -  Set nCount = nCount - 1
.head 8 +  If GetFallKey_ByHandle( hBeds[nCount] )
.head 9 +  If not nLastIndexWithFall
.head 10 -  Set nLastIndexWithFall = nCount
.head 8 +  Else
.head 9 +  If nLastIndexWithFall
.head 10 +  If MoveItem( hBeds[nCount], nLastIndexWithFall - nCount  )
.head 11 -  Set nLastIndexWithFall = nLastIndexWithFall - 1
.head 7 -  Return TRUE
.head 5 +  Function: MoveItem
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpItem
.head 7 -  Number: nMoveBy
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  While nMoveBy >0
.head 8 +  If not MoveDown( GetItemIndex( hpItem ) )
.head 9 -  Return FALSE
.head 8 -  Set nMoveBy = nMoveBy - 1
.head 7 -  Return TRUE
.head 5 -  !
.head 5 -  ! -- Cut&Paste, Drag&Drop
.head 5 +  Function: Move_CanCut
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTypeOfBAR
.head 7 -  !
.head 7 -  Number: nHandles[*]
.head 7 -  Number: nHandleCount
.head 7 -  Number: nFallKeys[*]
.head 7 -  ! Boolean: bAnyExp
.head 7 -  ! Boolean: bAnyNotExp
.head 6 +  Actions
.head 7 +  ! If Not SalArrayIsEmpty(HandleToPlace) and KHEL_Gruppe = nSelectedLevel
.head 8 -  Return FALSE
.head 7 -  ! Else
.head 7 +  If not KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  )) 
.head 8 +  Select Case nSelectedLevel
.head 9 +  Case KHEL_Gruppe
.head 10 -  Call GetFallsInGruppe( nSelectedHandle, nFallKeys )
.head 10 +  If SalArrayIsEmpty ( nFallKeys )
.head 11 -  Return FALSE
.head 10 -  Return TRUE
.head 9 +  Case KHEL_Bett
.head 10 +  If bCurrentBettHasFall and bCurrentBettLegalAbteilung
.head 11 +  If bPlanningMode and not HasHandlePlanExpFall( nSelectedHandle )
.head 12 -  Return FALSE
.head 11 +  If bPlanningMode and bMatingMode
.head 12 +  If SalStrScan( GetItemText( nSelectedHandle ), ", M," ) >= 0 and bMaleIsExist  
.head 13 -  Return FALSE
.head 11 -  Set nTypeOfBAR = GetTypeOfMove_ByHandle( nSelectedHandle )
.head 11 +  If ( nTypeOfBAR = nTYPE_PLAN) And Not bPlanningMode
.head 12 -  Return FALSE
.head 11 +  If nTypeOfBAR = nTYPE_LOCK
.head 12 -  Return FALSE
.head 11 -  Return TRUE
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 7 -  Return FALSE
.head 5 +  Function: Move_CanCutRack
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Sql Handle: hSqlCages
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  ! If Not SalArrayIsEmpty(HandleToPlace) and KHEL_Gruppe = nSelectedLevel
.head 8 -  Return FALSE
.head 7 -  ! Else
.head 7 +  If nSelectedLevel = KHEL_Station
.head 8 -  Call GetPosition( nSelectedHandle, sScreen, sRack, sCage, sBett )
.head 8 +  If GalConnect( hSqlCages )
.head 9 +  If SqlPrepareAndExecute( hSqlCages, "Select gruppe_key from gruppe where stat_key=:sRack and einricht_id=:nEinrichtId into :sCage  " )
.head 10 -  Set bOk = FALSE
.head 10 +  While not bOk and SqlFetchNext( hSqlCages, nFetch )
.head 11 +  If not KHE_IsOccupied( sScreen, sRack, sCage, "", GetTime4Refresh(  ) )
.head 12 +  If CageIsEmpty( sRack, sCage, GetTime4Refresh(  ), TRUE )
.head 13 -  Set bOk = TRUE
.head 9 -  Call SqlDisconnect( hSqlCages )
.head 9 -  Return bOk
.head 8 +  Else
.head 9 -  Return FALSE
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 +  Function: Move_CanGroupRelease
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTypeOfBAR
.head 7 -  !
.head 7 -  Number: nHandles[*]
.head 7 -  Number: nHandleCount
.head 7 -  Number: nFallKeys[*]
.head 7 -  ! Boolean: bAnyExp
.head 7 -  ! Boolean: bAnyNotExp
.head 6 +  Actions
.head 7 +  If not KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  )) 
.head 8 +  Select Case nSelectedLevel
.head 9 +  Case KHEL_Gruppe
.head 10 -  Call GetFallsInGruppe( nSelectedHandle, nFallKeys )
.head 10 +  If SalArrayIsEmpty ( nFallKeys )
.head 11 -  Return FALSE
.head 10 -  Return TRUE
.head 9 +  Case KHEL_Bett
.head 10 +  If bCurrentBettHasFall and bCurrentBettLegalAbteilung
.head 11 +  If bPlanningMode and not HasHandlePlanExpFall( nSelectedHandle )
.head 12 -  Return FALSE
.head 11 +  If bPlanningMode and bMatingMode
.head 12 +  If SalStrScan( GetItemText( nSelectedHandle ), ", M," ) >= 0 and bMaleIsExist  
.head 13 -  Return FALSE
.head 11 -  Set nTypeOfBAR = GetTypeOfMove_ByHandle( nSelectedHandle )
.head 11 +  If ( nTypeOfBAR = nTYPE_PLAN) And Not bPlanningMode
.head 12 -  Return FALSE
.head 11 +  If nTypeOfBAR = nTYPE_LOCK
.head 12 -  Return FALSE
.head 11 -  Return TRUE
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 7 -  Return FALSE
.head 5 +  Function: Move_CutCurrent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nHandles[*]
.head 7 -  Number: nHandlesIR[*]
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: hBet[*]
.head 7 -  ! Number: nBound
.head 7 -  Number: nFall
.head 7 -  Number: nBet
.head 7 -  Number: q
.head 7 -  Boolean: bSelect
.head 7 -  Boolean: bNotSelect
.head 7 -  Date/Time: dtDate
.head 6 +  Actions
.head 7 +  Select Case nSelectedLevel
.head 8 +  Case KHEL_Bett
.head 9 -  ! Call UnSelect()
.head 9 -  Call MultiSelect()
.head 9 -  ! Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 9 +  ! If nBound=1
.head 10 +  If bCurrentBettHasFall and bCurrentBettLegalAbteilung
.head 11 -  Set hMove_Source = nSelectedHandle
.head 11 -  Set bMove_SingleBett = TRUE
.head 11 -  Set bMove_HasInClipboard = TRUE
.head 9 +  ! Else
.head 10 -  Set hMove_Source = 0
.head 10 -  Set bMove_SingleBett = FALSE
.head 10 -  Set bMove_HasInClipboard = FALSE
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 +  If not KHE_IsExpanded(nSelectedHandle)
.head 10 -  Call PopulateAndExpand( nSelectedHandle, FALSE )
.head 9 -  Set dtDate = GetTime4Refresh(  )
.head 9 +  If bMenuCutFallNrX = TRUE
.head 10 +  If bInternalRequestMode
.head 11 -  ! If 0<GetBedsWhereFallsAreBookX( nSelectedHandle, nHandlesIR, TRUE, TRUE, TRUE ) 
.head 11 -  Set hMove_Source = nSelectedHandle
.head 11 -  Set bMove_SingleBett = FALSE
.head 11 -  Set bMove_HasInClipboard = TRUE
.head 11 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 11 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 11 -  Set i=0
.head 11 -  ! Set q=0
.head 11 +  While i<nBet
.head 12 -  Set k=0
.head 12 +  While k<=nBound
.head 13 +  If HandleToPlace[k, 1]=hBet[i]
.head 14 -  Set bSelect=TRUE
.head 14 -  Set hBet[i]= -1
.head 14 -  ! Set q=q+1
.head 14 -  Break
.head 13 -  Set k=k+1
.head 12 -  Set i=i+1
.head 11 +  If bSelect
.head 12 -  Set i=0
.head 12 +  While i<=nBet
.head 13 +  If hBet[i] >0
.head 14 -  Set nFall = GetFallKey_ByHandle (hBet[i])
.head 14 +  If nFall>0 and not KHE_IsOccupied_ByHandle( hBet[i], dtDate )
.head 15 -  Set nBound=nBound+1
.head 15 -  Set HandleToPlace[nBound, 0]=nFall
.head 15 -  Set HandleToPlace[nBound, 1]=hBet[i]
.head 15 -  Call clsExplorerLeft.KHEReAssignPics(hBet[i])
.head 15 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 15 -  Set bNotSelect = TRUE
.head 13 -  Set i=i+1
.head 11 +  If (bSelect and not bNotSelect) or not bSelect
.head 12 -  Call MultiSelectInCage()
.head 11 -  ! Break
.head 11 +  ! Else
.head 12 -  Call SalMessageBox( GetMessageFromSection( "KHE", 33, "No Cases to cut" ), GetMessageX( 201, "Warning" ), 0 )
.head 11 -  Break
.head 10 +  Else
.head 11 -  Call SalModalDialog(dlgFallNumber2Cut, hWndNULL, nSelectedHandle, nHandles, TRUE, TRUE, TRUE, nFallsQuantity, sFallSex)
.head 11 +  If 0 < EnumChildren( nSelectedHandle, nHandles )
.head 12 -  Set hMove_Source = nSelectedHandle
.head 12 -  Set bMove_SingleBett = FALSE
.head 12 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 12 -  Set bMove_HasInClipboard = TRUE
.head 12 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 12 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 12 -  Set i=0
.head 12 -  ! Set q=0
.head 12 +  While i<nBet
.head 13 -  Set k=0
.head 13 +  While k<=nBound
.head 14 +  If HandleToPlace[k, 1]=hBet[i]
.head 15 -  Set bSelect=TRUE
.head 15 -  Set hBet[i]= -1
.head 15 -  ! Set q=q+1
.head 15 -  Break
.head 14 -  Set k=k+1
.head 13 -  Set i=i+1
.head 12 +  If bSelect
.head 13 -  Set i=0
.head 13 +  While i<=nBet
.head 14 +  If hBet[i] >0
.head 15 -  Set nFall = GetFallKey_ByHandle (hBet[i])
.head 15 +  If nFall>0 and not KHE_IsOccupied_ByHandle( hBet[i], dtDate )
.head 16 -  Set nBound=nBound+1
.head 16 -  Set HandleToPlace[nBound, 0]=nFall
.head 16 -  Set HandleToPlace[nBound, 1]=hBet[i]
.head 16 -  Call clsExplorerLeft.KHEReAssignPics(hBet[i])
.head 16 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 16 -  Set bNotSelect = TRUE
.head 14 -  Set i=i+1
.head 12 +  If (bSelect and not bNotSelect) or not bSelect
.head 13 -  Call MultiSelectInCage()
.head 11 +  Else
.head 12 -  Call SalMessageBox( GetMessageFromSection( "KHE", 33, "No Cases to cut" ), GetMessageX( 201, "Warning" ), 0 )
.head 11 -  Break
.head 9 +  Else
.head 10 +  If bInternalRequestMode
.head 11 -  ! If GetBedsWhereFallsAreBookX( nSelectedHandle, nHandlesIR, TRUE, TRUE, TRUE ) = GetBedsWhereFallsAreX( nSelectedHandle, nHandles, TRUE, TRUE, TRUE )
.head 11 -  Set hMove_Source = nSelectedHandle
.head 11 -  Set bMove_SingleBett = FALSE
.head 11 -  Set bMove_HasInClipboard = TRUE
.head 11 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 11 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 11 -  Set i=0
.head 11 -  ! Set q=0
.head 11 +  While i<nBet
.head 12 -  Set k=0
.head 12 +  While k<=nBound
.head 13 +  If HandleToPlace[k, 1]=hBet[i]
.head 14 -  Set bSelect=TRUE
.head 14 -  Set hBet[i]= -1
.head 14 -  ! Set q=q+1
.head 14 -  Break
.head 13 -  Set k=k+1
.head 12 -  Set i=i+1
.head 11 +  If bSelect
.head 12 -  Set i=0
.head 12 +  While i<=nBet
.head 13 +  If hBet[i] >0
.head 14 -  Set nFall = GetFallKey_ByHandle (hBet[i])
.head 14 +  If nFall>0 and not KHE_IsOccupied_ByHandle( hBet[i], dtDate )
.head 15 -  Set nBound=nBound+1
.head 15 -  Set HandleToPlace[nBound, 0]=nFall
.head 15 -  Set HandleToPlace[nBound, 1]=hBet[i]
.head 15 -  Call clsExplorerLeft.KHEReAssignPics(hBet[i])
.head 15 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 15 -  Set bNotSelect = TRUE
.head 13 -  Set i=i+1
.head 11 +  If (bSelect and not bNotSelect) or not bSelect
.head 12 -  Call MultiSelectInCage()
.head 11 -  Break
.head 11 +  ! Else
.head 12 +  If IDYES=SalMessageBox( "There is not booked  cases.
Do you want to stop Internal Request Mode?" , "Warning" , MB_YesNo)
.head 13 -  Set hMove_Source = nSelectedHandle
.head 13 -  Set bMove_SingleBett = FALSE
.head 13 -  Set bMove_HasInClipboard = FALSE
.head 13 -  Set bInternalRequestMode = FALSE
.head 13 +  If SalIsWindowVisible( hWnd_IRServices )
.head 14 -  Call SalSendMsg(hWnd_IRServices,SAM_Close,0,0)
.head 13 -  Break 
.head 12 +  Else 
.head 13 -  Break 
.head 10 +  Else
.head 11 -  Set hMove_Source = nSelectedHandle
.head 11 -  ! Set bMove_SingleBett = FALSE
.head 11 -  ! Set bMove_HasInClipboard = TRUE
.head 11 -  ! Call UnSelect()
.head 11 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 11 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 11 -  Set i=0
.head 11 -  ! Set q=0
.head 11 +  While i<nBet
.head 12 -  Set k=0
.head 12 +  While k<=nBound
.head 13 +  If HandleToPlace[k, 1]=hBet[i]
.head 14 -  Set bSelect=TRUE
.head 14 -  Set hBet[i]= -1
.head 14 -  ! Set q=q+1
.head 14 -  Break
.head 13 -  Set k=k+1
.head 12 -  Set i=i+1
.head 11 +  If bSelect
.head 12 -  Set i=0
.head 12 +  While i<=nBet
.head 13 +  If hBet[i] >0
.head 14 -  Set nFall = GetFallKey_ByHandle (hBet[i])
.head 14 +  If nFall>0 and not KHE_IsOccupied_ByHandle( hBet[i], dtDate )
.head 15 -  Set nBound=nBound+1
.head 15 -  Set HandleToPlace[nBound, 0]=nFall
.head 15 -  Set HandleToPlace[nBound, 1]=hBet[i]
.head 15 -  Call clsExplorerLeft.KHEReAssignPics(hBet[i])
.head 15 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 15 -  Set bNotSelect = TRUE
.head 13 -  Set i=i+1
.head 11 +  If (bSelect and not bNotSelect) or not bSelect
.head 12 -  Call MultiSelectInCage()
.head 10 -  Break
.head 8 +  Default
.head 9 -  Set hMove_Source = 0
.head 9 -  Set bMove_HasInClipboard = FALSE
.head 9 -  Break
.head 7 -  Return bMove_HasInClipboard
.head 5 +  Function: Move_CanPaste
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  String: sAbtKeyTmp
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  Number: hBetts[*]
.head 7 -  Number: nBetts
.head 7 -  Number: nBound
.head 7 -  Boolean: bBettIsSummary
.head 7 -  Number: nBettIsSummaryNotFall
.head 6 +  Actions
.head 7 -  Set bOk = FALSE
.head 7 -  Set bBettIsSummary = BettIsSummary()
.head 7 +  If KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  ))
.head 8 -  Return bOk
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  If HandleToPlace[0,1] <=  0 and nBound > 0
.head 8 -  Call DelNul()
.head 8 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  If HandleToPlace[0,1] <=  0 and nBound = 0
.head 8 -  Return FALSE
.head 7 -  Set nBound = nBound + 1
.head 7 +  If (Not GetIsRackVirtual_ByHandle (nSelectedHandle) or bPlanningMode)
.head 8 +  If (not bCurrentBettHasFall or KHE_IsFallInRolingMatings(nFallKey_OnCurrentBett))  and (bMove_HasInClipboard  or  nBound >0 or HandleToPlace[0,1] > 0  )
.head 9 -  !
.head 9 +  If (nSelectedLevel = KHEL_Gruppe and  nBound<=QuantityOfEmptyBett(nSelectedHandle))
.head 10 -  Set bOk = (EnumChildren(hMove_Source, hBetts)>0) or bMove_SingleBett or (Not SalArrayIsEmpty(HandleToPlace))
.head 9 +  Else If (nSelectedLevel = KHEL_Bett) and bMove_SingleBett and not bBettIsSummary
.head 10 -  Set bOk = GetFallKey_ByHandle(hMove_Source)
.head 9 +  Else If (nSelectedLevel = KHEL_Bett) and nBound=0 and HandleToPlace[0,1] > 0 
.head 10 -  Set bOk = GetFallKey_ByHandle(HandleToPlace[0,1])
.head 9 +  Else If (nSelectedLevel = KHEL_Bett)  and bBettIsSummary
.head 10 -  Set nBettIsSummaryNotFall = QuantityOfEmptyBett(nSelectedHandle)
.head 10 +  If nBound <=  nBettIsSummaryNotFall 
.head 11 -  Set bOk = TRUE
.head 9 +  Else If (nSelectedLevel = KHEL_Station) and bMiniSolution and (nBound >0 or HandleToPlace[0,1] > 0) 
.head 10 -  Set bOk = TRUE
.head 7 -  Return bOk
.head 5 +  Function: Paste 		! - 15.12.2006 TO:
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bWithInternalRequest
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKey
.head 7 -  Number: anFallKeys[*]
.head 7 -  Number: nCount
.head 7 -  Number: nCounter
.head 7 -  Number: hBeds[ * ]
.head 7 -  String: sFallList
.head 7 -  String: sLicense
.head 7 -  String: sLicenseRecord
.head 7 -  String: sLicenseTmp
.head 7 -  String: sLicenseRecordTmp
.head 7 -  Boolean: bDifferentLicenses
.head 7 -  String: sExistingOrders
.head 7 -  String: sCasesWithIR
.head 7 -  String: sStrain
.head 7 -  String: sSex
.head 7 -  Boolean: bOk
.head 7 -  Number: nAnimalsLeftOrder
.head 7 -  Number: nRow
.head 7 -  Number: nAnimalsLeftPos
.head 7 -  String: sAbtKeyDes
.head 7 -  String: sStatKeyDes
.head 7 -  String: sGrpKeyDes
.head 7 -  String: sBettKey
.head 7 -  String: sAbtKeySou
.head 7 -  String: sStatKeySou
.head 7 -  String: sGrpKeySou
.head 7 -  Date/Time: dtDate
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  String: sIn
.head 7 -  Number: hSaveHandele
.head 7 -  Number: nCadavers
.head 7 -  String: sRFID
.head 7 -  Boolean: bToRFID
.head 7 -  Number: nHandeleGrpDes
.head 7 -  Number: nHandeleGrpTemp
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 +  If bInternalRequestMode
.head 8 +  If bPlanningMode
.head 9 -  Call SalMessageBox( "This action is not supported in planning mode !", GetMessageX( 205, "Attention !" ), MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 +  If Not bMove_HasInClipboard
.head 9 -  Return FALSE
.head 8 -  Set sFallList = ''
.head 8 +  If bMove_SingleBett
.head 9 -  Set nFallKey = GetFallKey_ByHandle( hMove_Source )
.head 9 +  If nFallKey
.head 10 -  Set sFallList = StrX( nFallKey )
.head 10 -  Set nCount = 1
.head 8 +  Else
.head 9 -  Set nCount = EnumChildren( hMove_Source, hBeds )
.head 9 +  If nCount = 0
.head 10 -  Return FALSE
.head 9 -  Set nCounter = 0
.head 9 +  While nCounter < nCount
.head 10 -  Set nFallKey = GetFallKey_ByHandle( hBeds[nCounter] )
.head 10 +  If nFallKey
.head 11 +  If sFallList
.head 12 -  Set sFallList = sFallList || ','
.head 11 -  Set sFallList = sFallList || StrX( nFallKey )
.head 11 -  ! we also need an array of cases
.head 11 -  Set anFallKeys[nCounter] = nFallKey
.head 10 -  Set nCounter = nCounter + 1
.head 8 +  If Not sFallList
.head 9 -  Return FALSE
.head 8 -  ! check that strain is the same
.head 8 +  If Not SelectToCSV( "
select	distinct s.STRAIN_KEY
from	FALL f, STRAIN_N s
where	f.EINRICHT_ID = :nEinrichtId
   and	f.FALL_KEY in ( " || sFallList || ")
   and	f.ID_STRAIN = s.ID
", sStrain )
.head 9 -  Return FALSE
.head 8 +  If SalStrScan( sStrain, ',' ) >= 0
.head 9 -  Call SalMessageBox( "There are animals with different strain in the cage !
Strains found: " || sStrain || ".
The strain must be the same to perform the movement.", "Error!", MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 -  ! check that the sex is the same
.head 8 +  If Not SelectToCSV( "
select	distinct GESCHL
from	FALL
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY in ( " || sFallList || ")
", sSex )
.head 9 -  Return FALSE
.head 8 +  If SalStrScan( sSex, ',' ) >= 0
.head 9 -  Call SalMessageBox( "There are animals with different sex in the cage !
The sex must be the same to perform the movement.", "Error!", MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 -  ! check license
.head 8 -  Set bDifferentLicenses = FALSE
.head 8 -  Set nCounter = 0
.head 8 +  While nCounter < nCount
.head 9 +  If Not License_CheckCase( anFallKeys[nCounter], sLicenseTmp, sLicenseRecordTmp )
.head 10 -  Return FALSE
.head 9 +  If sLicenseTmp And sLicenseRecordTmp
.head 10 +  If sLicense And sLicenseRecordTmp
.head 11 +  If sLicenseTmp != sLicense Or ( sLicenseTmp = sLicense And sLicenseRecordTmp != sLicenseRecord )
.head 12 -  Set bDifferentLicenses = TRUE
.head 12 -  Break
.head 10 +  Else
.head 11 -  Set sLicense = sLicenseTmp
.head 11 -  Set sLicenseRecord = sLicenseRecordTmp
.head 9 -  Set nCounter = nCounter + 1
.head 8 +  If bDifferentLicenses
.head 9 -  Call SalMessageBox( "Several cases belong to different license records.
License (License Record) found: " || sLicense || " (" || sLicenseRecord || "), " || sLicenseTmp || " (" || sLicenseRecordTmp || ")
Exclude these animals to perform the movement.", "Error!", MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 -  ! select existing orders
.head 8 +  If Not SelectToCSV( "
select	distinct INT_ORDER_ID
from	BEWEGUNG
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY in ( " || sFallList || ")
   and	INT_ORDER_ID is not NULL
", sExistingOrders )
.head 9 -  Return FALSE
.head 8 +  ! If Not IR_RequestPosition( sStrain, sSex, 0, 0, sLicense, sLicenseRecord, sExistingOrders, nInternalRequestOrderId, nInternalRequestOrderPosNr )
.head 9 -  Return FALSE
.head 8 +  If Not nInternalRequestOrderId Or Not nInternalRequestOrderPosNr
.head 9 -  Return FALSE
.head 8 -  ! check that the cases are not assigned to the IR already
.head 8 +  If Not SelectToCSV( "
select	FALL_KEY
from	FALL f
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY in ( " || sFallList || " )
   and	exists (
	select	1
	from	BEWEGUNG b
	where	f.EINRICHT_ID = b.EINRICHT_ID
	   and	f.FALL_KEY = b.FALL_KEY
	   and	b.INT_ORDER_ID = " || StrX( nInternalRequestOrderId ) || " )
", sCasesWithIR )
.head 9 -  Return FALSE
.head 8 +  If sCasesWithIR != ''
.head 9 -  Call SalMessageBox( "For some animals there are already movements with this internal request!
Animals found: " || sCasesWithIR || ".
Exclude these animals to perform the movement.", "Error!", MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 -  ! check number of animals
.head 8 -  Set nAnimalsLeftOrder = IR_CheckTotalNumberOfCases( nInternalRequestOrderId, nCount )
.head 8 +  If nAnimalsLeftOrder < 0
.head 9 -  Set nAnimalsLeftOrder = 0
.head 9 -  Call SalMessageBox( "It is not possible to add " || StrX( nCount ) || " animals to the order. 
Only " || StrX( nAnimalsLeftOrder ) || " can be added.", "Error!", MB_IconStop )
.head 9 -  Return FALSE
.head 8 -  Set nAnimalsLeftPos = IR_CheckNumberOfCases( nInternalRequestOrderId, nInternalRequestOrderPosNr, nCount )
.head 8 +  If nAnimalsLeftPos < 0
.head 9 -  Set nAnimalsLeftPos = 0
.head 9 -  Call SalMessageBox( "It is not possible to add " || StrX( nCount ) || " animals to the order position. 
Only " || StrX( nAnimalsLeftPos ) || " can be added.", "Error!", MB_IconStop )
.head 9 -  Return FALSE
.head 8 -  Set bInternalRequestIsNeeded = TRUE
.head 7 -  ! just do movements
.head 7 +  If GetLevel( nSelectedHandle ) = KHEL_Bett and BettIsSummary()
.head 8 -  Set nSelectedHandle=GetParent( nSelectedHandle )
.head 7 -  Call GetPosition( GetParent (HandleToPlace[0 , 1]), sAbtKeySou, sStatKeySou, sGrpKeySou, sBettKey )
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeyDes, sStatKeyDes, sGrpKeyDes, sBettKey )
.head 7 +  If sGrpKeySou
.head 8 -  Call SqlExists("
select RFID from gruppe
	where einricht_id = :nEinrichtId and gruppe_key=:sGrpKeySou and stat_key = :sStatKeySou
	into :sRFID
   						
	", bOk)
.head 8 +  If sRFID
.head 9 -  Call SqlExists("
select RFID from gruppe
	where einricht_id = :nEinrichtId and gruppe_key=:sGrpKeyDes and stat_key = :sStatKeyDes
	into :sRFID
   						
	", bOk)
.head 9 +  If sRFID
.head 10 -  Set bToRFID = TRUE
.head 7 -  Set nCadavers=KHE_IsCadavers(sAbtKeyDes, sStatKeyDes, sGrpKeyDes)
.head 7 +  If not bPlanningMode and GetLevel( nSelectedHandle ) = KHEL_Gruppe and IsEntireCageSelected() and nCadavers=0 and not CageIsTemp(sStatKeyDes, sGrpKeyDes) and not bInternalRequestMode and not bToRFID
.head 8 -  Set dtDate= GetTime4Refresh(  )
.head 8 +  If bRealTimeMode
.head 9 -  Call SqlExists("
select	1
from	fall f
where	f.LAST_Stat_key = '"||sStatKeyDes||"'
	and       f.LAST_Gruppe_key = '"||sGrpKeyDes||"'
	and       F.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   	and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   						
	", bOk)
.head 8 +  Else
.head 9 -  Call SqlExists("
select	1
from	bewegung bew, fall f
where	 bew.einricht_id=:nEinrichtId
	and     bew.Stat_key = '"||sStatKeyDes||"'
	and       bew.Gruppe_key = '"||sGrpKeyDes||"'
	and       bew.bew_zeit <=:dtDate
	and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   	and       (bew.bew_zeit_bis>:dtDate or bew.bew_zeit_bis is null  )
	and	f.einricht_id=bew.einricht_id	
	and	f.Fall_KEY = bew.Fall_KEY
   	and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   	and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   						
	", bOk)
.head 8 +  If not bOk
.head 9 -  Call SqlExists("
select	 bett.planbew_fall
from bett_locks bett
where		bett.Stat_key = '"||sStatKeyDes||"'
		and bett.Gruppe_key=  '"||sGrpKeyDes||"'
   						
	", bOk)
.head 8 +  If not bOk
.head 9 -  Call cDestination.Init( sAbtKeyDes, sStatKeyDes, sGrpKeyDes )
.head 9 -  Call GetPosition( GetParent (HandleToPlace[0 , 1]), sAbtKeySou, sStatKeySou, sGrpKeySou, sBettKey )
.head 9 -  ! Call cSource[0].Init( sAbtKeySou, sStatKeySou, sGrpKeySou )
.head 9 -  Set hSaveHandele=nSelectedHandle
.head 9 -  Set nSelectedHandle=GetParent (HandleToPlace[0 , 1])
.head 9 -  Set nHandeleGrpTemp = nSelectedHandle
.head 9 -  Call LT_OpenTransaction(5,SalDateCurrent(  ))
.head 9 -  Call LockSysadmAction("Move cage started...")
.head 9 -  Set bOk = MoveCage(sAbtKeySou, sStatKeySou, sGrpKeySou, sAbtKeyDes, sStatKeyDes, sGrpKeyDes, dtDate)
.head 9 -  Call LockSysadmAction("...move cage finished")
.head 9 -  Call LT_CloseLastTransaction()
.head 9 -  Call UnSelect()
.head 9 +  If sAbtKeySou != sAbtKeyDes
.head 10 -  Set sIn = sIn||sGrpKeyDes
.head 9 +  Else
.head 10 -  Set sIn = sIn||sGrpKeySou||","||sGrpKeyDes
.head 9 -  Call SalSendMsg( hWndItem, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 9 +  If bShowPlacesWithContent
.head 10 -  ! Call KHE_DeleteDescendents( hSaveHandele )
.head 10 -  ! Call KHE_RefreshGruppe( hSaveHandele )
.head 9 -  Set nHandeleGrpDes = FindChild( FindChild( FindChild(hRoot, sAbtKeyDes) ,sStatKeyDes) ,sStatKeyDes)
.head 9 +  If not nHandeleGrpDes
.head 10 -  Set nHandeleGrpDes = OpenGruppe(sAbtKeyDes, sStatKeyDes, sGrpKeyDes,  FALSE, -1)
.head 9 +  If hWnd_POC
.head 10 -  Call frmPOC.MoveHandle(nHandeleGrpTemp, nHandeleGrpDes)
.head 9 -  Call CloseGruppe(sAbtKeySou, sStatKeySou, sGrpKeySou)
.head 9 -  Call KHE_RefreshGruppe( nHandeleGrpDes )
.head 9 -  Set nIndex = GetItemIndex( nHandeleGrpDes )
.head 9 -  Call SalListSetSelect( hWndItem, nIndex )
.head 9 -  Call ActivateSelectedItem(  )     
.head 9 +  ! If bShowPlacesWithContent
.head 10 -  Call KHE_RefreshGruppe(GetParent (HandleToPlace[1 , 1]))
.head 10 -  Call KHE_RefreshGruppe(nSelectedHandle)
.head 9 +  ! Else
.head 10 -  Call PopulateSelectedItem( FALSE )
.head 9 +  If SalIsWindowVisible( hWndRack2DView )
.head 10 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sIn ))
.head 9 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 10 -  Call SalSendMsg(hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sIn ))
.head 9 -  Call Move_PrintCageCards( cSource, cDestination )
.head 9 -  ! Set nSelectedHandle=hSaveHandele
.head 8 +  Else
.head 9 -  Set bOk = Move_PasteToCurrent( )
.head 7 +  Else
.head 8 +  If Move_CanRolingMatings(  )
.head 9 -  Call Move_PasteRolingMatings(  )
.head 8 +  Else
.head 9 -  Set bOk = Move_PasteToCurrent( )
.head 7 +  If bInternalRequestIsNeeded
.head 8 +  If SalIsWindowVisible( hWL_Edit )
.head 9 -  Call SalSendMsg(hWL_Edit, AM_Refresh, 0, 0)
.head 8 -  Call SalSendMsg(frmIRServices.tblIRs, AM_Refresh, 0, 0)
.head 8 +  If not SalTblFindNextRow (frmIRServices.tblIRs, nRow, 0,0)
.head 9 -  Call SalSendMsg (frmIRServices, SAM_Close, 0, 0)
.head 7 -  ! clear _global_ vars
.head 7 -  Set bInternalRequestIsNeeded = FALSE
.head 7 -  Set bInternalRequestMode = FALSE
.head 7 -  Set nInternalRequestOrderId = 0
.head 7 -  Set nInternalRequestOrderPosNr = 0
.head 7 -  Return bOk
.head 5 +  Function: Move_PasteToCurrent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sStore_Abt
.head 7 -  ! String: sStore_Stat
.head 7 -  ! String: sStore_Grp
.head 7 -  ! String: sStore_Bett
.head 7 -  Boolean: bOk
.head 7 -  String: sBA_Key
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sAbtKeyDest
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nHandles[*]
.head 7 -  Number: hSourceCages[*]
.head 7 -  Number: nCages
.head 7 -  Number: i
.head 7 -  Number: hGrp
.head 7 -  Number: nBound
.head 7 -  Number: hMS
.head 7 -  String: sCagesList
.head 6 +  Actions
.head 7 -  Call SalArraySetUpperBound ( hSourceCages, 0, -1 ) 
.head 7 +  If GetCagesFromHandleToPlace(hSourceCages)>0
.head 8 -  Set bMove_HasInClipboard= TRUE
.head 8 -  Set hMove_Source= hSourceCages[0]
.head 8 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 8 +  If nBound = 0 and HandleToPlace[0,0] > 0
.head 9 -  Set bMove_SingleBett= TRUE
.head 7 +  Else
.head 8 +  If Not bMove_HasInClipboard
.head 9 -  Return FALSE
.head 8 +  If Not hMove_Source
.head 9 -  Return FALSE
.head 7 +  If Not nSelectedHandle
.head 8 -  Return FALSE
.head 7 +  If (hMove_Source = nSelectedHandle) and (not bMoveFlag)
.head 8 -  Return FALSE
.head 7 -  ! !!!!!! IB 18.07.2007
.head 7 -  Call GetPosition( hMove_Source, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 -  Set hMS=hMove_Source
.head 7 +  If Not sAbtKeySrc
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 +  If bPlanningMode and bMatingMode
.head 8 -  Set hGrp = FindH_4Gruppe( FindH_4Station( FindH_4Abteilung( sAbtKeyDest ), sStatKeyTmp, FALSE ), sGrpKeyTmp, FALSE )
.head 8 -  Set sFallSex = 'M'
.head 8 +  If (EnumChildren(hGrp, nHandles) = 1 and SalStrScan( GetItemText( hMove_Source ), ", M," ) >= 0)
	or EnumChildren(hGrp, nHandles) = 2
.head 9 -  Call SalMessageBox('You cannot use this cage', '', 0)
.head 9 -  Return FALSE
.head 8 -  ! !!!! cages can be repeated in different abteilungs
.head 8 +  If sCageForMating != '' and sCageForMating != sGrpKeyTmp
.head 9 -  Call SalMessageBox ('Please, use the same cage', '', 0)
.head 9 -  Return FALSE
.head 7 +  If Not sAbtKeyDest
.head 8 -  Return FALSE
.head 7 +  If sAbtKeySrc != sAbtKeyDest
.head 8 -  Set sBA_Key = 'VE'
.head 7 +  Else
.head 8 -  Set sBA_Key = 'UE'
.head 7 -  !
.head 7 -  Set dtBewZeit_New = DATETIME_Null
.head 7 +  While Not dtBewZeit_New
.head 8 -  Set dtBewZeit_New = GetTime4Refresh(  )
.head 8 -  ! If SalStrUpperX( ghsGetProfileStringX( 'Settings', 'AskForBewDate', 'YES' ) ) = 'YES'
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtBewZeit_New, sGrund1, sGrund2)
.head 9 -  Return FALSE
.head 8 +  ! Else 
.head 9 -  Set dtBewZeit_New = SalDateCurrent(  )
.head 9 -  Set sGrund1 = ''
.head 9 -  Set sGrund2 = ''
.head 8 +  If bUseCurrentTime
.head 9 +  If dtBewZeit_New > SalDateCurrent(  )
.head 10 +  If IDNO = SalMessageBox( GetMessageFromSection( "KHE", 7, "The date/time which You entered is in the future.
That could be a cause of incorrect showing of occupied places.
Whould You like to continue with this date/time ?" ), GetMessageX( 205, 'Attention !' ), MB_IconQuestion | MB_YesNo | MB_DefButton2 )
.head 11 -  Set dtBewZeit_New = DATETIME_Null
.head 7 -  Set dtKHK_RefreshTime = dtBewZeit_New
.head 7 +  If bMove_SingleBett
.head 8 -  Set bOk = Move_PasteSingleBed( sBA_Key, dtBewZeit_New )
.head 7 +  Else
.head 8 -  Set bOk  = Move_PasteGruppe( sBA_Key, dtBewZeit_New)
.head 7 -  ! printing the cagecards
.head 7 +  If bOk
.head 8 -  Set sCagesList = ""
.head 8 +  If not bPlanningMode
.head 9 -  Set nCages=GetCagesFromHandleToPlace(hSourceCages)
.head 9 -  Set sCagesList = ""
.head 9 +  If nCages >0
.head 10 -  Set i=0
.head 10 +  While i<=nCages
.head 11 +  If hSourceCages[i]=nSelectedHandle
.head 12 -  Set hSourceCages[i]=0
.head 11 -  Call GetPosition( hSourceCages[i], sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 11 -  ! *********************
.head 11 +  If sCagesList
.head 12 -  Set sCagesList = sCagesList||","
.head 11 -  Set sCagesList = sCagesList||sGrpKeyTmp
.head 11 -  Call cSource[i].Init( sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp )
.head 11 -  ! Set nCages=GetCagesFromHandleToPlace(hSourceCages)
.head 11 -  ! Call PopulateGruppe( hSourceCages[i], TRUE )
.head 11 -  Set i=i+1
.head 9 +  Else
.head 10 -  Call GetPosition( hMove_Source, sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 10 -  Set sCagesList = sGrpKeyTmp
.head 10 -  Call cSource[0].Init( sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 9 -  Set sCagesList = sCagesList||","||sGrpKeyTmp
.head 9 -  Call cDestination.Init( sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Call Rack2DView_RefreshCageContents(sCagesList)
.head 9 -  Call Move_PrintCageCards( cSource, cDestination )
.head 9 -  Call SalArraySetUpperBound (HandleToPlace, 1, -1)
.head 9 -  Call SalArraySetUpperBound (HandleToPlace, 0, -1)
.head 9 -  Set dtTime  = GetTime4Refresh(  )
.head 9 -  Call clsExplorerLeft.KHEReAssignPics(nSelectedHandle)
.head 9 -  Call POC_CloseAndUnregister(hMS)
.head 8 -  ! !!! IB 18.07.2007 
.head 8 +  If bPlanningMode and bMatingMode
.head 9 +  If sCageForMating = ''
.head 10 -  Set sCageForMating = sGrpKeyTmp
.head 9 -  Set sFallSex = 'M'
.head 9 +  If EnumChildren(hGrp, nHandles) = 1
.head 10 -  Set bMaleIsExist = TRUE
.head 9 -  Set sFallSex = 'F'
.head 9 +  If EnumChildren(hGrp, nHandles) = 1
.head 10 -  Set bFemaleIsExist = TRUE
.head 9 +  If bMaleIsExist and bFemaleIsExist
.head 10 -  ! Call SalMessageBox('Do you want to leave MatingMode?','',MB_YesNo) 
.head 10 -  ! !!!!!!Call GetCurrentPosition( sStore_Abt, sStore_Stat, sStore_Grp, sStore_Bett )
.head 10 +  ! If IDYES = SalMessageBox('Do you want to finish this Mating?','',MB_YesNo) 
.head 11 +  If IDYES = SalMessageBox('Do you want to create new Mating?

If NO Cage Explorer will be switched to real time','',MB_YesNo) 
.head 12 -  Set nPlan_LstErfNr = MM_InsertAdminLstErf(nPlan_Fall_Key, nPlan_AEBewNr, sPlan_TarifKey, sPlan_LstKey, 'AL', dtPlan_Started)
.head 12 -  Set sCageForMating = ''
.head 12 -  Set bMaleIsExist = FALSE
.head 12 -  Set bFemaleIsExist = FALSE
.head 11 +  Else 
.head 12 -  Set bPlanningMode = FALSE
.head 12 -  Set bMatingMode = FALSE
.head 12 -  Set bShowOnlyRealBew = TRUE
.head 12 -  Call SetTime4Refresh( SalDateCurrent ( ))
.head 12 -  Call PopulateEinrichtung( bAutoScan )
.head 12 -  Set bOk = SalPicSet( hWnd_pbSetTime, KHE_ClockW, PIC_FormatBitmap )
.head 12 +  If sAbtKeyDest
.head 13 -  Set bOk = GoToAbt( sAbtKeyDest )
.head 12 +  If sStatKeyTmp And bOk
.head 13 -  Set bOk = GoToStat( sAbtKeyDest, sStatKeyTmp, bAutoScan )
.head 12 +  If sGrpKeyTmp
.head 13 -  Set bOk = GotoGruppe( sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, bAutoScan )
.head 12 +  If sBettKeyTmp
.head 13 -  Set bOk = GotoBett( sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp, bAutoScan )
.head 10 -  Call Finish_Movement(TRUE, sAbtKeyDest, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp)
.head 7 -  Return bOk
.head 5 +  Function: Move_PasteGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sBA_Key
.head 7 -  Date/Time: dtBewZeit_New
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hSourceGrp
.head 7 -  Number: hDestinationGrp
.head 7 -  Number: hDestinationBed
.head 7 -  Number: hBeds2Operate[*]
.head 7 -  Number: nBeds2Operate
.head 7 -  Number: nInd
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bTmp
.head 7 -  Number: nFreeBedsCount
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Number: hFreeBeds[*]
.head 7 -  Number: hBeds[*]
.head 7 -  Number: hSourceCages[*]
.head 7 -  Number: i
.head 7 -  Number: nCages
.head 7 -  Boolean: bDestinationBed
.head 7 -  Number: hAbt
.head 7 -  Number: hGrp
.head 7 -  Number: hBett
.head 7 -  Number: hChildren[*]
.head 7 -  Boolean: bAnyFall
.head 7 -  Number: hGruppe[*]
.head 7 -  Number: nIndGrpRefresh
.head 7 -  Boolean: bGrpT
.head 7 -  Number: nFallChangeLicense[*]
.head 6 +  Actions
.head 7 +  If bMove_SingleBett
.head 8 -  Return FALSE
.head 7 +  If BettIsSummary()
.head 8 -  Set nSelectedHandle= GetParent(nSelectedHandle)
.head 7 -  Set bPastingMovement = TRUE
.head 7 -  !
.head 7 -  Set hDestinationGrp = nSelectedHandle
.head 7 +  If GetLevel( hDestinationGrp ) != KHEL_Gruppe and Not BettIsSummary()
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Set hSourceGrp = hMove_Source
.head 7 -  ! AS 07.04.2004 - fixing of "0152_CutAndPasteFromClosedCages"
.head 7 -  ! Call PopulateAndExpand( hSourceGrp, FALSE )
.head 7 -  Set hKHK_GruppeThatMayBeEmpty = hSourceGrp
.head 7 -  !
.head 7 +  If bInternalRequestMode
.head 8 -  Set nBeds2Operate = EnumChildren( hSourceGrp, hBeds2Operate)
.head 7 +  Else If bMenuCutFallNrX = TRUE
.head 8 -  Set nBeds2Operate = EnumChildren( hSourceGrp, hBeds2Operate )
.head 7 +  Else
.head 8 -  Set nBeds2Operate = EnumChildren( hSourceGrp, hBeds2Operate )
.head 7 +  If Not SalArrayIsEmpty ( HandleToPlace )
.head 8 -  Set nBeds2Operate = 0
.head 8 -  Call SalArraySetUpperBound ( hBeds2Operate, 1, -1 )
.head 8 -  Set nBeds2Operate = GetBedsFromHandleToPlace ( hBeds2Operate )
.head 7 +  If nBeds2Operate <= 0 and hBeds2Operate[0] <=0
.head 8 -  Return FALSE
.head 7 -  Set bAnyFall = TRUE
.head 7 -  !
.head 7 -  ! Set nFreeBedsCount = GetFreeBedsInGruppe( nSelectedHandle, hFreeBeds )
.head 7 -  Set nFreeBedsCount = QuantityOfEmptyBett( nSelectedHandle )
.head 7 +  If ((nFreeBedsCount) < nBeds2Operate and (not bMoveFlag)) or nFreeBedsCount=0
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Set bOk =TRUE
.head 7 -  Set nInd = 0
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 7 -  Call LockSysadmAction("Move animals started...")
.head 7 +  While bOk And nInd <= nBeds2Operate
.head 8 -  ! Call GetPosition( hFreeBeds[ nInd ], sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 +  If sBA_Key = 'VE' and bAskForLicense
.head 9 -  Set nFallChangeLicense[nInd] = GetFallKey_ByHandle( hBeds2Operate[ nInd ] )
.head 8 -  Set sBettKey=AddWonBett(dtBewZeit_New)
.head 8 +  If sBettKey=''
.head 9 -  Return FALSE
.head 8 -  Set bDestinationBed = Move_PasteSingleBed_DoIt( 
			hBeds2Operate[ nInd ], 
			sAbtKey, sStatKey, sGrpKey, sBettKey, 
			sBA_Key, dtBewZeit_New )
.head 8 +  If not bDestinationBed 
.head 9 -  Set bOk = FALSE
.head 9 -  Break
.head 8 +  If bShowPlacesWithContent and bOk
.head 9 -  !
.head 9 -  Set hGrp=GetParent(hBeds2Operate[ nInd ])
.head 9 -  Set i = 0
.head 9 -  Set bGrpT=FALSE
.head 9 +  While i<=nIndGrpRefresh
.head 10 +  If hGruppe[i] = hGrp
.head 11 -  Set bGrpT=TRUE
.head 11 -  Break
.head 10 -  Set i=i+1
.head 9 +  If bGrpT = FALSE
.head 10 -  Set hGruppe[nIndGrpRefresh] = hGrp
.head 10 -  Set nIndGrpRefresh =nIndGrpRefresh + 1
.head 8 -  Set bOk =TRUE
.head 8 -  Set nInd = nInd + 1
.head 7 -  Call LockSysadmAction("...move animals finished")
.head 7 -  Call LT_CloseLastTransaction()
.head 7 +  If sBA_Key = 'VE' and bAskForLicense
.head 8 -  Call SetMassLicense( nFallChangeLicense, sAbtKey )
.head 7 -  !
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Set hGruppe[nIndGrpRefresh] = nSelectedHandle
.head 7 -  Set nCages=GetCagesFromHandleToPlace(hSourceCages)
.head 7 +  If nCages >0
.head 8 -  Set i=0
.head 8 +  While i<=nCages
.head 9 +  If bShowPlacesWithContent
.head 10 -  !
.head 10 -  ! Call GetPosition( hSourceCages[i], sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 10 -  ! Call CloseGruppe(sAbtKey, sStatKey, sGrpKey)
.head 10 -  ! Call KHE_DeleteDescendents(hSourceCages[i])
.head 10 -  ! Call PopulateAndExpand(hSourceCages[i], TRUE )
.head 10 +  ! If bShowOnlyOpenCages
.head 11 -  Call OpenGruppe(sAbtKey, sStatKey, sGrpKey, TRUE)
.head 10 +  ! Else
.head 11 -  Set hAbt = SearchFrom(hRoot, sAbtKey)
.head 11 +  If SearchFrom(hAbt, sGrpKey)
.head 12 -  Call PopulateAndExpand( hSourceCages[i], TRUE )
.head 9 +  Else
.head 10 -  Call PopulateGruppe( hSourceCages[i], TRUE )
.head 9 -  Set i=i+1
.head 7 -  Else
.head 7 +  If bShowPlacesWithContent
.head 8 -  ! Call GetPosition(  hDestinationGrp , sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  ! Call CloseGruppe(sAbtKey, sStatKey, sGrpKey)
.head 8 -  ! Call KHE_DeleteDescendents(hDestinationGrp)
.head 8 -  ! Call PopulateAndExpand(hDestinationGrp, TRUE )
.head 8 +  ! If bShowOnlyOpenCages
.head 9 -  Call OpenGruppe(sAbtKey, sStatKey, sGrpKey, TRUE)
.head 8 +  ! Else
.head 9 -  Call PopulateAndExpand( hDestinationGrp, TRUE )
.head 8 -  Set nInd = 0
.head 8 +  While nInd<=nIndGrpRefresh
.head 9 -  Call KHE_RefreshGruppe(hGruppe[nInd])
.head 9 -  Set nInd = nInd + 1
.head 7 +  Else
.head 8 -  Call PopulateAndExpand( hDestinationGrp, TRUE )
.head 7 -  Call SalListSetSelect( hWndItem, GetItemIndex( hDestinationGrp ) )
.head 7 -  Call ActivateSelectedItem(  )
.head 7 -  !
.head 7 -  Set bMove_HasInClipboard = FALSE
.head 7 -  Call SalPostMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 7 -  ! refresh 2DView
.head 7 -  ! Call Rack2DView_RefreshCageContents("" )
.head 7 -  Return bOk
.head 5 +  Function: Move_PasteSingleBed
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sBA_Key
.head 7 -  Date/Time: dtBewZeit_New
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: hSourceBett
.head 7 -  Number: hDestinationBett
.head 7 -  Number: hFreeBeds[*]
.head 7 -  Number: nFreeBedsCount
.head 7 -  Number: nBound
.head 7 -  String: sAbtKeyDest
.head 7 -  String: sStatKeyDest
.head 7 -  String: sGrpKeyDest
.head 7 -  String: sBettKeyDest
.head 7 -  String: sBettKey
.head 7 -  Boolean: bDestinationBett
.head 7 -  Number: hAbt
.head 7 -  Number: hGrp
.head 7 -  Number: hBett
.head 7 -  Number: hSourceGrp
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nFallChangeLicense[*]
.head 6 +  Actions
.head 7 -  ! Setting bPastingMovement to True, not to show a automatic context menu after pasting and Cage refresh
.head 7 -  Set bPastingMovement = TRUE
.head 7 +  If Not bMove_SingleBett
.head 8 -  Return FALSE
.head 7 -  !
.head 7 +  If GetLevel( nSelectedHandle ) = KHEL_Bett
.head 8 +  If bShowPlacesWithContent
.head 9 -  Set hDestinationBett = GetParent(nSelectedHandle)
.head 8 +  Else
.head 9 +  If GetFallKey_ByHandle( nSelectedHandle )
.head 10 -  Return FALSE
.head 9 -  Set hDestinationBett = nSelectedHandle
.head 7 +  Else If GetLevel( nSelectedHandle ) = KHEL_Gruppe
.head 8 +  If bShowPlacesWithContent
.head 9 -  Set hDestinationBett = nSelectedHandle
.head 8 +  Else
.head 9 +  If GetFreeBedsInGruppe( nSelectedHandle, hFreeBeds ) < 1
.head 10 -  Return FALSE
.head 9 -  Set hDestinationBett = hFreeBeds[0]
.head 7 +  Else
.head 8 -  Return FALSE
.head 7 -  ! Set nFreeBedsCount = Move_FindFreeBeds( nSelectedHandle, sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest, 1 )
.head 7 +  ! If nFreeBedsCount < 1
.head 8 -  Return 0
.head 7 -  Set hSourceBett = hMove_Source
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  If nBound = 0 and HandleToPlace[0,1]>0
.head 8 -  Set hSourceBett= HandleToPlace[0,1]
.head 8 -  Set bMove_SingleBett= FALSE
.head 7 -  !
.head 7 -  Set hKHK_GruppeThatMayBeEmpty = GetParent( hSourceBett )
.head 7 -  Set bGrpNeedsRefresh = FALSE	! bGrpNeedsRefresh could be set to TRUE by one of HelStat_* function, which is called during insert bewegung
.head 7 -  Call GetPosition( hDestinationBett, sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest )
.head 7 +  If bShowPlacesWithContent
.head 8 -  Set sBettKeyDest =AddWonBett(dtBewZeit_New)
.head 8 -  Set sBettKey =sBettKeyDest
.head 7 +  If sBA_Key = 'VE' and bAskForLicense
.head 8 -  Set nFallChangeLicense[0] = GetFallKey_ByHandle( hSourceBett )
.head 7 -  ! Set sBettKeyDest =AddWonBett()
.head 7 +  If Not sBettKeyDest
.head 8 -  Return FALSE
.head 7 -  Call LT_OpenTransaction(7,SalDateCurrent(  ))
.head 7 -  Set bDestinationBett = Move_PasteSingleBed_DoIt( 
			hSourceBett, 
			sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest, 
			sBA_Key, dtBewZeit_New )
.head 7 +  If sBA_Key = 'VE' and bAskForLicense
.head 8 -  Call SetMassLicense( nFallChangeLicense, sAbtKeyDest )
.head 7 -  Call LT_CloseLastTransaction()
.head 7 +  If Not bDestinationBett
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Call SalArraySetUpperBound ( HandleToPlace, 1, -1 )
.head 7 -  !
.head 7 -  ! Call GetTime4Refresh(  )
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Call SalStatusSetText( hWndForm, GetMessageFromSection( 'KHE', 22, 'Redrawing the source place...' ) )
.head 7 +  If bShowPlacesWithContent
.head 8 -  Call GetPosition( hSourceBett, sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest)
.head 8 -  Call RefreshBettAfterMove( hSourceBett )
.head 8 -  Set hSourceGrp=GetParent(hSourceBett)
.head 8 -  Call DeleteGruppeFromStation(hSourceBett) 
.head 8 -  ! Call SetItemText( SearchFrom(hSourceGrp,'Empty Places in Cage'), '[ '|| SalNumberToStrX(QuantityOfEmptyBett(hSourceGrp),0)|| ' ]' || '  Empty Places in Cage' )
.head 8 -  ! Call AddStrBett(SearchFrom(hSourceGrp,'In Cage:') )
.head 8 -  Call KHE_RefreshGruppe(hSourceGrp)
.head 8 +  ! If EnumChildren (hSourceGrp, hChildren)<2
.head 9 -  Call KHESetHasFall( hSourceGrp, FALSE )
.head 9 -  Call clsExplorerLeft.KHEReAssignPics(hSourceGrp)
.head 8 -  ! Call KHE_DeleteDescendents(hSourceBett)
.head 8 -  ! Call PopulateAndExpand(hSourceBett, TRUE )
.head 8 +  ! If bShowOnlyOpenCages
.head 9 -  Call OpenGruppe(sAbtKeyDest, sStatKeyDest, sGrpKeyDest, TRUE)
.head 8 +  ! Else
.head 9 -  Set hAbt = SearchFrom(hRoot, sAbtKeyDest)
.head 9 +  If SearchFrom(hAbt, sGrpKeyDest)
.head 10 -  Call PopulateAndExpand( GetParent(hSourceBett), TRUE )
.head 7 +  Else
.head 8 -  Call RefreshBettAfterMove( hSourceBett )
.head 7 -  Call SalStatusSetText( hWndForm, GetMessageFromSection( 'KHE', 23, 'Redrawing the destination place...' ) )
.head 7 +  If bGrpNeedsRefresh
.head 8 +  If bShowPlacesWithContent
.head 9 -  Call GetPosition(hDestinationBett, sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest)
.head 9 -  ! Call CloseGruppe(sAbtKeyDest, sStatKeyDest, sGrpKeyDest)
.head 9 -  !
.head 9 +  If Not Expand( GetItemIndex( hDestinationBett ) )
.head 10 -  Return FALSE
.head 9 -  Call KHEReAssignPics( hDestinationBett)
.head 9 -  !
.head 9 -  ! Call KHE_DeleteDescendents( hDestinationBett)
.head 9 -  ! Call PopulateAndExpand( hDestinationBett, TRUE )
.head 9 +  ! If bShowOnlyOpenCages
.head 10 -  Call OpenGruppe(sAbtKeyDest, sStatKeyDest, sGrpKeyDest, TRUE)
.head 9 +  ! Else
.head 10 -  Call PopulateAndExpand( hDestinationBett, TRUE )
.head 8 +  Else
.head 9 -  Call PopulateAndExpand( GetParent( hDestinationBett ), TRUE )
.head 7 +  Else
.head 8 +  If bShowPlacesWithContent
.head 9 -  ! Call GetPosition( hDestinationBett, sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest)
.head 9 -  ! Call CloseGruppe(sAbtKeyDest, sStatKeyDest, sGrpKeyDest)
.head 9 -  ! Set hBett = SearchFrom( hDestinationBett,  'Empty Places in Cage')
.head 9 -  ! Call SetItemText( hBett, '('|| sBettKey ||')' || sBettKey )
.head 9 -  ! Call PopulateGruppeLight( hDestinationBett, TRUE )
.head 9 -  ! Call AddStrBett(hDestinationBett)
.head 9 -  ! Set hGrp = KHEAddChild( hDestinationBett, hPicFolderCollapsed, '(1) 1', 0 )
.head 9 -  ! Call KHESetChildChecked(hGrp, TRUE )
.head 9 -  ! Set nIndex = GetItemIndex( hNode )
.head 9 +  ! If Not Expand( GetItemIndex( hDestinationBett ) )
.head 10 -  Return FALSE
.head 9 -  ! Call KHEReAssignPics( hDestinationBett)
.head 9 -  ! Call KHE_DeleteDescendents(hDestinationBett) 
.head 9 +  ! If bShowOnlyOpenCages
.head 10 -  Call OpenGruppe(sAbtKeyDest, sStatKeyDest, sGrpKeyDest, TRUE)
.head 9 +  ! Else
.head 10 -  Call PopulateAndExpand( hDestinationBett, TRUE )
.head 9 -  Call KHE_RefreshGruppe(hDestinationBett)
.head 8 +  Else
.head 9 -  !
.head 9 -  Call RefreshBettAfterMove( hDestinationBett )
.head 7 -  !
.head 7 -  Set bMove_HasInClipboard = FALSE
.head 7 -  Call SalPostMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 7 -  Set bPastingMovement = FALSE
.head 7 -  ! refresh 2DView
.head 7 -  ! Call Rack2DView_RefreshCageContents("" )
.head 7 -  Return TRUE
.head 5 +  Function: Move_PasteSingleBed_DoIt
.head 6 -  Description: If sucess returns handle of a Destination Bed
of 0 if failed
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hSourceBett
.head 7 -  String: sAbtKeyDest
.head 7 -  String: sStatKeyDest
.head 7 -  String: sGrpKeyDest
.head 7 -  String: sBettKeyDest
.head 7 -  String: sBA_Key
.head 7 -  Date/Time: dtBewZeit_New
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sStatusText
.head 7 -  String: sItemText_Tmp
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeySrc
.head 7 -  String: sGrpKeySrc
.head 7 -  String: sBettKeySrc
.head 7 -  String: sBG1_Key
.head 7 -  String: sBG2_Key
.head 7 -  Number: nBewNr
.head 7 -  Number: nFallKey
.head 7 -  Number: hSourceGruppe
.head 7 -  Number: hDestinationBett
.head 7 -  Boolean: bOk
.head 7 -  String: sSqlBtt
.head 7 -  Sql Handle: hSql
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If (not hSourceBett)
.head 8 -  Return FALSE
.head 7 +  If (not sAbtKeyDest)
.head 8 -  Return FALSE
.head 7 +  If (not sStatKeyDest)
.head 8 -  Return FALSE
.head 7 +  If (not sGrpKeyDest)
.head 8 -  Return FALSE
.head 7 +  If (not sBettKeyDest)
.head 8 -  Return FALSE
.head 7 -  Set sStatusText = GetMessageFromSection( 'KHE', 24, 'Goto the place' ) || ': ' || sAbtKeyDest || '/' || sStatKeyDest || '/' || sGrpKeyDest || '/' || sBettKeyDest || '...'
.head 7 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 7 -  ! Set hDestinationBett = OpenBett( sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest, FALSE )
.head 7 +  ! If Not hDestinationBett
.head 8 -  Call SalStatusSetText( hWndForm, sStatusText || ' - ' || GetMessageX( 203, 'Error !' ))
.head 8 -  Return 0
.head 7 -  !
.head 7 -  Set sBG1_Key = STRING_Null
.head 7 -  Set sBG2_Key = STRING_Null
.head 7 -  Set nBewNr = 0
.head 7 -  Set sStatusText = GetMessageFromSection( 'KHE', 25, 'Get FallNr. ...' )
.head 7 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 7 -  Call GetPosition( hSourceBett , sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKeySrc )
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If Not GalConnect( hSql)
.head 8 -  Return FALSE
.head 7 +  If bRealTimeMode
.head 8 -  Set sSqlBtt = "
 select f.FALL_KEY
 from 	  FALL f
 where         f.EINRICHT_ID =" || StrX( nEinrichtId ) || "
 and	f.LAST_STAT_KEY = '"||sStatKeySrc||"'
 and	f.LAST_GRUPPE_KEY = '"||sGrpKeySrc||"'
 and 	f.LAST_BETT_KEY = '"||sBettKeySrc||"'
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )

into	 :nFallKey"


.head 7 +  Else
.head 8 -  Set sSqlBtt = "
 select b.FALL_KEY
 from 	  BEWEGUNG b
 where         b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
 and	b.STAT_KEY = '"||sStatKeySrc||"'
 and	b.GRUPPE_KEY = '"||sGrpKeySrc||"'
 and 	b.BETT_KEY = '"||sBettKeySrc||"'
 and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
 and	@nullvalue( b.GELOESCHT, 'N' ) != 'J'
 and       b.bew_zeit <=:dtGetTime
 and       (b.bew_zeit_bis>:dtGetTime or b.bew_zeit_bis is null  )

into	 :nFallKey"


.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, sSqlBtt )
.head 7 +  While bOk and SqlFetchNext( hSql, nFetch )
.head 8 -  Break
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  ! Set nFallKey = GetFallKey_ByHandle( hSourceBett )
.head 7 +  If nFallKey  < 1 
.head 8 -  Call SalStatusSetText( hWndForm, sStatusText || ' - ' || GetMessageX( 203, 'Error !' ))
.head 8 -  Return FALSE
.head 7 -  ! Set sItemText_Tmp =  GetItemText( hDestinationBett )
.head 7 -  ! Call SetItemText( hDestinationBett, sItemText_Tmp || ' +++-> ' || sBA_Key || ' ' || StrX( nFallKey ) )
.head 7 -  ! Set sStatusText = GetMessageFromSection( 'KHE', 26, 'Write data to DB' ) || ': ' || StrX( nFallKey ) || ' ' || sBA_Key || ' -> ' || sStatKeyDest || '/' || sGrpKeyDest || '/' || sBettKeyDest
.head 7 -  ! Call SalStatusSetText( hWndForm, sStatusText )
.head 7 +  If bPlanningMode
.head 8 -  Call LockSysadmAction("Move animal (plan) started...")
.head 8 -  Set nBewNr = PlanedMovement_AddMvmnt( 
		nFallKey, dtBewZeit_New, sBA_Key, sBG1_Key, sBG2_Key, 
		sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest, TRUE )
.head 7 +  Else
.head 8 +  If bMoveFlag
.head 9 -  Set sAbtKeyDest = sMoveScreen
.head 8 -  Call LockSysadmAction("Move animal started...")
.head 8 -  Set nBewNr = InsertBewegung( 
	nFallKey, 0, 
	dtBewZeit_New, sBA_Key, sBG1_Key, sBG2_Key,
	sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest,
	"", "", "", "" )
.head 8 +  If nBewNr > 0 And bInternalRequestIsNeeded
.head 9 +  If Not IR_UpdateMovement( nFallKey, nBewNr, nInternalRequestOrderId, nInternalRequestOrderPosNr, nInternalRequestLstErfNr )
.head 10 -  Set nBewNr = 0
.head 7 -  !
.head 7 +  If nBewNr > 0
.head 8 -  Call DoCloseTransaction( TRUE )
.head 8 +  If Not bPlanningMode
.head 9 -  Call Transfer_AppendToAll( sBA_Key, nFallKey, nBewNr )
.head 8 -  Call LockSysadmAction("...move animal finished")
.head 8 -  Call SalStatusSetText( hWndForm, '' )
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Call DoCloseTransaction( FALSE )
.head 8 -  ! Call SetItemText( hDestinationBett, sItemText_Tmp )
.head 8 -  ! Call SalStatusSetText( hWndForm, sStatusText || ' - Failed/Canceled !')
.head 8 -  Call LockSysadmAction("...move animal failed")
.head 8 -  Return FALSE
.head 5 +  Function: Move_FindFreeBeds
.head 6 -  Description: Searches for free beds 'under' specified node.
As a result - fills in the correspondent arrays.
Returns amount of found free beds.
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hStart
.head 7 -  Receive String: rsaAbtKey[*]
.head 7 -  Receive String: rsaStatKey[*]
.head 7 -  Receive String: rsaGrpKey[*]
.head 7 -  Receive String: rsaBettKey[*]
.head 7 -  Number: nRequestedAmount
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sSelect
.head 7 -  String: sAbtStatGrpBett
.head 7 -  String: sStatusText
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sErrorMsg
.head 7 -  String: s_nEinrichtId
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Number: nCountFound
.head 6 +  Actions
.head 7 -  Set sAbtStatGrpBett = GetPosition( hStart, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If Not sAbtKey
.head 8 -  Call SalMessageBox( GetMessageFromSection( 'KHE', 1, 'Could not locate the Screen' ), GetMessageX( 203, 'Error !' ), MB_IconExclamation )
.head 8 -  Return -1
.head 7 -  !
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Call SalMessageBox( GetMessageX( 226, 'Sql Error:' ) || ' GalConnect()', GetMessageX( 203, 'Error !' ), MB_IconExclamation )
.head 8 -  Return -1
.head 7 -  !
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Set sStatusText = GetMessageFromSection( 'KHE', 27, 'Search for a free place...' )
.head 7 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 7 -  !
.head 7 -  Set nCountFound = 0
.head 7 -  Set s_nEinrichtId = StrX( nEinrichtId )
.head 7 -  Set sSelect = "
select	 a.ABT_KEY, b.STAT_KEY, b.GRUPPE_KEY, b.BETT_KEY
into	:sAbtKey, :sStatKey, :sGrpKey, :sBettKey	
from	BETT b, ABT_STAT a
where	b.EINRICHT_ID = " || s_nEinrichtId || "
  and	a.EINRICHT_ID = " || s_nEinrichtId || "
  and	a.STAT_KEY = b.STAT_KEY
  and 	a.ABT_KEY =  '" || sAbtKey || "'
"
.head 7 +  If sStatKey
.head 8 -  Set sSelect  = sSelect || " and	b.STAT_KEY='" || sStatKey || "' "
.head 7 +  If sGrpKey
.head 8 -  Set sSelect  = sSelect || " and	b.GRUPPE_KEY='" || sGrpKey || "' "
.head 7 +  If sBettKey
.head 8 -  Set sSelect  = sSelect || " and	b.BETT_KEY='" || sBettKey || "' "
.head 7 -  Set sSelect = sSelect || " 
and         not exists( 
	select	bw.BETT_KEY 
	from	BEWEGUNG bw
	where 	bw.EINRICHT_ID = " || s_nEinrichtId || "
	  and 	bw.GELOESCHT = 'N'
	  and	bw.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	  and	bw.BEW_ZEIT <= :dtKHK_RefreshTime
	  and	( bw.BEW_ZEIT_BIS is null
		or
		bw.BEW_ZEIT_BIS > :dtKHK_RefreshTime )
"
.head 7 +  If sStatKey
.head 8 -  Set sSelect  = sSelect || "
	 and	bw.STAT_KEY='" || sStatKey || "' "
.head 7 +  Else
.head 8 -  Set sSelect  = sSelect || "
	  and	bw.STAT_KEY = b.STAT_KEY "
.head 7 +  If sGrpKey
.head 8 -  Set sSelect  = sSelect || "
	 and	bw.GRUPPE_KEY='" || sGrpKey || "' "
.head 7 +  Else
.head 8 -  Set sSelect  = sSelect || "
	 and	bw.GRUPPE_KEY = b.GRUPPE_KEY "
.head 7 +  If sBettKey
.head 8 -  Set sSelect  = sSelect || "
	 and	bw.BETT_KEY='" || sBettKey || "' "
.head 7 +  Else
.head 8 -  Set sSelect  = sSelect || "
	  and	bw.BETT_KEY = b.BETT_KEY "
.head 7 -  Set sSelect = sSelect || " )
order by	b.STAT_KEY, b.GRUPPE_KEY, b.BETT_KEY "
.head 7 -  Set sSelect = Gal_IR( sSelect, MDB_GetServerTypeX( hSql ) )
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, sSelect )
.head 7 +  While bOk And SqlFetchNext( hSql, nFetch )
.head 8 -  Set rsaAbtKey[ nCountFound ] = sAbtKey
.head 8 -  Set rsaStatKey[ nCountFound ] = sStatKey
.head 8 -  Set rsaGrpKey[ nCountFound ] = sGrpKey
.head 8 -  Set rsaBettKey[ nCountFound ] = sBettKey
.head 8 -  Set nCountFound = nCountFound + 1
.head 7 -  !
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  !
.head 7 +  If nRequestedAmount > nCountFound
.head 8 -  Call SalStatusSetText( hWndForm, sStatusText || ' - ' || GetMessageX( 203, 'Error !' ))
.head 8 -  !
.head 8 -  Set sErrorMsg = sAbtStatGrpBett || ' - ' || SalFmtFormatDateTime( dtKHK_RefreshTime, 'dd.MM.yyyy hhhh:mm:ss' )
.head 8 -  Set sErrorMsg = sErrorMsg || "
" || GetMessageFromSection( 'KHE', 2, 'No any (or not enough) free place(s) were found.' ) || "

" || StrX( nRequestedAmount ) || " " || GetMessageFromSection( 'KHE', 3, 'places were requested.' ) || "
" || StrX( nCountFound ) || " " || GetMessageFromSection( 'KHE', 4, 'places were found.' )
.head 8 -  Call SalMessageBox( sErrorMsg, GetMessageX( 205, 'Attention !' ), MB_IconExclamation )
.head 7 -  Return nCountFound
.head 5 +  Function: Move_PrintCageCards
.head 6 -  Description: Prints page cards for each source and destination cages after a movement
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocation
.head 7 -  Number: nCount
.head 7 -  Number: i
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call PrintCageCards(cSource,cDestination)
.head 7 +  If GalGetProfileBooleanX( 'Settings', 'AutoCloseCageAfterMovement', FALSE, sUserINIFileName )
.head 8 -  Call SalArrayGetUpperBound( cSource, 1, nCount )
.head 8 -  Set i=0
.head 8 +  While i<= nCount
.head 9 -  Call CloseGruppe(cSource[i].sScreenKey, cSource[i].sRackKey,cSource[i].sCageKey)
.head 9 -  Set i=i+1
.head 8 -  Call CloseGruppe(cDestination.sScreenKey, cDestination.sRackKey,cDestination.sCageKey)
.head 7 -  Return bOk
.head 5 +  Function: PrintCageCards
.head 6 -  Description: Prints page cards for each source and destination cages 
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: i
.head 7 -  Number: nCount
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocation
.head 7 -  Boolean: bPrint
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If GalGetProfileBooleanX( 'Settings', 'PrintCageCardsOnMovement', TRUE, sUserINIFileName )
.head 8 -  Call SalArrayGetUpperBound( cSource, 1, nCount )
.head 8 -  Set i=0
.head 8 +  While i<= nCount
.head 9 -  Set cCages[i] = cSource[i]
.head 9 -  Set i=i+1
.head 8 -  Set cCages[i] = cDestination
.head 8 +  If Not Requst_ListForCageCard( cCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 9 -  ! user canceled the action
.head 9 -  Set bOk = TRUE
.head 8 +  If bOk
.head 9 -  Call GetTime4Refresh( )
.head 9 +  If bPrint
.head 10 -  Call Formular_CageCard_Print( '', '', dtKHK_RefreshTime )
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: PlanedMovement_AddMvmnt
.head 6 -  Description: Returns BewNr or 0 if Error
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  String: sBA_Key
.head 7 -  String: sBG1_Key
.head 7 -  String: sBG2_Key
.head 7 -  String: sAbtKeyDest
.head 7 -  String: sStatKeyDest
.head 7 -  String: sGrpKeyDest
.head 7 -  String: sBettKeyDest
.head 7 -  Boolean: bWithLocking
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBewPlanNr
.head 7 -  Number: nIdminItemNr
.head 7 -  Boolean: bOk
.head 7 -  String: sAdminItemKey
.head 6 +  Actions
.head 7 -  Set sAdminItemKey = 'Plan2Real_Bew'
.head 7 +  If Not PlanedMovement_IsItPossible( sAdminItemKey )
.head 8 -  Return 0
.head 7 +  If bWithLocking
.head 8 -  Set nBewPlanNr = InsertBewegungPlan( 
	nFallKey, 0, 
	dtBewZeit_New, sBA_Key, sBG1_Key, sBG2_Key,
	sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest,
	"" )
.head 7 +  Else
.head 8 -  Set nBewPlanNr = InsertBewegungPlanX( 
	sUserSchema, nEinrichtId, nFallKey, 0, 
	dtBewZeit_New, sBA_Key, sBG1_Key, sBG2_Key,
	sAbtKeyDest, sStatKeyDest, sGrpKeyDest, sBettKeyDest,
	"", 0 )
.head 7 +  If nBewPlanNr <= 0 
.head 8 -  Return 0
.head 7 -  !
.head 7 -  Set nIdminItemNr = PlanedMovement_InsAdmAction( nFallKey, nBewPlanNr, sAdminItemKey )
.head 7 -  Return nBewPlanNr
.head 5 +  Function: PlanedMovement_IsItPossible
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spAdminItemKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If Not CheckDBVersion( 6.30 )
.head 8 -  Return FALSE
.head 7 +  If Not bPlanningMode
.head 8 -  Call SalMessageBox( GetMessageFromSection( "KHE", 8, "KHE must be set to the Planning Mode first !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 +  If Not nPlan_Fall_Key
.head 8 -  Call SalMessageBox( GetMessageFromSection( "KHE", 9, "Virtual Case is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 +  If Not nPlan_LstErfNr
.head 8 -  Call SalMessageBox( GetMessageFromSection( "KHE", 10, "LST_ERF record is not specified for the Virtual Case !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 -  !
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	ADMIN_ITEM_KEY
from	ADMIN_ITEM
where	ADMIN_ITEM_KEY = '" || spAdminItemKey || "' " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 7 -  Call SqlDisconnect( hSql )
.head 7 +  If Not bOk
.head 8 -  Call SalMessageBox( "'" || spAdminItemKey || "' - " || GetMessageFromSection( "KHE", 11, "the Admin Action  does not exist in ADMIN_ITEM table !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 -  Return TRUE
.head 5 +  Function: PlanedMovement_InsAdmAction
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npFallKey
.head 7 -  Number: npBewPlanNr
.head 7 -  String: spAdminItemKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nIdminItemNr
.head 6 +  Actions
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return 0
.head 7 -  !
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( ADMIN_ITEM_NR ) + 1
from	LST_ADM_TODO_ITEMS
where	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	FALL_KEY = " || StrX( nPlan_Fall_Key ) || "
   and	LST_ERF_NR =  " || StrX( nPlan_LstErfNr ) || "
into	:nIdminItemNr " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 7 +  If Not bOk
.head 8 +  If nFetch = FETCH_EOF
.head 9 -  Set bOk = TRUE
.head 8 +  Else
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return 0
.head 7 +  If Not nIdminItemNr
.head 8 -  Set nIdminItemNr = 1
.head 7 -  !
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert
into	LST_ADM_TODO_ITEMS (
	EINRICHT_ID, FALL_KEY, LST_ERF_NR,
	ADMIN_ITEM_NR, 	ADMIN_ITEM_KEY, 
	ITEM_EINRICHT_ID, ITEM_FALL_KEY, ITEM_BEW_NR )
values (	" || StrX( nEinrichtId ) || ", " || StrX( nPlan_Fall_Key ) || ", " || StrX( nPlan_LstErfNr ) || ", " || StrX( nIdminItemNr ) || ",
	'" || spAdminItemKey || "', " || StrX( nEinrichtId ) || ", " || StrX( npFallKey ) || ", " || StrX( npBewPlanNr ) || " )" )
.head 7 +  If bOk
.head 8 -  Set bOk = SqlCommit( hSql )
.head 7 +  If Not bOk
.head 8 -  Call SqlPrepareAndExecute( hSql, 'rollback' )
.head 8 -  Set nIdminItemNr = 0
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  Return nIdminItemNr
.head 5 +  Function: PlanedMovement_WithRack2d
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBet[*]
.head 7 -  Number: hBetFem
.head 7 -  Number: hBetFem1
.head 7 -  Number: hBetMale
.head 7 -  Number: nStat
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrM
.head 7 -  Number: nGrp
.head 7 -  Number: nBet
.head 7 -  Number: nFemale
.head 7 -  Number: nFemale2
.head 7 -  Number: nMale
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: l
.head 7 -  Number: a
.head 7 -  Number: nBound
.head 7 -  Number: hCurrent
.head 7 -  Number: hAbt
.head 7 -  Number: hSta
.head 7 -  Number: hSourceFem
.head 7 -  Number: hSourceMale
.head 7 -  Number: hTarget
.head 7 -  Number: nCounter
.head 7 -  Number: nCount
.head 7 -  String: sBetKey 
.head 7 -  String: sBettKeyTmp
.head 7 -  String: sGrpKey
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sBA_Key 
.head 7 -  String: sMetingSt
.head 7 -  String: sMetingGr
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  String: sRoomCage
.head 7 -  String: asRoomCage[*]
.head 7 -  Number: nQBed
.head 7 -  Number: nCountEmptyCage
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Boolean: bE
.head 7 -  Number: hFT
.head 7 -  Number: hFT1
.head 7 -  Number: hMT
.head 7 -  Sql Handle: hSql
.head 7 -  Window Handle: ahTargetCage[*]
.head 7 -  !
.head 7 -  FunctionalVar: cSourceF
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSourceM
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  !
.head 7 -  FunctionalVar: cCages[3]
.head 8 -  Class: clsLocation
.head 7 -  String: sCagesList
.head 6 +  Actions
.head 7 +  If bMatingActive 
.head 8 -  Return FALSE
.head 7 -  Set bMatingActive=TRUE
.head 7 -  Call MassMating(nFem,bMassMating)
.head 7 +  ! If bMassMating and Not bPlanningMode
.head 8 -  Call MassMating(nFem)
.head 7 +  ! Else
.head 8 +  If FALSE
.head 9 -  Set sAbtKey = ""
.head 9 -  Set sStatKey = ""
.head 9 -  Set sGrpKey = ""
.head 9 -  Set sGrpKey = GetKey_ByHandle( nSelectedHandle )
.head 9 -  Set hSta = GetParent( nSelectedHandle )
.head 9 -  Set sStatKey = GetKey_ByHandle( hSta )
.head 9 -  Set hAbt = GetParent( hSta )
.head 9 -  Set sAbtKey = GetKey_ByHandle( hAbt )
.head 9 -  ! Call MassMating(nFem)
.head 9 -  ! Chek selected cage
.head 9 +  If TRUE
.head 10 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 10 -  ! If nBet=1
.head 10 -  Set bE=TRUE
.head 10 -  Set nBet=  QuantityOfEmptyBett(nSelectedHandle)
.head 10 +  If nBet
.head 11 -  Set l = 0
.head 11 +  Loop 
.head 12 +  If l >= nBet
.head 13 -  Break 
.head 12 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 12 +  If SalStrScan(sText2,"{") > 0
.head 13 -  Set bE=FALSE
.head 13 -  Break 
.head 12 -  Set l = l + 1
.head 11 -  !
.head 10 +  If bE and nBet >= 2+nFem
.head 11 +  If not GetIsRackVirtual_ByHandle(hStat[ i ]) or bPlanningMode
.head 12 -  Set sMetingSt=sStatKey
.head 12 -  Set sMetingGr=sGrpKey
.head 12 -  Set hTarget=nSelectedHandle
.head 9 -  Set nStat = EnumChildren( hAbt, hStat )
.head 9 +  If nStat
.head 10 -  Set i = 0
.head 10 +  Loop 
.head 11 +  If i >= nStat
.head 12 -  Break 
.head 11 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 11 -  Set sStatKey = GetKey_FromLable (sText)
.head 11 -  Set nGrp = EnumChildren( hStat[ i ], hGrp )
.head 11 +  If nGrp
.head 12 -  Set k = 0
.head 12 +  Loop 
.head 13 +  If k >= nGrp
.head 14 -  Break 
.head 13 -  Call GetItemData( hGrp[ k ], sText1, nValueLoc1, nFlags1 )
.head 13 +  ! If SalStrScan(sText1, "MTT")>0
.head 14 -  Return FALSE
.head 13 -  ! --------------- chek cage ---------------
.head 13 -  Set sGrpKey = GetKey_FromLable (sText1)
.head 13 -  Set nBet = EnumChildren( hGrp[ k ], hBet )
.head 13 -  Set bF=FALSE
.head 13 -  Set bM=FALSE
.head 13 -  Set hFT=0
.head 13 -  Set hFT1=0
.head 13 -  Set hMT=0
.head 13 +  If nBet
.head 14 -  Set l = 0
.head 14 +  Loop 
.head 15 +  If l >= nBet
.head 16 -  Break 
.head 15 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 15 -  Set sBetKey = GetKey_FromLable (sText2)
.head 15 +  If SalStrScan(sText2,"{") > 0
.head 16 +  If Not SalStrScan(sText2,"PB")>0
.head 17 +  If not SalStrScan(sText2, " T ") > 0
.head 18 +  If SalStrScan(sText2, ", F,")>0
.head 19 -  Set bF=TRUE
.head 19 +  If not hFT1 and nFem=1 and hFT
.head 20 -  Set hFT1=hBet[ l ]
.head 19 +  If not hFT
.head 20 -  Set hFT=hBet[ l ]
.head 18 +  If SalStrScan(sText2, ", M,")>0
.head 19 -  Set bM=TRUE
.head 19 +  If not hMT
.head 20 -  Set hMT=hBet[ l ]
.head 15 -  Set l = l + 1
.head 14 -  !
.head 13 +  If not (bM or bF) and nBet >= 2+nFem and not hTarget
.head 14 +  If not GetIsRackVirtual_ByHandle(hStat[ i ]) or bPlanningMode
.head 15 -  Set sMetingSt=sStatKey
.head 15 -  Set sMetingGr=sGrpKey
.head 15 -  Set hTarget=hGrp[ k ]
.head 13 +  If bM and not bF and not hBetMale
.head 14 -  Set hBetMale= hMT
.head 14 -  Set nMale= GetFallKey_ByHandle(hMT)
.head 14 -  Set hSourceMale=hGrp[ k ]
.head 13 +  If bF and not bM and not hBetFem and ( not nFem or hFT1 )
.head 14 -  Set hBetFem= hFT
.head 14 -  Set nFemale= GetFallKey_ByHandle(hFT)
.head 14 -  Set hSourceFem=hGrp[ k ]
.head 14 +  If not nFemale2 and nFem
.head 15 -  Set nFemale2= GetFallKey_ByHandle(hFT1)
.head 15 -  Set hBetFem1= hFT1
.head 13 -  ! ------ if all vars found - stop
.head 13 +  If hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 14 -  Break 
.head 13 -  Set k = k + 1
.head 11 -  ! ------ if all vars found - stop
.head 11 +  If hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 12 -  Break 
.head 11 -  Set i = i + 1
.head 9 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 9 +  If nBound>0
.head 10 -  Set a=0
.head 10 -  Set nFemale2 =0
.head 10 -  Set nFemale =0
.head 10 -  Set nMale =0
.head 10 +  While a<= nBound
.head 11 -  Call GetItemData( HandleToPlace[a,1], sText2, nValueLoc2, nFlags2 )
.head 11 +  If not SalStrScan(sText2, " T ") > 0
.head 12 +  If GetSex_ByHandle( HandleToPlace[a,1])=0
.head 13 -  Set nFemale = HandleToPlace[a,0]
.head 13 +  If nFem =1 and nFemale2=0
.head 14 -  Set nFemale2= nFemale
.head 14 -  Set nFemale=0
.head 12 +  Else 
.head 13 -  Set nMale = HandleToPlace[a,0]
.head 11 -  Set a=a+1
.head 9 -  Set sBA_Key = 'UE'
.head 9 -  Set dtBewZeit_New= GetTime4Refresh()
.head 9 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtBewZeit_New, sGrund1, sGrund2 )
.head 10 -  Set bMatingActive=FALSE
.head 10 -  Return FALSE
.head 9 +  If nFemale and nMale And sMetingSt
.head 10 +  If bPlanningMode
.head 11 -  Set sBettKeyTmp = AddWonBettX( sAbtKey, sMetingSt, sMetingGr, dtBewZeit_New )
.head 11 +  If Not PlanedMovement_AddMvmnt(nMale, dtBewZeit_New, sBA_Key,"", "", sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp,TRUE)
.head 12 -  Call DoCloseTransaction( FALSE )
.head 12 -  Set bMatingActive=FALSE
.head 12 -  Return FALSE
.head 11 -  Set sBettKeyTmp = AddWonBettX( sAbtKey, sMetingSt, sMetingGr, dtBewZeit_New )
.head 11 +  If Not PlanedMovement_AddMvmnt(nFemale, dtBewZeit_New, sBA_Key,"", "", sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp,TRUE)
.head 12 -  Call DoCloseTransaction( FALSE )
.head 12 -  Set bMatingActive=FALSE
.head 12 -  Return FALSE
.head 11 -  Set sBettKeyTmp = AddWonBettX( sAbtKey, sMetingSt, sMetingGr, dtBewZeit_New )
.head 11 +  If nFem=1 and nFemale2!=0
.head 12 +  If Not PlanedMovement_AddMvmnt(nFemale2, dtBewZeit_New, sBA_Key,"", "", sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp,TRUE)
.head 13 -  Call DoCloseTransaction( FALSE )
.head 13 -  Set bMatingActive=FALSE
.head 13 -  Return FALSE
.head 12 -  Call RefreshBettAfterMove(hBetFem1)
.head 11 -  Call SalArraySetUpperBound ( HandleToPlace, 0, -1 )
.head 11 -  Call SalArraySetUpperBound ( HandleToPlace, 1, -1 )
.head 11 -  ! Call RefreshBettAfterMove(hBetMale)
.head 11 -  ! Call RefreshBettAfterMove(hBetFem)
.head 11 -  ! Call PopulateGruppe (hSourceFem,TRUE)
.head 11 -  ! Call PopulateGruppe (hSourceMale,TRUE)
.head 11 -  ! Call PopulateGruppeLight (hTarget,TRUE)
.head 11 -  Call KHE_RefreshGruppe (hSourceFem)
.head 11 -  Call KHE_RefreshGruppe (hSourceMale)
.head 11 -  Call KHE_RefreshGruppe (hTarget)
.head 11 -  Call Rack2DView_RefreshCageContents("")
.head 11 -  Call Finish_Movement(FALSE, sAbtKey, sMetingSt, sMetingGr,"")
.head 11 -  Call DoCommit()
.head 11 -  Call DoCloseTransaction( TRUE )
.head 10 +  Else 
.head 11 -  Call LT_OpenTransaction( 1, dtBewZeit_New )
.head 11 -  Call LockSysadmAction("Perfrm mate pair/trio...")
.head 11 -  Set sBettKeyTmp = AddWonBettX( sAbtKey, sMetingSt, sMetingGr, dtBewZeit_New )
.head 11 -  Set nBewNrM = InsertBewegung( nMale, 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp,"", "", "", "" )
.head 11 +  If nBewNrM<=0
.head 12 -  Call DoCloseTransaction( FALSE )
.head 12 -  Call LT_CloseLastTransaction(  )
.head 12 -  Set bMatingActive=FALSE
.head 12 -  Return FALSE
.head 11 -  Set sBettKeyTmp = AddWonBettX( sAbtKey, sMetingSt, sMetingGr, dtBewZeit_New )
.head 11 -  Set nBewNrF = InsertBewegung( nFemale, 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp,"", "", "", "" )
.head 11 +  If nBewNrF <=0
.head 12 -  Call DoCloseTransaction( FALSE )
.head 12 -  Call LockSysadmAction("...mate pair/trio failed")
.head 12 -  Call LT_CloseLastTransaction(  )
.head 12 -  Set bMatingActive=FALSE
.head 12 -  Return FALSE
.head 11 -  Set sBettKeyTmp = AddWonBettX( sAbtKey, sMetingSt, sMetingGr, dtBewZeit_New )
.head 11 +  If nFem=1 and nFemale2!=0
.head 12 -  Set nBewNrF1 = InsertBewegung( nFemale2, 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp,"", "", "", "" )
.head 12 +  If nBewNrF1<=0
.head 13 -  Call DoCloseTransaction( FALSE )
.head 13 -  Call LockSysadmAction("...mate pair/trio failed")
.head 13 -  Call LT_CloseLastTransaction(  )
.head 13 -  Set bMatingActive=FALSE
.head 13 -  Return FALSE
.head 12 -  Call RefreshBettAfterMove(hBetFem1)
.head 11 -  Call LockSysadmAction("...mate pair/trio performed")
.head 11 -  Call LT_CloseLastTransaction(  )
.head 11 -  Call DoCloseTransaction( TRUE )
.head 11 -  Call Transfer_AppendToAll( sBA_Key, nMale, nBewNrM )
.head 11 -  Call Transfer_AppendToAll( sBA_Key, nFemale, nBewNrF )
.head 11 -  Call Transfer_AppendToAll( sBA_Key, nFemale, nBewNrF1 )
.head 11 +  While a>=0
.head 12 -  Call RefreshBettAfterMove(HandleToPlace[a,1])
.head 12 -  Set a=a-1
.head 11 -  Call SalArraySetUpperBound ( HandleToPlace, 0, -1 )
.head 11 -  Call SalArraySetUpperBound ( HandleToPlace, 1, -1 )
.head 11 -  ! Call RefreshBettAfterMove(hBetFem)
.head 11 -  ! Call RefreshBettAfterMove(hBetMale)
.head 11 -  ! Call PopulateGruppe (hSourceFem,TRUE)
.head 11 -  ! Call PopulateGruppe (hSourceMale,TRUE)
.head 11 -  ! Call PopulateGruppe (hTarget,TRUE)
.head 11 -  Call KHE_RefreshGruppe (hSourceFem)
.head 11 -  Call KHE_RefreshGruppe (hSourceMale)
.head 11 -  Call KHE_RefreshGruppe (hTarget)
.head 11 -  !
.head 11 -  Call GetPosition ( hSourceFem, sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp )
.head 11 -  Set sCagesList = sMetingGr
.head 11 -  Call cSourceF.Init ( sAbtKey, sMetingSt, sMetingGr )
.head 11 -  Call GetPosition ( hSourceMale, sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp )
.head 11 -  Set sCagesList = sCagesList||","||sMetingGr
.head 11 -  Call cSourceM.Init( sAbtKey, sMetingSt, sMetingGr )
.head 11 -  Call GetPosition ( hTarget, sAbtKey, sMetingSt, sMetingGr, sBettKeyTmp )
.head 11 -  Set sCagesList = sCagesList||","||sMetingGr
.head 11 -  Call cDestination.Init ( sAbtKey, sMetingSt, sMetingGr )
.head 11 -  Call Rack2DView_RefreshCageContents(sCagesList)
.head 11 -  Call POC_CloseAndUnregister(hSourceFem)
.head 11 -  Call POC_CloseAndUnregister(hSourceMale)
.head 11 -  !
.head 11 -  Set cSource[0] = cSourceF
.head 11 -  Set cSource[1] = cSourceM
.head 11 -  Call Move_PrintCageCards(cSource,cDestination)
.head 11 +  ! If GalGetProfileBooleanX( 'Settings', 'PrintCageCardsOnMovement', TRUE, sGHSini_FileName )
.head 12 -  Set cCages[0] = cSourceF
.head 12 -  Set cCages[1] = cSourceM
.head 12 -  Set cCages[2] = cDestination
.head 12 -  Set bPrint=Requst_ListForCageCard( cCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 12 -  Call GetTime4Refresh( )
.head 12 +  If bPrint
.head 13 -  Call Formular_CageCard_Print( '', '', dtKHK_RefreshTime )
.head 13 -  ! Set nCounter = 0
.head 13 -  ! Call SalArrayGetUpperBound( cCages, 1, nCount )
.head 13 +  ! Loop
.head 14 +  If nCounter > nCount
.head 15 -  Break 
.head 14 -  Set sCageKey = cCages[nCounter].GetCageKey( )
.head 14 -  Set sRackKey = cCages[nCounter].GetRackKey( )
.head 14 +  If KHE_CageFormularWithLitter ( sRackKey, sCageKey )
.head 15 +  If KHE_RackIsIntensiv ( sRackKey )
.head 16 -  Call Formular_CageCardX( sRackKey, sCageKey, dtKHK_RefreshTime, '4', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 15 +  Else 
.head 16 -  Call Formular_CageCardX( sRackKey, sCageKey, dtKHK_RefreshTime, '2', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 14 +  Else 
.head 15 +  If KHE_RackIsIntensiv ( sRackKey )
.head 16 -  Call Formular_CageCardX( sRackKey, sCageKey, dtKHK_RefreshTime, '3', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 15 +  Else 
.head 16 -  Call Formular_CageCardX( sRackKey, sCageKey, dtKHK_RefreshTime, '1', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 14 -  Set nCounter = nCounter + 1
.head 11 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 9 +  Else 
.head 10 -  Set bMatingActive=FALSE
.head 10 -  Return FALSE
.head 7 -  Set bMatingActive=FALSE
.head 5 +  Function: CanPlanedMovement_WithRack2d
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBet[*]
.head 7 -  Number: hBetFem
.head 7 -  Number: hBetFem1
.head 7 -  Number: hBetMale
.head 7 -  Number: nStat
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrM
.head 7 -  Number: nGrp
.head 7 -  Number: nBet
.head 7 -  Number: nFemale
.head 7 -  Number: nFemale2
.head 7 -  Number: nMale
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: l
.head 7 -  Number: w
.head 7 -  Number: hCurrent
.head 7 -  Number: hAbt
.head 7 -  Number: hSta
.head 7 -  Number: hSourceFem
.head 7 -  Number: hSourceFem2
.head 7 -  Number: hSourceMale
.head 7 -  Number: hTarget
.head 7 -  Number: nCounter
.head 7 -  Number: nCount
.head 7 -  Number: nBound
.head 7 -  String: sBetKey 
.head 7 -  String: sBettKeyTmp
.head 7 -  String: sGrpKey
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sBA_Key 
.head 7 -  String: sMetingSt
.head 7 -  String: sMetingGr
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Boolean: bE
.head 7 -  Number: hFT
.head 7 -  Number: hFT1
.head 7 -  Number: hMT
.head 7 -  Sql Handle: hSql
.head 7 -  !
.head 7 -  ! clsLocationCage: cSourceF
.winattr class FunctionalVar:
.head 8 -  Class: clsLocationCage
.end
.head 7 -  ! clsLocationCage: cSourceM
.winattr class FunctionalVar:
.head 8 -  Class: clsLocationCage
.end
.head 7 -  ! clsLocationCage: cDestination
.winattr class FunctionalVar:
.head 8 -  Class: clsLocationCage
.end
.head 7 -  !
.head 7 -  ! clsLocation: cCages[3]
.winattr class FunctionalVar:
.head 8 -  Class: clsLocation
.end
.head 7 -  Number: nNext
.head 7 -  Boolean: bMale
.head 7 -  Boolean: bFeMale
.head 7 -  Boolean: bFeMale2
.head 7 -  Sql Handle: hSqlRoling
.head 7 -  Number: nFetch
.head 7 -  Number: nFallKey
.head 7 -  Boolean: bExists
.head 6 +  Actions
.head 7 -  Return CanMate( nFem )
.head 7 -  !
.head 7 +  ! If nSelectedLevel != KHEL_Gruppe 
.head 8 -  Return FALSE
.head 7 +  ! If CageIsEmpty_ByHandle()
.head 8 -  Return FALSE
.head 7 +  ! If not GalConnect( hSqlRoling )
.head 8 -  Return FALSE
.head 7 -  ! Set bExists = FALSE
.head 7 -  ! Set sGrpKey = GetKey_ByHandle( nSelectedHandle )
.head 7 -  ! Set hSta = GetParent( nSelectedHandle )
.head 7 -  ! Set sStatKey = GetKey_ByHandle( hSta )
.head 7 +  ! If SqlPrepareAndExecute( hSqlRoling, "select * from cadavers where rack=:sStatKey  and cage=:sGrpKey  " )
.head 8 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 9 -  Set bExists = TRUE
.head 7 -  ! Call DelNul()
.head 7 +  ! If not bExists
.head 8 +  If not SalArrayIsEmpty( HandleToPlace )
.head 9 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 9 -  Call SqlPrepare( hSqlRoling,  "select rf.fall_key 
  from roling_fall rf 
where rf.status = 0  and rf.fall_key=:nFallKey

union

select b.fall_key
 from sysadm.bewegung b 
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.fall_key = :nFallKey
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 9 +  If bMassMating
.head 10 -  Set nNext=0
.head 10 -  Set bMale=FALSE
.head 10 -  Set bFeMale=FALSE
.head 10 -  Set bFeMale2=FALSE
.head 10 +  If nFem=1 and nBound = 2
.head 11 +  While nNext<=nBound
.head 12 -  Set nFallKey = HandleToPlace[nNext,1]
.head 12 +  If SqlExecute( hSqlRoling )
.head 13 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 14 -  Call SqlDisconnect( hSqlRoling )
.head 14 -  Return FALSE
.head 12 -  Call GetItemData( HandleToPlace[nNext,1], sText2, nValueLoc2, nFlags2 )
.head 12 +  If Not SalStrScan(sText2," T ")>0
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =1
.head 14 -  Set bMale=TRUE
.head 14 +  If not hSourceMale
.head 15 -  Set hSourceMale = GetParent( HandleToPlace[nNext,1] )
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =0
.head 14 +  If bFeMale
.head 15 -  Set bFeMale2=TRUE
.head 15 -  Set hSourceFem2 = GetParent( HandleToPlace[nNext,1] )
.head 14 +  Else 
.head 15 -  Set bFeMale=TRUE
.head 15 -  Set hSourceFem = GetParent( HandleToPlace[nNext,1] )
.head 12 +  Else 
.head 13 -  Return FALSE
.head 12 -  Set nNext=nNext+1
.head 11 +  If bMale and bFeMale and bFeMale2 and hSourceFem != hSourceMale and hSourceFem2 != hSourceMale
.head 12 -  Return TRUE
.head 10 +  If nFem=0 and nBound = 1
.head 11 +  While nNext<=nBound
.head 12 -  Call GetItemData( HandleToPlace[nNext,1], sText2, nValueLoc2, nFlags2 )
.head 12 +  If Not SalStrScan(sText2," T ")>0
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =1
.head 14 -  Set bMale=TRUE
.head 14 +  If not hSourceMale
.head 15 -  Set hSourceMale = GetParent( HandleToPlace[nNext,1] )
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =0
.head 14 -  Set bFeMale=TRUE
.head 14 +  If not hSourceFem
.head 15 -  Set hSourceFem = GetParent( HandleToPlace[nNext,1] )
.head 12 +  Else 
.head 13 -  Return FALSE
.head 12 -  Set nNext=nNext+1
.head 11 +  If bMale and bFeMale and hSourceFem != hSourceMale 
.head 12 -  Return TRUE
.head 9 +  Else 
.head 10 -  Set i = 0
.head 10 +  Loop 
.head 11 +  If i > nBound
.head 12 -  Break 
.head 11 -  Set nFallKey = HandleToPlace[i,1]
.head 11 +  If SqlExecute( hSqlRoling )
.head 12 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 13 -  Call SqlDisconnect( hSqlRoling )
.head 13 -  Return FALSE
.head 11 -  Set i = i + 1
.head 10 -  Call GetItemData( HandleToPlace[0,1], sText2, nValueLoc2, nFlags2 )
.head 10 +  If Not SalStrScan(sText2," T ")>0
.head 11 -  Call GetItemData( HandleToPlace[1,1], sText2, nValueLoc2, nFlags2 )
.head 11 +  If Not SalStrScan(sText2," T ")>0
.head 12 +  If nFem=1 and nBound =2
.head 13 +  If ((GetSex_ByHandle(HandleToPlace[0,1]))+ (GetSex_ByHandle(HandleToPlace[1,1]))+(GetSex_ByHandle(HandleToPlace[2,1])))= 1
.head 14 -  Return TRUE
.head 12 +  If nFem=0 and nBound =1
.head 13 -  Call GetItemData( HandleToPlace[1,1], sText2, nValueLoc2, nFlags2 )
.head 13 +  If Not SalStrScan(sText2," T ")>0
.head 14 +  If ((GetSex_ByHandle(HandleToPlace[0,1])) + (GetSex_ByHandle(HandleToPlace[1,1]))) = 1 
.head 15 -  Return TRUE
.head 9 -  Return FALSE
.head 8 +  Else 
.head 9 -  Set sAbtKey = ""
.head 9 -  Set sStatKey = ""
.head 9 -  Set sGrpKey = ""
.head 9 -  Set sGrpKey = GetKey_ByHandle( nSelectedHandle )
.head 9 -  Set hSta = GetParent( nSelectedHandle )
.head 9 -  Set sStatKey = GetKey_ByHandle( hSta )
.head 9 -  Set hAbt = GetParent( hSta )
.head 9 -  Set sAbtKey = GetKey_ByHandle( hAbt )
.head 9 -  Call SqlPrepare( hSqlRoling,  "select rf.fall_key 
  from roling_fall rf join sysadm.bewegung b on (   b.einricht_id = :nEinrichtId and rf.fall_key= b.fall_key
						     and b.stat_key=:sStatKey  and b.gruppe_key = :sGrpKey
						     and @nullvalue(b.GELOESCHT,'N') ='N'
   			     and b.ba_key in ('AE','VE','UE','RE')
     			     and 	b.bew_zeit_bis is null )
 left join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
where rf.status = 0  

union

select b.fall_key
 from sysadm.bewegung b 
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.stat_key=:sStatKey and b.gruppe_key = :sGrpKey
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 9 -  ! ! Chek selected cage
.head 9 +  If TRUE
.head 10 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 10 -  ! If nBet=1
.head 10 -  Set nBet=  QuantityOfEmptyBett(nSelectedHandle)
.head 10 -  Set bE=TRUE
.head 10 +  If nBet
.head 11 -  Set l = 0
.head 11 +  Loop 
.head 12 +  If l >= nBet
.head 13 -  Break 
.head 12 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 12 +  If SalStrScan(sText2,"{") > 0
.head 13 -  Set bE=FALSE
.head 13 -  Break 
.head 12 -  Set l = l + 1
.head 11 -  !
.head 10 +  ! If bE and nBet >= 2+nFem and (not GetIsRackVirtual_ByHandle(hSta) or bPlanningMode)
.head 11 -  Set sMetingSt=sStatKey
.head 11 -  Set sMetingGr=sGrpKey
.head 11 -  Set hTarget=nSelectedHandle
.head 10 +  If bE and nBet >= 2+nFem
.head 11 -  Set sMetingSt=sStatKey
.head 11 -  Set sMetingGr=sGrpKey
.head 11 -  Set hTarget=nSelectedHandle
.head 10 +  Else 
.head 11 -  Return FALSE
.head 9 -  Set nStat = EnumChildren( hAbt, hStat )
.head 9 +  If nStat
.head 10 -  Set i = 0
.head 10 +  Loop 
.head 11 +  If i >= nStat
.head 12 -  Break 
.head 11 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 11 -  Set sStatKey = GetKey_FromLable (sText)
.head 11 -  Set nGrp = EnumChildren( hStat[ i ], hGrp )
.head 11 +  If nGrp
.head 12 -  Set k = 0
.head 12 +  Loop 
.head 13 +  If k >= nGrp
.head 14 -  Break 
.head 13 -  Call GetItemData( hGrp[ k ], sText1, nValueLoc1, nFlags1 )
.head 13 +  ! If SalStrScan(sText1, "MTT")>0
.head 14 -  Return FALSE
.head 13 -  ! --------------- chek cage ---------------
.head 13 -  Set sGrpKey = GetKey_FromLable (sText1)
.head 13 +  If SqlExecute( hSqlRoling )
.head 14 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 15 -  Call SqlDisconnect( hSqlRoling )
.head 15 -  Return FALSE
.head 13 -  Set nBet = EnumChildren( hGrp[ k ], hBet )
.head 13 -  Set bF=FALSE
.head 13 -  Set bM=FALSE
.head 13 -  Set hFT=0
.head 13 -  Set hFT1=0
.head 13 -  Set hMT=0
.head 13 +  If nBet
.head 14 -  Set l = 0
.head 14 +  Loop 
.head 15 +  If l >= nBet
.head 16 -  Break 
.head 15 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 15 -  Set sBetKey = GetKey_FromLable (sText2)
.head 15 +  If SalStrScan(sText2,"{") > 0
.head 16 +  If Not SalStrScan(sText2,"(PB)")>0 and Not SalStrScan(sText2," T ")>0
.head 17 +  If SalStrScan(sText2, ", F,")>0
.head 18 -  Set bF=TRUE
.head 18 +  If not hFT1 and nFem=1 and hFT
.head 19 -  Set hFT1=hBet[ l ]
.head 18 +  If not hFT
.head 19 -  Set hFT=hBet[ l ]
.head 17 +  If SalStrScan(sText2, ", M,")>0
.head 18 -  Set bM=TRUE
.head 18 +  If not hMT
.head 19 -  Set hMT=hBet[ l ]
.head 15 -  Set l = l + 1
.head 14 -  !
.head 13 +  If not (bM or bF) and nBet >= 2+nFem and not hTarget
.head 14 +  ! If not GetIsRackVirtual_ByHandle(hStat[ i ]) or bPlanningMode
.head 15 -  Set sMetingSt=sStatKey
.head 15 -  Set sMetingGr=sGrpKey
.head 15 -  Set hTarget=hGrp[ k ]
.head 14 -  Set sMetingSt=sStatKey
.head 14 -  Set sMetingGr=sGrpKey
.head 14 -  Set hTarget=hGrp[ k ]
.head 13 +  If bM and not bF and not hBetMale
.head 14 -  Set hBetMale= hMT
.head 14 -  Set nMale= GetFallKey_ByHandle(hMT)
.head 14 -  Set hSourceMale=hGrp[ k ]
.head 13 +  If bF and not bM and not hBetFem and ( not nFem or hFT1 )
.head 14 -  Set hBetFem= hFT
.head 14 -  Set nFemale= GetFallKey_ByHandle(hFT)
.head 14 -  Set hSourceFem=hGrp[ k ]
.head 14 +  If not nFemale2 and nFem
.head 15 -  Set nFemale2= GetFallKey_ByHandle(hFT1)
.head 15 -  Set hBetFem= hFT1
.head 13 -  ! ------ if all vars found - stop
.head 13 +  If hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 14 -  Break 
.head 13 -  Set k = k + 1
.head 11 -  ! ------ if all vars found - stop
.head 11 +  If hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 12 -  Break 
.head 11 -  Set i = i + 1
.head 9 -  Call SqlDisconnect( hSqlRoling )
.head 9 -  Return hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 7 -  ! Return FALSE
.head 5 -  ! !
.head 5 +  Function: MassMating
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 7 -  Boolean: bMass
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oEmptyCages[*]
.head 8 -  Class: cPositionData
.head 7 -  String: sBA_Key
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Sql Handle: hSqlSelect
.head 7 -  Number: nBound
.head 7 -  Number: nMales[*,2]
.head 7 -  Number: nFeMales[*,2]
.head 7 -  Number: nIndMale
.head 7 -  Number: nIndFeMale
.head 7 -  Number: nCountMale
.head 7 -  Number: nCountFeMale
.head 7 -  Number: nCountEmptyCage
.head 7 -  Number: nIndEmptyCage
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nBewNrM
.head 7 -  ! clsLocation: cCages[*]
.winattr class FunctionalVar:
.head 8 -  Class: clsLocation
.end
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nIndCage
.head 7 -  Number: nPrintCages[*]
.head 7 -  Number: nPrevCage
.head 7 -  Number: nCageID
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Number: hAbt
.head 7 -  Number: nFetch
.head 7 -  Boolean: bCancelBewegung
.head 7 -  Number: nCageRef[*]
.head 6 +  Actions
.head 7 -  Set bOk = CanMate( nFem )
.head 7 -  Set bCancelBewegung = FALSE
.head 7 -  Set bOk = bOk and _GetPositionID( nSelectedHandle, oPos )
.head 7 -  Set bOk = bOk and GalConnect( hSqlSelect )
.head 7 -  ! Clear vars
.head 7 +  If bOk
.head 8 -  Set nIndMale = -1
.head 8 -  Set nIndFeMale = -1
.head 8 -  Call SalArraySetUpperBound( nMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nFeMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( oEmptyCages, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( cSourceCage, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nPrintCages, 1, -1 )
.head 8 -  Set sGrund1=''
.head 8 -  Set sGrund2=''
.head 8 -  Set sBA_Key = 'UE'
.head 8 -  Set nIndCage = 0
.head 7 -  ! Prepare falls and empty cages
.head 7 +  If bOk
.head 8 +  If not SalArrayIsEmpty( HandleToPlace )
.head 9 -  Call SalArrayGetUpperBound( HandleToPlace, 1, nBound )
.head 9 -  Set bOk = bOk and SqlPrepare(hSqlSelect, "select last_cage_id from fall where einricht_id=:nEinrichtId and fall_key=:HandleToPlace[nBound,0] into :nCageID ")
.head 9 +  While nBound >=0 and bOk 
.head 10 -  Set bOk = bOk and SqlExecute(hSqlSelect) and SqlFetchNext(hSqlSelect, nFetch)
.head 10 +  If GetSex_ByHandle( HandleToPlace[nBound,1] )= 1
.head 11 -  Set nIndMale = nIndMale + 1
.head 11 -  Set nMales[nIndMale,0] = HandleToPlace[nBound,0]
.head 11 -  Set nMales[nIndMale,1] = nCageID
.head 10 +  Else
.head 11 -  Set nIndFeMale = nIndFeMale + 1
.head 11 -  Set nFeMales[nIndFeMale,0] = HandleToPlace[nBound,0]
.head 11 -  Set nFeMales[nIndFeMale,1] = nCageID
.head 10 -  Set nBound = nBound - 1
.head 9 -  Set nCountMale = nIndMale + 1
.head 9 -  Set nCountFeMale = nIndFeMale + 1
.head 8 +  Else
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlSelect, "select f.fall_key, t.id, g.gruppe_key,g.stat_key, g.rack_id
   from " || sUserName || ".t_cage t
   join fall f on(f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null and f.ee_datum is null)
   join gruppe g on (g.id = t.id )
where f.geschl='M'
order by t.id
into :nMales[nIndMale,0],:nMales[nIndMale,1]
" )
.head 9 -  Set nIndMale =0
.head 9 +  While bOk and SqlFetchNext(hSqlSelect, nFetch)
.head 10 -  Set nIndMale = nIndMale + 1 
.head 9 -  Set nCountMale = nIndMale
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlSelect, "select f.fall_key, t.id, g.gruppe_key,g.stat_key, g.rack_id
   from " || sUserName || ".t_cage t
   join fall f on(f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null and f.ee_datum is null )
   join gruppe g on (g.id = t.id )
where f.geschl!='M'
order by t.id
into :nFeMales[nIndFeMale,0],:nFeMales[nIndFeMale,1]
" )
.head 9 -  Set nIndFeMale =0
.head 9 +  While bOk and SqlFetchNext(hSqlSelect, nFetch)
.head 10 -  Set nIndFeMale = nIndFeMale + 1 
.head 9 -  Set nCountFeMale = nIndFeMale
.head 8 -  ! Prepare array empty cages
.head 8 +  If bMass
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlSelect, "select t.id , g.gruppe_key, g.stat_key, g.rack_id, @if(t.id-:oPos.nCageID,t.id,0)
  from "|| sUserName ||".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.culling_id is null and f.ee_datum is null )
  join gruppe g on(g.id=t.id)
  left join cadavers c on (c.rack=g.stat_key and c.cage=g.gruppe_key)
where f.geschl is null and c.id is null
group by 1,2,3,4
having  count(f.fall_key)-count(f.culling_id)=0
order by 5
into :oEmptyCages[nIndEmptyCage].nCageID, :oEmptyCages[nIndEmptyCage].sCage, :oEmptyCages[nIndEmptyCage].sRack, :oEmptyCages[nIndEmptyCage].nRackID
")
.head 9 -  Set nIndEmptyCage = 0
.head 9 +  While bOk and SqlFetchNext( hSqlSelect, nFetch )
.head 10 -  Set nIndEmptyCage = nIndEmptyCage + 1
.head 8 +  Else
.head 9 -  Set oEmptyCages[0].nActHandel = oPos.nActHandel
.head 9 -  Set oEmptyCages[0].nCageID = oPos.nCageID
.head 9 -  Set oEmptyCages[0].nPosID= oPos.nPosID
.head 9 -  Set oEmptyCages[0].nRackID = oPos.nRackID
.head 9 -  Set oEmptyCages[0].nScreenID = oPos.nScreenID
.head 9 -  Set oEmptyCages[0].sBett = oPos.sBett
.head 9 -  Set oEmptyCages[0].sCage = oPos.sCage
.head 9 -  Set oEmptyCages[0].sRack = oPos.sRack
.head 9 -  Set oEmptyCages[0].sScreen = oPos.sScreen
.head 9 -  Set nIndEmptyCage = 1
.head 8 -  Set nCountEmptyCage = nIndEmptyCage
.head 7 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtBewZeit_New, sGrund1, sGrund2 )
.head 8 -  Set bOk = FALSE
.head 7 +  If not bPlanningMode
.head 8 -  Call LT_OpenTransaction( 1, dtBewZeit_New )
.head 7 -  ! Move animals
.head 7 -  Set nIndMale = 0
.head 7 -  Set nIndFeMale = 0
.head 7 -  Set nIndEmptyCage = 0
.head 7 +  While bOk and nIndMale < nCountMale and nIndFeMale + nFem < nCountFeMale and nIndEmptyCage < nCountEmptyCage
.head 8 +  If bPlanningMode
.head 9 +  If Not PlanedMovement_AddMvmnt(nMales[nIndMale,0], dtBewZeit_New, sBA_Key,"", "", oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, "1",TRUE)
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bOk = FALSE
.head 9 -  Set nIndMale=nIndMale+1
.head 9 +  If bOk and Not PlanedMovement_AddMvmnt(nFeMales[nIndFeMale,0], dtBewZeit_New, sBA_Key,"", "", oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, "2",TRUE)
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bOk = FALSE
.head 9 -  Set nIndFeMale=nIndFeMale + 1
.head 9 +  If nFem=1
.head 10 +  If bOk and Not PlanedMovement_AddMvmnt(nFeMales[nIndFeMale,0], dtBewZeit_New, sBA_Key,"", "",oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, "3",TRUE)
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bOk = FALSE
.head 10 -  Set nIndFeMale=nIndFeMale + 1
.head 10 -  ! Call RefreshBettAfterMove(hSourceFF)
.head 9 -  Call DoCommit()
.head 9 -  Call DoCloseTransaction( TRUE )
.head 8 +  Else
.head 9 -  Set nBewNrF = InsertBewegung(nFeMales[nIndFeMale,0], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, AddWonBettX( oPos.sScreen, 
oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage,dtBewZeit_New ),"", "", "", "" )
.head 9 +  If nBewNrF <=0
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bOk = FALSE
.head 9 +  If nFem=1 and bOk
.head 10 -  Set nIndFeMale = nIndFeMale + 1
.head 10 -  Set nBewNrF1 = InsertBewegung(nFeMales[nIndFeMale,0], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2,  oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, AddWonBettX( oPos.sScreen, 
oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage,dtBewZeit_New ),"", "", "", "" )
.head 10 +  If nBewNrF1 <=0
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bOk = FALSE
.head 9 -  Set nIndFeMale = nIndFeMale + 1
.head 9 +  If bOk
.head 10 -  Set nBewNrM = InsertBewegung(nMales[nIndMale,0], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2,  oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, AddWonBettX( oPos.sScreen, 
oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage,dtBewZeit_New ),"", "", "", "" )
.head 10 +  If nBewNrM<=0
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bOk = FALSE
.head 10 -  Set nIndMale = nIndMale + 1
.head 10 +  If not bOk
.head 11 -  Set nCageRef[0]=0
.head 11 +  If nFem=1
.head 12 -  Call DeleteMovement(hWndNULL,  nFeMales[nIndFeMale - 1 ,0],nBewNrF1,nCageRef )
.head 12 -  Call DeleteMovement(hWndNULL,  nFeMales[nIndFeMale - 2,0],nBewNrF,nCageRef )
.head 11 +  Else
.head 12 -  Call DeleteMovement(hWndNULL,  nFeMales[nIndFeMale - 1,0],nBewNrF,nCageRef )
.head 11 -  If nFem=1
.head 11 -  Set bCancelBewegung = TRUE
.head 9 +  If bOk
.head 10 -  Call DoCloseTransaction( TRUE )
.head 10 -  Call Transfer_AppendToAll( sBA_Key, nMales[nIndMale-1,0], nBewNrM )
.head 10 +  If nFem=1
.head 11 -  Call Transfer_AppendToAll( sBA_Key, nFeMales[nIndFeMale-2,0], nBewNrF )
.head 11 -  Call Transfer_AppendToAll( sBA_Key,  nFeMales[nIndFeMale-1,0], nBewNrF1 )
.head 10 +  Else
.head 11 -  Call Transfer_AppendToAll( sBA_Key,  nFeMales[nIndFeMale-1,0], nBewNrF )
.head 10 -  Call cSourceCage[nIndCage].Init( oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage )
.head 10 -  Set nIndCage = nIndCage + 1
.head 9 -  Set nIndEmptyCage = nIndEmptyCage + 1
.head 7 -  Set bOk = (bOk or bCancelBewegung) and (nIndCage > 0)
.head 7 -  Set bOk = bOk and SqlPrepare(hSqlSelect, "select g.stat_key, g.gruppe_key
				from gruppe g 
				where g.id=:nCageID
                                            into :sRack, :sCage ")
.head 7 +  If bOk
.head 8 -  Set hAbt = GetParent( GetParent(nSelectedHandle) )
.head 8 -  Set nCageID = -1
.head 7 -  ! Refresh and prepare print cages with male
.head 7 +  Loop
.head 8 -  Set nIndMale = nIndMale - 1
.head 8 +  If nIndMale < 0 or not bOk
.head 9 -  Break
.head 8 +  If nCageID != nMales[nIndMale,1]
.head 9 -  Set nCageID = nMales[nIndMale,1]
.head 9 -  Set bOk = bOk and SqlExecute(hSqlSelect) and SqlFetchNext(hSqlSelect, nFetch)
.head 9 +  If bOk
.head 10 +  If not CageIsEmpty(  sRack, sCage, GetTime4Refresh(), FALSE )
.head 11 -  Call CloseGruppe(  oPos.sScreen, sRack, sCage )
.head 10 +  Else
.head 11 -  Call KHE_RefreshGruppe(SearchFrom(SearchFrom( hAbt, sRack ), sCage))
.head 11 -  Call cSourceCage[nIndCage].Init( oPos.sScreen, sRack, sCage )
.head 11 -  Set nIndCage = nIndCage + 1
.head 7 -  ! Refresh and prepare print cages with female
.head 7 +  Loop
.head 8 -  Set nIndFeMale = nIndFeMale - 1
.head 8 +  If nIndFeMale < 0 or not bOk
.head 9 -  Break
.head 8 +  If nCageID != nFeMales[nIndFeMale,1]
.head 9 -  Set nCageID = nFeMales[nIndFeMale,1]
.head 9 -  Set bOk = bOk and SqlExecute(hSqlSelect) and SqlFetchNext(hSqlSelect, nFetch)
.head 9 +  If bOk
.head 10 +  If not CageIsEmpty(  sRack, sCage, GetTime4Refresh(), FALSE )
.head 11 -  Call CloseGruppe(  oPos.sScreen, sRack, sCage )
.head 10 +  Else
.head 11 -  Call KHE_RefreshGruppe(SearchFrom(SearchFrom( hAbt, sRack ), sCage))
.head 11 -  Call cSourceCage[nIndCage].Init( oPos.sScreen, sRack, sCage )
.head 11 -  Set nIndCage = nIndCage + 1
.head 7 +  If bOk
.head 8 -  Set cDest = cSourceCage[nIndCage - 1]
.head 7 -  ! Refresh Source cages
.head 7 +  Loop
.head 8 -  Set nIndEmptyCage = nIndEmptyCage - 1
.head 8 +  If nIndEmptyCage<0 or not bOk
.head 9 -  Break
.head 8 +  If not CageIsEmpty( oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, GetTime4Refresh(), FALSE )
.head 9 -  Call CloseGruppe(  oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage )
.head 8 +  Else
.head 9 -  Call KHE_RefreshGruppe(SearchFrom(SearchFrom( hAbt, oEmptyCages[nIndEmptyCage].sRack ), oEmptyCages[nIndEmptyCage].sCage))
.head 7 +  ! While (3*nIndex1<=nCountEmptyCage) and (nIndex2<=nCountMale-1) and ((nIndex3+nFem)<=nCountFemale-1) and (nCountEmptyCage>0)
.head 8 +  ! If bPlanningMode
.head 9 +  If Not PlanedMovement_AddMvmnt(SalStrToNumber( asMale[nIndex2,0]), dtBewZeit_New, sBA_Key,"", "", sAbtKey, asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1], "1",TRUE)
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Return FALSE
.head 9 -  Set nIndex2=nIndex2+1
.head 9 +  If Not PlanedMovement_AddMvmnt(SalStrToNumber(asFemale[nIndex3,0]), dtBewZeit_New, sBA_Key,"", "", sAbtKey, asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1], "2",TRUE)
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Return FALSE
.head 9 -  Set nIndex3=nIndex3+1
.head 9 +  If nFem=1
.head 10 +  If Not PlanedMovement_AddMvmnt(SalStrToNumber(asFemale[nIndex3+1,0]), dtBewZeit_New, sBA_Key,"", "", sAbtKey, asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1], "3",TRUE)
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Return FALSE
.head 10 -  Set nIndex3=nIndex3+1
.head 10 -  ! Call RefreshBettAfterMove(hSourceFF)
.head 9 -  Call DoCommit()
.head 9 -  Call DoCloseTransaction( TRUE )
.head 8 +  Else 
.head 9 -  Set nBewNrF = InsertBewegung(nFeMales[], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, sAbtKey, asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1], AddWonBettX( sAbtKey, 
asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1],dtBewZeit_New ),"", "", "", "" )
.head 9 +  If nBewNrF <0
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bOk = FALSE
.head 9 -  Set nIndex3=nIndex3+1
.head 9 +  If nFem=1
.head 10 -  Set nBewNrF1 = InsertBewegung(SalStrToNumber(asFemale[nIndex3,0]), 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, sAbtKey, asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1], AddWonBettX( sAbtKey, 
asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1],dtBewZeit_New ),"", "", "", "" )
.head 10 +  If nBewNrF1 <0
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Return FALSE
.head 10 -  Set nIndex3=nIndex3+1
.head 9 -  Set nBewNrM = InsertBewegung( SalStrToNumber(asMale[nIndex2,0]), 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, sAbtKey, asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1], AddWonBettX( sAbtKey, 
asEmptyRoomCage[3*nIndex1], asEmptyRoomCage[3*nIndex1+1],dtBewZeit_New ),"", "", "", "" )
.head 9 +  If nBewNrM<0
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Return FALSE
.head 9 -  Set nIndex2=nIndex2+1
.head 9 -  Call DoCloseTransaction( TRUE )
.head 9 -  Call Transfer_AppendToAll( sBA_Key, SalStrToNumber(asMale[nIndex2-1,0]), nBewNrM )
.head 9 +  If nFem=1
.head 10 -  Call Transfer_AppendToAll( sBA_Key, SalStrToNumber(asFemale[nIndex3-2,0]), nBewNrF )
.head 10 -  Call Transfer_AppendToAll( sBA_Key, SalStrToNumber(asFemale[nIndex3-1,0]), nBewNrF1 )
.head 9 +  Else 
.head 10 -  Call Transfer_AppendToAll( sBA_Key, SalStrToNumber(asFemale[nIndex3-1,0]), nBewNrF )
.head 8 -  Set anCageTarget[nIndex1] = SalStrToNumber(asEmptyRoomCage[3*nIndex1+2])
.head 8 -  Set nIndex1=nIndex1+1
.head 7 +  If not bPlanningMode
.head 8 -  Call LT_CloseLastTransaction(  )
.head 7 +  If hSqlSelect
.head 8 -  Call SqlDisconnect( hSqlSelect )
.head 7 -  Call Rack2DView_RefreshCageContents("")
.head 7 +  If not SalArrayIsEmpty( cSourceCage )
.head 8 -  Call Move_PrintCageCards(cSourceCage,cDest)
.head 7 -  Call UnSelect(  )
.head 7 -  ! Clear arrays
.head 7 +  If TRUE
.head 8 -  Call SalArraySetUpperBound( nMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nFeMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( oEmptyCages, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( cSourceCage, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nPrintCages, 1, -1 )
.head 7 -  !
.head 7 -  Return bOk
.head 5 +  Function: GetCurrentSexFromCage
.head 6 -  Description: If Sex is Female- bSex= False
If Sex is Male  bSex= True
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nSourceCage
.head 7 -  Number: nFem
.head 7 -  Receive String: sSexHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  Number: hBet[*]
.head 7 -  Number: nBet
.head 7 -  Number: l
.head 7 -  Boolean: bTRUE
.head 6 +  Actions
.head 7 -  Set nBet = EnumChildren( nSourceCage, hBet )
.head 7 -  Set sSexHandle=''
.head 7 -  Set sText=''
.head 7 -  Set bTRUE=TRUE
.head 7 +  If nBet
.head 8 -  Set l = 0
.head 8 +  Loop
.head 9 +  If l >= nBet
.head 10 -  Break
.head 9 -  Call GetItemData( hBet[ l ], sText, nValueLoc, nFlags )
.head 9 -  ! Set sBetKey = GetKey_FromLable (sText)
.head 9 +  If SalStrScan(sText,"{") > 0
.head 10 +  If Not SalStrScan(sText,"PB")>0
.head 11 +  If SalStrScan(sText, ", F,")>0
.head 12 +  If SalStrScan(sSexHandle, "F")>0 and nFem=1 and bTRUE
.head 13 -  Set sSexHandle=SalNumberToStrX(hBet[ l ],0)||','||sSexHandle
.head 13 -  Set bTRUE=FALSE
.head 12 +  If sSexHandle=''
.head 13 -  Set sSexHandle=SalNumberToStrX(hBet[ l ],0)||','||'F'
.head 11 +  If SalStrScan(sText, ", M,")>0
.head 12 +  If sSexHandle=''
.head 13 -  Set sSexHandle=SalNumberToStrX(hBet[ l ],0)||','||'M'
.head 9 -  Set l = l + 1
.head 8 -  !
.head 5 -  !
.head 5 +  Function: MultiSelect
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nDim
.head 7 -  Number: nFall
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 -  Set nFall = GetFallKey_ByHandle (nSelectedHandle)
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 +  If KHE_IsOccupied_ByHandle( nSelectedHandle, dtTime)
.head 8 -  Return FALSE
.head 7 +  If nFall= NUMBER_Null or nFall = 0
.head 8 -  Return FALSE
.head 7 +  If nBound=0 and HandleToPlace[0,0]= 0
.head 8 +  If HandleToPlace[nBound,0]=0
.head 9 -  Set HandleToPlace[0,0] = nFall
.head 9 -  Set HandleToPlace[0,1] = nSelectedHandle
.head 9 -  Call clsExplorerLeft.KHEReAssignPics(nSelectedHandle)
.head 9 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 9 -  Return TRUE
.head 7 -  Set i=0
.head 7 +  While i<=  nBound
.head 8 +  If HandleToPlace[i,0]= nFall
.head 9 +  While i<  nBound
.head 10 -  Set HandleToPlace[i,0]= HandleToPlace[i+1,0]
.head 10 -  Set HandleToPlace[i,1]= HandleToPlace[i+1,1]
.head 10 -  Set i=i+1
.head 9 -  Call SalArraySetUpperBound (HandleToPlace, 1, i-1)
.head 9 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 9 +  If nBound=0 and HandleToPlace[0,0]= 0
.head 10 -  Call SalArraySetUpperBound (HandleToPlace, 1, -1)
.head 9 -  Call clsExplorerLeft.KHEReAssignPics(nSelectedHandle)
.head 9 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 9 -  Return TRUE
.head 8 -  Set i=i+1
.head 7 -  Set HandleToPlace[i,0]= nFall
.head 7 -  Set HandleToPlace[i,1]= nSelectedHandle
.head 7 -  Call clsExplorerLeft.KHEReAssignPics(nSelectedHandle)
.head 7 -  Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 7 -  Return TRUE
.head 5 +  Function: UnSelect
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTemp
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 6 +  Actions
.head 7 -  Set nTemp=0
.head 7 -  Set nTemp= nSelectedHandle
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 -  Set i=0
.head 7 +  While i<=nBound
.head 8 -  Set nSelectedHandle=HandleToPlace[0,1]
.head 8 -  Call MultiSelect()
.head 8 -  Set i=i+1
.head 7 -  Call SalArraySetUpperBound (HandleToPlace, 1, -1)
.head 7 -  Set nSelectedHandle= nTemp
.head 5 +  Function: Refresh_HandleToPlace
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: q
.head 7 -  Number: a
.head 7 -  Number: nN
.head 7 -  Number: nBound
.head 7 -  Number: hBet[*]
.head 7 -  Number: nBet
.head 7 -  Number: nGrp
.head 7 -  Number: hGrp[*]
.head 7 -  Number: nLevelLoc
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sAbtKeyHTP
.head 6 +  Actions
.head 7 -  Set nLevelLoc = GetLevel( nSelectedHandle )
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Abteilung
.head 9 -  ! Call SalArraySetUpperBound ( HandleToPlace, 0, -1 )
.head 9 -  ! Call SalArraySetUpperBound ( HandleToPlace, 1, -1 )
.head 9 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 9 -  Set a=0
.head 9 -  Set q=0
.head 9 +  While a<=  nBound
.head 10 -  Call GetPosition( HandleToPlace[a,1], sAbtKeyHTP, sStatKey, sGrpKey, sBettKey )
.head 10 +  If sAbtKeyHTP=sAbtKey
.head 11 -  Set i=q
.head 11 +  While i<=  nBound
.head 12 -  Set HandleToPlace[i,0]= HandleToPlace[i+1,0]
.head 12 -  Set HandleToPlace[i,1]= HandleToPlace[i+1,1]
.head 12 -  Set i=i+1
.head 11 -  Set nBound=  nBound-1
.head 11 -  Call SalArraySetUpperBound (HandleToPlace, 1, nBound)
.head 11 -  Set a=-1
.head 11 -  Set q=0
.head 10 +  Else
.head 11 -  Set q=q+1
.head 10 -  Set a=a+1
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set nGrp = EnumChildren( nSelectedHandle, hGrp )
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set hGrp[0]= nSelectedHandle
.head 9 -  Set nGrp= 0
.head 9 -  Break
.head 7 -  Set q=0
.head 7 +  While q<= nGrp
.head 8 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 8 -  Set a=0
.head 8 -  Set nBet = EnumChildren( hGrp[q], hBet )
.head 8 +  While a<=  nBound
.head 9 -  Set i=0
.head 9 +  While i<= nBet
.head 10 +  If hBet[i] = HandleToPlace[a,1]
.head 11 -  Set nN=a
.head 11 +  While nN<=  nBound
.head 12 -  Set HandleToPlace[nN,0]= HandleToPlace[nN+1,0]
.head 12 -  Set HandleToPlace[nN,1]= HandleToPlace[nN+1,1]
.head 12 -  Set nN=nN + 1
.head 11 -  Set nBound=  nBound-1
.head 11 -  Set a=a-1
.head 11 -  Call SalArraySetUpperBound (HandleToPlace, 1, nBound)
.head 11 +  If nBound < 0
.head 12 -  Call SalArraySetUpperBound (HandleToPlace, 1, -1)
.head 11 -  ! Set a=0
.head 11 -  Break
.head 10 -  Set i=i+1
.head 9 -  Set a=a+1
.head 8 -  Set q= q+1
.head 7 -  Return TRUE
.head 5 +  Function: IsSelectedMiceInCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hGroupRelease
.head 7 -  Receive Number: hMiceInCage[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hBeds2Trans[ * ]
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: nSelectedMiceInCage
.head 7 -  Number: n2Trans
.head 6 +  Actions
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 -  Set n2Trans = EnumChildren( hGroupRelease, hBeds2Trans)
.head 7 -  Set nSelectedMiceInCage= -1
.head 7 -  Set i=0
.head 7 +  While i <= nBound
.head 8 +  While k <= n2Trans
.head 9 +  If hBeds2Trans [k] = HandleToPlace [i,1] and HandleToPlace [i,1] !=0
.head 10 -  Set nSelectedMiceInCage = nSelectedMiceInCage+1
.head 10 -  Set hMiceInCage [nSelectedMiceInCage] = hBeds2Trans [k]
.head 9 -  Set k=k+1
.head 8 -  Set i=i+1
.head 8 -  Set k=0
.head 7 -  Return nSelectedMiceInCage+1
.head 5 +  Function: MultiSelectInCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBet
.head 7 -  Number: hBet[*]
.head 7 -  Number: i
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  Number: nTemp
.head 7 -  String: sText
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 +  If GetLevel( nSelectedHandle ) != KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 -  Set nTemp = nSelectedHandle
.head 7 +  If KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  ))
.head 8 -  Return FALSE
.head 7 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 7 +  If nBet
.head 8 -  Set i = 0
.head 8 +  Loop
.head 9 +  If i >= nBet
.head 10 -  Break
.head 9 -  Call GetItemData( hBet[ i ], sText, nValueLoc, nFlags)
.head 9 +  If SalStrScan(sText,"{") > 0
.head 10 -  Set nSelectedHandle=  hBet[ i ]
.head 10 -  Call MultiSelect()
.head 9 -  Set i = i + 1
.head 7 -  Set nSelectedHandle= nTemp
.head 7 -  Return TRUE
.head 5 -  !
.head 5 +  Function: Move_GroupRelease
.head 6 -  Description: fast copy of Move_PasteToCurrent()
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bMakeDischarge
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGroupRelease
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  Boolean: bCulling
.head 7 -  Number: nInd
.head 7 -  !
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sFallList
.head 7 -  !
.head 7 -  Number: nFall
.head 7 -  Number: nFallKey

.head 7 -  Date/Time: dtEE_Datum
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  !
.head 7 -  Number: nFallKey2Trans[ * ]
.head 7 -  Number: nBewNr2Trans[ * ]
.head 7 -  String: sBettKey2Trans[ * ]
.head 7 -  Number: hBeds2Trans[ * ]
.head 7 -  Number: n2Trans
.head 7 -  String: sStatusText
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cNullLocation
.head 8 -  Class: clsLocationCage
.head 7 -  !
.head 7 -  FunctionalVar: oCullingData
.head 8 -  Class: cCullingData
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Boolean: bShowDischargeDialog
.head 7 -  Number: hGruppe[*]
.head 7 -  Number: nIndGrpRefresh
.head 7 -  Number: i
.head 7 -  Boolean: bGrpT
.head 7 -  String: sGrpKeyTemp
.head 7 -  Boolean: bPrintCage
.head 7 -  Date/Time: dtTime
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Number: nMax
.head 6 +  Actions
.head 7 +  If hWndDlgEntlasung = hWndNULL
.head 8 -  Set hGroupRelease = nSelectedHandle
.head 8 -  Set dtEE_Datum = GetTime4Refresh(  )
.head 8 +  If KHE_IsOccupied_ByHandle( hGroupRelease, dtEE_Datum )
.head 9 -  Return FALSE
.head 8 +  If nSelectedLevel = KHEL_Gruppe or (  nSelectedLevel = KHEL_Bett and IsSelectedMiceInCage ( GetParent(  hGroupRelease), hBeds2Trans ))
.head 9 +  If nSelectedLevel = KHEL_Bett
.head 10 -  Set hGroupRelease = GetParent(  hGroupRelease)
.head 10 -  Call SalListSetSelect( hWndItem, GetItemIndex( hGroupRelease ) )
.head 10 -  Call ActivateSelectedItem(  )
.head 9 -  ! Set n2Trans = GetBedsWhereFallsAreX( hGroupRelease, hBeds2Trans, TRUE, TRUE, TRUE )
.head 9 -  Set n2Trans = EnumChildren( hGroupRelease, hBeds2Trans)
.head 9 +  If n2Trans = 0
.head 10 -  Return TRUE
.head 9 -  !
.head 9 +  If not SalArrayIsEmpty(HandleToPlace) and HandleToPlace[0,0]
.head 10 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, n2Trans ) 
.head 10 -  Set nInd = 0
.head 10 -  Call SalArraySetUpperBound ( hBeds2Trans, 1, -1 )
.head 10 +  While nInd <= n2Trans
.head 11 -  Set nFallKey2Trans[ nInd ] =  HandleToPlace[ nInd,0 ] 
.head 11 +  If nFallKey2Trans[ nInd ]
.head 12 -  Set sBettKey2Trans[ nInd ] = GetKey_ByHandle( HandleToPlace[ nInd, 1] )
.head 12 -  Set hBeds2Trans[ nInd ] =  HandleToPlace[ nInd,1 ] 
.head 12 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[ nInd ]
.head 11 -  Set nInd = nInd + 1
.head 9 +  Else
.head 10 -  Set nInd = 0
.head 10 +  While nInd < n2Trans
.head 11 -  Set nFallKey2Trans[ nInd ] = GetFallKey_ByHandle( hBeds2Trans[ nInd ] )
.head 11 +  If nFallKey2Trans[ nInd ]
.head 12 -  Set sBettKey2Trans[ nInd ] = GetKey_ByHandle( hBeds2Trans[ nInd ] )
.head 12 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[ nInd ]
.head 11 -  Set nInd = nInd + 1
.head 9 -  ! Collect items for moving
.head 8 +  Else If nSelectedLevel = KHEL_Bett
.head 9 +  If IsSelectedMiceInCage ( GetParent(  hGroupRelease), hBeds2Trans )
.head 10 -  Set n2Trans = 0
.head 10 -  Call SalArraySetUpperBound ( hBeds2Trans, 1, -1 )
.head 10 -  Set n2Trans = IsSelectedMiceInCage ( hGroupRelease, hBeds2Trans )
.head 10 -  ! Set nInd = 0
.head 10 +  ! While nInd < n2Trans
.head 11 -  Set sBettKey2Trans[ nInd ] = GetKey_ByHandle( hBeds2Trans[ nInd ] )
.head 11 -  Set nFallKey2Trans[ nInd ] = GetFallKey_ByHandle( hBeds2Trans[ nInd ] )
.head 11 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[ nInd ]
.head 11 -  Set nInd = nInd + 1
.head 9 +  If not SalArrayIsEmpty(HandleToPlace) and HandleToPlace[0,0]
.head 10 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, n2Trans ) 
.head 10 -  Set nInd = 0
.head 10 -  Call SalArraySetUpperBound ( hBeds2Trans, 1, -1 )
.head 10 +  While nInd <= n2Trans
.head 11 -  Set nFallKey2Trans[ nInd ] =  HandleToPlace[ nInd,0 ] 
.head 11 +  If nFallKey2Trans[ nInd ] 
.head 12 -  Set sBettKey2Trans[ nInd ] = GetKey_ByHandle( HandleToPlace[ nInd, 1] )
.head 12 -  Set hBeds2Trans[ nInd ] =  HandleToPlace[ nInd,1 ] 
.head 12 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[ nInd ]
.head 11 -  Set nInd = nInd + 1
.head 9 +  Else
.head 10 -  Set nFallKey2Trans[ 0 ] = GetFallKey_ByHandle( hGroupRelease )
.head 10 +  If nFallKey2Trans[ 0 ]
.head 11 -  Set sBettKey2Trans[ 0 ] = GetKey_ByHandle(hGroupRelease)
.head 11 -  Set hBeds2Trans[ 0 ] =  hGroupRelease
.head 11 -  Set oCullingData.nAnimals[0] = nFallKey2Trans[ 0 ]
.head 10 -  Set n2Trans = 1
.head 8 +  Else
.head 9 -  Return FALSE
.head 8 -  Set bShowDischargeDialog = GalGetProfileBooleanX( "Settings", "ShowDischargDialog", TRUE, sUserINIFileName )
.head 8 -  Set bOk = TRUE
.head 8 -  !
.head 8 +  If bMakeDischarge
.head 9 +  If not bShowDischargeDialog
.head 10 -  ! Call SalSendMsg(dlgKHE_SetBewDatumAndGrund, AM_Ok,0,0)
.head 10 +  If GalConnect(hSql)
.head 11 -  Set bOk = bOk and SqlPrepareAndExecute(hSql, "select bg1_key
from Bew_Grund1
where
 Einricht_ID = 1
 and	BA_Key = 'EE'
 and tod = 1
order by BG1_Key
into :sGrund1")
and SqlFetchNext(hSql, nFetch)
.head 11 -  Set bOk = bOk and SqlPrepareAndExecute(hSql, "select bg2_key
from	Bew_Grund2
where	Einricht_ID = 1 and BA_Key = 'EE'
order by BG2_Key
into :sGrund2")
and SqlFetchNext(hSql, nFetch)
.head 11 -  Call SqlDisconnect(hSql)
.head 11 +  If NOT bOk
.head 12 -  Call GalMessageBox("Death reason(s) not specified correctly! You cannot proceed without discharge dialog.", "Error", MB_Ok)
.head 12 -  Return FALSE
.head 9 +  Else
.head 10 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, 'EE', dtEE_Datum, sGrund1, sGrund2 )
.head 11 -  Return FALSE
.head 8 +  Else
.head 9 -  Set bCulling = TRUE
.head 8 -  Set oCullingData.sDischargeReason1 = sGrund1
.head 8 -  Set oCullingData.sDischargeReason2 = sGrund2
.head 8 -  Set oCullingData.dtCulling = dtEE_Datum
.head 8 -  Set sFallList=''
.head 8 -  Set nInd = 0
.head 8 -  ! 19.07.2007 SS
.head 8 -  ! if reason is DEATH and animals not culling - start dlgculling
.head 8 +  If sGrund1= 'DEATH'
.head 9 +  While nInd <= n2Trans
.head 10 +  If nFallKey2Trans[ nInd ] And sBettKey2Trans[ nInd ]
.head 11 -  Set nFall = nFallKey2Trans[ nInd ] 
.head 11 +  If nFall
.head 12 +  ! If SalStrScan( GetItemText( hBeds2Trans[ nInd ]), 'T {') <0
.head 13 -  Set bCulling= TRUE
.head 12 +  If not KHE_IsDead( hBeds2Trans[ nInd ], SalDateCurrent ( ))
.head 13 -  Set bCulling= TRUE
.head 11 +  If sFallList
.head 12 -  Set sFallList = sFallList || ','
.head 11 -  Set sFallList = sFallList || StrX( nFall )
.head 10 -  Set nInd = nInd + 1
.head 8 +  If bCulling
.head 9 +  ! If bMiniSolution or not GalGetProfileBooleanX( "Settings", "ShowDischargDialog", TRUE, sUserINIFileName )
.head 10 -  Set bPOC = TRUE
.head 9 +  If IDOK != SalModalDialog( dlgCulling_Prepare, hWndForm, sFallList, NOT bShowDischargeDialog, dtEE_Datum, oCullingData )
.head 10 -  Return FALSE
.head 8 -  Set dtKHK_RefreshTime = dtEE_Datum
.head 8 -  !
.head 8 -  ! Call GetPosition( hGroupRelease, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  ! AS 07.08.2003
.head 8 +  ! If not LockSysadmAction( "KHE Group EE: STAT_KEY=" || sStatKey || ", GRUPPE_KEY=" || sGrpKey )
.head 9 -  Return FALSE
.head 8 -  !
.head 8 -  ! Do DB changes
.head 8 +  ! If Not bPlanningMode	! Open LT
.head 9 -  Call LT_OpenTransaction(2,GetTime4Refresh(  ))
.head 8 -  ! Set bOk =TRUE
.head 8 -  ! Set nInd = 0
.head 8 +  ! While bOk And nInd < n2Trans
.head 9 +  If nFallKey2Trans[ nInd ] And sBettKey2Trans[ nInd ]
.head 10 -  Set sStatusText = GetMessageFromSection( 'KHE', 26, 'Write data to DB' ) || ': EE -> ' || StrX( nFallKey2Trans[ nInd ] ) || '...'
.head 10 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 10 +  If bPlanningMode
.head 11 -  Set nBewNr2Trans[ nInd ] = PlanedMovement_AddMvmnt(
	nFallKey2Trans[ nInd ], dtEE_Datum, 'EE', sGrund1, sGrund2,
	sAbtKey, sStatKey, sGrpKey, sBettKey2Trans[ nInd ], FALSE )
.head 10 +  Else 
.head 11 -  Set nBewNr2Trans[ nInd ] = __InsertBewegungX(
	sCurrentName, nEinrichtId, nFallKey2Trans[ nInd ], 0,
	dtEE_Datum, 'EE', sGrund1, sGrund2,
	sAbtKey, sStatKey, sGrpKey, sBettKey2Trans[ nInd ],
	'', '', '', '', 0 )
.head 10 +  If nBewNr2Trans[ nInd ] = 0
.head 11 -  Set bOk = FALSE
.head 11 -  Call SalStatusSetText( hWndForm, sStatusText || ' - ' || GetMessageX( 203, 'Error !' ))
.head 11 -  Break 
.head 10 +  Else 
.head 11 -  ! Call DischargeService( sStatKey, sGrpKey, dtEE_Datum )
.head 11 -  ! Call DischargeFallDoneService( nFallKey2Trans[ nInd ], dtEE_Datum )
.head 9 -  Set nInd = nInd + 1
.head 8 +  If bOk
.head 9 -  Set bOk = DoCulling(nEinrichtId, oCullingData)
.head 9 +  If bMakeDischarge
.head 10 -  Set nInd = 0
.head 10 -  Call LockSysadmAction("Perform discharge...")
.head 10 +  While bOk And nInd <= n2Trans
.head 11 +  If nFallKey2Trans[ nInd ] And sBettKey2Trans[ nInd ]
.head 12 -  Call GetPosition( hBeds2Trans[nInd], sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 12 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 12 -  Set nBewNr2Trans[ nInd ] = __InsertBewegungX(
	sCurrentName, nEinrichtId, nFallKey2Trans[ nInd ], 0,
	dtEE_Datum, 'EE', sGrund1, sGrund2,
	sAbtKey, sStatKey, sGrpKey, sBettKey,
	'', '', '', '', 0 )
.head 12 -  Set bOk = nBewNr2Trans[ nInd ]
.head 12 -  Call cSource[nInd].Init( sAbtKey, sStatKey, sGrpKey )
.head 11 -  Set nInd = nInd + 1
.head 10 +  If bOk
.head 11 -  Call LockSysadmAction("...discharge performed")
.head 10 +  Else
.head 11 -  Call LockSysadmAction("...discharge failed")
.head 8 +  ! If Not bPlanningMode	! Close LT
.head 9 -  Call LT_CloseLastTransaction()
.head 8 -  ! Call VisWaitCursor( TRUE )
.head 8 -  !
.head 8 -  ! Call DoCloseTransaction( bOk )
.head 8 -  ! Call ReleaseSysadmAction( bOk )
.head 8 -  !
.head 8 +  ! If Not bPlanningMode	! Transfer data to subsystems; ClearCagePurpose
.head 9 +  If bOk			! Transfer data to subsystems
.head 10 -  Set sStatusText = GetMessageFromSection( 'KHE', 26, 'Write data to DB' ) || ': ' || GetMessageFromSection( 'KHE', 28, 'Transfer EE data to subsystems...' )
.head 10 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 10 -  Set nInd = 0
.head 10 +  While nInd < n2Trans
.head 11 -  Call Transfer_AppendToAll( 'EE', nFallKey2Trans[ nInd ], nBewNr2Trans[ nInd ] )
.head 11 -  Set nInd = nInd + 1
.head 9 +  If bUseCurrentTime		! ClearCagePurpose
.head 10 -  Set sStatusText = GetMessageFromSection( 'KHE', 26, 'Write data to DB' ) || ': ' || GetMessageFromSection( 'KHE', 29, 'clear PURPOSE for' ) || ': ' || sStatKey || '/' || sGrpKey || '...'
.head 10 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 10 -  Set bOk = KHE_ClearCagePurpose( sStatKey, sGrpKey )
.head 8 -  !
.head 8 +  ! If bOk	! write statustext
.head 9 -  Call SalStatusSetText( hWndForm, '' )
.head 8 +  ! Else
.head 9 -  Call SalStatusSetText( hWndForm, sStatusText || ' - ' || GetMessageX( 203, 'Error !' ))
.head 8 -  !
.head 8 -  Call UnSelect()
.head 8 -  ! Call PopulateAndExpand( hGroupRelease, FALSE )
.head 8 +  If nSelectedLevel = KHEL_Bett
.head 9 -  Call SalListSetSelect( hWndItem, GetItemIndex( GetParent (hGroupRelease) ) )
.head 9 -  Call ActivateSelectedItem(  )
.head 9 -  Set hGroupRelease = nSelectedHandle
.head 8 -  Set nInd = 0
.head 8 -  Set sGrpKey = ""
.head 8 +  While nInd <= n2Trans
.head 9 -  Set i = 0
.head 9 -  Set bGrpT=FALSE
.head 9 +  While i<=nIndGrpRefresh
.head 10 +  If hGruppe[i] = GetParent(  hBeds2Trans[nInd])
.head 11 -  Set bGrpT=TRUE
.head 11 -  Break
.head 10 -  Set i=i+1
.head 9 +  If bGrpT = FALSE
.head 10 -  Set hGruppe[nIndGrpRefresh] = GetParent(  hBeds2Trans[nInd])
.head 10 -  Call GetPosition( hGruppe[nIndGrpRefresh], sAbtKey, sStatKey, sGrpKeyTemp, sBettKey )
.head 10 -  Set nIndGrpRefresh =nIndGrpRefresh + 1
.head 10 +  If sGrpKey
.head 11 -  Set sGrpKey = sGrpKey||","
.head 10 -  Set sGrpKey = sGrpKey||sGrpKeyTemp
.head 9 -  Set nInd = nInd + 1
.head 8 -  Set i = 0
.head 8 +  While i<=nIndGrpRefresh
.head 9 -  Call KHE_RefreshGruppe( hGruppe[i] )
.head 9 -  Set i=i+1
.head 8 -  !
.head 8 +  ! If hwndToolBar
.head 9 -  Call SalPostMsg( hwndToolBar, AM_Refresh, 0, 0 )
.head 8 -  Call SalPostMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 8 -  Call VisWaitCursor( FALSE )
.head 8 -  ! Call GetPosition( hGroupRelease, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Call Rack2DView_RefreshCageContents(sGrpKey)
.head 8 -  ! Call Rack2DView_ReflectButtonsState()
.head 8 -  ! printing the cagecards 
.head 8 +  If bOk
.head 9 -  ! Call cSource[0].Init( sAbtKey, sStatKey, sGrpKey )
.head 9 +  ! If SalStrScan(GetItemText( hGroupRelease ), '[+]')>0
.head 10 -  Call Move_PrintCageCards( cSource, cNullLocation )
.head 9 -  Set nInd = 0
.head 9 -  Set bPrintCage = FALSE
.head 9 -  Set dtTime = GetTime4Refresh(  )
.head 9 +  While nInd<nIndGrpRefresh
.head 10 -  Call _GetPositionID( hGruppe[nInd] , oPos )
.head 10 +  If CageIsEmpty(oPos.sRack, oPos.sCage, dtTime, TRUE )
.head 11 -  Set bPrintCage = TRUE
.head 11 -  Call cSource[nInd].Init( oPos.sScreen, oPos.sRack,oPos.sCage )
.head 11 +  If SalStrScan( sCagesWRSClose, "("||oPos.sRack||")"||oPos.sCage )>-1
.head 12 -  Call cSource[nInd].SetRepeatType( "L" )
.head 10 +  Else
.head 11 -  Call POC_CloseAndUnregister(hGruppe[nInd])
.head 10 -  Set nInd = nInd + 1
.head 9 +  ! If CageIsEmpty_ByHandle() 
.head 10 -  Call Move_PrintCageCards( cSource, cNullLocation )
.head 9 +  ! Else
.head 10 -  Call POC_CloseAndUnregister(hGroupRelease)
.head 9 +  If bPrintCage
.head 10 -  Call Move_PrintCageCards( cSource, cNullLocation )
.head 8 +  If hWndWorklist and VisWinIsWindow(hWndWorklist)
.head 9 -  Call SalSendMsg( hWndWorklist, AM_Refresh, wParam, lParam )
.head 8 -  Return bOk
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 +  Function: Move_GroupCulling
.head 6 -  Description: fast copy of Move_PasteToCurrent()
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeySrc
.head 7 -  String: sGrpKeySrc
.head 7 -  String: sBettKeySrc
.head 7 -  !
.head 7 -  Number: hGroupCulling
.head 7 -  Number: nFallKey2Trans
.head 7 -  Number: hBeds2Trans[ * ]
.head 7 -  Number: n2Trans
.head 7 -  Number: nInd
.head 7 -  !
.head 7 -  String: sFallList
.head 7 -  Date/Time: dtCul
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: oCullingData
.head 8 -  Class: cCullingData
.head 6 +  Actions
.head 7 +  ! If hWndDlgCulling = hWndNULL
.head 8 +  ! If bPlanningMode
.head 9 -  Call SalMessageBox( "Planning of Culling is under Reconstruction !", GetMessageX( 205, "Attention !" ), MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 -  Set hGroupCulling = nSelectedHandle
.head 8 +  If nSelectedLevel = KHEL_Gruppe
.head 9 -  Set n2Trans = GetBedsWhereFallsAre( hGroupCulling, hBeds2Trans, TRUE )
.head 9 +  If n2Trans = 0
.head 10 -  Return FALSE
.head 9 -  !
.head 9 +  If IsSelectedMiceInCage ( hGroupCulling, hBeds2Trans )
.head 10 -  Set n2Trans = 0
.head 10 -  Call SalArraySetUpperBound ( hBeds2Trans, 1, -1 )
.head 10 -  Set n2Trans = IsSelectedMiceInCage ( hGroupCulling, hBeds2Trans )
.head 9 -  ! Collect items for moving
.head 9 -  Set nInd = 0
.head 9 -  Set sFallList = ''
.head 9 +  While nInd < n2Trans
.head 10 -  Set nFallKey2Trans = GetFallKey_ByHandle( hBeds2Trans[ nInd ] )
.head 10 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans
.head 10 +  If sFallList
.head 11 -  Set sFallList = sFallList || ','
.head 10 -  Set sFallList = sFallList || StrX( nFallKey2Trans )
.head 10 -  Set nInd = nInd + 1
.head 8 +  Else If nSelectedLevel = KHEL_Bett
.head 9 -  Set nFallKey2Trans = GetFallKey_ByHandle( nSelectedHandle )
.head 9 -  Set oCullingData.nAnimals[0] = nFallKey2Trans
.head 9 +  If sFallList
.head 10 -  Set sFallList = sFallList || ','
.head 9 -  Set sFallList = sFallList || StrX( nFallKey2Trans )
.head 8 +  !
.head 9 -  ! ! AS 09.01.2004: using ':dtKHK_RefreshTime' instead of 'SYSDATETIME'
.head 9 -  ! Set dtKHK_RefreshTime = SalDateCurrent(  )
.head 9 -  ! Set sFallList = PutSelectToString( "
select f.FALL_KEY
from FALL f, BEWEGUNG b
" || BedIsUsed_SQL_Where( FALSE, ':dtKHK_RefreshTime' ) || "
  and	b.EINRICHT_ID = :nEinrichtId
  and	b.ABT_KEY = '" || sAbtKeySrc || "'
  and	b.STAT_KEY = '" || sStatKeySrc || "'
  and	b.GRUPPE_KEY = '" || sGrpKeySrc || "'
", ',' )
.head 8 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc,sGrpKeySrc,sBettKeySrc )
.head 8 +  If Not sFallList
.head 9 -  Return FALSE
.head 8 +  If bMiniSolution
.head 9 -  Set bPOC = TRUE
.head 8 +  If IDOK != SalModalDialog( dlgCulling, hWndForm, sFallList, bPOC, dtCul )
.head 9 +  If bMiniSolution
.head 10 -  Set bPOC = FALSE
.head 9 -  Return FALSE
.head 8 -  Call cSource[0].Init( sAbtKeySrc, sStatKeySrc, sGrpKeySrc )
.head 8 -  Call cDestination.Init( sAbtKeySrc, sStatKeySrc, sGrpKeySrc )
.head 8 -  Call Move_PrintCageCards( cSource, cDestination )
.head 8 +  If bMiniSolution
.head 9 -  Set bPOC = FALSE
.head 8 -  Call PopulateAndExpand( nSelectedHandle, FALSE )
.head 8 -  Return TRUE
.head 7 +  ! Else
.head 8 -  Return FALSE
.head 7 -  Return Move_GroupRelease(FALSE)
.head 5 +  Function: Gruppe2StudyGroup
.head 6 -  Description: fast copy of Move_PasteToCurrent()
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallGroupId
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGroup2Study
.head 7 -  Number: nFallKey2Trans[*]
.head 7 -  Number: nFallKeyTmp
.head 7 -  Number: hBeds2Trans[*]
.head 7 -  Number: nBeds2Trans
.head 7 -  Number: nFalls2Trans
.head 7 -  Number: nInd
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  FunctionalVar: cSource[1]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set hGroup2Study = nSelectedHandle
.head 7 -  Set nBeds2Trans = EnumChildren( hGroup2Study, hBeds2Trans )
.head 7 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 7 +  If nBeds2Trans = 0
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  ! Collect items for moving
.head 7 -  Call VisWaitCursor( TRUE )
.head 7 -  Set bOk = TRUE
.head 7 -  Set nInd = 0
.head 7 -  Set nFalls2Trans = 0
.head 7 +  While bOk And nInd < nBeds2Trans
.head 8 -  Set nFallKeyTmp = GetFallKey_ByHandle( hBeds2Trans[ nInd ] )
.head 8 +  If nFallKeyTmp
.head 9 -  Set bOk = DoImmediateSingle( "
select	FALL_KEY
from	FALL_GROUP_MEMBER
where	FALL_GROUP_ID = " || StrX( nFallGroupId ) || "
  and	EINRICHT_ID = " || StrX( nEinrichtId ) || "
  and	FALL_KEY = " || StrX( nFallKeyTmp ), bExists ) 
.head 9 +  If bOk And Not bExists
.head 10 -  Set nFallKey2Trans[ nFalls2Trans ] = nFallKeyTmp
.head 10 -  Set nFalls2Trans = nFalls2Trans + 1
.head 8 -  Set nInd = nInd + 1
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 +  If Not bOk Or nFalls2Trans = 0
.head 8 -  Return FALSE
.head 7 +  !
.head 8 -  ! Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc,sGrpKeySrc,sBettKeySrc )
.head 8 -  ! ! AS 09.01.2004: using ':dtKHK_RefreshTime' instead of 'SYSDATETIME'
.head 8 -  ! Set dtKHK_RefreshTime = SalDateCurrent(  )
.head 8 -  ! Call hSqlDoImmediate.CloseTransaction( DoUpdateForSelect( "
select f.FALL_KEY
from FALL f, BEWEGUNG b
" || BedIsUsed_SQL_Where( FALSE, ':dtKHK_RefreshTime' ) || "
  and	b.EINRICHT_ID = :nEinrichtId
  and	b.ABT_KEY = '" || sAbtKeySrc || "'
  and	b.STAT_KEY = '" || sStatKeySrc || "'
  and	b.GRUPPE_KEY = '" || sGrpKeySrc || "'
  and	f.FALL_KEY not in ( select FALL_KEY from FALL_GROUP_MEMBER g
		where	g.FALL_GROUP_ID = " || StrX( nGroupId ) || "
		  and	g.FALL_KEY = f.FALL_KEY )
into :n[0]
", "
insert into FALL_GROUP_MEMBER(
	FALL_GROUP_ID, EINRICHT_ID, FALL_KEY )
values ( " || StrX( nFallGroupId ) || ", " || StrX( nEinrichtId ) || ", :n[0] )
" ) )
.head 7 +  ! If Not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  Call LockSysadmAction("Add to license...")
.head 7 -  Call VisWaitCursor( TRUE )
.head 7 -  Set nInd = 0
.head 7 +  While bOk And nInd < nFalls2Trans
.head 8 -  ! Set bOk = SqlExecute( hSql )
.head 8 -  Set bOk = Groups_AddCase( nFallGroupId, nFallKey2Trans[ nInd ] )
.head 8 -  Set nInd = nInd + 1
.head 7 +  If bOk
.head 8 -  Set bOk = DoCommit()
.head 8 -  Call cSource[0].Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 8 -  Call cDestination.Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 8 -  Call PrintCageCards(cSource, cDestination)
.head 8 -  Call LockSysadmAction("...added to license")
.head 7 +  If Not bOk
.head 8 -  Call DoRollback()
.head 8 -  Call LockSysadmAction("...not added to license")
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 -  Return bOk
.head 5 +  Function: Bett2StudyGroup
.head 6 -  Description: fast copy of Move_PasteToCurrent()
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallGroupId
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGroup2Study
.head 7 -  Number: nFallKey2Trans[*]
.head 7 -  Number: nFallKeyTmp
.head 7 -  Number: hBeds2Trans[*]
.head 7 -  Number: nBeds2Trans
.head 7 -  Number: nFalls2Trans
.head 7 -  Number: nInd
.head 7 -  Number: nF
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  FunctionalVar: cSource[1]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set hGroup2Study = nSelectedHandle
.head 7 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 7 -  Set nF = GetFallKey_ByHandle( nSelectedHandle)
.head 7 +  If not nF
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Call VisWaitCursor( TRUE )
.head 7 -  Set bOk = TRUE
.head 7 -  Set bOk = DoImmediateSingle( "
select	FALL_KEY
from	FALL_GROUP_MEMBER
where	FALL_GROUP_ID = " || StrX( nFallGroupId ) || "
  and	EINRICHT_ID = " || StrX( nEinrichtId ) || "
  and	FALL_KEY = " || StrX( nF ), bExists ) 
.head 7 +  If not bOk or bExists
.head 8 -  Call VisWaitCursor( FALSE )
.head 8 -  Return FALSE
.head 7 -  Set bOk = Groups_AddCase( nFallGroupId, nF )
.head 7 +  If bOk
.head 8 -  Set bOk = DoCommit()
.head 8 -  Call cSource[0].Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 8 -  Call cDestination.Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 8 -  Call PrintCageCards(cSource, cDestination)
.head 7 +  If Not bOk
.head 8 -  Call DoRollback()
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 -  Return bOk
.head 5 +  Function: Gruppe2Experiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKey2Trans[*]
.head 7 -  String: sLicenseKey
.head 7 -  String: sLicenseRecord
.head 7 -  Number: nInd
.head 7 -  Number: nCountSuccess
.head 7 -  Boolean: bOk
.head 7 -  String: sBackMsg
.head 7 -  String: sResultMsg
.head 7 -  ! *****
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  FunctionalVar: cSource[1]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 6 +  Actions
.head 7 +  If not GetFallsInGruppe( nSelectedHandle, nFallKey2Trans )
.head 8 -  Return FALSE
.head 7 -  Call GetPosition(nSelectedHandle, sAbt, sStat, sGrp, sBett)
.head 7 +  If not bPlanningMode and Not Request_License( sLicenseKey, sLicenseRecord, sAbt )
.head 8 -  Return FALSE
.head 7 -  Set bOk = TRUE
.head 7 -  Call LockSysadmAction("Add to group...")
.head 7 -  Set nCountSuccess = 0
.head 7 +  While bOk and nFallKey2Trans[nInd]
.head 8 -  Set sBackMsg = ''
.head 8 +  If License_AddCaseMsg( sLicenseKey, sLicenseRecord, nFallKey2Trans[nInd], '', sBackMsg )
.head 9 -  Set nCountSuccess = nCountSuccess + 1
.head 8 +  Else
.head 9 +  If sBackMsg = ''	! means SqlError happened
.head 10 -  Set bOk = FALSE 
.head 9 +  Else
.head 10 -  Set sResultMsg = sResultMsg || "
" || sBackMsg
.head 8 -  Set nInd = nInd + 1
.head 7 -  Set bOk = DoCloseTransaction( bOk ) and bOk
.head 7 +  If bOk
.head 8 -  Call LockSysadmAction("...added to group")
.head 8 -  Set sResultMsg = StrX( nCountSuccess ) || " " || GetMessageFromSection( "FALL_GROUPS", 12060, "cases assigned to the License" ) || " " || sLicenseKey  || "
---------------------------------------------------------------------
" || sResultMsg
.head 8 -  ! *****
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber(sGrp))
.head 8 -  ! Call SalMessageBox( sResultMsg, GetMessage( 202 ), 0 )
.head 8 -  Call GalTimedMessageBox( hWndForm, sResultMsg, GetMessage( 202 ), 1000 )
.head 8 -  Call cSource[0].Init( sAbt, sStat, sGrp )
.head 8 -  Call cDestination.Init(sAbt, sStat, sGrp )
.head 8 -  Call PrintCageCards(cSource, cDestination)
.head 7 +  Else
.head 8 -  Call LockSysadmAction("...not added to group")
.head 7 -  Return bOk
.head 5 +  Function: Bett2Experiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKey2Trans[*]
.head 7 -  String: sLicenseKey
.head 7 -  String: sLicenseRecord
.head 7 -  Number: nInd
.head 7 -  Number: nF
.head 7 -  Number: nCountSuccess
.head 7 -  Boolean: bOk
.head 7 -  String: sBackMsg
.head 7 -  String: sResultMsg
.head 7 -  ! *****
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  FunctionalVar: cSource[1]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 6 +  Actions
.head 7 -  Set nF=GetFallKey_ByHandle( nSelectedHandle )
.head 7 +  If not nF
.head 8 -  Return FALSE
.head 7 -  Call GetPosition(nSelectedHandle, sAbt, sStat, sGrp, sBett)
.head 7 +  If not bPlanningMode and  Not Request_License( sLicenseKey, sLicenseRecord, sAbt )
.head 8 -  Return FALSE
.head 7 -  Set bOk = TRUE
.head 7 -  Set nCountSuccess = 0
.head 7 +  If License_AddCaseMsg( sLicenseKey, sLicenseRecord, nF, '', sBackMsg )
.head 8 -  Set nCountSuccess = nCountSuccess + 1
.head 7 +  Else
.head 8 +  If sBackMsg = ''	! means SqlError happened
.head 9 -  Set bOk = FALSE 
.head 8 +  Else
.head 9 -  Set sResultMsg = sResultMsg || "
" || sBackMsg
.head 7 -  Set bOk = DoCloseTransaction( bOk ) and bOk
.head 7 +  If bOk
.head 8 -  Set sResultMsg = StrX( nCountSuccess ) || " " || GetMessageFromSection( "FALL_GROUPS", 12060, "cases assigned to the License" ) || " " || sLicenseKey  || "
---------------------------------------------------------------------
" || sResultMsg
.head 8 -  ! *****
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber(sGrp))
.head 8 -  Call SalMessageBox( sResultMsg, GetMessage( 202 ), 0 )
.head 8 -  Call cSource[0].Init( sAbt, sStat, sGrp )
.head 8 -  Call cDestination.Init(sAbt, sStat, sGrp )
.head 8 -  Call PrintCageCards(cSource, cDestination)
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: Refresh_HasFall
.head 6 -  Description: Refresh "Has Fall" status of the given node
.head 6 +  Returns
.head 7 -  Boolean: bExists
.head 6 +  Parameters
.head 7 -  Number: hNode
.head 7 -  Date/Time: dtGetOnTime
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return Refresh_HasFallX( hNode, dtGetOnTime, FALSE )
.head 5 +  Function: Refresh_HasFallX
.head 6 -  Description: Refresh "Has Fall" status of the given node
.head 6 +  Returns
.head 7 -  Boolean: bExists
.head 6 +  Parameters
.head 7 -  Number: hNode
.head 7 -  Date/Time: dtGetOnTime
.head 7 -  Boolean: bSetOnly4TRUE
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bExists
.head 7 -  Number: nFallKeyInNode
.head 7 -  Number: nBewNr_LockId
.head 7 -  Boolean: bBewReal
.head 7 -  Date/Time: dtBewNr_LockId_Zeit
.head 7 -  Number: nLE_Id
.head 6 +  Actions
.head 7 -  Call GetPosition( hNode, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Set nBewNr_LockId = Bew_GetFall_InPlaceOnDateX( 
		bShowOnlyRealBew, dtGetOnTime, 
		sAbtKey, sStatKey, sGrpKey, sBettKey, nLE_Id, nFallKeyInNode, bBewReal, dtBewNr_LockId_Zeit )
.head 7 +  If nBewNr_LockId
.head 8 -  Set bExists = TRUE
.head 7 +  If bExists Or Not bSetOnly4TRUE
.head 8 -  Call KHESetHasFall( hNode, bExists )
.head 7 -  Return bExists
.head 5 +  Function: RefreshSingleGruppeLabel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 7 -  String: spGruppeKey
.head 7 -  String: spStatKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sGruppeLabelNew
.head 7 -  String: sGruppeLabelOld
.head 7 -  Boolean: bGruppeHasFall
.head 7 -  Number: nColorOld
.head 7 -  Boolean: bIsAlert
.head 7 -  Number: nIsAlert
.head 7 -  Date/Time: dtGetTime
.head 6 +  Actions
.head 7 +  If hpGruppe = 0
.head 8 +  If nSelectedLevel = KHEL_Gruppe
.head 9 -  Set hpGruppe = nSelectedHandle
.head 8 +  Else
.head 9 -  Return FALSE
.head 7 +  If spGruppeKey = ''
.head 8 -  Set spGruppeKey = GetKey_ByHandle( hpGruppe )
.head 7 +  If spStatKey = ''
.head 8 -  Set spStatKey = GetKey_ByHandle( GetParent( hpGruppe ) )
.head 7 -  Set nColorOld = GetItemColor( hpGruppe )
.head 7 -  Set sGruppeLabelOld = GetItemText( hpGruppe )
.head 7 +  ! If SalStrScan( sGruppeLabelOld,"[+]" ) >= 0
.head 8 -  Set bGruppeHasFall = TRUE
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If CageIsEmpty(spStatKey, spGruppeKey, dtGetTime, TRUE)
.head 8 -  Set bGruppeHasFall = TRUE
.head 7 -  Set s[0] = ""
.head 7 -  Set s[1] = ""
.head 7 -  Set n[0] = NUMBER_Null
.head 7 -  Set n[1] = NUMBER_Null
.head 7 +  If Not DoImmediate( "
select	g.CageNName, g.PURPOSE_KEY, g.COLOR, g.Uniq_Nr 
into	:s[0], :s[1], :n[0], :n[1]
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	g.STAT_KEY = '" || spStatKey || "'
and 	g.GRUPPE_KEY = '" || spGruppeKey   || "' ")	
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  ! Call SqlExists( "
select  leg.ISALERT
from  LST_ERF l, LEISTUNG leg
where  l.GRUPPE_KEY= :spGruppeKey
and 	l.LST_KEY=leg.LST_KEY
and	l.DONE=0
and 	l.LST_ERF_VON<:dtGetTime
and 	(l.LST_ERF_BIS>:dtGetTime or l.LST_ERF_BIS is null)
into	:nIsAlert
", bIsAlert )
.head 7 -  Set sGruppeLabelNew =  '(' || spGruppeKey || ') '
.head 7 -  ! If bIsAlert 
.head 7 +  ! Else
.head 8 -  Set sGruppeLabelNew =  '(' || spGruppeKey || ') ' ||  s[0]
.head 7 +  ! If s[0]
.head 8 -  Set sGruppeLabelNew = sGruppeLabelNew ||'Cage Nr '|| s[0]
.head 7 +  If bShowCageName and s[0]
.head 8 -  Set sGruppeLabelNew = sGruppeLabelNew ||' Cage Nr: '|| s[0]
.head 7 +  If bShowCageUniqNr and n[1] > 0 and bGruppeHasFall
.head 8 -  Set sGruppeLabelNew = sGruppeLabelNew ||' Card Nr: '||SalNumberToStrX(n[1], 0)
.head 7 -  !
.head 7 +  If Not n[0]
.head 8 -  Set n[0] = COLOR_Black
.head 7 -  Call SetItemFont(hpGruppe, hFontCages)
.head 7 +  If bGruppeHasFall
.head 8 +  If s[1] 
.head 9 -  Set sGruppeLabelNew= sGruppeLabelNew || ", " || s[1]
.head 8 -  Set sGruppeLabelNew= sGruppeLabelNew || " [+] "
.head 7 +  Else
.head 8 +  If bUseCurrentTime
.head 9 +  If s[1]
.head 10 -  Call KHE_ClearCagePurpose( spStatKey, spGruppeKey )
.head 8 -  ! Call SetItemFont(hpGruppe, hFontCommon)
.head 7 -  Call SetItemText( hpGruppe, sGruppeLabelNew )
.head 7 +  If Not (nColorOld = n[0])
.head 8 -  Call SetItemColor( hpGruppe, n[0] )
.head 7 -  Return TRUE
.head 5 +  Function: RefreshBettAfterMove
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hBett
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGruppe
.head 7 -  Number: nFallKeyOnBed
.head 6 +  Actions
.head 7 +  If GetLevel( hBett ) != KHEL_Bett
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Set hGruppe = GetParent( hBett )
.head 7 -  Call PopulateBett( hBett, '', '', nFallKeyOnBed )
.head 7 -  Call Refresh_HasFall( hGruppe, dtKHK_RefreshTime )
.head 7 -  Call RefreshSingleGruppeLabel( hGruppe, '', '' )
.head 7 -  Set dtTime  = GetTime4Refresh(  )
.head 7 -  Call KHEReAssignPics( hGruppe )
.head 7 -  Return TRUE
.head 5 -  !
.head 5 -  ! --Positioning
.head 5 +  Function: GoToAbt
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hAbt
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 -  Set hAbt = FindH_4Abteilung( sAbtKey )
.head 7 +  If hAbt = 0
.head 8 -  Return FALSE
.head 7 -  ! Set nSelectedHandle = hAbt
.head 7 -  ! Set nSelectedLevel = KHEL_Abteilung
.head 7 -  ! Set nSelectedItem = GetItemIndex( hAbt )
.head 7 -  ! Return SalListSetSelect( hWndItem, nSelectedItem )
.head 7 -  Set nIndex = GetItemIndex( hAbt )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  Call ActivateSelectedItem(  )
.head 7 -  Call PopulateAndExpand( hAbt, bAutoScan )
.head 7 -  Return TRUE
.head 5 +  Function: GoToStat
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hStat
.head 7 -  ! Number: hAbt
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 -  Set hStat = FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, FALSE )
.head 7 +  If hStat = 0
.head 8 -  Return FALSE
.head 7 -  Call PopulateAndExpand( hStat, bForceScan )
.head 7 -  Set nIndex = GetItemIndex( hStat )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  Call ActivateSelectedItem(  )
.head 7 +  ! If bBreedingIsON And (sOpenKHKItemOnScan = "On") 
.head 8 +  If Not bPastingMovement
.head 9 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 9 -  Call SalPostMsg( hWndItem, SAM_ContextMenu, -1, -1 )
.head 7 -  Return TRUE
.head 5 +  Function: OpenGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 7 -  Number: nPozish
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hStat
.head 7 -  Number: hGrp
.head 7 -  Number: hStation
.head 7 -  Number: hAbt
.head 7 -  Number: nIndex
.head 7 -  Number: hChildren[*]
.head 7 -  Window Handle: hWnd
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 7 -  Sql Handle: hSqlGruppe
.head 7 -  String: sSqlGruppe
.head 7 -  Boolean: bOk
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetchNext
.head 7 -  Number: i
.head 7 -  FunctionalVar: cCage
.head 8 -  Class: clsWFElement
.head 7 -  Number: hTemp
.head 7 -  FunctionalVar: oCage
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  ! ! SS 15.12.2007 add sRoomCage for transfer Room and Cage to Mice_imp
.head 7 -  ! AS 11.11.2004: use bAutoScan instead of FALSE
.head 7 +  ! If FindChild( hGrp, sGrpKey )
.head 8 -  Return TRUE
.head 7 -  Set hCageInVirt = 0
.head 7 -  Set bMatingCage = FALSE
.head 7 -  Set bDeadInCage = FALSE
.head 7 +  If not KHE_IsPopulated( hRoot )
.head 8 -  Call PopulateAndExpand( hRoot, bAutoScan )
.head 7 +  If not KHE_IsExpanded( hRoot )
.head 8 +  If Not Expand( GetItemIndex( hRoot ) )
.head 9 -  Return FALSE
.head 7 -  Set hAbt = FindChild( hRoot , sAbtKey )
.head 7 +  If hAbt <= 0
.head 8 -  Return 0
.head 7 +  If not KHE_IsPopulated( hAbt )
.head 8 -  Call PopulateAndExpand( hAbt, bAutoScan )
.head 7 +  If not KHE_IsExpanded( hAbt )
.head 8 +  If Not Expand( GetItemIndex( hAbt ) )
.head 9 -  Return FALSE
.head 7 -  Set hStation = FindChild( hAbt , sStatKey )
.head 7 +  If hStation <= 0
.head 8 -  Return 0
.head 7 +  If not KHE_IsPopulated( hStation )
.head 8 -  Call PopulateAndExpand( hStation, bAutoScan )
.head 7 +  If not KHE_IsExpanded( hStation )
.head 8 +  If Not Expand( GetItemIndex( hStation ) )
.head 9 -  Return FALSE
.head 7 -  Set hGrp = FindChild( hStation, sGrpKey )
.head 7 +  If hGrp
.head 8 -  Set nIndex = GetItemIndex( hGrp )
.head 8 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 9 -  Call SetOutlineRedraw ( TRUE)
.head 9 -  Return 0
.head 8 -  Call ActivateSelectedItem(  )     
.head 8 +  If not KHE_IsPopulated( hGrp )
.head 9 -  Call PopulateAndExpand( hGrp, bAutoScan )
.head 8 +  If not KHE_IsExpanded( hGrp )
.head 9 +  If Not Expand( nIndex )
.head 10 -  Return FALSE
.head 8 -  ! Call KHE_RefreshGruppe( hGrp )
.head 8 -  Return hGrp
.head 7 -  Call SetOutlineRedraw ( FALSE)
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  ! If bDischargeDead
.head 8 -  Set bSelectDead = TRUE
.head 7 -  Call SalArraySetUpperBound( nFallDeadHandle, 1, -1 )
.head 7 -  Set nCountDead = -1
.head 7 +  If bShowOnlyOpenCages
.head 8 -  ! Set hStat = FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan )
.head 8 -  Call AddGruppeToStation (hStation, sAbtKey, sStatKey, sGrpKey, bForceScan)
.head 8 -  ! Call AddCageToVisibleList(sStatKey, sGrpKey)
.head 8 -  ! Call PopulateStation (FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan ),  bForceScan)
.head 8 -  ! Set hGrp = FindH_4Gruppe( FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan ), sGrpKey, bForceScan )
.head 7 +  ! Else
.head 8 -  Set hGrp = FindH_4Gruppe( FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan ), sGrpKey, bForceScan )
.head 7 +  Else
.head 8 +  If bShowWithContent
.head 9 -  ! Call AddGruppeToStation (sAbtKey, sStatKey, sGrpKey, bForceScan)
.head 9 +  If Not GalConnect( hSqlGruppe )
.head 10 -  Call SetOutlineRedraw ( TRUE)
.head 10 -  Return 0
.head 9 -  Set bOk =FALSE
.head 9 +  If bRealTimeMode
.head 10 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, count( f.LAST_BETT_KEY)
from 	GRUPPE g, FALL f, BETT b
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = g.GRUPPE_KEY
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and	b.CANCELED = 'N'
   and       f.last_abt_key = '" || sAbtKey || "'
   and       f.LAST_STAT_KEY = '" || sStatKey || "'
   and       f.LAST_GRUPPE_KEY = g.GRUPPE_KEY
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )


group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL"
.head 9 +  Else
.head 10 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY)
from 	GRUPPE g, BEWEGUNG bew, BETT b
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = g.GRUPPE_KEY
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and	b.CANCELED = 'N'
   and       bew.abt_key = '" || sAbtKey || "'
   and       bew.STAT_KEY = '" || sStatKey || "'
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtGetTime
   and       (bew.bew_zeit_bis> :dtGetTime or bew.bew_zeit_bis is null  )


group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL"
.head 9 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 9 +  If not SqlFetchNext( hSqlGruppe, nFetchNext )
.head 10 -  Call AddGruppeToStation (hStation, sAbtKey, sStatKey, sGrpKey, bForceScan)
.head 10 -  Call SqlDisconnect( hSqlGruppe )
.head 9 -  Else
.head 8 +  ! Else
.head 9 -  Set hGrp = FindH_4Gruppe( FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan ), sGrpKey, bForceScan )
.head 7 -  !
.head 7 -  ! Call PopulateAndExpand(hStation, bAutoScan )
.head 7 -  Set nIndex = GetItemIndex( hStation )
.head 7 +  If Not Expand( nIndex )
.head 8 -  Return FALSE
.head 7 -  ! Set hGrp = SearchFrom( hStation, sGrpKey )
.head 7 -  Set hGrp = FindChild( hStation, sGrpKey )
.head 7 -  Set nIndex = GetItemIndex( hGrp )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Call SetOutlineRedraw ( TRUE)
.head 8 -  Return 0
.head 7 -  Call ActivateSelectedItem(  )     
.head 7 +  If not KHE_IsPopulated( hGrp )
.head 8 -  Call PopulateAndExpand( hGrp, bAutoScan )
.head 7 +  If not KHE_IsExpanded( hGrp )
.head 8 +  If Not Expand( nIndex )
.head 9 -  Return FALSE
.head 7 +  If bBreedingIsON
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 8 +  If sOpenKHKItemOnScan = "On" and not hWnd_POC
.head 9 -  Call SalPostMsg( hWndItem, SAM_ContextMenu,  -1, -1 )
.head 7 +  If nPozish>0
.head 8 -  Call SetPOCPos(hGrp, nPozish)
.head 7 -  Call SetOutlineRedraw ( TRUE)
.head 7 +  If not KHE_IsOccupied_ByHandle( hGrp, dtGetTime )
.head 8 -  Call SalSendMsg(hWndStar2000, AM_AddCage, hGrp, 0)
.head 7 +  If bDischargeDead 
.head 8 +  If bDeadInCage
.head 9 +  If nCountDead > -1
.head 10 +  If GalMessageBox( D_GetMessageStatic( 10033 ), D_GetMessageStatic( 11060 ) , MB_YesNo) =IDYES
.head 11 -  Set hTemp = nSelectedHandle
.head 11 +  While nCountDead > -1
.head 12 -  Set nSelectedHandle = nFallDeadHandle[nCountDead]
.head 12 -  Call MultiSelect(  )
.head 12 -  Set nCountDead = nCountDead -1
.head 11 -  Set nSelectedHandle = hTemp
.head 11 -  Call Move_GroupRelease(TRUE)
.head 11 -  Set nCountDead = -1
.head 10 +  Else
.head 11 -  Call UnSelect(  )
.head 9 +  Else
.head 10 +  If GalMessageBox( D_GetMessageStatic( 10033 ), D_GetMessageStatic( 11061) , MB_YesNo)  =IDYES
.head 11 -  Call Move_GroupRelease(TRUE)
.head 10 +  Else
.head 11 -  Call UnSelect(  )
.head 7 -  Call SalArraySetUpperBound( nFallDeadHandle, 1, -1 )
.head 7 -  Set bDeadInCage = FALSE
.head 7 -  ! Set bSelectDead = FALSE
.head 7 -  Set bMatingCage = FALSE
.head 7 +  If NOT GetIsRackVirtual_ByHandle(hGrp)
.head 8 +  If (NOT bPlanningMode)  and GalGetProfileBooleanX( "KHE", "ShowSevicesAndMR", FALSE, sUserINIFileName ) !!!!!!!!and not bOpenCageFromWorkList
.head 9 +  If SalStrUpperX( GalGetProfileStringX(  "KHE", "AutoStartService", "ASK", sUserINIFileName) ) = "ON" 
.head 10 -  Set cCage = SalObjCreateFromString("clsCageServices")
.head 10 -  Call cCage.Init( sAbtKey||";"||sStatKey||";"||sGrpKey )
.head 9 +  Else If SalStrUpperX( GalGetProfileStringX(  "KHE", "AutoStartService", "ASK", sUserINIFileName) ) = "ASK" 
.head 10 +  If GalMessageBox("Service Workflow" , "Perform services for cage " || RemoveLead0(  sGrpKey ) || " in rack " || RemoveLead0(sStatKey) || " ?", MB_YesNo ) = IDYES
.head 11 -  Set cCage = SalObjCreateFromString("clsCageServices")
.head 11 -  Call cCage.Init(  sAbtKey||";"||sStatKey||";"||sGrpKey )
.head 9 +  Else
.head 10 -  Set cCage.bIsEmpty = TRUE
.head 9 -  ! Set bAutoShowTableSevices = FALSE
.head 8 +  Else
.head 9 -  Set cCage.bIsEmpty = TRUE
.head 8 -  ! Set sQuestionOnShowTableServices = ""
.head 8 -  Call SalPostMsg( hWndBreedingBook, AM_Breeding_OpenDL, GetCageNR_ByHandle( hGrp ), 0 )
.head 8 +  If bMoveToVirt and ((cCage = OBJ_Null) or cCage.bIsEmpty)
.head 9 +  If TempIsPossible(FALSE,0)
.head 10 -  If SalSendMsg( hWndKHE, AM_KHE_OpenTempCage, 0, 0 )
.head 10 -  Set hGrp = hCageInVirt
.head 10 -  Set hCageInVirt = 0
.head 7 +  If _GetPositionID( hGrp, oCage )
.head 8 -  Call T_OpenCage( oCage.nCageID,oCage.nScreenID, GetPOCPort(nSelectedHandle) )
.head 7 -  ! Call T_OpenCage( GetCageID(sStatKey, sGrpKey ), GetPOCPort(nSelectedHandle) )
.head 7 -  Return hGrp
.head 5 +  Function: OpenLitter
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nBet
.head 7 -  Number: nIndex
.head 7 -  Number: hBet[*]
.head 7 -  Number: nFlags
.head 7 -  Number: nValueLoc
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  If GalGetProfileBooleanX(  "LitterWidget", "VisibleLitterWidget", TRUE,  sUserINIFileName)
.head 8 -  ! Return SalModalDialog( dlgChooseLitterEdit, hWndForm,  lParam)
.head 8 +  If nSelectedLevel = KHEL_Bett
.head 9 -  Call GetItemData(nSelectedHandle, sText, nValueLoc, nFlags)
.head 9 +  If SalStrScan(sText, ', F,')>0
.head 10 -  Call ActivateSelectedItem(  )
.head 10 -  ! Call SalModalDialog( dlgChooseLitterEdit, hWndForm, GetFallKey_ByHandle(nSelectedHandle),-1)
.head 10 -  Call OpenLitterWidget(hActiveSession,0,  GetFallKey_ByHandle(nSelectedHandle),-1, hWndRack2DView)
.head 8 +  Else
.head 9 -  Set nBet= EnumChildren( nSelectedHandle, hBet )
.head 9 +  If nBet
.head 10 -  Set i=0
.head 10 +  Loop
.head 11 +  If i >=nBet
.head 12 -  Break
.head 11 -  Call GetItemData( hBet[i], sText, nValueLoc, nFlags )
.head 11 +  If SalStrScan(sText, ', F,')>0
.head 12 -  Set nIndex = GetItemIndex(  hBet[i] )
.head 12 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 13 -  Return FALSE
.head 12 -  Set nSelectedLevel = KHEL_Bett
.head 12 -  Call ActivateSelectedItem(  )
.head 12 -  ! Call SalModalDialog( dlgChooseLitterEdit, hWndForm, GetFallKey_ByHandle(hBet[i]),-1)
.head 12 -  Call OpenLitterWidget(hActiveSession,0,  GetFallKey_ByHandle(hBet[i]),-1, hWndRack2DView)
.head 12 -  Break
.head 12 -  ! Call SalSendMsg( hWndMDI, AM_Menu, 1, FMenu_Bearb_Neugeb  )
.head 11 -  Set i=i+1
.head 5 +  Function: GotoGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hAbt
.head 7 -  Number: hStat
.head 7 -  Number: hGrp
.head 6 +  Actions
.head 7 +  If Not OpenGruppe( sAbtKey, sStatKey, sGrpKey, bForceScan, 0 )
.head 8 -  Return FALSE
.head 7 -  ! AS 11.11.2004 - It exists in OpenGruppe()
.head 7 -  ! Call ActivateSelectedItem(  )
.head 7 -  Return TRUE
.head 5 +  Function: GotoGruppeByString
.head 6 -  Description: String param should be ABT_KEY;STAT_KEY;GRUPPE_KEY
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sWhereToGo
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 +  If ExtractPlaceFromString( sWhereToGo, sAbtKey, sStatKey, sGrpKey, sBettKey ) < 3
.head 8 -  Call SalMessageBeep( MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 -  Return GotoGruppe( sAbtKey, sStatKey, sGrpKey, bForceScan )
.head 5 +  Function: GotoGruppeByFallKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtGetTime
.head 7 -  Sql Handle: hSqlGGBFK
.head 7 -  Number: ni
.head 6 +  Actions
.head 7 -  Call GalConnect( hSqlGGBFK )
.head 7 +  If bRealTimeMode
.head 8 +  ! If not DoImmediate("
select	f.LAST_ABT_KEY, f.LAST_STAT_KEY, f.LAST_GRUPPE_KEY
from	FALL f
where	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.FALL_KEY = " || StrX( nFallKey ) || "
   and	f.LAST_BEW_NR in ('AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
into	:s[1], :s[2], :s[3] ")
.head 9 -  Return FALSE
.head 8 -  Call SqlPrepareAndExecute( hSqlGGBFK, "
select	f.LAST_ABT_KEY, f.LAST_STAT_KEY, f.LAST_GRUPPE_KEY
from	FALL f
where	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.FALL_KEY = " || StrX( nFallKey ) || "
   and	f.LAST_BA_KEY in ('AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
into	:s[1], :s[2], :s[3] " )
.head 7 +  Else
.head 8 -  Set dtGetTime = GetTime4Refresh(  )
.head 8 +  ! If not DoImmediate("
select	bew.ABT_KEY, bew.STAT_KEY, bew.GRUPPE_KEY
from	FALL f, BEWEGUNG bew
where	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.FALL_KEY = " || StrX( nFallKey ) || "
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
  and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
  and	bew.Fall_KEY = f.Fall_KEY
  and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
  and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   
into	:s[1], :s[2], :s[3] ")
.head 9 -  Return FALSE
.head 8 -  Call SqlPrepareAndExecute( hSqlGGBFK, "
select	bew.ABT_KEY, bew.STAT_KEY, bew.GRUPPE_KEY
from	FALL f, BEWEGUNG bew
where	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.FALL_KEY = " || StrX( nFallKey ) || "
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
  and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
  and	bew.Fall_KEY = f.Fall_KEY
  and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
  and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   
into	:s[1], :s[2], :s[3] " )
.head 7 -  Call SqlFetchNext( hSqlGGBFK, ni )
.head 7 -  Call SqlDisconnect( hSqlGGBFK )
.head 7 -  Return GotoGruppe( s[1], s[2], s[3], bForceScan )
.head 5 +  Function: OpenBett
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hBett
.head 7 -  Number: hAbt
.head 7 -  Number: hStation
.head 7 -  Number: hCage
.head 7 -  Number: nLeft
.head 7 -  Number: hChildren[*]
.head 6 +  Actions
.head 7 -  !
.head 7 +  If Not KHE_IsPopulated ( hRoot )
.head 8 -  Call PopulateItem( hRoot, TRUE )
.head 7 +  If Not KHE_IsExpanded( hRoot )
.head 8 -  Set nIndex = GetItemIndex( hRoot )
.head 8 -  Call Expand( nIndex )
.head 8 -  Call KHEReAssignPics( hRoot )
.head 7 -  Set hAbt = FindChild( hRoot , sAbtKey )
.head 7 +  If Not KHE_IsPopulated ( hAbt )
.head 8 -  Call PopulateItem( hAbt, TRUE )
.head 7 +  If Not KHE_IsExpanded( hAbt )
.head 8 -  Set nIndex = GetItemIndex( hAbt )
.head 8 -  Call Expand( nIndex )
.head 8 -  Call KHEReAssignPics( hAbt )
.head 7 -  Set hStation = FindChild( hAbt , sStatKey )
.head 7 +  If Not KHE_IsPopulated ( hStation )
.head 8 -  Call PopulateItem( hStation, TRUE )
.head 7 +  If Not KHE_IsExpanded( hStation )
.head 8 -  Set nIndex = GetItemIndex( hStation )
.head 8 -  Call Expand( nIndex )
.head 8 -  Call KHEReAssignPics( hStation )
.head 7 -  Set hCage = FindChild( hStation , sGrpKey )
.head 7 +  If not hCage and bShowOnlyOpenCages
.head 8 -  Set hCage = OpenGruppe (sAbtKey,sStatKey,sGrpKey, bForceScan, 0)
.head 7 +  If Not KHE_IsPopulated ( hCage )
.head 8 -  Call PopulateItem( hCage, TRUE )
.head 7 +  If Not KHE_IsExpanded( hCage )
.head 8 -  Set nIndex = GetItemIndex( hCage )
.head 8 -  Call Expand( nIndex )
.head 8 -  Call KHEReAssignPics( hCage )
.head 7 -  Set hBett = FindChild(hCage , sBettKey )
.head 7 +  If hBett = 0
.head 8 -  Return 0
.head 7 -  Set nIndex = GetItemIndex( hBett )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return 0
.head 7 -  Call ActivateSelectedItem(  )
.head 7 -  !
.head 7 -  ! AS 11.11.2004 using bAutoScan instead of FALSE
.head 7 -  Call PopulateAndExpand( hBett, bAutoScan )
.head 7 -  ! *****
.head 7 -  ! If bBreedingIsON And (sOpenKHKItemOnScan = "On") 
.head 7 +  If Not bPastingMovement
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 8 +  If sOpenKHKItemOnScan = "On" or sOpenKHKItemOnScan = "YES"
.head 9 -  Call SalPostMsg( hWndItem, SAM_ContextMenu, -1, -1 )
.head 7 +  ! If bBreedingIsON
.head 8 +  If Not bPastingMovement
.head 9 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 9 -  Call SalPostMsg( hWndItem, SAM_ContextMenu, -1, -1 )
.head 7 -  Return hBett
.head 5 +  Function: GotoBett
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return OpenBett( sAbtKey, sStatKey, sGrpKey, sBettKey, bForceScan )
.head 5 +  Function: GotoBettByString
.head 6 -  Description: String param should be ABT_KEY;STAT_KEY;GRUPPE_KEY;BETT_KEY
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sWhereToGo
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 +  If ExtractPlaceFromString( sWhereToGo, sAbtKey, sStatKey, sGrpKey, sBettKey ) < 4
.head 8 -  Call SalMessageBeep( MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 -  Return GotoBett( sAbtKey, sStatKey, sGrpKey, sBettKey, bForceScan )
.head 5 +  Function: OpenBettByFallKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExist
.head 7 -  Number: hStation
.head 7 -  String: sABT
.head 7 -  String: sStat
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Call VisWaitCursor( TRUE )
.head 7 +  If Not KHE_IsExpanded( nSelectedHandle )
.head 8 -  Call PopulateAndExpand( nSelectedHandle, FALSE )
.head 7 -  Set bOk = DoImmediateSingle( "
select	FALL_KEY 
from	FALL
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY = " || StrX( nFallKey ) || "
   and	GELOESCHT = 'N' 
", bExist )
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 +  If bOk And Not bExist
.head 8 -  Call ErrorMessageBox( 137 )
.head 8 -  Set bOk = FALSE
.head 7 +  If Not bOk
.head 8 -  Return FALSE
.head 7 -  Set s[1] =""
.head 7 -  Set s[2] =""
.head 7 -  Set s[3] =""
.head 7 -  Set s[4] =""
.head 7 +  If bRealTimeMode
.head 8 +  If not DoImmediate("
select	f.LAST_ABT_KEY, f.LAST_STAT_KEY, f.LAST_GRUPPE_KEY, f.LAST_BETT_KEY
into	:s[1],:s[2],:s[3],:s[4]
from	FALL f
where	f.EINRICHT_ID = :nEinrichtId
   and	f.FALL_KEY = " || SalNumberToStrX(nFallKey,0)   || "
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	f.GELOESCHT = 'N'
order by	f.LAST_BEW_NR desc
")
.head 9 -  Return FALSE
.head 7 +  Else
.head 8 +  If not DoImmediate("
select	b.ABT_KEY, b.STAT_KEY, b.GRUPPE_KEY, b.BETT_KEY
into	:s[1],:s[2],:s[3],:s[4]
from	BEWEGUNG b
where	b.EINRICHT_ID = :nEinrichtId
   and	b.FALL_KEY = " || SalNumberToStrX(nFallKey,0)   || "
   and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	b.BEW_ZEIT <= :dtKHK_RefreshTime
   and	(b.BEW_ZEIT_BIS >:dtKHK_RefreshTime  or b.bew_zeit_bis is null )
   and	b.GELOESCHT = 'N'
order by	b.BEW_ZEIT desc, b.BEW_NR desc
")
.head 9 -  Return FALSE
.head 7 +  If not s[1] or not s[2] or not s[3] or not s[4]
.head 8 -  Call SalPostMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( nFallKey ) )
.head 8 -  Return FALSE
.head 7 -  Set sABT = s[1]
.head 7 -  Set sStat = s[2]
.head 7 -  Set sCage = s[3]
.head 7 -  Set sBett = s[4]
.head 7 -  ! Set hStation= FindH_4Station( FindH_4Abteilung( sABT ), sStat, FALSE )
.head 7 +  ! If bShowOnlyOpenCages and FindH_4Gruppe( hStation, sCage, FALSE ) = 0
.head 8 -  Call AddGruppeToStation (hStation, sABT,sStat,sCage, bForceScan)
.head 7 -  Return GotoBett(sABT,sStat,sCage,sBett, bForceScan )
.head 5 +  Function: GotoBettByFallKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return OpenBettByFallKey( nFallKey, bForceScan )
.head 5 +  Function: CloseGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bForceScan
.head 7 -  Number: hGrp
.head 7 -  Number: nScan
.head 7 -  Number: nLength
.head 7 -  Number: nIndex
.head 7 -  Number: hStation
.head 7 -  Sql Handle: hSqlGruppe
.head 7 -  String: sSqlGruppe
.head 7 -  Boolean: bOk
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetchNext
.head 7 -  Boolean: DelGrp
.head 7 -  Number: nFetch
.head 7 -  Number: nGrp
.head 7 -  Number: hAbt
.head 7 -  Number: nCageClose
.head 7 -  Number: nPort
.head 7 -  Number: nNeedPrint
.head 7 -  FunctionalVar: cCage[1]
.head 8 -  Class: clsLocation
.head 7 -  FunctionalVar: cDistinct
.head 8 -  Class: clsLocationCage
.head 7 -  Boolean: bPrint
.head 6 +  Actions
.head 7 +  If not sAbtKey or not  sStatKey or not sGrpKey
.head 8 -  Return FALSE
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set nCageClose = GetCageID(sStatKey,sGrpKey  )
.head 7 -  Call T_GetStateCage(nCageClose,nPort, nNeedPrint )
.head 7 -  Call T_CloseCage(  nCageClose )
.head 7 +  If nNeedPrint
.head 8 -  Call cDistinct.Init( sAbtKey, sStatKey, sGrpKey )
.head 8 -  Set cCage[0] = cDistinct
.head 8 -  If Not Requst_ListForCageCard( cCage, "Cage Cards For Source And Destination Cages", bPrint )
.head 8 +  If bPrint
.head 9 -  Call Formular_CageCard_Print( '', '', dtGetTime )
.head 7 -  Set bForceScan = FALSE
.head 7 -  Set hAbt = FindChild( hRoot , sAbtKey )
.head 7 -  Set hStation = FindChild( hAbt, sStatKey )
.head 7 -  Set hGrp = FindChild( hStation, sGrpKey )
.head 7 +  If SalIsWindowVisible( hWndTblShowService )
.head 8 -  Call SalSendMsg( hWndTblShowService, AM_KHE_CloseGrp, SalHStringToNumber( sGrpKey ), SalHStringToNumber( sStatKey ) )
.head 7 +  If bOpenTempCage and not CageIsTemp(sStatKey, sGrpKey)
.head 8 +  If not CloseCageTemp( hGrp, dtGetTime )
.head 9 -  Return FALSE
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call frmPOC.CloseCageFromKHE( sAbtKey, sStatKey, sGrpKey )
.head 7 -  !
.head 7 -  Set nIndex = GetItemIndex( hGrp )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  Call ActivateSelectedItem( )
.head 7 -  Call CollapseNode( hGrp )
.head 7 -  Call SalSendMsg(hWndStar2000, AM_RemoveCage, hGrp, 0)
.head 7 -  Call Refresh_HandleToPlace()
.head 7 +  If bBreedingIsON And (sOpenKHKItemOnScan = "On") and bShowMenuOnClosingCage
.head 8 -  Call SalSendMsg( hWndItem,SAM_Click,wParam, lParam )
.head 8 -  Call SalPostMsg( hWndItem, SAM_ContextMenu,  -1, -1 )
.head 7 +  If bShowOnlyOpenCages
.head 8 -  Call DeleteGruppeFromStation (hGrp)
.head 8 -  Call Focus(hStation)
.head 8 -  Return TRUE
.head 7 +  If (bShowWithContent and not bShowOnlyOpenCages)
.head 8 +  If Not GalConnect( hSqlGruppe )
.head 9 -  Return FALSE
.head 8 -  Set bOk =FALSE
.head 8 -  ! Set sSqlGruppe = "
select     g.GRUPPE_KEY
from      GRUPPE g
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY = '" || sStatKey || "'
   and     g.CANCELED = 'N'
   and     g.GRUPPE_KEY = '" || sGrpKey || "'
   and     exists(select bett_key from bett b
          where     b.EINRICHT_ID =g.EINRICHT_ID
             and      b.STAT_KEY =g.STAT_KEY
                and     b.GRUPPE_KEY = g.GRUPPE_KEY
               and     b.CANCELED = 'N' )

   and  not exists ( select     bew.BA_KEY
               from       BEWEGUNG bew
               where      g.EINRICHT_ID =bew.EINRICHT_ID
                   and      bew.STAT_KEY= g.STAT_KEY
                   and      g.CANCELED = 'N'
                   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
                   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
                   and       bew.bew_zeit <:dtGetTime
                   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
                   
    )
  and      not exists (select bl.EINRICHT_ID
                         from BETT_LOCKS bl
                         where bl.STAT_KEY=g.STAT_KEY
                         and bl.EINRICHT_ID=g.EINRICHT_ID
                         and       bl.GRUPPE_KEY = g.GRUPPE_KEY
                         and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
                                )
into	:sGrpKey"
.head 8 -  Set sSqlGruppe = "
select     g.GRUPPE_KEY
from      GRUPPE g
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY = '" || sStatKey || "'
   and     g.CANCELED = 'N'
   and     g.GRUPPE_KEY = '" || sGrpKey || "'
     and     exists(select bett_key from bett b
          where     b.caGE_ID =g.ID
                          and     b.CANCELED = 'N' )

  
   and  not exists ( select     bew.BA_KEY
               from       BEWEGUNG bew
               where        bew.CAGE_ID = g.ID
                   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
                   and       bew.bew_zeit <:dtGetTime
                   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
                   
    )
  and      not exists (select bl.EINRICHT_ID
                         from BETT_LOCKS bl , BETT b
                         where b.CAGE_ID=g.ID
		and  bl.POS_ID=b.ID
		 and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
                                )
into	:sGrpKey"
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 8 +  If SqlFetchNext( hSqlGruppe, nFetchNext )
.head 9 -  Call DeleteGruppeFromStation (hGrp)
.head 9 -  ! Set sSqlGruppe = "
select     g.GRUPPE_KEY
from      GRUPPE g
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY = '" || sStatKey || "'
   and     g.CANCELED = 'N'
   and     exists(select bett_key from bett b
          where     b.EINRICHT_ID =g.EINRICHT_ID
             and      b.STAT_KEY =g.STAT_KEY
                and     b.GRUPPE_KEY = g.GRUPPE_KEY
               and     b.CANCELED = 'N' )

   and  not exists ( select     bew.BA_KEY
               from       BEWEGUNG bew
               where      g.EINRICHT_ID =bew.EINRICHT_ID
                   and      bew.STAT_KEY= g.STAT_KEY
                   and      g.CANCELED = 'N'
                   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
                   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
                   and       bew.bew_zeit <:dtGetTime
                   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
                   
    )
  and      not exists (select bl.EINRICHT_ID
                         from BETT_LOCKS bl
                         where bl.STAT_KEY=g.STAT_KEY
                         and bl.EINRICHT_ID=g.EINRICHT_ID
                         and       bl.GRUPPE_KEY = g.GRUPPE_KEY
                         and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
                                )
into	:sGrpKey "


.head 9 -  Set sSqlGruppe = "
select     g.GRUPPE_KEY
from      GRUPPE g
where     g.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and      g.STAT_KEY = '" || sStatKey || "'
   and     g.CANCELED = 'N'
    and     exists(select bett_key from bett b
          where     b.CAGE_ID =g.ID
                 and     b.CANCELED = 'N' )

   and  not exists ( select     bew.BA_KEY
               from       BEWEGUNG bew
               where        bew.CAGE_ID = g.ID
                   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
                   and       bew.bew_zeit <:dtGetTime
                   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
                   
    )
  and      not exists (select bl.EINRICHT_ID
                         from BETT_LOCKS bl , BETT b
                         where b.CAGE_ID=g.ID
				and bl.POS_ID=b.ID
				
                         and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
                                )
into	:sGrpKey "


.head 9 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 9 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 10 -  Set hGrp = SearchFrom( hStation, sGrpKey )
.head 10 +  If hGrp <= 0
.head 11 -  Set nGrp = nGrp + 1
.head 9 -  Set hGrp = SearchFrom( hStation, 'Empty Cages in Rack')
.head 9 -  Call SetItemText( hGrp, SalNumberToStrX(nGrp,0) || '  Empty Cages in Rack' )
.head 9 -  Call SqlDisconnect( hSqlGruppe )
.head 9 -  Call Focus(hStation)
.head 9 -  Return TRUE
.head 7 +  If SalIsWindowVisible( hWnd_EarTags ) and hWnd_EarTags.sGruppeKey = sGrpKey
.head 8 -  Call SalSendMsg(hWnd_EarTags,SAM_Close,0,0)
.head 7 +  If DelGrp
.head 8 -  Call PopulateAndExpand( hStation, bForceScan )
.head 8 -  Call Focus(hStation)
.head 7 -  Return TRUE
.head 5 +  Function: CloseGruppeByString
.head 6 -  Description: String param should be ABT_KEY;STAT_KEY;GRUPPE_KEY
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sWhereToGo
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 +  If ExtractPlaceFromString( sWhereToGo, sAbtKey, sStatKey, sGrpKey, sBettKey ) < 3
.head 8 -  Call SalMessageBeep( MB_IconExclamation )
.head 8 -  Return FALSE
.head 7 -  Return CloseGruppe( sAbtKey, sStatKey, sGrpKey )
.head 5 -  !
.head 5 +  Function: KHE_SelectPurpose
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sPurposeKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 +  If SalModalDialog( dlgPurposeSelect, hWndForm, sPurposeKey )
.head 8 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 8 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurposeKey || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStatKey  || "'
   and	GRUPPE_KEY = '" || sGruppeKey  || "'
;
commit")
.head 9 -  Call RefreshSingleGruppeLabel( nSelectedHandle, sGruppeKey, sStatKey )
.head 8 +  Else
.head 9 -  Call DoImmediate("rollback")
.head 5 +  Function: KHE_SelectColor
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nColor
.head 7 -  String: sGruppeKey
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 +  If SalModalDialog( dlgSelectPredefinedColor, hWndForm, nColor )
.head 8 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 8 +  If DoImmediate("
update	GRUPPE
set	COLOR = " || StrX( nColor ) || "
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStatKey  || "'
   and	GRUPPE_KEY = '" || sGruppeKey  || "'
;
commit ")
.head 9 -  Call SetItemColor( nSelectedHandle, nColor)
.head 8 +  Else
.head 9 -  Call DoImmediate("rollback")
.head 5 +  Function: KHE_CallAufnahme
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nAM_Aufnahme_Msg
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 -  Set bCallerKHE = TRUE
.head 7 -  Set bBettDispoBar = TRUE
.head 7 -  !
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 -  Call GalSetProfileString( 'Bettendispo',  'CurrentStation',  sStatKey,  sUserINIFileName )
.head 7 -  Call GalSetProfileString( 'Bettendispo', 'CurrentGruppe',  sGruppeKey, sUserINIFileName )
.head 7 +  If BettIsSummary()
.head 8 -  Set sBettKey=AddWonBett(dtKHK_RefreshTime)
.head 8 +  If not sBettKey or sBettKey = 'In Cage:' or (bMiniSolution and sBettKey = 'Cage is used') or (bMiniSolution and sBettKey = 'Cage is not used')
.head 9 -  Return FALSE
.head 7 -  Call GalSetProfileString( 'Bettendispo', 'CurrentBett',  sBettKey, sUserINIFileName )
.head 7 -  !
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Call GalSetProfileString( 'Bettendispo', 'CurrentDate', SalFmtFormatDateTime(dtKHK_RefreshTime, 'DD.MM.YYYY hhhh:mm'), sUserINIFileName )
.head 7 -  !
.head 7 -  Call SalPostMsg( hWndStar2000, AM_BettDispo, nAM_Aufnahme_Msg, 0)
.head 5 +  Function: KHE_HS_for_Rack
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sStat
.head 6 +  Actions
.head 7 -  Set sStat = GetCurrentLevelKey( KHEL_Station )
.head 7 -  Call HelStat_Set4GruppeDlg( hWndForm, sStat, '' )
.head 5 +  Function: KHE_HS_for_Cage
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 7 +  If DoCloseTransaction( HelStat_Set4GruppeDlg( hWndForm, sStat, sGrp ) )
.head 8 -  Call SalPostMsg( hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 5 +  Function: KHE_CageMemberBarcodes
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 -  Call GetTime4Refresh(  )
.head 7 -  ! Call Formular_Show( 'BC_CAGE', sStatKey || "," || sGruppeKey || "," || SalFmtFormatDateTime( dtKHK_RefreshTime, 'yyyy-MM-dd hhhh:mm:ss' ), FALSE )
.head 7 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, 'BC_CAGE', FALSE, FALSE )
.head 5 +  Function: KHE_UpdateGruppeAttributes
.head 6 -  Description: For GSF project, when all mice leave the cage,
it's attributes should be cleared
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFALL_KEY
.head 7 -  Number: nBEW_NR
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bExists
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bUpdated
.head 7 -  String: sSqlSelect
.head 7 -  String: sAbt_Key_4Fall
.head 7 -  String: sAbt_Key_Tmp
.head 7 -  String: sStat_Key_Tmp
.head 7 -  String: sGrp_Key_Tmp
.head 7 -  String: sBett_Key_Tmp
.head 7 -  Number: nLE_Id_Tmp
.head 7 -  Number: nFallKey_Tmp
.head 7 -  Boolean: bIsBewReal
.head 7 -  Date/Time: dtBew_Lock_Zeit
.head 6 +  Actions
.head 7 +  If bPlanningMode Or Not bUseCurrentTime
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  Set s1 = ""
.head 7 -  Set s2 = ""
.head 7 -  Set s3 = ""
.head 7 -  ! Search for the prev. Bewegung
.head 7 -  Set bOk = DoImmediateSingle( "
select	GRUPPE_KEY, STAT_KEY, ABT_KEY
into	:s1, :s2, :s3
from	BEWEGUNG
where	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	FALL_KEY = " || StrX( nFALL_KEY ) || "
   and	BEW_NR < " || StrX( nBEW_NR ) || "
   and	GELOESCHT = 'N'
order by	BEW_NR desc ", bExists )
.head 7 +  If Not bOk
.head 8 -  Return FALSE
.head 7 -  Set sAbt_Key_Tmp = s3
.head 7 -  Set sStat_Key_Tmp = s2
.head 7 -  Set sGrp_Key_Tmp = s1
.head 7 -  Set sBett_Key_Tmp = ''
.head 7 +  If Not bExists Or Not sStat_Key_Tmp Or Not sGrp_Key_Tmp
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  ! Search for other FALLs in that place on Now
.head 7 -  Call GetTime4Refresh(  )
.head 7 +  If Not Bew_GetFall_InPlaceOnDateX( 
		bShowOnlyRealBew, dtKHK_RefreshTime, 
		sAbt_Key_4Fall, sStat_Key_Tmp, sGrp_Key_Tmp, sBett_Key_Tmp, 
		nLE_Id_Tmp, nFallKey_Tmp, bIsBewReal, dtBew_Lock_Zeit )
.head 8 +  If bPlanningMode
.head 9 -  Set bUpdated = TRUE
.head 8 +  Else
.head 9 -  Set bUpdated = KHE_ClearCagePurpose( sStat_Key_Tmp, sGrp_Key_Tmp )
.head 8 +  ! If bUpdated And hKHK_GruppeThatMayBeEmpty
.head 9 -  Call RefreshSingleGruppeLabel( hKHK_GruppeThatMayBeEmpty, '' , '')
.head 9 -  Set hKHK_GruppeThatMayBeEmpty = 0
.head 8 +  If bUpdated
.head 9 +  If GotoGruppe( sAbt_Key_Tmp, sStat_Key_Tmp, sGrp_Key_Tmp, bAutoScan )
.head 10 -  Call Refresh_HasFall( nSelectedHandle, dtKHK_RefreshTime )
.head 10 -  Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp_Key_Tmp , sStat_Key_Tmp)
.head 7 -  Return bUpdated
.head 5 -  ! AOS - Internal Request
.head 5 +  Function: KHE_ShowIRServices
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sWorkList
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  String: sStrain_Key
.head 7 -  String: sSex
.head 7 -  Number: nAge
.head 6 +  Actions
.head 7 -  Set nInternalRequestLstErfNr = NUMBER_Null
.head 7 -  Set nInternalRequestOrderId = NUMBER_Null
.head 7 -  Set nInternalRequestOrderPosNr = NUMBER_Null
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 -  Set hWnd_IRServices=SalCreateWindow( frmIRServices, hWndStar2000 , sWorkList)
.head 7 +  ! If Not IR_RequestServices (sAbtKey, sStrain_Key, sSex, nAge, nInternalRequestOrderId, nInternalRequestOrderPosNr, nInternalRequestLstErfNr )
.head 8 -  Return FALSE
.head 7 +  ! If Not IR_GetFallsForIRService (sAbtKey, sStrain_Key, sSex, nAge, sFallsAvailableForCurrentIR)
.head 8 -  Call SalMessageBox( "There are no animals fulfilling selected Internal Order","Animal search...", MB_Ok )
.head 8 -  Return FALSE
.head 7 -  ! Call SalMessageBox( sAbtKey, sFallsAvailableForCurrentIR[0], MB_Ok)
.head 7 -  ! VARAN Set bInternalRequestMode = TRUE
.head 7 -  ! Call GotoGruppeByFallKey( SalStrToNumber (sFallsAvailableForCurrentIR[0]), bAutoScan )
.head 7 -  Return TRUE
.head 5 +  Function: KHE_IR_IsCurrentFallAreBooked
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKeyParm
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCounter
.head 6 +  Actions
.head 7 +  If not bInternalRequestMode
.head 8 -  Return FALSE
.head 7 -  Set nCounter=0
.head 7 +  While nInternalRequestCount > nCounter
.head 8 +  If NumberX(sFallsAvailableForCurrentIR[nCounter])=nFallKeyParm
.head 9 -  Return TRUE 
.head 8 -  Set nCounter=nCounter+1
.head 7 -  Return FALSE
.head 5 +  Function: KHE_ShowWorkLists
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  String: sStrain_Key
.head 7 -  String: sSex
.head 7 -  Number: nAge
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 -  ! Call SalCreateWindow( tblWorklistsOpened, hWndNULL, SalDateCurrent (), sAbtKey)
.head 7 +  If sAbtKey = sAbtKeyOld
.head 8 +  If SalIsWindowVisible (hWorkLstOpened) 
.head 9 -  Call SalBringWindowToTop (hWorkLstOpened)
.head 8 +  Else
.head 9 -  Set hWorkLstOpened = SalCreateWindow( tblWorklistsOpened, hWndStar2000 , SalDateCurrent (), sAbtKey)
.head 7 +  Else
.head 8 +  If SalIsWindowVisible (hWorkLstOpened) 
.head 9 -  Call SalSendMsg( tblWorklistsOpened, SAM_Close, 0, 0 )
.head 9 -  Set hWorkLstOpened = SalCreateWindow( tblWorklistsOpened, hWndStar2000 , SalDateCurrent (), sAbtKey)
.head 8 +  Else
.head 9 -  Set hWorkLstOpened = SalCreateWindow( tblWorklistsOpened, hWndStar2000 , SalDateCurrent (), sAbtKey)
.head 7 -  Set sAbtKeyOld = sAbtKey
.head 7 -  Return TRUE
.head 5 +  Function: KHE_FindFallOrCageForIR
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sStrain_KeyParam
.head 7 -  String: sSexParam
.head 7 -  Number: nAgeParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  ! If IR_Find
.head 5 -  !
.head 5 +  Function: KHE_ClearCagePurpose
.head 6 -  Description: For GSF project, when all mice leave the cage,
it's PURPOSEs should be cleared (if the PURPOSE is not marked as DONOTCLEAR_IFEMPTY)
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spStatKey
.head 7 -  String: spGruppeKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bPurposeExists
.head 7 -  String: sSql2Check
.head 6 +  Actions
.head 7 +  If nDB_Version >= 6.28
.head 8 -  Set sSql2Check = "
select	g.PURPOSE_KEY
from 	GRUPPE g, PURPOSE p
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	g.STAT_KEY = '" || spStatKey || "'
   and	g.GRUPPE_KEY = '" || spGruppeKey || "'
   and	p.PURPOSE_KEY = g.PURPOSE_KEY
   and	p.DONOTCLEAR_IFEMPTY = 0 "
.head 7 +  Else
.head 8 -  Set sSql2Check = "
select	g.PURPOSE_KEY
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	g.STAT_KEY = '" || spStatKey || "'
   and	g.GRUPPE_KEY = '" || spGruppeKey || "'
   and	g.PURPOSE_KEY is not null
   and not	(g.PURPOSE_KEY = 'TRANSFER') "
.head 7 -  Set bOk = DoImmediateSingle( sSql2Check, bPurposeExists )
.head 7 +  If Not bOk
.head 8 -  Return FALSE
.head 7 +  If Not bPurposeExists
.head 8 -  Return TRUE
.head 7 -  !
.head 7 -  Set bOk = DoImmediate("
update 	GRUPPE
set 	PURPOSE_KEY = null
where	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	STAT_KEY = '" || spStatKey || "'
   and	GRUPPE_KEY = '" || spGruppeKey || "'
;
commit ")
.head 7 +  If Not bOk
.head 8 -  Call DoRollback(  )
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: KHE_Plan2Real_Bew
.head 6 -  Description: Does InsertBewegung4Plan()
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey_Parm
.head 7 -  Number: nBewPlanNr_Parm
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBewNr_Real
.head 6 +  Actions
.head 7 -  Set nBewNr_Real = InsertBewegung4Plan( nFallKey_Parm,  nBewPlanNr_Parm )
.head 7 -  Return nBewNr_Real
.head 5 -  !
.head 5 +  Function: KHE_Download2Reader
.head 6 -  Description: Downloads all mice's Name1 of the current cage (place) o\into a Reader
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hBeds2Operate[*]
.head 7 -  Number: nBeds2Operate
.head 7 -  Number: hSource
.head 7 -  Number: nLevel
.head 7 -  Boolean: bOk
.head 7 -  String: sCustomCode
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  Number: n2Reader
.head 7 -  Number: nFall_Key
.head 6 +  Actions
.head 7 -  Set nLevel = GetLevel( nSelectedHandle )
.head 7 +  Select Case nLevel
.head 8 +  Case KHEL_Bett
.head 9 -  Set nFall_Key = GetFallKey_ByHandle( nSelectedHandle )
.head 9 +  If nFall_Key
.head 10 -  Set hBeds2Operate[ nBeds2Operate ] = nSelectedHandle
.head 10 -  Set nBeds2Operate = 1
.head 10 -  Set hSource = nSelectedHandle
.head 9 +  Else
.head 10 -  Set nBeds2Operate = 0
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set hSource = nSelectedHandle
.head 9 -  Call PopulateAndExpand( hSource, FALSE )
.head 9 -  Set nBeds2Operate = EnumChildren( hSource, hBeds2Operate )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Return FALSE
.head 7 -  !
.head 7 +  If nBeds2Operate < 0
.head 8 -  Return FALSE
.head 7 +  Else If nBeds2Operate = 0
.head 8 -  Call SalMessageBox( "Nothing to download.", "Download to Reader", MB_IconInformation )
.head 8 -  Return TRUE
.head 7 -  !
.head 7 +  If Reader_IsBluetoothConfigured( )
.head 8 +  If nBeds2Operate != 1
.head 9 -  Call SalMessageBox( 'Sorry. The feature is under construction at the moment!', 'Warning!', MB_IconExclamation )
.head 9 -  Return FALSE
.head 8 -  Set bOk = Reader_FindTransponder( nFall_Key )
.head 7 +  Else If Reader_IsTrovanConfigured( )
.head 8 -  Call GetPosition( hSource, sAbt, sStat, sGrp, sBett )
.head 8 -  Set sCustomCode = sStat || '/' || sGrp
.head 8 -  !
.head 8 -  ! Prepare Arays for Downloading
.head 8 +  If nBeds2Operate
.head 9 -  Call SalSendMsg( hWndStar2000, AM_ReaderArray_Init, 0, 0 )
.head 9 -  Set n2Reader = 0
.head 9 +  While n2Reader < nBeds2Operate
.head 10 -  Set s1 = GetName1_FromLable( GetItemText( hBeds2Operate[ n2Reader ] ) )
.head 10 -  Set s2 = sCustomCode
.head 10 -  Call SalSendMsg( hWndStar2000, AM_ReaderArray_AddItem, GalSetAsWinMsgWParam_String( s1 ), GalSetAsWinMsgLParam_String( s2 ) )
.head 10 -  Set n2Reader = n2Reader + 1
.head 9 -  Set bOk = SalSendMsg( hWndStar2000, AM_Reader_Write2Reader, 0, 0 )
.head 7 -  !
.head 7 -  Return bOk
.head 5 +  Function: CallBulkImport
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sPlace
.head 7 -  String: sParam
.head 6 +  Actions
.head 7 -  ! Call SalSendMsg(hWndStar2000, AM_OpenDL, 0, 0)
.head 7 +  If Not GetCurrentPosition( sScreen, sRack, sCage, sPlace )
.head 8 -  Return FALSE
.head 7 +  If Not sScreen
.head 8 -  Return FALSE
.head 7 +  If Not sRack
.head 8 -  Return FALSE
.head 7 -  Set sParam = "/screen=" || sScreen || " " || "/rack=" || sRack
.head 7 +  If sCage
.head 8 -  Set sParam = sParam || " " || "/cage=" || sCage
.head 7 -  Return SalSendMsg( hWndStar2000, AM_Start_Bulkimport, SalHStringToNumber( sParam ), 0 )
.head 7 -  ! Return StartSeparateEXEx( 'Mice_Imp.exe', sParam )
.head 5 +  ! Function: KHE_ContextMenu
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: sTypeMenu
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Window Handle: hMenu
.head 6 +  Actions 
.head 7 +  If sTypeMenu = 'MenuCage'
.head 8 -  Call SetForegroundWindow( hWndForm )
.head 8 -  Set hMenu = CreatePopupMenu( )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1000, 'Purpose' )
.head 8 -  Call AppendMenuA( hMenu, MF_SEPARATOR, 0, '' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1001, 'Color' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1002, 'View &Cage Card' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1003, 'Print Cage Card' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1004, '&Barcodes of Cage Members' )
.head 8 -  Call AppendMenuA( hMenu, MF_SEPARATOR, 0, '' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1005, 'Cut' )
.head 8 -  !
.head 8 -  Call TrackPopupMenu( hMenu, TPM_RightAlign, nX, nY, 0, hWndForm, STRING_Null )
.head 8 -  !
.head 8 +  If Not Move_CanCut()
.head 9 -  Call EnableMenuItem( hMenu, 1005, MF_GRAYED )
.head 8 +  If (Not bBreedingIsON) And (Not Move_CanCut())
.head 9 -  Call EnableMenuItem( hMenu, 1004, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED )
.head 8 +  If Not bBreedingIsON
.head 9 -  Call EnableMenuItem( hMenu, 1003, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED )
.head 8 +  If Not bBreedingIsON
.head 9 -  Call EnableMenuItem( hMenu, 1002, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED )
.head 8 -  Set hLastOpenedMenu = hMenu
.head 7 +  ! If sTypeMenu = 'BettMenu'
.head 8 -  Call SetForegroundWindow( hWndForm )
.head 8 -  Set hMenu = CreatePopupMenu( )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1000, 'Purpose' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1001, 'Color' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1002, 'Disconnect' )
.head 8 -  Call AppendMenuA( hMenu, MF_STRING, 1010, 'Close' )
.head 8 +  If Not bReader_Initialized
.head 9 -  Call EnableMenuItem( hMenu, 1002, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED )
.head 8 +  If bReader_Initialized
.head 9 -  Call EnableMenuItem( hMenu, 1001, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED )
.head 8 -  Call AppendMenuA( hMenu, MF_SEPARATOR, 0, '' )
.head 8 -  Call TrackPopupMenu( hMenu, TPM_RightAlign, nX, nY, 0, hWndForm, STRING_Null )
.head 8 -  Set hLastOpenedMenu = hMenu
.head 5 +  Function: KHE_TrackContextMenu
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 7 -  Number: nRightBett
.head 7 -  Boolean: bOpenedByClick
.head 6 +  Actions
.head 7 +  If wParam >= 0 And lParam >= 0
.head 8 -  Set bOpenedByClick = TRUE
.head 8 -  Set nX = wParam
.head 8 -  Set nY = lParam
.head 7 +  Else
.head 8 -  Set bOpenedByClick = FALSE
.head 8 -  Set nFocusIndex = VisListGetFocusIndex ( hWndItem )
.head 8 -  Call VisListGetTextRectangle( hWndItem, nFocusIndex , nTop, nLeft, nBottom, nRight )
.head 8 -  Call GetWindowRect( hWndItem, nX, nY, nW, nH )
.head 8 -  Set nX = nX + nRight
.head 8 -  Set nY = nY + nTop
.head 7 +  If nSelectedLevel = KHEL_Einrichtung
.head 8 +  If SalStrLength(sSelectedKeyLocal)
.head 9 -  Call SalTrackPopupMenu ( hWndForm, 'MenuEinrichtung' , TPM_LeftAlign, nX, nY )
.head 8 +  Else
.head 9 -  Call SalTrackPopupMenu ( hWndForm, 'MenuMail' , TPM_LeftAlign, nX, nY )
.head 7 +  Else If nSelectedLevel = KHEL_Abteilung
.head 8 -  Call SalTrackPopupMenu ( hWndForm, 'MenuAbteilung' , TPM_LeftAlign, nX, nY )
.head 7 +  Else If nSelectedLevel = KHEL_Station
.head 8 +  If bBreedingIsON
.head 9 +  If GetIsRackVirtual_ByHandle (nSelectedHandle)
.head 10 -  Call SalTrackPopupMenu ( hWndForm, 'MenuVirtualRack', TPM_LeftAlign, nX, nY )
.head 9 +  Else
.head 10 -  Call SalTrackPopupMenu ( hWndForm, 'MenuRack' , TPM_LeftAlign, nX, nY )
.head 8 +  Else
.head 9 -  Call SalTrackPopupMenu ( hWndForm, 'MenuStation' , TPM_LeftAlign, nX, nY )
.head 7 +  Else If nSelectedLevel = KHEL_Gruppe
.head 8 +  If Not bOpenedByClick
.head 9 -  Set nRightBett = _GetRightBettCoord( nFocusIndex )
.head 9 -  Set nX = nX + ( nRightBett - nRight )
.head 8 +  If bBreedingIsON
.head 9 +  If GetIsRackVirtual_ByHandle (nSelectedHandle)
.head 10 -  Call SalTrackPopupMenu ( hWndForm, 'MenuVirtualCage', TPM_LeftAlign, nX, nY )
.head 9 +  Else
.head 10 -  Call SalTrackPopupMenu ( hWndForm, 'MenuCage', TPM_LeftAlign, nX, nY )
.head 8 +  Else
.head 9 -  Call SalTrackPopupMenu ( hWndForm, 'MenuGruppe', TPM_LeftAlign, nX, nY )
.head 7 +  Else If nSelectedLevel = KHEL_Bett
.head 8 +  If GetIsRackVirtual_ByHandle (nSelectedHandle)
.head 9 -  Call SalTrackPopupMenu ( hWndForm, 'MenuVirtualBett', TPM_LeftAlign, nX, nY )
.head 8 +  Else
.head 9 -  Call SalTrackPopupMenu ( hWndForm, 'MenuBett', TPM_LeftAlign, nX, nY )
.head 7 -  Return TRUE
.head 5 +  Function: _GetRightBettCoord
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nGruppeIndex
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildren
.head 7 -  Number: hChildren[*]
.head 7 -  Number: hChild
.head 7 -  Number: nIndex
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nRightMax
.head 6 +  Actions
.head 7 -  Set nRightMax = 0
.head 7 -  Set nChildren =  EnumChildren( GetItemHandle( nGruppeIndex ), hChildren )
.head 7 -  Set nIndex = 0
.head 7 +  While nIndex < nChildren
.head 8 -  Set hChild = hChildren[ nIndex ]
.head 8 -  Call VisListGetTextRectangle( hWndItem, GetItemIndex( hChild ) , nTop, nLeft, nBottom, nRight )
.head 8 +  If nRight > nRightMax
.head 9 -  Set nRightMax = nRight
.head 8 -  Set nIndex = nIndex + 1
.head 7 -  Return nRightMax
.head 5 -  !
.head 5 +  Function: KHE_Locations_Clear
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call SalArraySetUpperBound( oLocations, 1, -1 )
.head 7 -  Set nLocationsCount = 0
.head 7 -  Return TRUE
.head 5 +  Function: KHE_Locations_Add
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  FunctionalVar: oLocation
.head 8 -  Class: clsLocation
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If oLocation.IsEmpty( )
.head 8 -  Return TRUE
.head 7 +  If KHE_Locations_Find( oLocation ) < 0
.head 8 -  Set oLocations[nLocationsCount] = oLocation
.head 8 -  Set nLocationsCount = nLocationsCount + 1
.head 8 -  Return TRUE
.head 7 -  Return TRUE
.head 5 +  Function: KHE_Locations_Remove
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  FunctionalVar: oLocation
.head 8 -  Class: clsLocation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 +  If KHE_Locations_IsEmpty( )
.head 8 -  Return TRUE
.head 7 -  Set nIndex = KHE_Locations_Find( oLocation )
.head 7 +  If nIndex < 0
.head 8 -  Return TRUE
.head 7 -  Set nIndex = nIndex + 1
.head 7 +  While ( nIndex < nLocationsCount )
.head 8 -  Set oLocations[nIndex - 1] = oLocations[nIndex]
.head 8 -  Set nIndex = nIndex + 1
.head 7 -  Set nLocationsCount = nLocationsCount - 1
.head 7 -  Call SalArraySetUpperBound( oLocations, 1, nLocationsCount - 1 )
.head 7 -  Return TRUE
.head 5 +  Function: KHE_Locations_Find
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  FunctionalVar: oLocation
.head 8 -  Class: clsLocation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCounter
.head 7 -  Boolean: bFound
.head 6 +  Actions
.head 7 +  If KHE_Locations_IsEmpty( )
.head 8 -  Return -1
.head 7 -  Set nCounter = 0
.head 7 -  Set bFound = FALSE
.head 7 +  While ( nCounter < nLocationsCount )
.head 8 +  If oLocations[nCounter].IsEqual( oLocation )
.head 9 -  Set bFound = TRUE
.head 9 -  Break
.head 8 -  Set nCounter = nCounter + 1
.head 7 +  If bFound
.head 8 -  Return nCounter
.head 7 +  Else
.head 8 -  Return -1
.head 5 +  Function: KHE_Locations_IsEmpty
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return ( nLocationsCount = 0 )
.head 5 +  Function: KHE_Locations_StrToObj
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  FunctionalVar:
.head 8 -  Class: clsLocation
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sPlaceKey
.head 7 -  FunctionalVar: oLocation
.head 8 -  Class: clsLocation
.head 6 +  Actions
.head 7 -  Call ExtractPlaceFromString( sParam, sScreenKey, sRackKey, sCageKey, sPlaceKey )
.head 7 -  Call oLocation.SetScreenKey( sScreenKey )
.head 7 -  Call oLocation.SetRackKey( sRackKey )
.head 7 -  Call oLocation.SetCageKey( sCageKey )
.head 7 -  Call oLocation.SetPlaceKey( sPlaceKey )
.head 7 -  Return oLocation
.head 5 +  Function: KHE_Locations_DoRefresh
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCounter
.head 7 -  Number: hpGruppe
.head 7 -  FunctionalVar: oCages[*]
.head 8 -  Class: clsLocation
.head 6 +  Actions
.head 7 +  If KHE_Locations_IsEmpty( )
.head 8 -  Return TRUE
.head 7 -  Set nCounter = 0
.head 7 +  While ( nCounter < nLocationsCount )
.head 8 -  ! Set bPastingMovement = TRUE
.head 8 -  ! Set hpGruppe = FindH_4Gruppe( 
	FindH_4Station( FindH_4Abteilung( oLocations[nCounter].GetScreenKey( ) ), oLocations[nCounter].GetRackKey( ), bAutoScan ),
	oLocations[nCounter].GetCageKey( ), bAutoScan )
.head 8 -  Set hpGruppe = FindChild(
	FindChild( FindChild( hRoot, oLocations[nCounter].GetScreenKey( ) ), oLocations[nCounter].GetRackKey( ) ),
	oLocations[nCounter].GetCageKey( ) )
.head 8 -  ! Call PopulateGruppe( hpGruppe, bAutoScan )
.head 8 -  Call KHE_RefreshGruppe( hpGruppe )
.head 8 -  ! Call SalMessageBox('','KHE_Locations_DoRefresh',0)
.head 8 -  Set nCounter = nCounter + 1
.head 7 -  Call KHE_Locations_Clear( )
.head 7 -  ! refresh 2DView
.head 7 -  Call Rack2DView_RefreshCageContents("" )
.head 7 -  Return TRUE
.head 5 +  Function: KHE_AddLocation
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nlParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sBuffer
.head 7 -  Number: nAddrString
.head 7 -  Number: nLength
.head 7 -  String: sLocation
.head 6 +  Actions
.head 7 -  Set sBuffer = ""
.head 7 -  Call SalStrSetBufferLength( sBuffer, 12 )
.head 7 -  Call CStructCopyFromFarMem( nlParam, sBuffer, 12 )
.head 7 -  Set nLength = CStructGetLong( sBuffer, 4 )
.head 7 -  Set nAddrString = CStructGetLong( sBuffer, 8 )
.head 7 -  Set sLocation = ""
.head 7 -  Call SalStrSetBufferLength( sLocation, 255 )
.head 7 -  Call CStructCopyFromFarMem( nAddrString, sLocation, nLength  )
.head 7 -  !
.head 7 -  Call SalStatusSetText( hWndForm, sLocation )
.head 7 -  !
.head 7 -  Return KHE_Locations_Add( KHE_Locations_StrToObj( sLocation ) )
.head 5 -  ! CageCard Viewing/Printing
.head 5 +  ! Function: KHE_CageFormularWithLitter
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: sStatParam
.head 7 -  String: sGrpParam
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Boolean: bShowLitterFormular
.head 7 -  Boolean: bExist
.head 7 -  Sql Handle: hSql
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sPurpose
.head 7 -  String: sFallKeyWithOpenMR
.head 7 -  String: sSingleFemale
.head 7 -  Number: nFetch
.head 7 -  Number: nFemaleCount
.head 7 -  Number: nMaleCount
.head 7 -  Number: nSingleFemaleFallKey
.head 7 -  Boolean: bOpenMR
.head 7 -  Date/Time: dtGetTime 
.head 6 +  Actions 
.head 7 -  Set bShowLitterFormular = FALSE
.head 7 -  Set bOpenMR = FALSE
.head 7 +  If (Not sStatParam) Or (Not sGrpParam)
.head 8 -  Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 7 +  Else 
.head 8 -  Set sStat = sStatParam
.head 8 -  Set sGrp = sGrpParam
.head 7 +  If not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  ! Female count in a cage
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If TRUE
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	 FALL f
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
into	:nFemaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  Else 
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and          gs.GESCHL_KEY = l.GESCHL
into	:nFemaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  ! Checking Open Mating relationship and Female count in it
.head 7 +  If TRUE
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY
from	 FALL f,  RELSHIP_FALL fr
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'W'
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	fr.FALL_KEY = f.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
group by	f.FALL_KEY
into	 :nSingleFemaleFallKey
" )
.head 10 +  If SqlFetchNext( hSql, nFetch )
.head 11 +  If nFemaleCount > 0
.head 12 -  Set bOpenMR = TRUE
.head 12 -  Set sPurpose = 'MTT'
.head 11 +  Else 
.head 12 -  Set sPurpose = ''
.head 11 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurpose  || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 12 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 8 +  Else 
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a, RELSHIP_FALL fr
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and          gs.GESCHL_KEY = l.GESCHL
and	fr.FALL_KEY = b.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
group by	f.FALL_KEY
into	 :nSingleFemaleFallKey
" )
.head 10 +  If SqlFetchNext( hSql, nFetch )
.head 11 +  If nFemaleCount > 0
.head 12 -  Set bOpenMR = TRUE
.head 12 -  Set sPurpose = 'MTT'
.head 11 +  Else 
.head 12 -  Set sPurpose = ''
.head 11 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurpose  || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 12 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 7 -  ! Male count in Open Mating relationship
.head 7 +  If TRUE
.head 8 +  ! If bOpenMR
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a, RELSHIP_FALL fr
where
b.GRUPPE_KEY =   :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'M'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	b.BEW_ZEIT <= @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and          gs.GESCHL_KEY = l.GESCHL
and	fr.FALL_KEY = b.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	 FALL f
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'M'
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  Else 
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'M'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and          gs.GESCHL_KEY = l.GESCHL
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  ! Case 1 & Case 2 
.head 7 +  If bOpenMR And nFemaleCount = 1
.head 8 +  If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 -  ! Case 2 (open relationship between a Female and a Male, Litters)
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set bShowLitterFormular = TRUE
.head 9 -  ! Case 1 (open relationship between a Female and a Male, without Litters)
.head 9 +  Else 
.head 10 -  Set bShowLitterFormular = FALSE
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return bShowLitterFormular
.head 7 -  ! Case 3 (open relationship between several Females and one Male)
.head 7 +  If bOpenMR And nFemaleCount > 1 And nMaleCount = 1
.head 8 -  Set bShowLitterFormular = FALSE
.head 8 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = ''
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 9 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bShowLitterFormular
.head 7 -  ! Case 4 (open or closed Mate relationship; Female is alone)
.head 7 +  If nFemaleCount = 1 And nMaleCount = 0
.head 8 +  ! If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr, GESCHLECHT g
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set bShowLitterFormular = TRUE
.head 9 +  Else 
.head 10 -  Set bShowLitterFormular = FALSE
.head 9 +  ! If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = ''
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 10 -  Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return bShowLitterFormular
.head 7 -  ! Call SqlDisconnect( hSql )
.head 7 -  ! Return bShowLitterFormular
.head 5 +  Function: KHE_CageFormularWithLitter
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sStatParam
.head 7 -  String: sGrpParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bShowLitterFormular
.head 7 -  Boolean: bExist
.head 7 -  Sql Handle: hSql
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sPurpose
.head 7 -  String: sFallKeyWithOpenMR
.head 7 -  String: sSingleFemale
.head 7 -  Number: nFetch
.head 7 -  Number: nFemaleCount
.head 7 -  Number: nMaleCount
.head 7 -  Number: nSingleFemaleFallKey
.head 7 -  Boolean: bOpenMR
.head 7 -  Date/Time: dtGetTime
.head 6 +  Actions
.head 7 -  Set bShowLitterFormular = FALSE
.head 7 -  Set bOpenMR = FALSE
.head 7 +  If (Not sStatParam) Or (Not sGrpParam)
.head 8 -  Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 7 +  Else
.head 8 -  Set sStat = sStatParam
.head 8 -  Set sGrp = sGrpParam
.head 7 +  If not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  ! Female count in a cage
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If TRUE
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	 FALL f
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
into	:nFemaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  Else
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
into	:nFemaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  ! Checking Open Mating relationship and Female count in it
.head 7 +  If TRUE
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY
from	 FALL f,  RELSHIP_FALL fr
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'W'
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	fr.FALL_KEY = f.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
group by	f.FALL_KEY
into	 :nSingleFemaleFallKey
" )
.head 10 +  If SqlFetchNext( hSql, nFetch )
.head 11 +  If nFemaleCount > 0
.head 12 -  Set bOpenMR = TRUE
.head 12 -  Set sPurpose = 'MTT'
.head 11 +  Else
.head 12 -  Set sPurpose = ''
.head 11 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurpose  || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 12 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 8 +  Else
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY
from	BEWEGUNG b, FALL f, LE l, RELSHIP_FALL fr
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
and	fr.FALL_KEY = b.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
group by	f.FALL_KEY
into	 :nSingleFemaleFallKey
" )
.head 10 +  If SqlFetchNext( hSql, nFetch )
.head 11 +  If nFemaleCount > 0
.head 12 -  Set bOpenMR = TRUE
.head 12 -  Set sPurpose = 'MTT'
.head 11 +  Else
.head 12 -  Set sPurpose = ''
.head 11 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurpose  || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 12 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 7 -  ! Male count in Open Mating relationship
.head 7 +  If TRUE
.head 8 +  ! If bOpenMR
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a, RELSHIP_FALL fr
where
b.GRUPPE_KEY =   :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'M'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	b.BEW_ZEIT <= @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and          gs.GESCHL_KEY = l.GESCHL
and	fr.FALL_KEY = b.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	 FALL f
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'M'
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  Else
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'M'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  ! Case 1 & Case 2
.head 7 +  If bOpenMR And nFemaleCount = 1
.head 8 +  If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 -  ! Case 2 (open relationship between a Female and a Male, Litters)
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set bShowLitterFormular = TRUE
.head 9 -  ! Case 1 (open relationship between a Female and a Male, without Litters)
.head 9 +  Else
.head 10 -  Set bShowLitterFormular = FALSE
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return bShowLitterFormular
.head 7 -  ! Case 3 (open relationship between several Females and one Male)
.head 7 +  If bOpenMR And nFemaleCount > 1 And nMaleCount = 1
.head 8 -  Set bShowLitterFormular = FALSE
.head 8 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = ''
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 9 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bShowLitterFormular
.head 7 -  ! Case 4 (open or closed Mate relationship; Female is alone)
.head 7 +  If nFemaleCount = 1 And nMaleCount = 0
.head 8 +  ! If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr, GESCHLECHT g
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set bShowLitterFormular = TRUE
.head 9 +  Else
.head 10 -  Set bShowLitterFormular = FALSE
.head 9 +  ! If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = ''
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 10 -  Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return bShowLitterFormular
.head 7 -  ! Call SqlDisconnect( hSql )
.head 7 -  ! Return bShowLitterFormular
.head 5 +  Function: KHE_RackIsIntensiv
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sStatParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bIntensiv
.head 7 -  Sql Handle: hSql
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sIntensiv
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set bIntensiv = FALSE
.head 7 +  If not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 +  If Not sStatParam
.head 8 -  Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 7 +  Else
.head 8 -  Set sStat = sStatParam
.head 7 +  If SqlPrepareAndExecute( hSql, "
  Select INTENSIV
  from STATION
  where STAT_KEY = :sStat
  and EINRICHT_ID = :nEinrichtId
  into	:sIntensiv
" )
.head 8 +  If SqlFetchNext( hSql, nFetch )
.head 9 +  If sIntensiv = 'J'
.head 10 -  Set bIntensiv = TRUE
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  Return bIntensiv
.head 5 +  Function: KHE_CageCard
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  ! String: sFormularKey
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 -  Call GetTime4Refresh(  )
.head 7 +  ! AS 07.04.2004
.head 8 -  ! Set sFormularKey = GetFormular4Gruppe( sStatKey, sGruppeKey, KHE_DefaultCageCard )
.head 8 -  ! Call ShowReport( REPORT_View, sFormularKey, sStatKey || "," || sGruppeKey || "," || SalFmtFormatDateTime( dtKHK_RefreshTime, 'yyyy-MM-dd hhhh:mm:ss' ))
.head 7 +  If KHE_CageFormularWithLitter ( '', '' )
.head 8 +  If KHE_RackIsIntensiv('' )
.head 9 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '4', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 8 +  Else
.head 9 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '2', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 7 +  Else
.head 8 +  If KHE_RackIsIntensiv('' )
.head 9 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '3', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 8 +  Else
.head 9 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '1', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 5 +  Function: KHE_PrintCageCard
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  ! String: sFormularKey
.head 6 +  Actions
.head 7 +  If not KHE_IsOccupied_ByHandle( nSelectedHandle, GetTime4Refresh(  ))
.head 8 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 8 -  ! Call GetTime4Refresh(  )
.head 8 +  ! If KHE_CageFormularWithLitter ( '', '' )
.head 9 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '2', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 8 +  ! Else
.head 9 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '1', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 8 +  If KHE_CageFormularWithLitter ( '', '' )
.head 9 +  If KHE_RackIsIntensiv('' )
.head 10 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '4', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 9 +  Else
.head 10 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '2', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 8 +  Else
.head 9 +  If KHE_RackIsIntensiv('' )
.head 10 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '3', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 9 +  Else
.head 10 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '1', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 5 +  Function: KHE_CageCardForRack
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bPr
.head 7 -  FunctionalVar: cRack
.head 8 -  Class: clsLocationRack
.head 7 -  FunctionalVar: cLocations[1]
.head 8 -  Class: clsLocation
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 +  If Not cRack.Init( sAbtKey, sStatKey )
.head 8 -  Return FALSE
.head 7 -  Set cLocations[0] = cRack
.head 7 -  Call GetTime4Refresh( )
.head 7 -  Set bPr = GalGetProfileBooleanX( "KHE", "CageCardAutoPrint", FALSE, sUserINIFileName )
.head 7 -  Call GalSetProfileBoolean( "KHE", "CageCardAutoPrint", FALSE, sUserINIFileName )
.head 7 +  If Not Requst_ListForCageCard( cLocations, "Print Cage Cards For Rack "  || sStatKey, bPrint )
.head 8 -  ! user canceled the action
.head 8 -  Return FALSE
.head 7 +  If bPrint
.head 8 -  ! print cage card
.head 8 -  Call Formular_CageCard_Print( '', '', dtKHK_RefreshTime )
.head 7 +  Else
.head 8 -  ! show cage card
.head 8 -  Call Formular_CageCard_Int( '', '', dtKHK_RefreshTime )
.head 7 -  Call GalSetProfileBoolean( "KHE", "CageCardAutoPrint", bPr, sUserINIFileName )
.head 7 -  Return TRUE
.head 5 +  Function: KHE_CageCardForScreen
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bPr
.head 7 -  FunctionalVar: cScreen
.head 8 -  Class: clsLocationScreen
.head 7 -  FunctionalVar: cLocations[1]
.head 8 -  Class: clsLocation
.head 6 +  Actions
.head 7 -  Call GetCurrentPosition( sAbtKey, sStatKey, sGruppeKey, sBettKey )
.head 7 +  If Not cScreen.Init( sAbtKey)
.head 8 -  Return FALSE
.head 7 -  Set cLocations[0] = cScreen
.head 7 -  Call GetTime4Refresh( )
.head 7 -  Set bPr = GalGetProfileBooleanX( "KHE", "CageCardAutoPrint", FALSE, sUserINIFileName )
.head 7 -  Call GalSetProfileBoolean( "KHE", "CageCardAutoPrint", FALSE, sUserINIFileName )
.head 7 +  If Not Requst_ListForCageCard( cLocations, "Print Cage Cards For Screen "  || sAbtKey, bPrint )
.head 8 -  ! user canceled the action
.head 8 -  Return FALSE
.head 7 +  If bPrint
.head 8 -  ! print cage card
.head 8 -  Call Formular_CageCard_Print( '', '', dtKHK_RefreshTime )
.head 7 +  Else
.head 8 -  ! show cage card
.head 8 -  Call Formular_CageCard_Int( '', '', dtKHK_RefreshTime )
.head 7 -  Call GalSetProfileBoolean( "KHE", "CageCardAutoPrint", bPr, sUserINIFileName )
.head 7 -  Return TRUE
.head 5 +  Function: FindRack
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hAbt
.head 7 -  Number: hStat
.head 7 -  Number: hGrp
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 6 +  Actions
.head 7 -  Set sAbt = GetCurrentLevelKey ( KHEL_Abteilung )
.head 7 +  If Not sAbt
.head 8 -  Call SalMessageBox ('Please, choose Abteilung', 'Searching Rack...', MB_Ok)
.head 8 -  Return FALSE
.head 7 +  If SalModalDialog( dlgKHEItemSearch, hWndForm, 'Rack', sStat )
.head 8 +  If GoToStat( sAbt, sStat, bAutoScan )
.head 9 -  Return TRUE
.head 8 -  ! If sStore_Stat And bOk
.head 8 +  ! If sStore_Grp
.head 9 -  Set bOk = GotoGruppe( sStore_Abt, sStore_Stat, sStore_Grp, bAutoScan )
.head 8 +  ! If sStore_Bett
.head 9 -  Set bOk = GotoBett( sStore_Abt, sStore_Stat, sStore_Grp, sStore_Bett, bAutoScan )
.head 5 +  Function: FindCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sGrpKey
.head 7 -  ! Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hAbt
.head 7 -  Number: hStat
.head 7 -  Number: hGrp
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sCagePrefix
.head 6 +  Actions
.head 7 -  Set sAbt = GetCurrentLevelKey (  KHEL_Abteilung )
.head 7 -  Set sStat = GetCurrentLevelKey (  KHEL_Station )
.head 7 +  If Not sStat
.head 8 -  Call SalMessageBox ('Please, choose Rack', 'Searching Cage...', MB_Ok)
.head 8 -  Return FALSE
.head 7 -  Set sCagePrefix = SalStrRightX ( sStat, 4 )
.head 7 +  If SalModalDialog( dlgKHEItemSearch, hWndForm, 'Cage (Prefix: ' || sCagePrefix || ')', sGrp )
.head 8 -  ! Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 8 +  If GotoGruppe( sAbt, sStat, sCagePrefix || sGrp, bAutoScan )
.head 9 -  Return TRUE
.head 8 -  ! If sStore_Stat And bOk
.head 8 +  ! If sStore_Grp
.head 9 -  Set bOk = GotoGruppe( sStore_Abt, sStore_Stat, sStore_Grp, bAutoScan )
.head 8 +  ! If sStore_Bett
.head 9 -  Set bOk = GotoBett( sStore_Abt, sStore_Stat, sStore_Grp, sStore_Bett, bAutoScan )
.head 5 +  Function: FindAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sGrpKey
.head 7 -  ! Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sFallKey
.head 6 +  Actions
.head 7 +  If SalModalDialog( dlgKHEItemSearch, hWndForm, 'Animal ID', sFallKey )
.head 8 -  Return SalSendMsg( frmAtlantaMain, AM_KHE_GotoBedByFall, 0, GalSetAsWinMsgLParam_Number( SalStrToNumber( sFallKey ) ) )
.head 5 +  Function: FindFreeCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call frmAtlantaMain.KHE_FindEmptyBed( TRUE, TRUE)
.head 5 +  Function: Expand
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nIndex
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nReturn
.head 6 +  Actions
.head 7 -  Set nReturn = cListBoxExtension.Expand( nIndex )
.head 7 +  If nReturn
.head 8 -  Call Rack2DView_SetButtonState( GetItemHandle( nIndex ) )
.head 8 -  Return nReturn
.head 7 -  Return -1
.head 5 +  Function: Collapse
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nIndex
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = cListBoxExtension.Collapse( nIndex )
.head 7 +  If bReturn
.head 8 -  Call Rack2DView_SetButtonState( GetItemHandle( nIndex ) )
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: Rack2DView_CheckState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bForceWindowCreation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bShouldBeShown
.head 7 -  Boolean: bShouldBeCreated
.head 7 -  Boolean: bCreateAutomatically
.head 7 -  Boolean: bShowAutoSR
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sRefreshDate
.head 7 -  Number: nRefreshStatus
.head 6 +  Actions
.head 7 -  Set bCreateAutomatically = GalGetProfileBooleanX( "Rack 2D View", "Auto_Open", TRUE, sUserINIFileName )
.head 7 -  Set bShowAutoSR = GalGetProfileBooleanX( "Rack 2D View", "Auto_Show", TRUE, sUserINIFileName )
.head 7 +  If Not bCreateAutomatically And Not bForceWindowCreation And Not SalIsWindowVisible( hWndRack2DView ) and Not SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Return TRUE
.head 7 -  Set bShouldBeShown = bForceWindowCreation Or ( nSelectedLevel >= KHEL_Station )
.head 7 -  Set bShouldBeCreated = bForceWindowCreation Or ( nSelectedLevel >= KHEL_Station )
.head 7 +  If Not bShouldBeShown
.head 8 +  If SalIsWindowVisible( hWndRack2DView )
.head 9 -  Call SalHideWindow( hWndRack2DView )
.head 8 -  ! For Virtual Rack!
.head 8 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 9 -  Call SalHideWindow( hWndRack2DViewVirt )
.head 7 +  Else
.head 8 +  If NOT bRackCreationInProcess
.head 9 -  ! Call GalSetProfileBoolean( "Rack 2D View", "PlannedMode", bPlanningMode, sUserINIFileName )
.head 9 -  Set bRackCreationInProcess = TRUE
.head 9 -  Set sScreenKey = GetCurrentLevelKey( KHEL_Abteilung )
.head 9 -  Set sRackKey = GetCurrentLevelKey( KHEL_Station )
.head 9 -  ! Call SalSetProfileString( "Rack 2D View", "PlannedExp", sPlan_Experiment, sUserINIFileName )
.head 9 +  If bShouldBeCreated And ( hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView ) ) and Not GetIsRackVirtual_ByHandle(nSelectedHandle)
.head 10 -  Set hWndRack2DView = SalCreateWindow( frmKHE2DView, hWndStar2000)
.head 9 -  ! For Virtual Rack!
.head 9 +  If bShouldBeCreated And ( hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt ) ) and GetIsRackVirtual_ByHandle(nSelectedHandle)
.head 10 -  Set hWndRack2DViewVirt = SalCreateWindow( frmKHE2DViewVirt, hWndStar2000)
.head 9 +  If bShouldBeShown And Not SalIsWindowVisible( hWndRack2DView ) and Not GetIsRackVirtual_ByHandle(nSelectedHandle)  and VisWinIsWindow( hWndRack2DView )
.head 10 +  If not frmKHE2DView.cRack2DLayoutManager.bNotShow and bShowAutoSR
.head 11 -  Call SalShowWindow( hWndRack2DView )
.head 10 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 10 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 11 -  Call Rack2DView_ReflectButtonsState( )
.head 9 -  ! For Virtual Rack!
.head 9 +  If bShouldBeShown And Not SalIsWindowVisible( hWndRack2DViewVirt ) and GetIsRackVirtual_ByHandle(nSelectedHandle) and VisWinIsWindow( hWndRack2DViewVirt )
.head 10 +  If not frmKHE2DViewVirt.cRack2DLayoutManager.bNotShow and bShowAutoSR
.head 11 -  Call SalShowWindow( hWndRack2DViewVirt )
.head 10 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 10 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 11 -  Call Rack2DView_ReflectButtonsState( )
.head 9 -  ! refresh Data
.head 9 +  If sScreenKey And sRackKey
.head 10 +  If GetIsRackVirtual_ByHandle( nSelectedHandle)
.head 11 +  If VisWinIsWindow( hWndRack2DViewVirt )
.head 12 +  If SalIsWindowVisible( hWndRack2DViewVirt ) or frmKHE2DViewVirt.cRack2DLayoutManager.bNotShow
.head 13 -  ! refresh Data
.head 13 +  If sScreenKey And sRackKey
.head 14 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 14 -  Call SalSendMsg( hWndRack2DViewVirt, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 14 -  Set nRefreshStatus = SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_FullRefresh,
					SalHStringToNumber( sScreenKey || ";" || sRackKey ) )
.head 14 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 15 -  Call Rack2DView_ReflectButtonsState( )
.head 10 +  Else
.head 11 +  If VisWinIsWindow( hWndRack2DView )
.head 12 +  If SalIsWindowVisible( hWndRack2DView ) or frmKHE2DView.cRack2DLayoutManager.bNotShow
.head 13 -  ! refresh Data
.head 13 +  If sScreenKey And sRackKey
.head 14 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 14 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 14 -  Set nRefreshStatus = SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_FullRefresh,
					SalHStringToNumber( sScreenKey || ";" || sRackKey ) )
.head 14 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 15 -  Call Rack2DView_ReflectButtonsState( )
.head 9 -  Set bRackCreationInProcess = FALSE
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_SetButtonState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bExpanded
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sPlace
.head 6 +  Actions
.head 7 -  Call GetPosition( hHandle, sScreenKey, sRackKey, sCageKey, sPlace )
.head 7 +  If sScreenKey And sRackKey And sCageKey
.head 8 +  If GetIsRackVirtual_ByHandle(hHandle)
.head 9 +  If nSelectedLevel = KHEL_Gruppe And SalIsWindowVisible( hWndRack2DViewVirt )
.head 10 -  Set bExpanded = KHE_IsExpanded( hHandle )
.head 10 -  ! set state
.head 10 -  Call SalSendMsg( hWndRack2DViewVirt, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 8 +  Else
.head 9 +  If nSelectedLevel = KHEL_Gruppe And SalIsWindowVisible( hWndRack2DView )
.head 10 -  Set bExpanded = KHE_IsExpanded( hHandle )
.head 10 -  ! set state
.head 10 -  Call SalSendMsg( hWndRack2DView, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_ReflectButtonsState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hStat
.head 7 -  Number: nChildren
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nIndex
.head 7 -  Number: hChild
.head 7 -  Boolean: bExpanded
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sPlace
.head 6 +  Actions
.head 7 +  If Not SalIsWindowVisible( hWndRack2DView ) and Not SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Return TRUE
.head 7 +  If nSelectedLevel < KHEL_Station
.head 8 -  Return TRUE
.head 7 +  Select Case nSelectedLevel
.head 8 +  Case KHEL_Station
.head 9 -  Set hStat = nSelectedHandle
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set hStat = GetParent( nSelectedHandle )
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  Set hStat = GetParent( GetParent( nSelectedHandle ) )
.head 9 -  Break
.head 7 -  !
.head 7 -  Set nChildren =  EnumChildren( hStat, hChildren )
.head 7 -  Set nIndex = 0
.head 7 +  While nIndex < nChildren
.head 8 -  Set hChild = hChildren[ nIndex ]
.head 8 -  Set bExpanded = KHE_IsExpanded( hChild )
.head 8 -  Call GetPosition( hChild, sScreenKey, sRackKey, sCageKey, sPlace )
.head 8 +  If sScreenKey And sRackKey And sCageKey
.head 9 +  If GetIsRackVirtual_ByHandle(hChild)
.head 10 +  If SalIsWindowVisible( hWndRack2DViewVirt ) 
.head 11 -  ! Call SalSendMsg( hWndRack2DViewVirt, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 11 -  ! Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshContent,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 11 -  Call SalSendMsg( hWndRack2DViewVirt, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 9 +  Else
.head 10 +  If SalIsWindowVisible( hWndRack2DView ) 
.head 11 -  ! Call SalSendMsg( hWndRack2DView, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 11 -  Call SalSendMsg( hWndRack2DView, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 8 -  Set nIndex = nIndex + 1
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_OnRackCollapsed
.head 6 -  Description: If Rack is just collapsed in KHE, then just buttons state should be cleared
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If nSelectedLevel = KHEL_Station
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_ClearState, 0 )
.head 8 -  Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_ClearState, 0 )
.head 5 +  Function: Rack2DView_RefreshCageContents
.head 6 -  Description: Refreshes content for all cages in the 2D View
Dont have enough time to implement this only for changed cagesRACK2D_RefreshTimeChanged
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sCagesList
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sRefreshDate
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 8 -  ! Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged, SalHStringToNumber( sRefreshDate ))
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sCagesList ))
.head 7 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 8 -  ! Call SalSendMsg( hWndRack2DViewVirt, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 8 -  ! Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 8 -  Call SalSendMsg(hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshTimeChanged, SalHStringToNumber( sRefreshDate ))
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_SetButtonFocus
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bExpanded
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sPlace
.head 6 +  Actions
.head 7 +  If nSelectedLevel >= KHEL_Gruppe And (SalIsWindowVisible( hWndRack2DView ) or SalIsWindowVisible( hWndRack2DViewVirt ))
.head 8 -  ! set focus
.head 8 -  Call GetPosition( hHandle, sScreenKey, sRackKey, sCageKey, sPlace )
.head 8 +  If sScreenKey And sRackKey And sCageKey
.head 9 +  If GetIsRackVirtual_ByHandle(hHandle)
.head 10 +  If SalIsWindowVisible( hWndRack2DViewVirt ) 
.head 11 -  Call SalSendMsg( hWndRack2DViewVirt, AM_SetFocus, TRUE,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 9 +  Else
.head 10 +  If SalIsWindowVisible( hWndRack2DView ) 
.head 11 -  Call SalSendMsg( hWndRack2DView, AM_SetFocus, TRUE,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_RefreshOnTimeChanged
.head 6 -  Description: Refreshes content for all cages in the 2D View
Dont have enough time to implement this only for changed cages
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sRefreshDate
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
		SalHStringToNumber( sRefreshDate ) )
.head 7 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 8 -  Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshTimeChanged,
		SalHStringToNumber( sRefreshDate ) )
.head 7 -  Return TRUE
.head 5 +  Function: AddCageToVisibleList
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCounter
.head 7 -  Number: nTemp
.head 6 +  Actions
.head 7 +  If sStatKey = '' or sGrpKey = ''
.head 8 -  Return FALSE
.head 7 -  Set nCounter = 0
.head 7 -  Set nTemp = 0
.head 7 +  While nCounter < nCagesFrom2DNr
.head 8 +  If sCagesFrom2D[nCounter, 0] = sStatKey
.head 9 -  Break
.head 8 -  Set nCounter = nCounter + 1
.head 7 +  If nCounter = nCagesFrom2DNr
.head 8 -  Set sCagesFrom2D[nCounter, 0] = sStatKey
.head 8 -  Set nCagesFrom2DNr = nCagesFrom2DNr +1
.head 7 +  If SalStrScan(sCagesFrom2D[nCounter, 1], sGrpKey) = -1
.head 8 -  Set sCagesFrom2D[nCounter, 1] = sCagesFrom2D[nCounter, 1] || ",'"||sGrpKey||"'"
.head 5 +  Function: MM_InsertAdminLstErf
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Number: nBewNr_AE
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  String: sLAKey
.head 7 -  Date/Time: dtLstErfVon
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewLstErf
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return 0
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	FALL_KEY = " || StrX( nFallKey ) || "
into	:nNewLstErf " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 7 +  If Not bOk And nFetch = FETCH_EOF
.head 8 -  Set nNewLstErf = 1
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk And Not nNewLstErf
.head 8 -  Set nNewLstErf = 1
.head 7 -  !
.head 7 +  If nNewLstErf
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR, 
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY, 
	Lst_Erf_VON, 
	MENGE, STATISTIK, PRZ, 
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID, 
	FKT, BEW_NR, DONE )
 values (	" || StrX( nEinrichtId ) || ", " || StrX( nFallKey ) || ", " || StrX( nNewLstErf ) || ", SYSDATETIME, 
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', " || StrX( nUserId ) || ", 1, " || StrX( nBewNr_AE ) || ", 0 ) " )
.head 8 -  Set bOk = bOk And SqlCommit( hSql ) 
.head 8 +  If Not bOk
.head 9 -  Call SqlPrepareAndExecute( hSql, 'rollback' )
.head 9 -  Set nNewLstErf = 0
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  Return nNewLstErf
.head 5 +  Function: CageUsingEnable
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible (hWL_Plan2Real_Bew)
.head 8 -  Return TRUE
.head 7 -  ! If frmWL_Plan2Real_Bew.tblWL_Plan2Real_Bew.colVirtual = 'J'
.head 5 +  Function: CageInsteadVirtual
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call hWL_Plan2Real_Bew.frmWL_Plan2Real_Bew.tblWL_Plan2Real_Bew.UpdateAAWithRealCage (sAbtKey, sStatKey, sGrpKey)
.head 7 +  If SalStrUpperX( ghsGetProfileStringX( 'Settings', 'DoBewPlOnUseCage', 'YES' ) ) = 'YES'
.head 8 +  If not hWL_Plan2Real_Bew.frmWL_Plan2Real_Bew.VirtualRoomRackExists ()
.head 9 -  Call SalSendMsg (frmWL_Plan2Real_Bew, AM_Ok, wParam, lParam)
.head 7 +  Else
.head 8 -  Call SalMessageBox("Cage "||sGrpKey||" is blocked for Plan Movements","Msg.",0)
.head 7 -  Call Rack2DView_RefreshCageContents("")
.head 5 +  Function: DeleteLst_Erf_NrWithoutMovement
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bExists
.head 6 +  Actions
.head 7 +  If DoImmediateSingle ("Select * from LST_ADM_TODO_ITEMS where LST_ERF_NR = "|| StrX( nPlan_LstErfNr ) ||" ", bExists)
.head 8 +  If not bExists
.head 9 -  Call DoImmediate ("Update LST_ERF
		set STORNIERT = 'J' 
		where LST_ERF_NR = "|| StrX( nPlan_LstErfNr ) ||" 
		and EINRICHT_ID = " || StrX( nEinrichtId ) || "
		and FALL_KEY = " || StrX( nPlan_Fall_Key ) )
.head 9 -  Call DoImmediate("commit")
.head 5 -  !
.head 5 +  Function: ChangingEarTags
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 +  Static Variables
.head 7 -  String: sAbt_Key
.head 7 -  String: sStat_Key
.head 7 -  String: sGruppe_Key
.head 7 -  String: sBett_Key
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible( hWnd_EarTags )
.head 8 -  Call SalSendMsg(hWnd_EarTags,SAM_Close,0,0)
.head 7 -  Call GetPosition(nSelectedHandle, sAbt_Key, sStat_Key, sGruppe_Key, sBett_Key)
.head 7 -  ! Call SalCreateWindow( tblEarTags, hWndNULL, sAbt_Key, sStat_Key, sGruppe_Key)
.head 7 -  Set hWnd_EarTags = SalCreateWindow( tblEarTags, hWndStar2000 , sAbt_Key, sStat_Key, sGruppe_Key)
.head 5 +  Function: Finish_Movement
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Boolean: bFinish
.head 7 -  String: sAbtKeyDest
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If bFinish
.head 8 +  If IDYES != SalMessageBox('Do you want to finish this Mating?','',MB_YesNo) 
.head 9 -  Return FALSE
.head 7 +  If IDYES = SalMessageBox('Do you want to create new Mating?
If NO Cage Explorer will be switched to real time','',MB_YesNo) 
.head 8 -  Set nPlan_LstErfNr = MM_InsertAdminLstErf(nPlan_Fall_Key, nPlan_AEBewNr, sPlan_TarifKey, sPlan_LstKey, 'AL', dtPlan_Started)
.head 8 -  Set sCageForMating = ''
.head 8 -  Set bMaleIsExist = FALSE
.head 8 -  Set bFemaleIsExist = FALSE
.head 8 -  Call DoCommit()
.head 8 -  Call DoCloseTransaction( TRUE )
.head 7 +  Else
.head 8 -  Set bPlanningMode = FALSE
.head 8 -  Set bR2DLoadSettings = TRUE
.head 8 -  Set bMatingMode = FALSE
.head 8 -  Call GalSetProfileBoolean( "Rack 2D View", "PlannedMode", FALSE, sUserINIFileName )
.head 8 -  Set bShowOnlyRealBew = TRUE
.head 8 -  Call SetTime4Refresh( SalDateCurrent ( ))
.head 8 -  Call SalSendMsg( hWndRack2DViewVirt, AM_CloseAllCages, 0, 0 )
.head 8 -  Call PopulateEinrichtung( bAutoScan )
.head 8 -  Call SalSendMsg(hWndRack2DView , AM_CloseAllCages, 0, 0)
.head 8 -  Call SalPicSet( hWnd_pbSetTime, KHE_ClockW, PIC_FormatBitmap )
.head 8 -  Call DoCommit()
.head 8 -  Call DoCloseTransaction( TRUE )
.head 8 -  Call SalSendMsg(hWndRack2DViewVirt, SAM_Close, 0, 0)
.head 5 +  Function: CanMoveScreen
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbgKeySrc
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sRettKeyTmp
.head 7 -  Number: nTmp
.head 7 -  Number: nFetch
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nPosID
.head 7 -  Number: nCageID
.head 7 -  String: sSqlCheck
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 -  Call GetPositionID( nSelectedHandle, nScrID, nRackID, nCageID, nPosID )
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  Set nTmp = 0
.head 7 +  ! If SqlPrepareAndExecute(hSql, "
select count(*) from abt_stat ABT, ben_abteilung BA, abteilung A 
where ABT.stat_key=:sStatKeyTmp and BA.ABT_KEY=ABT.abt_key and ba.benutzer_id=:nUserId and ba.abt_key=a.abt_key and ABT.einricht_id=:nEinrichtId and ABT.abt_key<>:sAbtKeySrc 
into :nTmp")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 7 +  If nRackID > 0
.head 8 -  Set sSqlCheck = "
select count(*) from abt_stat ABT, ben_abteilung BA, abteilung A
where ABT.RACK_ID=:nRackID
     and ba.SCR_ID=ABT.SCR_ID
 	and   ba.benutzer_id=:nUserId
     and a.id=ba.SCR_ID
	and a.id<>:nScrID
into :nTmp"
.head 7 +  Else If nScrID > 0
.head 8 -  Set sSqlCheck = "
select count(count(abt.abt_key))  from abt_stat ABT, ben_abteilung BA, abteilung A
where ba.SCR_ID=ABT.SCR_ID
 	and   ba.benutzer_id=:nUserId
     and a.id=ba.SCR_ID
	and a.id<>:nScrID
group by abt.abt_key
into :nTmp"
.head 7 +  If sSqlCheck != STRING_Null and sSqlCheck != ""
.head 8 +  If SqlPrepareAndExecute(hSql, sSqlCheck)
.head 9 -  Call SqlFetchNext(hSql, nFetch)
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Return nTmp>0
.head 5 +  Function: LoadFonts
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 -  Actions
.head 5 +  ! Function: AddAlert
.head 6 -  Description: 
.head 6 -  Returns 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: nFall
.head 7 -  String: sMenuItems[*]
.head 7 -  String: sMenuKeys[*]
.head 7 -  String: sMenuItem
.head 7 -  String: sMenuKey
.head 7 -  Number: nSelected
.head 7 -  Number: nMax
.head 7 -  Sql Handle: hSql
.head 7 -  String: sComment
.head 7 -  Date/Time: dtDT
.head 7 -  String: sLA_KEY
.head 7 -  String: sTARIF_KEY
.head 7 -  Number: nTmp
.head 7 -  Boolean: bOk
.head 6 +  Actions 
.head 7 -  ! Set nFall = GetLicenseFall()
.head 7 +  If Not SqlConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  Set sMenuItems[0] = Labels_GetTranslation( 'Available Alerts...' )
.head 7 -  Set sMenuItems[1] = "---"
.head 7 -  Set nMax=2
.head 7 +  If SqlPrepareAndExecute(hSql," select  LST_KEY, LST_BEZ
from LEISTUNG
where ISALERT=1
into :sMenuKey, :sMenuItem")
.head 8 +  While SqlFetchNext(hSql, nSelected)
.head 9 -  Set sMenuItems[nMax] = sMenuItem
.head 9 -  Set sMenuKeys[nMax] = sMenuKey
.head 9 -  Set nMax = nMax+1
.head 8 +  If nMax > 2
.head 9 -  Set nSelected = GalPopupMenu_CreateShowRmv(sMenuItems)
.head 9 +  If nSelected>0
.head 10 -  ! Set dtDT = GetTime4Refresh( )
.head 10 +  Call SalModalDialog(dlgAddAlert, hWndForm, sMenuKeys[nSelected], sMenuItems[nSelected])
.head 11 +  ! If SqlPrepareAndExecute(hSql,"select LA_KEY, TARIF_KEY from LEISTUNG where LST_KEY = :sMenuKeys[nSelected] into :sLA_KEY, :sTARIF_KEY")
.head 12 -  Call SqlFetchNext(hSql, nTmp)
.head 12 +  If SqlPrepareAndExecute(hSql, "select @NULLVALUE(MAX(LST_ERF_NR),0)+1 from LST_ERF where Einricht_ID = :nEinrichtId and Fall_Key = :nFall into :nMax")
.head 13 -  Call SqlFetchNext(hSql, nTmp)
.head 13 +  If SqlPrepareAndExecute(hSql, "insert into LST_ERF(LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR, 
			         LST_ERF_VON, STORNIERT,IND_BEGR)
			values (:sLA_KEY, :sTARIF_KEY, :sMenuKeys[nSelected], :nFall, 'N', :nEinrichtId, :nMax, :dtDT, 'N', :sComment)") 
.head 14 -  Set bOk = TRUE
.head 7 +  ! If bOk
.head 8 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 7 +  ! Else
.head 8 -  Call SqlPrepareAndExecute(hSql, "rollback")
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: POC_Open
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If hWnd_POC and not SalIsWindowVisible( hWnd_POC )
.head 8 -  Call SalSendMsg( hWnd_POC, 30000, 0, WM_LButtonDblClk )
.head 7 +  If not SalIsWindowVisible( hWnd_POC )
.head 8 -  Set hWnd_POC=SalCreateWindow( frmPOC, hWndStar2000 )
.head 7 +  Else
.head 8 -  Call SalSendMsg( hWnd_POC, SAM_Close, 0, 0 )
.head 5 +  Function: POC_Register_Cage
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 -  Call GetPosition(nSelectedHandle, sAbt, sStat, sGrp, sBett)
.head 7 +  If not SalIsWindowVisible( hWnd_POC )
.head 8 -  Set hWnd_POC=SalCreateWindow( frmPOC, hWndStar2000 )
.head 7 -  Call frmPOC.RegCage(sAbt, sStat, sGrp)
.head 5 +  Function: POC_ChangeCageType
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Receive String: sType
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sTmp
.head 7 -  String: sTypeT
.head 7 -  Number: nFlags
.head 7 -  Number: nValueLoc
.head 6 +  Actions
.head 7 -  Call GetPosition(nSelectedHandle, sAbt, sStat, sGrp, sBett)
.head 7 -  Call GetItemData( nSelectedHandle, sTmp, nValueLoc, nFlags )
.head 7 +  If not sType
.head 8 -  Call SalModalDialog(dlgSelectCageType, hWndNULL, sTypeT)
.head 8 -  Set sType=sTypeT
.head 7 +  If sGrp and sType and not SalStrScan(sTmp, '[+]')>=0
.head 8 +  If CT_SetType(sStat,sGrp,sType)
.head 9 -  Call KHE_RefreshGruppe(nSelectedHandle)
.head 9 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  ! Function: POC_FindCage
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Number: nCage
.head 7 -  Receive String: sAbtKey
.head 7 -  Receive String: sStatKey
.head 7 -  Receive String: sGrpKey
.head 7 -  Receive Number: hGrp
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hScreen[*] 
.head 7 -  Number: hRoom[*] 
.head 7 -  Number: hGroppe[*] 
.head 7 -  Number: nGroppe 
.head 7 -  Number: nRoom
.head 7 -  Number: nScreen 
.head 7 -  Number: i 
.head 7 -  Number: m
.head 7 -  Number: hCurrent
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 6 +  Actions 
.head 7 -  Set nScreen = EnumChildren( hRoot, hScreen)
.head 7 +  If nScreen
.head 8 -  Set i = 0
.head 8 +  Loop 
.head 9 +  If i >= nScreen
.head 10 -  Break 
.head 9 -  Call GetItemData( hScreen[ i ], sText, nValueLoc, nFlags )
.head 9 -  Set sAbtKey = GetKey_FromLable (sText)
.head 9 -  Set nRoom = EnumChildren( hScreen[ i ], hRoom )
.head 9 +  If nRoom
.head 10 -  Set m= 0
.head 10 +  Loop 
.head 11 +  If m>= nRoom
.head 12 -  Break 
.head 11 -  Call GetItemData( hRoom[ m ], sText1, nValueLoc1, nFlags1 )
.head 11 -  Set sStatKey = GetKey_FromLable (sText1)
.head 11 -  Set nGroppe = EnumChildren( hRoom[ m ], hGroppe )
.head 11 +  If nGroppe>= nCage
.head 12 -  Call GetItemData( hGroppe[ nCage-1 ], sText2, nValueLoc2, nFlags2 )
.head 12 -  Set sGrpKey= GetKey_FromLable (sText2)
.head 12 -  Set hGrp= hGroppe[ nCage-1 ]
.head 12 -  Return TRUE
.head 11 +  Else 
.head 12 -  Set nCage = nCage-nGroppe
.head 11 -  Set m = m + 1
.head 9 -  Set i = i + 1
.head 7 -  Return FALSE
.head 5 +  Function: POC_FocusGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGrp
.head 7 -  Number: hStat
.head 7 -  Number: nIndex
.head 7 -  Window Handle: hWnd
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 6 +  Actions
.head 7 -  ! ! SS 15.12.2007 add sRoomCage for transfer Room and Cage to Mice_imp
.head 7 -  ! AS 11.11.2004: use bAutoScan instead of FALSE
.head 7 -  ! Set hGrp = FindH_4Gruppe( FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan ), sGrpKey, bForceScan )
.head 7 -  Set hGrp = FindChild( FindChild( FindChild( hRoot, sAbtKey ), sStatKey ), sGrpKey )
.head 7 -  !
.head 7 -  Set nIndex = GetItemIndex( hGrp )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  Call ActivateSelectedItem(  )     
.head 7 -  ! Call PopulateAndExpand( hGrp, bAutoScan )
.head 7 +  If bBreedingIsON
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 7 -  Return TRUE
.head 5 +  Function: POC_FocusGruppeH
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGrp
.head 7 -  Number: hStat
.head 7 -  Number: nIndex
.head 7 -  Window Handle: hWnd
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 6 +  Actions
.head 7 -  ! ! SS 15.12.2007 add sRoomCage for transfer Room and Cage to Mice_imp
.head 7 -  ! AS 11.11.2004: use bAutoScan instead of FALSE
.head 7 -  Set hGrp = hCage
.head 7 -  !
.head 7 -  Set nIndex = GetItemIndex( hGrp )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  Call ActivateSelectedItem(  )     
.head 7 -  ! Call PopulateAndExpand( hGrp, FALSE )
.head 7 +  If bBreedingIsON
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 7 -  Return TRUE
.head 5 +  Function: POC_FocusStation
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGrp
.head 7 -  Number: hStat
.head 7 -  Number: nIndex
.head 7 -  Window Handle: hWnd
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 6 +  Actions
.head 7 -  ! ! SS 15.12.2007 add sRoomCage for transfer Room and Cage to Mice_imp
.head 7 -  ! AS 11.11.2004: use bAutoScan instead of FALSE
.head 7 -  ! Set hGrp =  FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan )
.head 7 -  Set hGrp =  FindChild( FindChild( hRoot, sAbtKey ), sStatKey )
.head 7 -  !
.head 7 -  Set nIndex = GetItemIndex( hGrp )
.head 7 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  Call ActivateSelectedItem(  )     
.head 7 -  ! Call PopulateAndExpand( hGrp, bAutoScan )
.head 7 +  If bBreedingIsON
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 7 -  Return TRUE
.head 5 +  Function: POC_Discharge
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bPOC=TRUE
.head 7 +  If Move_GroupRelease(TRUE)
.head 8 -  Set bPOC=FALSE
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Set bPOC=FALSE
.head 8 -  Return FALSE
.head 5 +  Function: POC_Fall_Litter 
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nBet
.head 7 -  Number: nIndex
.head 7 -  Number: hBet[*]
.head 7 -  Number: nFlags
.head 7 -  Number: nValueLoc
.head 7 -  String: sText
.head 7 -  Boolean: bExist
.head 7 -  Number: nFallKey
.head 7 -  Date/Time: dtKHEDate
.head 7 -  Number: nMatingAge
.head 7 -  Boolean: bOk
.head 7 -  ! cPositionData: oPosition
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set dtKHEDate = GetTime4Refresh(  )
.head 7 -  Set bOk = TRUE
.head 7 -  Set nMatingAge = SalStrToNumber(GalGetProfileStringX( "KHE", "MatingAge", "30", sUserINIFileName ))
.head 7 +  If nSelectedLevel = KHEL_Bett
.head 8 -  Call GetItemData(nSelectedHandle, sText, nValueLoc, nFlags)
.head 8 +  If SalStrScan(sText, ', F,')>0 
.head 9 -  Call ActivateSelectedItem(  )     
.head 9 +  If GetOptionBooleanUW( "LitterWidget", "VisibleLitterWidget", FALSE )
.head 10 +  ! If SalModalDialog( dlgChooseLitterEdit, hWndForm, GetFallKey_ByHandle(nSelectedHandle),-1) = IDCANCEL
.head 11 -  Set bOk = FALSE
.head 10 +  If OpenLitterWidget( hActiveSession,0, GetFallKey_ByHandle(nSelectedHandle),-1 , hWndRack2DView) = IDCANCEL
.head 11 -  Set bOk = FALSE
.head 9 +  Else
.head 10 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( GetFallKey_ByHandle(nSelectedHandle)) )
.head 10 -  Call SalPostMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data CLASSPROPSSIZE
0000: 1600
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.head 8 +  Else
.head 9 -  Set bOk = FALSE
.head 7 +  Else
.head 8 -  Set nBet= EnumChildren( nSelectedHandle, hBet )
.head 8 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 8 +  If nBet
.head 9 -  Set i=0
.head 9 +  Loop
.head 10 +  If i >=nBet
.head 11 -  Break
.head 10 -  Call GetItemData( hBet[i], sText, nValueLoc, nFlags )
.head 10 +  If SalStrScan(sText, ', F,')>0 
.head 11 -  Set nFallKey= GetFallKey_ByHandle( hBet[i] )
.head 11 -  Call SqlExists( "select r.RELSHIP_ID
 from relationship r,relship_fall rf,RELSHIP_TYPE rt
  where
   rf.EINRICHT_ID = :nEinrichtId
   and  rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.PLACE = 'J'
   and rf.RELSHIP_ID=r.RELSHIP_ID
   and rf.fall_key= :nFallKey
   and (@nullvalue(r.RELSHIP_END, (:dtKHEDate))>=((:dtKHEDate)-@timevalue(:dtKHEDate) - (:nMatingAge))
or exists(select lc.litter_id from litter_child lc, litter l, relship_fall rff where l.place_relship_id=rf.relship_id and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id )))", bExist )
.head 11 +  If bExist 
.head 12 -  ! Set nIndex = GetItemIndex(  hBet[i] )
.head 12 +  ! If Not SalListSetSelect( hWndItem, nIndex )
.head 13 -  Return FALSE
.head 12 -  ! Set nSelectedLevel = KHEL_Bett
.head 12 -  ! Call ActivateSelectedItem(  )     
.head 12 +  If GetOptionBooleanUW( "LitterWidget", "VisibleLitterWidget", FALSE )
.head 13 +  ! If SalModalDialog( dlgChooseLitterEdit, hWndForm, GetFallKey_ByHandle(hBet[i]),-1) = IDCANCEL
.head 14 -  Set bOk = FALSE
.head 13 -  ! Call _GetPositionID( nSelectedHandle, oPosition )
.head 13 +  If OpenLitterWidget(hActiveSession,oPos.nCageID, GetFallKey_ByHandle(hBet[i]), -1, hWndRack2DView  ) = IDCANCEL
.head 14 -  Set bOk = FALSE
.head 12 +  Else
.head 13 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( GetFallKey_ByHandle(hBet[i])) )
.head 13 -  Call SalPostMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data CLASSPROPSSIZE
0000: 1600
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.head 12 -  Break
.head 10 +  Else If i =nBet
.head 11 -  Set bOk = FALSE
.head 10 -  Set i=i+1
.head 7 -  Return bOk
.head 5 +  Function: POC_AddEmpty_Litter
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nBet
.head 7 -  Number: nIndex
.head 7 -  Number: hBet[*]
.head 7 -  Number: nFlags
.head 7 -  Number: nValueLoc
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  If nSelectedLevel = KHEL_Bett
.head 8 -  Call GetItemData(nSelectedHandle, sText, nValueLoc, nFlags)
.head 8 +  If SalStrScan(sText, ', F,')>0 
.head 9 -  Call ActivateSelectedItem(  )     
.head 9 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( GetFallKey_ByHandle(nSelectedHandle)) )
.head 9 -  Call SalSendMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data CLASSPROPSSIZE
0000: 1600
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.head 9 -  Call SalSendMsg( frmFall_Litter_Edit.pbInsert, SAM_Click,0,0 )
.head 9 -  Call SalSendMsg( frmFall_Litter_Edit.pbUpdate, SAM_Click,0,0 )
.head 7 +  Else
.head 8 -  Set nBet= EnumChildren( nSelectedHandle, hBet )
.head 8 +  If nBet
.head 9 -  Set i=0
.head 9 +  Loop
.head 10 +  If i >=nBet
.head 11 -  Break
.head 10 -  Call GetItemData( hBet[i], sText, nValueLoc, nFlags )
.head 10 +  If SalStrScan(sText, ', F,')>0 
.head 11 -  Set nIndex = GetItemIndex(  hBet[i] )
.head 11 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 12 -  Return FALSE
.head 11 -  Call ActivateSelectedItem( )     
.head 11 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( GetFallKey_ByHandle(hBet[i])))
.head 11 -  Call SalSendMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data CLASSPROPSSIZE
0000: 1600
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.head 11 -  Call SalSendMsg( frmFall_Litter_Edit.pbInsert, SAM_Click,0,0 )
.head 11 -  Call SalMessageBox('Insert','',0)
.head 11 -  Call SalSendMsg( frmFall_Litter_Edit.pbUpdate, SAM_Click,0,0 )
.head 11 -  Call SalMessageBox('Update','',0)
.head 10 -  Set i=i+1
.head 5 +  Function: POC_Check_Fall_Litter
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nBet
.head 7 -  Number: hBet[*]
.head 7 -  Number: nFlags
.head 7 -  Number: nValueLoc
.head 7 -  String: sText
.head 7 -  Boolean: bExists
.head 7 -  Date/Time: dtKHEDate
.head 7 -  Number: nMatingAge
.head 7 -  Number: nFallKey
.head 7 -  Number: nScr
.head 7 -  Number: nRack
.head 7 -  Number: nCage
.head 7 -  Number: nPos
.head 6 +  Actions
.head 7 -  Set dtKHEDate = GetTime4Refresh(  )
.head 7 -  Set bExists = FALSE
.head 7 +  If not KHE_IsOccupied_ByHandle( nSelectedHandle, dtKHEDate )
.head 8 -  !
.head 8 -  !
.head 8 -  Call GetPositionID( nSelectedHandle, nScr, nRack, nCage, nPos )
.head 8 +  If nSelectedLevel = KHEL_Bett
.head 9 -  Call SqlExists( "select rf.RELSHIP_ID
 from fall f, relship_fall rf
  where
   f.pos_id=:nPos
  and f.ee_datum is null
 and f.geloescht ='N'
  and f.geschl !='M'
   and rf.EINRICHT_ID = f.EINRICHT_ID
   and rf.fall_key= f.fall_key
and  rf.fallrolle_key = 'MATE'
   and (@nullvalue(rf.RS_FALL_VALID,@datevalue(:dtKHEDate) + 1 ) >= :dtKHEDate
or exists(select lc.litter_id from litter_child lc, litter l where l.place_relship_id=rf.relship_id and @nullvalue(l.miss,0)=0 and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id and @nullvalue(kk.miss,0)=0
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id ))
)
  
", bExists )
.head 8 +  Else If nSelectedLevel = KHEL_Gruppe
.head 9 -  Call SqlExists( "select rf.RELSHIP_ID
 from fall f, relship_fall rf
  where
   f.last_cage_id=:nCage
  and f.ee_datum is null
 and f.geloescht ='N'
and f.geschl!='M'
   and rf.EINRICHT_ID = f.EINRICHT_ID
   and rf.fall_key= f.fall_key
  and  rf.fallrolle_key = 'MATE'
and ( @nullvalue(rf.RS_FALL_VALID,@datevalue(:dtKHEDate) + 1 ) >= :dtKHEDate
or exists(select lc.litter_id from litter_child lc, litter l where l.place_relship_id=rf.relship_id and @nullvalue(l.miss,0)=0 and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id and @nullvalue(kk.miss,0)=0
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id ))
) ", bExists )
.head 7 -  Return bExists
.head 5 +  Function: POC_CheckHasFall
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return SalStrScan( GetItemText( nSelectedHandle ), "[+]" ) >= 0
.head 5 +  Function: POC_CloseAndUnregister
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 +  If not SalStrScan( GetItemText( hCage ), "[+]" ) >= 0
.head 8 -  Call POC_Unregister(hCage)
.head 8 -  Call GetPosition(hCage, sAbt, sStat, sGrp, sBett)
.head 8 +  If GalGetProfileBooleanX( "KHE", "CloseEmptyCage", TRUE, sUserINIFileName )
.head 9 -  Call CloseGruppe( sAbt, sStat, sGrp )
.head 7 +  If not VisWinIsWindow( hWnd_POC )
.head 8 -  Return FALSE
.head 7 +  If not SalStrScan( GetItemText( hCage ), "[+]" ) >= 0
.head 8 -  Call frmPOC.CageNowEmpty( sStat, sGrp )
.head 5 +  ! Function: POC_Unregister
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Number: hCage
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 6 +  Actions 
.head 7 -  Set bOk = TRUE
.head 7 +  If not SalStrScan( GetItemText( hCage ), "[+]" ) >= 0
.head 8 +  If Not GalConnect( hSql )
.head 9 -  Set bOk = FALSE
.head 8 +  If bOk
.head 9 -  Call GetPosition(hCage, sAbt, sStat, sGrp, sBett)
.head 9 -  Set bOk = SqlPrepareAndExecute( hSql, "Update GRUPPE
		set RFID='',
		      RF_ABT_KEY=''
		Where Stat_Key=:sStat
		and Gruppe_key=:sGrp")
.head 9 -  Set bOk = bOk and  SqlPrepareAndExecute( hSql, "commit")
.head 9 -  Call SqlDisconnect( hSql )
.head 9 +  If bOk
.head 10 -  Call KHE_RefreshGruppe(hCage)
.head 10 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 10 +  If hWnd_POC
.head 11 +  If VisWinIsWindow ( hWnd_POC )
.head 12 -  Call frmPOC.CloseCageFromKHE( sAbt, sStat, sGrp )
.head 10 -  ! Call KHEReAssignPics(hCage)
.head 9 -  ! If
.head 7 -  Return bOk
.head 5 +  Function: POC_Unregister
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sAbt
.head 7 -  ! String: sStat
.head 7 -  ! String: sGrp
.head 7 -  ! String: sBett
.head 7 -  ! Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: cData
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  ! If not SalStrScan( GetItemText( hCage ), "[+]" ) >= 0
.head 8 +  If Not GalConnect( hSql )
.head 9 -  Set bOk = FALSE
.head 8 +  If bOk
.head 9 -  Call GetPosition(hCage, sAbt, sStat, sGrp, sBett)
.head 9 -  Set bOk = SqlPrepareAndExecute( hSql, "Update GRUPPE
		set RFID='',
		      RF_ABT_KEY=''
		Where Stat_Key=:sStat
		and Gruppe_key=:sGrp")
.head 9 -  Set bOk = bOk and  SqlPrepareAndExecute( hSql, "commit")
.head 9 -  Call SqlDisconnect( hSql )
.head 9 +  If bOk
.head 10 -  Call KHE_RefreshGruppe(hCage)
.head 10 -  Call T_SetPortPOC(GetCageID(sStat, sGrp ), NUMBER_Null )
.head 10 -  Call SetPOCPos(hCage, NUMBER_Null)
.head 10 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 10 +  If hWnd_POC
.head 11 +  If VisWinIsWindow ( hWnd_POC )
.head 12 -  Call frmPOC.CloseCageFromKHE( sAbt, sStat, sGrp )
.head 10 -  ! Call KHEReAssignPics(hCage)
.head 9 -  ! If
.head 7 -  Call _GetPositionID(hCage,cData)
.head 7 +  If cData = OBJ_Null
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  ! Call ClearLabel(cData.nCageID)
.head 8 -  Set bOk = POC_Unreg(cData.nCageID,TRUE)
.head 8 +  If bOk
.head 9 -  Call KHE_RefreshGruppe(hCage)
.head 9 -  Call SetPOCPos(hCage, NUMBER_Null)
.head 9 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 9 +  If hWnd_POC
.head 10 +  If VisWinIsWindow ( hWnd_POC )
.head 11 -  Call frmPOC.CloseCageFromKHE( cData.sScreen, cData.sRack, cData.sCage )
.head 7 -  Return bOk
.head 5 +  Function: POC_CheckAndCloseFall
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nBet
.head 7 -  Number: hBet[*]
.head 6 +  Actions
.head 7 +  If Not VisWinIsWindow( hWndFall )
.head 8 -  Return TRUE
.head 7 -  Set nBet= EnumChildren( nSelectedHandle, hBet )
.head 7 +  If nBet
.head 8 -  Set i=0
.head 8 +  Loop
.head 9 +  If i >=nBet
.head 10 -  Break
.head 9 +  If GetFallKey_ByHandle(hBet[i])= Fall.dfFall_Key
.head 10 -  Call SalSendMsg(hWndFall, SAM_Close,0,0)
.head 10 -  Return TRUE
.head 9 -  Set i=i+1
.head 5 -  !
.head 5 +  ! Function: ChangeCage
.head 6 -  Description: 
.head 6 -  Returns 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Number: nFall
.head 7 -  String: sBettKey
.head 7 -  Date/Time: dtZeit
.head 7 -  String: sNull
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sGrpKeySrc
.head 7 -  String: sStatKeySrc
.head 6 +  Actions 
.head 7 +  If Not GalConnect(hSql)
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey )
.head 7 -  Set dtZeit = GetTime4Refresh()
.head 7 -  Set sNull = STRING_Null
.head 7 -  Call SqlPrepareAndExecute(hSql, "select fall_key, bett_key from bewegung where 
   EINRICHT_ID = :nEinrichtId
   and	GELOESCHT = 'N'
   and	BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	BEW_ZEIT <= :dtZeit
   and	(BEW_ZEIT_BIS is null or BEW_ZEIT_BIS > :dtZeit )
   and 	abt_key = :sAbtKeySrc
   and 	stat_key=:sStatKeySrc
   and	gruppe_key=:sGrpKeySrc
   into :nFall, :sBettKey")
.head 7 +  While SqlFetchNext(hSql, nFetch)
.head 8 -  Call InsertBewegung(nFall, 0, dtZeit, 'UE', sNull, sNull, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey, "","","","")
.head 7 -  Call CloseGruppe(sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp)
.head 7 -  Call SqlPrepareAndExecute(hSql, 'commit')
.head 7 -  Call SqlDisconnect(hSql)
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sEinrichtung
.head 7 -  String: sString
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  ! arrays
.head 7 -  Number: hEinrichtungs[*]
.head 7 -  Number: hScreens[*]
.head 7 -  Number: hRacks[*]
.head 7 -  Number: hCages[*]
.head 7 -  Number: hBetts[*]
.head 7 -  ! sizes
.head 7 -  Number: nEinrichtungQuant
.head 7 -  Number: nScreenQuant
.head 7 -  Number: nRackQuant
.head 7 -  Number: nCageQuant
.head 7 -  Number: nBettQuant
.head 7 -  ! counters
.head 7 -  Number: nEinrichtungCount
.head 7 -  Number: nScreenCount
.head 7 -  Number: nRackCount
.head 7 -  Number: nCageCount
.head 6 +  Actions
.head 7 +  If not bShowOnlyOpenCages
.head 8 -  Return TRUE
.head 7 -  Set nEinrichtungQuant = EnumChildren(GetRoot(), hEinrichtungs)
.head 7 -  Set nEinrichtungCount = 0
.head 7 +  While (nEinrichtungQuant > 0) and (nEinrichtungCount < nEinrichtungQuant)
.head 8 -  Set nScreenQuant = EnumChildren(hEinrichtungs[nEinrichtungCount], hScreens)
.head 8 -  Set nScreenCount = 0
.head 8 +  While (nScreenQuant > 0) and (nScreenCount < nScreenQuant)
.head 9 -  Set nRackQuant = EnumChildren(hScreens[nScreenCount], hRacks)
.head 9 -  Set nRackCount = 0
.head 9 +  While (nRackQuant > 0) and (nRackCount < nRackQuant)
.head 10 -  Set nCageQuant = EnumChildren(hRacks[nRackCount], hCages)
.head 10 -  Set nCageCount = 0
.head 10 +  While (nCageQuant > 0) and (nCageCount < nCageQuant)
.head 11 -  Set nBettQuant = EnumChildren(hCages[nCageCount], hBetts)
.head 11 +  If nBettQuant = 0
.head 12 -  Call DeleteGruppeFromStation(hCages[nCageCount])
.head 11 -  Set nCageCount = nCageCount + 1
.head 10 -  Set nRackCount = nRackCount +1
.head 9 -  Set nScreenCount = nScreenCount + 1
.head 8 -  Set nEinrichtungCount = nEinrichtungCount +1
.head 5 +  Function: ChangeCageIsAvailable
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bYes
.head 7 -  String: sTmp
.head 7 -  Number: nVal
.head 7 -  Number: nFlags
.head 6 +  Actions
.head 7 -  Set bYes = FALSE
.head 7 +  If nSelectedLevel = KHEL_Gruppe
.head 8 -  Call GetItemData( nSelectedHandle, sTmp, nVal, nFlags )
.head 8 -  Set bYes = (SalStrScan(sTmp, '[+]')>=0)
.head 7 -  Return bYes
.head 5 +  Function: ChangeCage1
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Number: nFall
.head 7 -  String: sBettKey
.head 7 -  Date/Time: dtZeit
.head 7 -  String: sNull
.head 7 -  String: sBG1
.head 7 -  String: sBG2
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sGrpKeySrc
.head 7 -  String: sStatKeySrc
.head 7 -  !
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 6 +  Actions
.head 7 +  If Not GalConnect(hSql)
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey )
.head 7 -  Call GetPositionID(  nSelectedHandle, nScrID, nRackID, nCageID, nPosID )
.head 7 -  Set dtZeit = GetTime4Refresh()
.head 7 -  Set sNull = STRING_Null
.head 7 -  Call SqlPrepareAndExecute(hSql, "select BG1_KEY, BG2_KEY from BEW_GRUND1 b1,BEW_GRUND2 b2 where
   b1.BA_KEY='UE'
   and b1.STANDARD='J'
   and b2.BA_KEY='UE'
   and b2.STANDARD='J'
   into :sBG1, :sBG2")
.head 7 -  Call SqlFetchNext(hSql, nFetch)
.head 7 -  ! Call SqlPrepareAndExecute(hSql, "select fall_key, bett_key from bewegung where
   EINRICHT_ID = :nEinrichtId
   and	GELOESCHT = 'N'
   and	BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	BEW_ZEIT <= :dtZeit
   and	(BEW_ZEIT_BIS is null or BEW_ZEIT_BIS > :dtZeit )
   and 	abt_key = :sAbtKeySrc
   and 	stat_key=:sStatKeySrc
   and	gruppe_key=:sGrpKeySrc
   into :nFall, :sBettKey")
.head 7 -  Call SqlPrepareAndExecute(hSql, "select fall_key, bett_key from bewegung where
   cage_ID = :nCageID
   and	GELOESCHT = 'N'
   and	BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	BEW_ZEIT <= :dtZeit
   and	(BEW_ZEIT_BIS is null or BEW_ZEIT_BIS > :dtZeit )
    into :nFall, :sBettKey")
.head 7 +  While SqlFetchNext(hSql, nFetch)
.head 8 -  Call InsertBewegung(nFall, 0, dtZeit, 'UE', sBG1, sBG2, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey, "","","","")
.head 7 -  ! Call CloseGruppe(sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp)
.head 7 -  Call SqlPrepareAndExecute(hSql, 'commit')
.head 7 -  Call SqlDisconnect(hSql)
.head 5 +  Function: ChangeCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sNull
.head 7 -  String: sBG1
.head 7 -  String: sBG2
.head 7 -  String: sBedLabel
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sBettKey
.head 7 -  String: sGrpKeySrc
.head 7 -  String: sStatKeySrc
.head 7 -  String: sLaKey
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  Number: nInd
.head 7 -  Number: nBedAmount
.head 7 -  Number: nFallR
.head 7 -  Number: nLstNrPP
.head 7 -  Number: nLstNrP
.head 7 -  Date/Time: dtBuh
.head 7 -  Number: hBeds[*]
.head 7 -  String: sCom
.head 7 -  Number: nDone
.head 7 -  !
.head 7 -  Number: nCage
.head 7 -  Number: nScr
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey )
.head 7 -  Set nInd = 0
.head 7 +  If GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select id from sysadm.gruppe where gruppe_key = :sGrpKeySrc and stat_key = :sStatKeySrc and einricht_id = :nEinrichtId into :nCage")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select id from sysadm.abteilung where abt_key = :sAbtKeySrc and einricht_id = :nEinrichtId into :nScr")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlDisconnect(hSql)
.head 8 -  Set nFallR = GetLicenseFall()
.head 8 +  If nFallR and nCCSrv and nScr and nCage
.head 9 -  Call InsertServiceINT(nCCSrv, nFallR, SalDateCurrent(), sGrpKeySrc||" changed with POC", nScr, nCage, FALSE, TRUE)
.head 7 -  ! Set nBedAmount = EnumChildren( nSelectedHandle, hBeds )
.head 7 +  ! While nInd <= nBedAmount 
.head 8 -  Set sBedLabel = GetItemText( hBeds[ nInd ] )
.head 8 +  If bPlanningMode
.head 9 -  Return FALSE
.head 8 +  If SalStrScan( sBedLabel, "{" ) >=0	
.head 9 -  Set nFallR=GetFallKey_FromLable(sBedLabel)
.head 9 +  If Not GalConnect(hSql)
.head 10 -  Return FALSE
.head 9 -  Call SqlPrepareAndExecute(hSql, "Select  LA_KEY, TARIF_KEY, LST_KEY from LEISTUNG
		where LST_KEY='CC'
		into	:sLaKey,
			:sTarifKey,
			:sLstKey")

.head 9 -  Call SqlFetchNext(hSql, nFetch)
.head 9 -  Call SqlPrepareAndExecute(hSql, 'commit')
.head 9 -  Call SqlDisconnect(hSql)
.head 9 +  If Not GalConnect(hSql)
.head 10 -  Return FALSE
.head 9 -  Call SqlPrepareAndExecute(hSql, "Select  (@NULLVALUE(MAX(LST_ERF_NR),0)+1) from LST_ERF
		where EINRICHT_ID= :nEinrichtId
		           and FALL_KEY= :nFallR
		into    :nLstNrP")
.head 9 -  Call SqlFetchNext(hSql, nFetch)
.head 9 -  Call SqlPrepareAndExecute(hSql, 'commit')
.head 9 -  Call SqlDisconnect(hSql)
.head 9 -  Set nLstNrPP=nLstNrP
.head 9 -  Set sCom =sGrpKeySrc||':'||'Ok'
.head 9 -  Set nDone =1
.head 9 -  Set dtBuh=SalDateCurrent( )
.head 9 +  If Not GalConnect(hSql)
.head 10 -  Return FALSE
.head 9 -  Call SqlPrepareAndExecute(hSql, "insert into LST_ERF(LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR, 
			        LST_ERF_VON, STORNIERT, IND_BEGR, DONE)
	     values ( :sLaKey, :sTarifKey,:sLstKey, :nFallR, 'N', :nEinrichtId, :nLstNrPP,  :dtBuh,  'N', :sCom, :nDone )")
.head 9 -  Call SqlPrepareAndExecute(hSql, 'commit')
.head 9 -  Call SqlDisconnect(hSql)
.head 8 -  Set nInd = nInd + 1
.head 5 +  Function: AddStrNotFallGrup
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpStation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sGrpKey
.head 7 -  String: sGrpBez
.head 7 -  String: sBettKey
.head 7 -  String: sSqlGruppe
.head 7 -  String: sSqlGruppeFall
.head 7 -  String: sSqlGruppeOcup
.head 7 -  String: sSqlGruppePlan
.head 7 -  Number: nGrpNotFall
.head 7 -  Number: nGrpOcup
.head 7 -  Number: nGrp
.head 7 -  Number: nGrpFall
.head 7 -  Sql Handle: hSqlGruppe
.head 7 -  Sql Handle: hSql
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 7 -  Number: hGrp
.head 7 -  Number: j
.head 7 -  ! Number: hRacks
.head 7 -  Number: hGruppe [*]
.head 7 -  Number: nGruppeOpen
.head 7 -  Boolean: baaa
.head 7 -  String: sInList
.head 7 -  Number: nPlanGrup
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 6 +  Actions
.head 7 +  If hpStation <= 0
.head 8 -  Return 0
.head 7 -  Call DeleteStrNotFallGrup( hpStation )
.head 7 -  !
.head 7 -  Call GetPosition( hpStation, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call GetPositionID( hpStation, nScrID, nRackID, nCageID, nPosID )
.head 7 +  If Not sStatKey or nRackID<0
.head 8 -  Return 0
.head 7 +  If Not GalConnect( hSqlGruppe )
.head 8 -  Return 0
.head 7 -  Set sInList = ""
.head 7 -  Set nGruppeOpen  = EnumChildren( hpStation, hGruppe )
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set nGrp = 0
.head 7 +  If bRealTimeMode
.head 8 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ
	 
	
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
  

   and	not  exists ( select	f.LAST_GRUPPE_KEY
from 	 fall f
where	f.LAST_STAT_KEY =  g.STAT_KEY
   and       f.LAST_GRUPPE_KEY = g.GRUPPE_KEY
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'


	)
  and	not  exists(select bl.GRUPPE_KEY
				     from BETT_LOCKS bl
				     where bl.STAT_KEY= g.STAT_KEY
				     and bl.EINRICHT_ID=g.EINRICHT_ID
				     
				     and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
  				     
				     and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     )
  
  
  


group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez "


.head 8 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ
from 	GRUPPE g
where 	g.RACK_ID =  :nRackID
   and	g.CANCELED = 'N'
   and	not  exists ( select	f.LAST_GRUPPE_KEY
						from 	 fall f
						where	f.LAST_CAGE_ID =  g.ID
						   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   				   		   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
	)
  and not exists ( select b.cage_id from bett b, bett_locks bl
				where b.cage_id=g.id
					and bl.pos_id=b.id
					and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			)
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL

into	:sGrpKey, :sGrpBez "


.head 7 +  Else
.head 8 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ
	 
	
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
  

   and	not  exists ( select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew, fall f
where	bew.STAT_KEY =  g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'


	)
  and	not  exists(select bl.GRUPPE_KEY
				     from BETT_LOCKS bl
				     where bl.STAT_KEY= g.STAT_KEY
				     and bl.EINRICHT_ID=g.EINRICHT_ID
				     
				     and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
  				     
				     and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     )
  
  
  


group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez "


.head 8 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ
from 	GRUPPE g
where	g.RACK_ID = :nRackID
   and	g.CANCELED = 'N'
     and	not  exists ( select	bew.GRUPPE_KEY
					from 	 BEWEGUNG bew, fall f
					where	  bew.cage_id = g.id
   						and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  						 and       bew.bew_zeit <=:dtGetTime
 						 and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
 						  and	f.Fall_KEY = bew.Fall_KEY
   						  and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 						  and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'


	)
and not exists ( select b.cage_id from bett b, bett_locks bl
				where b.cage_id=g.id
					and bl.pos_id=b.id
					and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
)
  group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez "


.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 7 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 8 -  Set hGrp = SearchFrom( hpStation, sGrpKey )
.head 8 +  If hGrp <= 0
.head 9 -  Set nGrp = nGrp + 1
.head 7 -  ! Set nGrpNotFall = (nGrp - nGrpFall-nGrpOcup-nPlanGrup)-(nGruppeOpen-nGrpFall)
.head 7 -  ! Set hGrp = KHEAddChild( hpStation, hPicFolderCollapsed, SalNumberToStrX(nGrp,0) || '  Empty Cages in Rack', 0 )
.head 7 -  Call SetItemFont(hGrp, hFontCages)
.head 7 +  If bShouPics 
.head 8 -  Set hGrp = KHEAddChild( hpStation, hPicFolderCollapsed, SalNumberToStrX(nGrp,0) || '  Empty Cages in Rack', 0 )
.head 7 +  Else
.head 8 -  Set hGrp = KHEAddChild( hpStation, hPicNull, SalNumberToStrX(nGrp,0) || '  Empty Cages in Rack', 0 )
.head 7 -  Call KHESetChildChecked(hGrp, TRUE )
.head 7 +  If hGrp = -1
.head 8 -  Call PopulateAndExpand(hpStation, bAutoScan )
.head 7 -  Call SqlDisconnect( hSqlGruppe )
.head 7 -  Return nGrpNotFall
.head 5 +  Function: AddWonNotFallGrup
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  Receive String: sGrpKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sGrpBez
.head 7 -  String: sBettKey
.head 7 -  String: sSqlGruppe
.head 7 -  String: sPurposeKey
.head 7 -  Number: hStation
.head 7 -  ! Number: hStation1
.head 7 -  Number: hStation111
.head 7 -  Date/Time: dtGetTime
.head 7 -  Sql Handle: hSqlGruppe
.head 7 -  Number: nFetch
.head 7 -  Number: nColor
.head 7 -  ! Number: nBettAmount
.head 7 -  Boolean: bOk
.head 7 -  Number: hAbt
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 6 +  Actions
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If hpGruppe = 0 or hpGruppe = NUMBER_Null
.head 8 +  If not sStatKey or not sAbtKey
.head 9 -  Return 0
.head 8 +  If bRealTimeMode
.head 9 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR
	
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	g.RFID = ''
  

   and	not  exists ( select	f.LAST_GRUPPE_KEY
from 	 fall f
where	f.LAST_STAT_KEY =  g.STAT_KEY
   and       f.LAST_GRUPPE_KEY = g.GRUPPE_KEY
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'


)
  and	not  exists(select bl.GRUPPE_KEY
				     from BETT_LOCKS bl
				     where bl.STAT_KEY= '" || sStatKey || "'
				     and bl.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     
				     and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
  				     
				     and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     )
  
  
  


group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 9 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ, g.PURPOSE_KEY, g.COLOR
			
		from 	GRUPPE g
		where	g.RACK_ID = :nRackID
		   and	g.CANCELED = 'N'
		   and	g.RFID = ''
	   and	not  exists ( select	f.LAST_CAGE_ID
						from 	 fall f
		where	f.LAST_CAGE_ID =  g.ID
		    and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
		    and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'		
		)
		and not  exists ( select b.cage_id from bett b, bett_locks bl
					where b.rack_id=g.RACK_ID 
					   and bl.pos_id = b.id
					 and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime )
		group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
			g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
		order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 8 +  Else
.head 9 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR
	
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
   and	g.RFID = ''
  

   and	not  exists ( select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew, fall f
where	bew.STAT_KEY =  g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'


)
  and	not  exists(select bl.GRUPPE_KEY
				     from BETT_LOCKS bl
				     where bl.STAT_KEY= '" || sStatKey || "'
				     and bl.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     
				     and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
  				     
				     and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     )
  
  
  


group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 9 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,g.PURPOSE_KEY, g.COLOR	
from 	GRUPPE g
where	g.RACK_ID = :nRackID
    and	g.CANCELED = 'N'
   and	g.RFID = ''
     and	not  exists ( select	bew.cage_id
			from 	 BEWEGUNG bew, fall f
			where      bew.CAGE_ID = g.ID
			   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   				and       bew.bew_zeit <=:dtGetTime
			   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
			  
   			and	f.Fall_KEY = bew.Fall_KEY
			   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   			and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'


)
  		and not  exists ( select b.cage_id from bett b, bett_locks bl
					where b.rack_id=g.RACK_ID 
					   and bl.pos_id = b.id
					 and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime)

group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 7 +  Else
.head 8 -  Call GetPosition( hpGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Call GetPositionID( hpGruppe, nScrID, nRackID, nCageID, nPosID )
.head 8 +  If bRealTimeMode
.head 9 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR
	
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
     and	not  exists ( select	f.LAST_GRUPPE_KEY
from 	 fall f
where	f.LAST_STAT_KEY =  g.STAT_KEY
   and       f.LAST_GRUPPE_KEY = g.GRUPPE_KEY
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
	)
  and	not  exists (select bl.GRUPPE_KEY
				     from BETT_LOCKS bl
				     where bl.STAT_KEY= '" || sStatKey || "'
				     and bl.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     
				     and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
  				     
				     and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     )
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 9 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ, g.PURPOSE_KEY, g.COLOR
	from 	GRUPPE g
where	g.RACK_ID = :nRackID
     and	g.CANCELED = 'N'
     and	not  exists ( select	f.LAST_CAGE_ID
				from 	 fall f
				where	f.LAST_CAGE_ID =  g.ID
   				and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
				and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
					)
   and not exists ( select b.cage_id from bett b, bett_locks bl
				where b.rack_id=g.RACK_ID 
					and bl.pos_id=b.id
					 and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
  )
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 8 +  Else
.head 9 -  ! Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR
	
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'N'
     and	not  exists ( select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew, fall f
where	bew.STAT_KEY =  g.STAT_KEY
   and       bew.GRUPPE_KEY = g.GRUPPE_KEY
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.Fall_KEY = f.Fall_KEY
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
	)
  and	not  exists (select bl.GRUPPE_KEY
				     from BETT_LOCKS bl
				     where bl.STAT_KEY= '" || sStatKey || "'
				     and bl.EINRICHT_ID=" || StrX( nEinrichtId ) || "
				     
				     and 	bl.GRUPPE_KEY = g.GRUPPE_KEY
  				     
				     and       @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
			                     )
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 9 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR
	
from 	GRUPPE g
where	g.Rack_ID = :nRackID
   and	g.CANCELED = 'N'
     and	not  exists ( select	bew.GRUPPE_KEY
					from 	 BEWEGUNG bew, fall f
					where	bew.cage_id =  g.id
 					   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
					   and       bew.bew_zeit <=:dtGetTime
  						 and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtGetTime
 						  and	f.Fall_KEY = bew.Fall_KEY
  					 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
  						 and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
						)
  and not exists ( select b.cage_id from bett b, bett_locks bl 
      			where b.rack_id=g.Id and bl.pos_id = b.id and @nullvalue( bl.BIS, @datevalue('2222-12-31')) >:dtGetTime
 			                     )
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ,
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sGrpKey, :sGrpBez, :sPurposeKey, :nColor "


.head 7 +  If Not GalConnect( hSqlGruppe )
.head 8 -  Return FALSE
.head 7 -  ! ! Set hStation1 = FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, TRUE )
.head 7 -  Set hAbt = SearchFrom( hRoot , sAbtKey )
.head 7 -  Set hStation = SearchFrom( hAbt , sStatKey )
.head 7 +  If nRackID<=0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, "select id from station where einricht_id=:nEinrichtId and stat_key=:sStatKey into :nRackID  " )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlGruppe, sSqlGruppe )
.head 7 +  While bOk and SqlFetchNext( hSqlGruppe, nFetch )
.head 8 -  Set hStation111 = SearchFrom( hStation, sGrpKey )
.head 8 +  If hStation111 <= 0
.head 9 -  Set hStation111 = OpenGruppe(sAbtKey, sStatKey, sGrpKey, TRUE, 0)
.head 9 -  Break
.head 7 -  Return hStation111
.head 5 +  Function: DeleteStrNotFallGrup
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpStation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sSearch
.head 7 -  Number: hGrp
.head 6 +  Actions
.head 7 +  If hpStation <= 0
.head 8 -  Return 0
.head 7 -  ! Call GetPosition( hpStation, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  !
.head 7 -  Set sSearch =  "Empty Cages in Rack"
.head 7 -  Set hGrp = SearchFrom( hpStation, sSearch)
.head 7 +  If hGrp > 0
.head 8 -  ! Set nIndex = GetItemIndex( hGrp )
.head 8 -  Call DeleteGruppeFromStation (hGrp)
.head 8 -  ! Call SetItemFont(nIndex, hFontCommon)
.head 7 +  ! While (nCageQuant > 0) and (nCageCount < nCageQuant)
.head 8 -  Call GetItemData( hGruppe[nCageCount], sText, nValueLoc, nFlags )
.head 8 +  If SalStrScan(  sText ,  sSearch  ) > -1
.head 9 -  Set hGrp=hGruppe[nCageCount]
.head 8 +  If hGrp > 0
.head 9 -  Set nIndex = GetItemIndex( hGrp )
.head 9 -  ! Call DeleteGruppeFromStation (hGrp)
.head 9 -  ! Call SetItemFont(nIndex, hFontCommon)
.head 9 -  Set nCageCount = nCageCount - 1
.head 9 -  Set hGrp=0
.head 9 -  ! Break
.head 8 -  Set nCageCount = nCageCount + 1
.head 5 +  Function: CageIsSummary
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText =  GetItemText( nSelectedHandle )
.head 7 +  If SalStrScan( sText, 'Empty Cages in Rack')>0
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: Focus
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hStation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 7 -  Number: hChildren[*]
.head 6 +  Actions
.head 7 -  Set nIndex = GetItemIndex( hStation )
.head 7 +  If EnumChildren (hStation, hChildren) <=0
.head 8 -  Call SalListSetSelect( hWndItem, nIndex )
.head 8 -  ! Set nSelectedHandle = hStation
.head 8 -  ! Set nSelectedLevel  = 2
.head 8 -  Call ActivateSelectedItem(  )
.head 8 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )
.head 7 +  Else
.head 8 -  Call SalListSetSelect( hWndItem, nIndex+1 )
.head 8 -  ! Set hStation = GetItemHandle (nIndex+1)
.head 8 -  ! Set nSelectedLevel  = 3
.head 8 -  ! Set nSelectedHandle = hStation
.head 8 -  Call ActivateSelectedItem(  )
.head 8 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )
.head 5 -  !
.head 5 +  ! Function: FemaleIsUnplugged
.head 6 -  Description: 
.head 6 -  Returns 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: nFallNumber
.head 7 -  String: sSex
.head 7 -  Date/Time: dtPlugged
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions 
.head 7 -  Set nFallNumber = GetFallKey_ByHandle (nSelectedHandle)
.head 7 +  If GalConnect( hSql )
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
	select 	g.GESCHL_ABR, rf.PLUGGED
		from	GESCHLECHT g, RELSHIP_FALL rf, FALL f
		where	f.FALL_KEY = :nFallNumber
		and	f.FALL_KEY = rf.FALL_KEY
		and	g.GESCHL_KEY = f.GESCHL
		and	FALLROLLE_KEY = 'MATE'
		and	RS_FALL_END is NULL
		into	:sSex, :dtPlugged")
.head 8 -  Set bOk = SqlFetchNext( hSql, nFetch )
.head 8 -  Call SqlDisconnect( hSql )
.head 7 +  If sSex = 'F' and dtPlugged = DATETIME_Null 
.head 8 -  Return TRUE
.head 7 +  Else 
.head 8 -  Return FALSE
.head 5 +  ! Function: SetStatusPlugged
.head 6 -  Description: 
.head 6 -  Returns 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: nFallNumber
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions 
.head 7 -  Set nFallNumber = GetFallKey_ByHandle (nSelectedHandle)
.head 7 +  If GalConnect( hSql )
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
		update 	RELSHIP_FALL
		set	PLUGGED = @NOW
		where	FALL_KEY = :nFallNumber
		and	FALLROLLE_KEY = 'MATE'
		and	RS_FALL_END is NULL")
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "commit")
.head 8 -  Call SqlDisconnect( hSql )
.head 7 -  Return TRUE
.head 5 +  Function: FemaleIsUnplugged
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallNumber
.head 7 -  String: sSex
.head 7 -  Date/Time: dtPlugged
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nTime
.head 6 +  Actions
.head 7 -  Set nFallNumber = GetFallKey_ByHandle (nSelectedHandle)
.head 7 -  Set nTime = -1
.head 7 -  Set nFetch = 0
.head 7 +  ! If GalConnect( hSql )
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
		select 	rf.PLUGGED
		from	GESCHLECHT g, RELSHIP_FALL rf, FALL f
		where	f.FALL_KEY = :nFallNumber
		and	f.FALL_KEY = rf.FALL_KEY
		and	g.GESCHL_KEY = f.GESCHL
		and	FALLROLLE_KEY = 'MATE'
		and	RS_FALL_END is NULL
		into	:dtPlugged")
.head 8 -  Set bOk = SqlFetchNext( hSql, nFetch )
.head 8 -  Set nFetch = 0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
	select @DATEVALUE(@datetochar(@NOW, 'dd.mm.yyyy' )) - @DATEVALUE(@datetochar(MAX(rf.rs_fall_end), 'dd.mm.yyyy' ))
		 FROM RELSHIP_FALL RF
		WHERE rf.fall_key = :nFallNumber
		and rf.fallrolle_key = 'MATE'
		and rf.rs_fall_end is not NULL
		AND RF.PLUGGED IS NULL
		into	:nTime")
.head 8 -  Set bOk = SqlFetchNext( hSql, nFetch )
.head 8 -  Set nFetch = 0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, " Select geschl from fall where fall_key = :nFallNumber into :sSex")
.head 8 -  Set bOk = SqlFetchNext( hSql, nFetch )
.head 8 -  Call SqlDisconnect( hSql )
.head 7 +  If GalConnect( hSql )
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql, "
		select 	@DATEVALUE(@datetochar(@NOW, 'dd.mm.yyyy' )) - @DATEVALUE(@datetochar(max(@nullvalue(rf.rs_fall_end,@now)), 'dd.mm.yyyy' ))
		from 	RELSHIP_FALL RF, fall f
		where	f.FALL_KEY = :nFallNumber
		and	f.FALL_KEY = rf.FALL_KEY
		and	f.GESCHL = 'W'
		and	FALLROLLE_KEY = 'MATE'
		and 	RF.PLUGGED IS NULL
		into	:nTime")
.head 8 -  Set bOk = SqlFetchNext( hSql, nFetch )
.head 8 -  Call SqlDisconnect( hSql )
.head 7 +  If nTime > -1 and nTime < 21 and nTime != NUMBER_Null
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 +  Function: SetStatusPlugged
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallNumber
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Date/Time: nMaxStart
.head 7 -  Date/Time: dtPluggTime
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 +  If IDOK = SalModalDialog( dlgPluggedTime, hWndForm, dtPluggTime )
.head 8 -  Set nFallNumber = GetFallKey_ByHandle (nSelectedHandle)
.head 8 -  Set nFetch = 0
.head 8 +  If GalConnect( hSql )
.head 9 -  Set bOk = SqlPrepareAndExecute( hSql, "
	select max(RS_FALL_START) from relship_fall
	where 	FALL_KEY = :nFallNumber
	and	FALLROLLE_KEY = 'MATE'
	into	:nMaxStart")
.head 9 -  Set bOk = SqlFetchNext( hSql, nFetch )
.head 9 -  Set nFetch = 0
.head 9 -  Set bOk = SqlPrepareAndExecute( hSql, "
		update 	RELSHIP_FALL
		set	PLUGGED = :dtPluggTime
		where	FALL_KEY = :nFallNumber
		and	FALLROLLE_KEY = 'MATE'
		and	RS_FALL_START = :nMaxStart")
.head 9 -  Set bOk = SqlPrepareAndExecute( hSql, "commit")
.head 9 -  Call SqlDisconnect( hSql )
.head 9 +  If SalIsWindowVisible( hWndRack2DView )
.head 10 -  Call GetPosition(nSelectedHandle, sScr, sRack, sCage, sBett)
.head 10 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sCage))
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 +  Function: AddStrBett
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlBett
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nGrp
.head 7 -  Number: hGrp
.head 7 -  Number: nIndex
.head 7 -  Number: nW
.head 7 -  Number: nM
.head 7 -  String: sString
.head 7 -  String: sCageString
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 6 +  Actions
.head 7 +  If hpGruppe <= 0
.head 8 -  Return 0
.head 7 -  !
.head 7 -  Call GetPosition( hpGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call GetPositionID( hpGruppe, nScrID, nRackID, nCageID, nPosID )
.head 7 +  If Not sGrpKey or nCageID<0
.head 8 -  Return 0
.head 7 +  If Not GalConnect( hSqlBett )
.head 8 -  Return 0
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set nGrp = 0
.head 7 +  If bRealTimeMode
.head 8 -  ! Set sSqlGruppe = "
select	 b.BETT_KEY
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'

    and	(
	   not  exists (
				select	 f.LAST_BETT_KEY
					from fall f
   					where	f.EINRICHT_ID=b.EINRICHT_ID
						and       f.LAST_STAT_KEY = b.STAT_KEY
  						 and       f.LAST_GRUPPE_KEY = b.GRUPPE_KEY
  						 and       f.LAST_BETT_KEY = b.BETT_KEY
   						and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
			  )


	 and 		not  exists (
					    select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	 bl.EINRICHT_ID =b.EINRICHT_ID 
						and     bl.STAT_KEY = b.STAT_KEY
  						 and       bl.GRUPPE_KEY = b.GRUPPE_KEY
						 and       bl.BETT_KEY = b.BETT_KEY
   						 and       (bl.bis>:dtGetTime or bl.bis is null  )
					)


	)
order 	by b.BETT_KEY
into	:sBettKey"


.head 8 -  Set sSqlGruppe = "
select	 b.BETT_KEY
from 	BETT b
where	b.cage_ID =:nCageID
   and 	b.CANCELED = 'N'
    and	(
	   not  exists (
				select	 f.LAST_BETT_KEY
					from fall f
   					where	
  						       f.POS_ID = b.ID
   						and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
			  )
	 and 		not  exists (
					    select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	 bl.POS_ID =b.ID	
   					 and       (bl.bis>@now or bl.bis is null  )
					)
	)
order 	by b.BETT_KEY
into	:sBettKey"


.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSqlBett, nFetch )
.head 9 -  Set hGrp = SearchFrom( hpGruppe, "("||sBettKey||")"||sBettKey )
.head 9 +  If hGrp <= 0
.head 10 -  Set nGrp = nGrp + 1
.head 8 -  ! Set sSqlGruppe = "	select	 f.LAST_BETT_KEY
		from fall f
   		where	  f.EINRICHT_ID=:nEinrichtId 
			and     f.LAST_STAT_KEY = '" || sStatKey || "'
  			 and       f.LAST_GRUPPE_KEY = '" || sGrpKey || "'
   			 and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
			and	f.geschl='W'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
			 
order 	by f.LAST_BETT_KEY
into	:sBettKey"


.head 8 -  Set sSqlGruppe = "	select	 f.LAST_BETT_KEY
		from fall f
   		where
  			       f.LAST_cage_id = :nCageID
   			 and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
			and	f.geschl='W'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
			 
order 	by f.LAST_BETT_KEY
into	:sBettKey"


.head 8 -  Set nFetch=0
.head 8 -  Set nW=0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSqlBett, nFetch )
.head 9 -  Set nW=nW+1
.head 8 -  ! Set sSqlGruppe = "	select	 f.LAST_BETT_KEY
		from  fall f
   		where	   f.EINRICHT_ID=:nEinrichtId   
			and   f.LAST_STAT_KEY = '" || sStatKey || "'
  			 and       f.LAST_GRUPPE_KEY = '" || sGrpKey || "'
   			 and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
			and	f.geschl='M'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
			 
order 	by f.LAST_BETT_KEY
into	:sBettKey"


.head 8 -  Set sSqlGruppe = "	select	 f.LAST_BETT_KEY
		from fall f
   		where
  			       f.LAST_cage_id = :nCageID
   			 and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
			and	f.geschl='M'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
			 
order 	by f.LAST_BETT_KEY
into	:sBettKey"


.head 8 -  Set nFetch=0
.head 8 -  Set nM=0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSqlBett, nFetch )
.head 9 -  Set nM=nM+1
.head 7 +  Else
.head 8 -  ! Set sSqlGruppe = "
select	 b.BETT_KEY
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'

    and	(
	   not  exists (
				select	 bew.BETT_KEY
					from BEWEGUNG bew,  fall f
   					where	 bew.EINRICHT_ID=b.EINRICHT_ID
						and    bew.STAT_KEY = b.STAT_KEY
  						 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
  						 and       bew.BETT_KEY = b.BETT_KEY
   						and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  						 and       bew.bew_zeit <=:dtGetTime
   						and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   						and	bew.Fall_KEY = f.Fall_KEY
   						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   						and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
			  )


	 and 		not  exists (
					    select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	  bl.EINRICHT_ID= b.EINRICHT_ID
						and      bl.STAT_KEY = b.STAT_KEY
  						 and       bl.GRUPPE_KEY = b.GRUPPE_KEY
						 and       bl.BETT_KEY = b.BETT_KEY
   						 and       (bl.bis>:dtGetTime or bl.bis is null  )
					)


	)
order 	by b.BETT_KEY
into	:sBettKey"


.head 8 -  Set sSqlGruppe = "
select	 b.BETT_KEY
from 	BETT b
where	b.CAGE_ID =:nCageID
   and 	b.CANCELED = 'N'
    and	(
	   not  exists (   select	 bew.BETT_KEY
					from BEWEGUNG bew,  fall f
   					where	    bew.pos_id = b.id
   						and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  						 and       bew.bew_zeit <=@now
   						and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
   						and	bew.Fall_KEY = f.Fall_KEY
   						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   						and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
			  )

	 and 		not  exists (    select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	   bl.pos_id = b.id
   						 and       (bl.bis>@now or bl.bis is null  )
					)


	)
order 	by b.BETT_KEY
into	:sBettKey"


.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSqlBett, nFetch )
.head 9 -  Set hGrp = SearchFrom( hpGruppe, "("||sBettKey||")"||sBettKey )
.head 9 +  If hGrp <= 0
.head 10 -  Set nGrp = nGrp + 1
.head 8 -  ! Set sSqlGruppe = "	select	 bew.BETT_KEY
		from BEWEGUNG bew,  fall f
   		where	bew.EINRICHT_ID=:nEinrichtId  
			and    bew.STAT_KEY = '" || sStatKey || "'
  			 and       bew.GRUPPE_KEY = '" || sGrpKey || "'
   			 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  			 and       bew.bew_zeit <=:dtGetTime
   			 and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   			 and	bew.Fall_KEY = f.Fall_KEY
			and	f.geschl='W'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   			and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
			 
order 	by bew.BETT_KEY
into	:sBettKey"


.head 8 -  Set sSqlGruppe = "	select	 bew.BETT_KEY
		from BEWEGUNG bew,  fall f
   		where	    bew.cage_id = :nCageID
   			 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  			 and       bew.bew_zeit <=@now
   			 and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
   			 and	bew.Fall_KEY = f.Fall_KEY
			and	f.geschl='W'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   			and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'

			 
order 	by bew.BETT_KEY
into	:sBettKey"


.head 8 -  Set nFetch=0
.head 8 -  Set nW=0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSqlBett, nFetch )
.head 9 -  Set nW=nW+1
.head 8 -  ! Set sSqlGruppe = "	select	 bew.BETT_KEY
		from BEWEGUNG bew,  fall f
   		where	   bew.EINRICHT_ID=:nEinrichtId  and   bew.STAT_KEY = '" || sStatKey || "'
  			 and       bew.GRUPPE_KEY = '" || sGrpKey || "'
   			 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  			 and       bew.bew_zeit <=:dtGetTime
   			 and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   			 and	bew.Fall_KEY = f.Fall_KEY
			and	f.geschl='M'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   			and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
			 
order 	by bew.BETT_KEY
into	:sBettKey"


.head 8 -  Set sSqlGruppe = "	select	 bew.BETT_KEY
		from BEWEGUNG bew,  fall f
   		where	    bew.cage_id = :nCageID
   			 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  			 and       bew.bew_zeit <=@now
   			 and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
   			 and	bew.Fall_KEY = f.Fall_KEY
			and	f.geschl='M'
   			and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   			and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'

			 
order 	by bew.BETT_KEY
into	:sBettKey"


.head 8 -  Set nFetch=0
.head 8 -  Set nM=0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 8 +  While bOk and SqlFetchNext( hSqlBett, nFetch )
.head 9 -  Set nM=nM+1
.head 7 -  Set sString= ' In Cage:'
.head 7 +  If nW>0
.head 8 -  Set sString= sString || ' F: '|| SalNumberToStrX(nW,0)
.head 7 +  If nM>0
.head 8 +  If sString!=' In Cage:'
.head 9 -  Set sString= sString ||','
.head 8 -  Set sString= sString || ' M: '|| SalNumberToStrX(nM,0)
.head 7 +  If nGrp>0
.head 8 +  If sString!=' In Cage:'
.head 9 -  Set sString= sString ||','
.head 8 -  Set sString= sString || ' Empty: [ '|| SalNumberToStrX(nGrp,0)||' ]'
.head 7 +  ! If BettIsSummary() and GetItemIndex(SearchFrom( hpGruppe,  'in Cage:'))>0
.head 8 -  Call SetItemText( nSelectedHandle, sString )
.head 8 -  ! Set nIndex = GetItemIndex( nSelectedHandle )
.head 8 -  ! Call MoveDown (nIndex)
.head 7 +  ! Else
.head 8 -  ! Set hGrp = KHEAddChild( hpGruppe, hPicFolderCollapsed, '[ '|| SalNumberToStrX(nGrp,0) ||' ]' || '  In Cage:', 0 )
.head 8 +  If bShouPics 
.head 9 -  Set hGrp = KHEAddChild( hpGruppe, hPicFolderCollapsed, sString, 0 )
.head 8 +  Else 
.head 9 -  Set hGrp = KHEAddChild( hpGruppe, hPicNull, sString, 0 )
.head 8 -  Call KHESetChildChecked(hGrp, TRUE )
.head 7 -  Set sCageString = GetItemText(hpGruppe)
.head 7 -  Call SetItemText( hpGruppe, sCageString || sString )
.head 7 -  Call SqlDisconnect( hSqlBett )
.head 7 -  Return nGrp
.head 5 +  Function: AddWonBett
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Date/Time: dtGetTime
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sBettLabel
.head 7 -  Sql Handle: hSql
.head 7 -  String: sSqlBtt
.head 7 -  Number: nFetch
.head 7 -  Number: hBett
.head 7 -  Number: hGruppe
.head 7 -  Number: nIndex
.head 7 -  Boolean: bOk
.head 7 -  Number: hAbt
.head 7 -  Number: nBettKey
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  ! If not sGrpKey
.head 8 -  Return sGrpKey
.head 7 -  ! Set hAbt=SearchFrom( hRoot, sAbtKey )
.head 7 -  ! Set hGruppe=SearchFrom( hAbt, sGrpKey )
.head 7 +  ! If Not GalConnect( hSql)
.head 8 -  Return ''
.head 7 -  ! Call SalStatusSetText( hWndForm, ' ' )
.head 7 +  ! If not dtGetTime
.head 8 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  ! Set sBettKey = "" 
.head 7 -  ! Set sSqlBtt = "
select	 b.BETT_KEY
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	b.BETT_KEY not in ( select bew.BETT_KEY
				from 	 BETT b, BEWEGUNG bew, FALL f
  				   where         b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   					and	b.STAT_KEY = '"||sStatKey||"'
   					and	b.GRUPPE_KEY = '"||sGrpKey||"'
   					and 	b.CANCELED = 'N'
   					and	bew.STAT_KEY = b.STAT_KEY

  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					and 		bew.BETT_KEY=b.BETT_KEY
   					
   					and	    bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J')

into	 :sBettKey "


.head 7 +  ! If bPlanningMode
.head 8 -  Set sSqlBtt = "
select	 @VALUE( b.BETT_KEY)
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY

  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					 and 	bew.BETT_KEY=b.BETT_KEY
   					
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
   and	not  exists ( select bl.BETT_KEY
				from 	 BETT_LOCKS bl
  				   where         bl.EINRICHT_ID =b.EINRICHT_ID
   					and	bl.STAT_KEY = b.STAT_KEY
   					and	bl.GRUPPE_KEY = b.GRUPPE_KEY
					and 		bl.BETT_KEY=b.BETT_KEY
   					and       bl.VON <=:dtGetTime
   					and       (bl.bis>:dtGetTime or bl.bis is null  ))
					
order by 1
into	 :nBettKey "


.head 7 +  ! Else
.head 8 -  Set sSqlBtt = "
select	 min(@VALUE( b.BETT_KEY))
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY

  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					 and 	bew.BETT_KEY=b.BETT_KEY
   					
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
 and	not  exists ( select bl.BETT_KEY
				from 	 BETT_LOCKS bl
  				   where         bl.EINRICHT_ID =b.EINRICHT_ID
   					and	bl.STAT_KEY = b.STAT_KEY
   					and	bl.GRUPPE_KEY = b.GRUPPE_KEY
					and 	bl.BETT_KEY=b.BETT_KEY)

into	 :nBettKey "


.head 7 -  ! Set bOk = SqlPrepareAndExecute( hSql, sSqlBtt )
.head 7 +  ! While bOk and SqlFetchNext( hSql, nFetch )
.head 8 -  ! Set hBett = KHEAddChild( hGruppe, hPicFolderFree, sBettLabel  , 0 )
.head 8 -  Break 
.head 7 -  ! Call AddStrBett(hGruppe)
.head 7 -  ! Set nSelectedHandle = hBett
.head 7 -  ! Call SqlDisconnect( hSql )
.head 7 +  ! If nBettKey>0 and nBettKey != NUMBER_Null
.head 8 -  Set sBettKey = SalNumberToStrX( nBettKey, 0 )
.head 7 -  ! Call SalStatusSetText( hWndForm, '' )
.head 7 -  ! Call PopulateAndExpand( hGruppe, TRUE)
.head 7 -  Return AddWonBettX(sAbtKey, sStatKey, sGrpKey, dtGetTime)
.head 5 +  Function: AddWonBettFall
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sBettLabel
.head 7 -  Sql Handle: hSql
.head 7 -  Date/Time: dtGetTime
.head 7 -  String: sSqlBtt
.head 7 -  Number: nFetch
.head 7 -  Number: hBett
.head 7 -  Number: hGruppe
.head 7 -  Number: nIndex
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bAnyBett
.head 7 -  Number: nFallKeyOnBed
.head 7 -  Boolean: bAnyFall
.head 7 -  Number: hAbt
.head 6 +  Actions
.head 7 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If not sAbtKey and not  sStatKey and not  sGrpKey and not  sBettKey
.head 8 -  Return FALSE
.head 7 -  Set hAbt=SearchFrom( hRoot, sAbtKey )
.head 7 -  Set hGruppe=SearchFrom( hAbt, sGrpKey )
.head 7 +  If Not GalConnect( hSql)
.head 8 -  Return FALSE
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set dtTime  = dtGetTime
.head 7 -  Set sSqlBtt = "
select	'('|| b.BETT_KEY ||')'|| b.BETT_BEZ , b.BETT_KEY
from 	sysadm.BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'

   and	b.BETT_KEY='" || sBettKey  || "'
   
order 	by b.BETT_KEY
into	:sBettLabel, :sBettKey"


.head 7 -  Call GetTime4Refresh(  )
.head 7 -  Call RefreshSingleGruppeLabel( hGruppe, sGrpKey, sStatKey )
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, sSqlBtt )
.head 7 +  While bOk and SqlFetchNext( hSql, nFetch )
.head 8 -  Set bAnyBett = TRUE
.head 8 -  Call SetItemFont(hBett, hFontBetts)
.head 8 -  Set hBett = KHEAddChild( hGruppe, hPicFolderFree, sBettLabel, 0 )
.head 8 +  ! If bShouPics 
.head 9 -  Set hBett = KHEAddChild( hGruppe, hPicFolderFree, sBettLabel, 0 )
.head 8 +  ! Else
.head 9 -  Set hBett = KHEAddChild( hGruppe, hPicNull, sBettLabel, 0 )
.head 8 -  ! Call KHESetChildChecked(hBett , TRUE )
.head 8 +  If TRUE
.head 9 -  Set bOk = PopulateBett( hBett, sBettKey, sBettLabel, nFallKeyOnBed )
.head 9 +  If nFallKeyOnBed
.head 10 -  Set bAnyFall = TRUE
.head 7 +  If TRUE
.head 8 -  Call AddStrBett(hGruppe)
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  !
.head 7 -  Call KHESetPopulated( hGruppe, bOk )
.head 7 +  If bOk
.head 8 -  Call KHESetHasChild( hGruppe, bAnyBett )
.head 8 +  If TRUE
.head 9 -  Call KHESetHasFall( hGruppe, bAnyFall )
.head 8 -  Call SetItemFont(hGruppe, hFontCages)
.head 8 -  ! If bAnyFall
.head 8 +  ! Else
.head 9 -  Call SetItemFont(hGruppe, hFontCommon)
.head 7 -  Call clsExplorerLeft.KHEReAssignPics(hGruppe)
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 5 +  Function: QuantityOfEmptyBett
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlBett
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nBewBett
.head 7 -  Number: nLocBett
.head 7 -  ! Number: nIndex
.head 7 -  Number: nBettKey
.head 6 +  Actions
.head 7 +  If hpGruppe <= 0
.head 8 -  Return 0
.head 7 -  !
.head 7 -  Call GetPosition( hpGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If Not sGrpKey
.head 8 -  Return 0
.head 7 +  If Not GalConnect( hSqlBett )
.head 8 -  Return 0
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set sSqlGruppe = "
select	COUNT(b.BETT_KEY)
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'

    
order 	by b.BETT_KEY
into	:nBettKey"

.head 7 -  Call SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 7 -  Call SqlFetchNext( hSqlBett, nFetch )
.head 7 +  If bRealTimeMode
.head 8 -  Set sSqlGruppe = "
select	 COUNT(f.LAST_BETT_KEY)
					from   fall f
   					where	     f.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   						and 	f.LAST_STAT_KEY = '" || sStatKey || "'
  						 and       f.LAST_GRUPPE_KEY = '" || sGrpKey || "'
   						and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by f.LAST_BETT_KEY
into	:nBewBett"

.head 7 +  Else
.head 8 -  Set sSqlGruppe = "
select	 COUNT(bew.BETT_KEY)
					from BEWEGUNG bew,  fall f
   					where	     bew.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   						and 	bew.STAT_KEY = '" || sStatKey || "'
  						 and       bew.GRUPPE_KEY = '" || sGrpKey || "'
   						and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
  						 and       bew.bew_zeit <=:dtGetTime
   						and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
   						and	bew.Fall_KEY = f.Fall_KEY
   						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   						and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
order 	by bew.BETT_KEY
into	:nBewBett"

.head 7 -  Call SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 7 -  Call SqlFetchNext( hSqlBett, nFetch )
.head 7 -  Set sSqlGruppe = "
select	 COUNT(bl.BETT_KEY)
					from  BETT_LOCKS bl,  fall f
   					where	      bl.EINRICHT_ID =" || StrX( nEinrichtId ) || "
  						 and	bl.STAT_KEY = '" || sStatKey || "'
  						 and       bl.GRUPPE_KEY = '" || sGrpKey || "'
   						 and       (bl.bis>:dtGetTime or bl.bis is null  )
						and	bl.PLANBEW_FALL = f.Fall_KEY
						and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by bl.BETT_KEY
into	:nLocBett"

.head 7 -  Call SqlPrepareAndExecute( hSqlBett, sSqlGruppe )
.head 7 -  Call SqlFetchNext( hSqlBett, nFetch )
.head 7 -  Call SqlDisconnect( hSqlBett )
.head 7 -  Set nBettKey=nBettKey-nBewBett-nLocBett
.head 7 -  Return nBettKey
.head 5 +  Function: KHE_RefreshGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hGruppe
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  !
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  ! Number: hGrpe
.head 7 -  ! !
.head 7 -  ! !
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetch1
.head 7 -  Number: nFetchB
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bBOk
.head 7 -  Sql Handle: hSqlBett
.head 7 -  Sql Handle: hSqlGrp
.head 7 -  String: sSqlGruppe
.head 7 -  String: sSqlBett
.head 7 -  String: sFallKey
.head 7 -  Number: hBett
.head 7 -  ! Number: hGrp
.head 7 -  Number: nIndex
.head 7 -  Number: nBettKey
.head 7 -  Boolean: bPlannedMode
.head 7 -  Number: nFallKeyOnBed
.head 7 -  Boolean: bAnyFall
.head 7 -  ! Number: nUniqNr
.head 7 -  Number: nPos
.head 7 -  String: sRfid
.head 7 -  String: sTextGrp
.head 7 -  Number: nIsPort
.head 7 -  Number: nLength
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 7 -  Number: hBettS
.head 6 +  Actions
.head 7 +  If GetLevel( hGruppe ) != KHEL_Bett and GetLevel( hGruppe ) !=KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 -  Call GetPosition(hGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If GetLevel( hGruppe ) = KHEL_Bett
.head 8 -  Set hGruppe=GetParent(hGruppe)
.head 8 -  ! Set nSelectedLevel  = KHEL_Gruppe
.head 7 +  If bShowPlacesWithContent
.head 8 -  Call KHE_DeleteDescendents( hGruppe )
.head 7 -  ! Set bAnyFall = FALSE
.head 7 +  ! If Not GalConnect( hSqlGrp )
.head 8 -  Return 0
.head 7 -  ! Set bPlannedMode = GalGetProfileBooleanX( "Rack 2D View", "PlannedMode", FALSE, sUserINIFileName )
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set dtTime =dtGetTime
.head 7 -  ! Call SetOutlineRedraw ( FALSE)
.head 7 -  ! Call KHE_DeleteDescendents( hGruppe )
.head 7 -  Call PopulateAndExpand(hGruppe, FALSE)
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  If nBound >0 or (nBound = 0 and HandleToPlace[0,0] > 0)
.head 8 -  Set i=0
.head 8 +  While i<=  nBound
.head 9 -  Set hBettS= SearchFrom(hGruppe, SalNumberToStrX( HandleToPlace[i,0] , 0 ))
.head 9 +  If hBettS >0 
.head 10 -  Set HandleToPlace[i,1] = hBettS
.head 9 -  Set i=i+1
.head 7 -  ! Call SetOutlineRedraw ( TRUE)
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call SqlExists( "
select  RFID
from  GRUPPE
where  STAT_KEY = '"||sStatKey||"'

and	GRUPPE_KEY = '"||sGrpKey||"'

into :sRfid
", bBOk )
.head 9 +  If sRfid
.head 10 -  Set nPos = frmPOC.IsCageOpen(sRfid)
.head 10 +  If not(nPos>0)
.head 11 -  Set sRfid = ""
.head 9 +  If not sRfid
.head 10 -  Call SqlExists( "
select  l.id_label
from  GRUPPE g
 join smart_labels l on (l.cageuniqnr = g.uniq_nr)
where  g.STAT_KEY = '"||sStatKey||"'

and	g.GRUPPE_KEY = '"||sGrpKey||"'

into :sRfid
", bBOk )
.head 9 +  If sRfid
.head 10 -  Set nPos = frmPOC.IsCageOpen(sRfid)
.head 10 +  If nPos>0
.head 11 -  Call POC_ShowPort( hGruppe, nPos)
.head 10 +  Else
.head 11 -  Set sTextGrp =  GetItemText( hGruppe )
.head 11 -  Set nIsPort=SalStrScan(sTextGrp, 'Pos>')
.head 11 +  If nIsPort>-1
.head 12 -  Set nLength = SalStrLength ( sTextGrp )
.head 12 -  Set sTextGrp=SalStrRightX(sTextGrp, nLength-(nIsPort+4))
.head 12 -  Call SetItemText(hGruppe, sTextGrp)
.head 12 -  Set sTextGrp=sAbtKey||","||sStatKey||","||sGrpKey
.head 12 -  Call SalPostMsg( hWndStar2000, AM_AttachPOC, -1, SalHStringToNumber ( sTextGrp ) )
.head 9 +  Else
.head 10 -  Set sTextGrp=sAbtKey||","||sStatKey||","||sGrpKey
.head 10 -  Call SalPostMsg( hWndStar2000, AM_AttachPOC, -1, SalHStringToNumber ( sTextGrp ) )
.head 8 +  Else
.head 9 -  Set sTextGrp =  GetItemText( hGruppe )
.head 9 -  Set nIsPort=SalStrScan(sTextGrp, 'Pos>')
.head 9 +  If nIsPort>-1
.head 10 -  Set nLength = SalStrLength ( sTextGrp )
.head 10 -  Set sTextGrp=SalStrRightX(sTextGrp, nLength-(nIsPort+4))
.head 10 -  Call SetItemText(hGruppe, sTextGrp)
.head 10 -  Set sTextGrp=sAbtKey||","||sStatKey||","||sGrpKey
.head 10 -  Call SalPostMsg( hWndStar2000, AM_AttachPOC, -1, SalHStringToNumber ( sTextGrp ) )
.head 7 +  If sBettKey
.head 8 -  Set hBett=SearchFrom(hGruppe, "("||sBettKey||")")
.head 8 +  If hBett
.head 9 -  Set nIndex=GetItemIndex(hBett)
.head 9 -  Call SalListSetSelect (hWndKHE, nIndex)
.head 9 -  Set nSelectedItem= nIndex
.head 9 -  Set nSelectedHandle= hBett
.head 9 -  Set nSelectedLevel = KHEL_Bett
.head 7 -  Call Rack2DView_RefreshCageContents(sGrpKey)
.head 7 -  Return TRUE
.head 5 +  Function: POC_ShowPort
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hGruppe
.head 7 -  Number: nPort
.head 6 +  Static Variables
.head 7 -  String: sTextGrp
.head 7 -  ! Number: nValue
.head 7 -  ! Number: nItemFlags
.head 6 +  Local variables
.head 7 -  Number: nIsPort
.head 7 -  Number: nLength
.head 7 -  String: sABT
.head 7 -  String: sScren
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 +  Actions
.head 7 -  Call GetPosition( hGruppe, sABT, sScren, sCage, sBett )
.head 7 -  Set sTextGrp =  GetItemText( hGruppe )
.head 7 -  Set nIsPort=SalStrScan(sTextGrp, 'Pos>')
.head 7 -  Set nLength = SalStrLength ( sTextGrp )
.head 7 +  If nIsPort>-1
.head 8 -  Set sTextGrp=SalStrRightX(sTextGrp, nLength-(nIsPort+4))
.head 7 -  ! Set sTextGrp= '<'||SalNumberToStrX (nPort, 0)||' Pos>' || sTextGrp
.head 7 -  Set sTextGrp= '<'||GetPOCPointDescr(nPort)||' Pos>' || sTextGrp
.head 7 -  Call SetItemText(hGruppe, sTextGrp)
.head 7 -  Set sTextGrp=sABT||","||sScren||","||sCage
.head 7 -  Call SetPOCPos(hGruppe, nPort)
.head 7 -  Call SalPostMsg( hWndStar2000, AM_AttachPOC, nPort, SalHStringToNumber ( sTextGrp ) )
.head 5 +  Function: GetLicenseFall
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  Sql Handle: hSql
.head 7 -  Date/Time: dtDT
.head 7 -  Number: nFKey
.head 7 -  ! Number: nGCFKey
.head 7 -  Number: n
.head 7 -  String: sSql
.head 6 +  Actions
.head 7 -  Call GetPosition(nSelectedHandle, sAbt, sStat, sGrp, sBett)
.head 7 +  If Not GalConnect( hSql )
.head 8 -  Return FALSE
.head 7 -  !
.head 7 -  Set dtDT = GetTime4Refresh( )
.head 7 -  Set nFKey = 0
.head 7 +  If sBett = ""
.head 8 +  If KHEGetHasFall(nSelectedHandle)
.head 9 -  ! Set sSql = "select f.fall_key
from	FALL_EXPERIMENT fe, BEWEGUNG b, fall f
where
   @nullvalue( b.GELOESCHT, 'N' ) = 'N'
   and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
   and	b.BEW_ZEIT <= :dtDT
   and	( b.BEW_ZEIT_BIS >= :dtDT or ( b.BEW_ZEIT_BIS is NULL ) )
   and 	b.EINRICHT_ID = :nEinrichtId
   and 	b.ABT_KEY = :sAbt
   and	b.STAT_KEY = :sStat
   and 	b.gruppe_key = :sGrp
   and 	b.FALL_KEY= fe.FALL_KEY
   and f.name1=fe.experiment_key
order by b.bew_zeit desc
into :nFKey"
.head 9 +  If nGCFall_Key=0 or nGCFall_Key=NUMBER_Null
.head 10 -  Set sSql = " select Fall_key 
  from fall_experiment fe, experiment e
 where e.experiment_key=fe.experiment_key
 and e.EXP_SIGNED_P2=4
into :nGCFall_Key"
.head 10 +  If SqlPrepareAndExecute(hSql, sSql)
.head 11 -  Call SqlFetchNext(hSql, n)
.head 9 -  Set sSql = "select @NULLVALUE(f.fall_key, " || SalNumberToStrX( nGCFall_Key, 0 ) || ")
from     BEWEGUNG b left join fall_experiment fe on (b.fall_key = fe.fall_key and fe.end_date is null) left join fall f on (f.name1 = fe.experiment_key)
where
   @nullvalue( b.GELOESCHT, 'N' ) = 'N'
   and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
   and	b.BEW_ZEIT <= :dtDT
   and	( b.BEW_ZEIT_BIS >= :dtDT or ( b.BEW_ZEIT_BIS is NULL ) )
   and 	b.EINRICHT_ID = :nEinrichtId
   and 	b.ABT_KEY = :sAbt
   and	b.STAT_KEY = :sStat
   and 	b.gruppe_key = :sGrp
group by 1
into :nFKey"
.head 9 +  If SqlPrepareAndExecute(hSql, sSql)
.head 10 +  If SqlGetResultSetCount (hSql, n)
.head 11 +  If n>1
.head 12 -  Set nFKey=0
.head 11 +  Else
.head 12 -  Call SqlFetchNext(hSql, n)
.head 9 +  ! If (nFKey = 0) 
.head 10 -  Call SqlImmediate("select f.fall_key
from experiment e, fall f
where
 exp_signed_p2=4
 and f.name1 = e.experiment_key
 and f.vis_kat_key = 'V'
 into :nFKey")
.head 7 +  Else
.head 8 -  ! Set sSql = "select distinct
  f.fall_key
from
  bewegung b, fall f " ||
  BedIsUsedX_SQL_Where( FALSE, ':dtDT', ':dtDT' ) || "
  and	f.EINRICHT_ID = b.EINRICHT_ID
  and	f.FALL_KEY = b.FALL_KEY
  and b.gruppe_key = :sGrp
  and b.stat_key = :sStat
  and b.abt_key = :sAbt
  and b.bett_key = :sBett
into :nFKey"
.head 8 -  ! Set sSql = "select
  b.fall_key
from
  bewegung b
where
  @nullvalue( b.GELOESCHT, 'N' ) = 'N'
  and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
  and	b.BEW_ZEIT <= :dtDT
   and	( b.BEW_ZEIT_BIS >= :dtDT or ( b.BEW_ZEIT_BIS is NULL ) )
  and 	b.EINRICHT_ID = :nEinrichtId
  and b.gruppe_key = :sGrp
  and b.stat_key = :sStat
  and b.abt_key = :sAbt
  and b.bett_key = :sBett
into :nFKey"
.head 8 -  Set nFKey = GetFallKey_ByHandle(nSelectedHandle)
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Return nFKey
.head 5 +  Function: CageIsEmpty
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spStat
.head 7 -  String: spGrp
.head 7 -  Date/Time: dtpTime ! NOT Use
.head 7 -  Boolean: bpAllBew
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: sqlGrp
.head 7 -  Boolean: bEmpty
.head 7 -  Boolean: bPlanEmpty
.head 7 -  Number: nFetch
.head 7 -  Number: nFall
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  If not spStat or not spGrp or not dtpTime
.head 8 -  Return FALSE
.head 7 +  If bpAllBew
.head 8 +  If bRealTimeMode
.head 9 -  Call SqlExists("  select	f.LAST_GRUPPE_KEY
from 	 FALL f
where
         f.LAST_STAT_KEY =  '" || spStat || "'
   and       f.LAST_GRUPPE_KEY = '" || spGrp || "'
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "  ", bEmpty)
.head 8 +  Else
.head 9 -  ! Call SqlExists("  select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew
where
         bew.STAT_KEY =  '" || spStat || "'
   and       bew.GRUPPE_KEY = '" || spGrp || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <=:dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtpTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "  ", bEmpty)
.head 9 -  Call SqlExists("  select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew
where
         bew.STAT_KEY =  '" || spStat || "'
   and       bew.GRUPPE_KEY = '" || spGrp || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <=SYSDATETIME
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >SYSDATETIME
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "  ", bEmpty)
.head 7 +  Else
.head 8 -  ! Call SqlExists(" select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.STAT_KEY = '" || spStat || "'
  and       bl.GRUPPE_KEY = '" || spGrp || "'
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis>:dtpTime or bl.bis is null  )   ", bEmpty)
.head 8 -  Call SqlExists(" select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.STAT_KEY = '" || spStat || "'
  and       bl.GRUPPE_KEY = '" || spGrp || "'
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= SYSDATETIME
  and       (bl.bis>:dtpTime or bl.bis is null  )   ", bEmpty)
.head 8 +  If bEmpty
.head 9 -  Return bEmpty
.head 8 +  If Not GalConnect( sqlGrp )
.head 9 -  Return FALSE
.head 8 -  ! Set bOk = SqlPrepareAndExecute( sqlGrp, "  select	bew.FALL_KEY
from 	 BEWEGUNG bew
where
         bew.STAT_KEY =  '" || spStat || "'
   and       bew.GRUPPE_KEY = '" || spGrp || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtpTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into :nFall" )
.head 8 -  Set bOk = SqlPrepareAndExecute( sqlGrp, "  select	bew.FALL_KEY
from 	 BEWEGUNG bew
where
         bew.STAT_KEY =  '" || spStat || "'
   and       bew.GRUPPE_KEY = '" || spGrp || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=SYSDATETIME
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >SYSDATETIME
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into :nFall" )
.head 8 +  While bOk and SqlFetchNext( sqlGrp, nFetch )
.head 9 -  Call SqlExists(" select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.PLANBEW_FALL = :nFall
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= SYSDATETIME
  and       (bl.bis>:dtpTime or bl.bis is null  )   ", bPlanEmpty)
.head 9 +  If not bPlanEmpty
.head 10 -  Set bEmpty= TRUE
.head 10 -  Break
.head 8 -  Call SqlDisconnect( sqlGrp )
.head 7 -  Return bEmpty
.head 5 +  Function: MoveCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sScrFrom
.head 7 -  String: sRackFrom
.head 7 -  String: sCageFrom
.head 7 -  String: sScrTo
.head 7 -  String: sRackTo
.head 7 -  String: sCageTo
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  ! Sql Handle: hSql1
.head 7 -  Number: nFetch
.head 7 -  String: sEmpty
.head 7 -  Number: nBewNr
.head 7 -  !
.head 7 -  String: sCageTypeFrom
.head 7 -  Number: nCageID_From
.head 7 -  String: sRFIDFrom
.head 7 -  Number: nUniqNrFrom
.head 7 -  String: sGruppeBarFrom
.head 7 -  !
.head 7 -  String: sCageTypeTo
.head 7 -  Number: nCageID_To
.head 7 -  String: sRFIDTo
.head 7 -  Number: nUniqNrTo
.head 7 -  String: sGruppeBarTo
.head 7 -  !
.head 7 -  Number: nFall
.head 7 -  Number: nBettKey
.head 7 -  !
.head 7 -  ! Number: nRelID
.head 7 -  ! String: sRelName
.head 7 -  ! Number: nOriginRelID
.head 7 -  !
.head 7 -  Number: nTransferredFalls[*]
.head 7 -  Number: nBetts[*]
.head 7 -  Number: nTransferredCount
.head 7 -  Number: nTransferBack
.head 7 -  !
.head 7 -  String: sBA
.head 7 -  Boolean: bRFIDToAndFrom
.head 7 -  String: sSqlBew
.head 7 -  String: sRfAbtKeyFrom
.head 7 -  String: sRfAbtKeyTo
.head 7 -  Number: nMinUniqNr
.head 7 -  Boolean: bOk
.head 7 -  String: sClear
.head 6 +  Actions
.head 7 -  Set sEmpty = ""
.head 7 -  Set bRFIDToAndFrom = FALSE
.head 7 -  Call GalConnect(hSql)
.head 7 -  ! Call SqlSetIsolationLevel(hSql, "RL")
.head 7 +  If SqlPrepareAndExecute(hSql, "select RFID, Uniq_Nr, type, gruppe_bar, rf_abt_key , id from gruppe
	where einricht_id = :nEinrichtId and gruppe_key=:sCageFrom and stat_key = :sRackFrom
	into :sRFIDFrom, :nUniqNrFrom, :sCageTypeFrom, :sGruppeBarFrom, :sRfAbtKeyFrom, :nCageID_From")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 +  If SqlPrepareAndExecute(hSql, "select RFID, Uniq_Nr, type, gruppe_bar, rf_abt_key, s.stat_key,g.ID from gruppe g left join station s on (s.id=g.rack_id and s.clearRFID='J')
	where g.einricht_id = :nEinrichtId and g.gruppe_key=:sCageTo and g.stat_key = :sRackTo
	into :sRFIDTo, :nUniqNrTo, :sCageTypeTo, :sGruppeBarTo, :sRfAbtKeyTo, :sClear, :nCageID_To")
.head 9 -  Call SqlFetchNext(hSql, nFetch)
.head 9 +  If sClear != "" or sClear != STRING_Null
.head 10 -  Set sRFIDFrom = ""
.head 9 +  ! If sRFIDFrom and sRFIDTo
.head 10 -  Set bRFIDToAndFrom = TRUE
.head 9 -  ! If not bRFIDToAndFrom
.head 9 -  Call SwapCagesStr(sRackFrom, sCageFrom, sRackTo, sCageTo)
.head 9 -  ! Call CT_SetType(sRackTo, sCageTo, sCageTypeFrom)
.head 9 +  ! If SqlPrepareAndExecute(hSql, "select relship_id, family_name, originrelid from relationship
	where rs_gruppe_key=:sCageFrom
	and relship_start<:dtAction
	and (relship_end is null or relship_end>=:dtAction)
	into :nRelID, :sRelName, :nOriginRelID")
.head 10 -  Call SqlFetchNext(hSql, nFetch)
.head 10 +  If NOT nOriginRelID
.head 11 -  Set nOriginRelID = nRelID
.head 10 -  Call CT_SetType(sRackFrom, sCageFrom, sCageTypeTo)
.head 9 +  If bRealTimeMode
.head 10 -  Set sSqlBew = "select f.fall_key, f.last_bett_key from fall f
	where f.einricht_id = :nEinrichtId
	and f.last_gruppe_key = :sCageFrom 
	and f.last_stat_key = :sRackFrom
	and f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 9 +  Else
.head 10 -  Set sSqlBew = "select b.fall_key, bett_key from bewegung b, fall f
	where b.einricht_id = :nEinrichtId and gruppe_key = :sCageFrom and stat_key = :sRackFrom
	and b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and b.geloescht = 'N'
	and bew_zeit<:dtAction
	and (bew_zeit_bis is null or bew_zeit_bis >= :dtAction)
	and f.fall_key=b.fall_key
	and f.einricht_id=b.einricht_id
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 9 +  If SqlPrepareAndExecute(hSql, sSqlBew)
.head 10 -  Set nTransferredCount = 0
.head 10 +  While SqlFetchNext(hSql, nFetch)
.head 11 -  Set nTransferredCount = nTransferredCount+1
.head 11 -  Call SalArraySetUpperBound(nTransferredFalls, 1, nTransferredCount)
.head 11 -  Set nTransferredFalls[nTransferredCount-1] = nFall
.head 11 -  Set nBetts[nTransferredCount-1]=nBettKey
.head 10 +  If sScrFrom != sScrTo
.head 11 -  Set sBA = "VES"
.head 10 +  Else
.head 11 -  Set sBA="UES"
.head 10 -  Set bOk = TRUE
.head 10 +  While (nTransferredCount>0) and bOk
.head 11 -  Set bOk = bOk and InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, sRackTo, sCageTo, SalNumberToStrX(nBetts[nTransferredCount-1],0),"", "", "", "" )
.head 11 -  ! If not bRFIDToAndFrom
.head 11 +  If bOk
.head 12 -  Call SqlPrepareAndExecute(hSql, "update fall set last_cage_nr = :nUniqNrFrom where fall_key=:nTransferredFalls[nTransferredCount-1] and einricht_id=:nEinrichtId")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 12 -  Call SqlPrepareAndExecute(hSql, "select max(bew_nr) from bewegung where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] into :nBewNr")
.head 12 -  Call SqlFetchNext(hSql, nFetch)
.head 12 -  Call SqlPrepareAndExecute(hSql, "update bewegung set cage_nr=:nUniqNrFrom
	where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] and bew_nr = :nBewNr")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 12 -  Set nTransferredCount = nTransferredCount-1
.head 11 +  Else
.head 12 -  Call GalMessageBox("Error!", "Error in cage transfer. All mice will be returned to source cage.", MB_Ok)
.head 12 -  Call SalArrayGetUpperBound(nTransferredFalls, 1, nTransferBack)
.head 12 -  Set nTransferredCount = nTransferredCount + 1
.head 12 +  While nTransferredCount <= nTransferBack
.head 13 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction+0.00000001, sBA,"", "", sScrFrom, sRackFrom, sCageFrom, SalNumberToStrX(nBetts[nTransferredCount-1],0),"", "", "", "" )
.head 13 -  Call SqlPrepareAndExecute(hSql, "update fall set last_cage_nr = :nUniqNrTo where fall_key=:nTransferredFalls[nTransferredCount-1] and einricht_id=:nEinrichtId")
.head 13 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 13 -  Call SqlPrepareAndExecute(hSql, "select max(bew_nr) from bewegung where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] into :nBewNr")
.head 13 -  Call SqlFetchNext(hSql, nFetch)
.head 13 -  Call SqlPrepareAndExecute(hSql, "update bewegung set cage_nr=:nUniqNrTo
	where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] and bew_nr = :nBewNr")
.head 13 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 13 -  Set nTransferredCount = nTransferredCount+1
.head 10 +  If bOk 
.head 11 +  If (sBA = 'VES') and bAskForLicense
.head 12 -  Call SetMassLicense( nTransferredFalls, sScrTo)
.head 11 -  Call SqlPrepareAndExecute(hSql, "select min(@NULLVALUE(uniq_nr,0) -1) from gruppe into :nMinUniqNr")
.head 11 -  Call SqlFetchNext(hSql, nFetch)
.head 11 +  If SqlPrepareAndExecute(hSql, "update gruppe set Uniq_Nr = :nMinUniqNr, RFID = '---', gruppe_bar = '---'
	where einricht_id = :nEinrichtId and gruppe_key=:sCageFrom and stat_key = :sRackFrom")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 12 +  If SqlPrepareAndExecute(hSql, "update gruppe set Uniq_Nr = :nUniqNrFrom, RFID = :sRFIDFrom, gruppe_bar = :sGruppeBarFrom, rf_abt_key=:sScrTo
	where einricht_id = :nEinrichtId and gruppe_key=:sCageTo and stat_key = :sRackTo")
.head 13 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 13 +  If SqlPrepareAndExecute(hSql, "update gruppe set Uniq_Nr = :nUniqNrTo, RFID = :sRFIDTo, gruppe_bar=:sGruppeBarTo, rf_abt_key=:sScrFrom
	where einricht_id = :nEinrichtId and gruppe_key=:sCageFrom and stat_key = :sRackFrom")
.head 14 +  If SqlPrepareAndExecute(hSql, "Update lst_erf set  gruppe_key= :sCageTo,  stat_key=:sRackTo where stat_key=:sRackFrom and gruppe_key= :sCageFrom")
.head 15 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 11 +  If nCageID_To != nCageID_From
.head 12 -  Call T_ShiftCage( nCageID_From, nCageID_To )
.head 10 -  Call SqlPrepareAndExecute(hSql, "select min(@NULLVALUE(uniq_nr,0) -1) from gruppe into :nMinUniqNr")
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Call SalArraySetUpperBound(nTransferredFalls, 1, 0)
.head 7 -  Return bOk
.head 5 +  Function: CloseGaps0
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Boolean: bMakeAction
.head 7 -  Boolean: bTerminateBySex
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sTmp
.head 7 -  Date/Time: dtNow
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sStopCage
.head 7 -  Number: nRackHandle
.head 7 -  Number: hCages[*]
.head 7 -  Number: nOfCages
.head 7 -  Number: nCount
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sCagesList
.head 7 -  Boolean: bNeedNext
.head 6 +  Actions
.head 7 -  ! ********** silly values ******
.head 7 -  ! Set dtNow = SalDateCurrent() GetTime4Refresh()
.head 7 -  Set dtNow = GetTime4Refresh()
.head 7 -  Call GetPosition(nSelectedHandle, sScr, sRack, sCage, sTmp)
.head 7 -  Set nRackHandle = GetParent(nSelectedHandle)
.head 7 -  Set nOfCages = EnumChildren(nRackHandle, hCages)
.head 7 -  Set nCount = 0
.head 7 -  Set sStopCage = ""
.head 7 -  Set sCagesList = ""
.head 7 +  While (nCount<nOfCages) 
.head 8 +  If KHE_IsExpanded(hCages[nCount])
.head 9 -  Call GetPosition(hCages[nCount], sScr, sRack, sStopCage, sTmp)
.head 9 +  ! If nOfCages=2 and nCount = 0 
.head 10 -  Set sCage = sStopCage
.head 9 +  If sCagesList
.head 10 -  Set sCagesList = sCagesList||","
.head 9 -  Set sCagesList = sCagesList||"'"||sStopCage||"'"
.head 8 -  Set nCount = nCount+1
.head 7 +  If sCagesList
.head 8 -  Call GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select 
gruppe_key 
from 
gruppe 
where stat_key =:sRack
and gruppe_key in ("||sCagesList||")
order by y_pos_label, x_pos_label
into :sStopCage")
.head 8 -  Set bNeedNext = FALSE
.head 8 +  While SqlFetchNext(hSql, nFetch)
.head 9 +  If bNeedNext
.head 10 -  Break
.head 9 +  If nOfCages=2
.head 10 -  Set sCage = sStopCage
.head 9 +  If sStopCage = sCage
.head 10 -  Set bNeedNext = TRUE
.head 8 +  If sStopCage = sCage
.head 9 -  Set sStopCage = ""
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Call SalArraySetUpperBound( hCages, 1, -1 )
.head 7 -  Return CloseGaps(sScr, sRack, sCage, dtNow, bMakeAction, bTerminateBySex, sStopCage)
.head 5 +  Function: CloseGaps
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sScreen0
.head 7 -  String: sRack0
.head 7 -  String: sCage0
.head 7 -  Date/Time: dtDt
.head 7 -  Boolean: bMakeAction
.head 7 -  Boolean: bTerminateBySex
.head 7 -  String: sStopCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Sql Handle: hSqlPlan
.head 7 -  Sql Handle: hSqlReal
.head 7 -  String: sXStart
.head 7 -  Number: nYStart
.head 7 -  String: sXEnd
.head 7 -  Number: nYEnd
.head 7 -  String: sFrom[*]
.head 7 -  String: sTo[*]
.head 7 -  Number: nNumberOfTargets
.head 7 -  Number: nNumberOfSources
.head 7 -  String: sStrainTarget
.head 7 -  String: sStrainP
.head 7 -  String: sStrainP1
.head 7 -  String: sStrainR
.head 7 -  String: sStrainR1
.head 7 -  String: sSexTarget
.head 7 -  String: sSexR
.head 7 -  String: sSexR1
.head 7 -  String: sScreen
.head 7 -  String: sScreen1
.head 7 -  String: sCurrentCage
.head 7 -  String: sCurrentCageP
.head 7 -  String: sCurrentCageR
.head 7 -  Number: nY
.head 7 -  Number: nYPlan
.head 7 -  Number: nYReal
.head 7 -  Date/Time: dtNow
.head 7 -  Number: nFetch
.head 7 -  Number: nFetchPlan
.head 7 -  Number: nFetchReal
.head 7 -  Boolean: bTerminate
.head 7 -  String: sSQL
.head 7 -  String: sTemp
.head 7 -  Number: hStat
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nChild
.head 7 -  Number: i
.head 6 +  Actions
.head 7 -  Set nNumberOfTargets = 0
.head 7 -  Set nNumberOfSources = 0
.head 7 +  If GalConnect(hSql) and GalConnect(hSqlPlan) and GalConnect(hSqlReal)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select @VALUE(y_pos_label), x_pos_label from gruppe where gruppe_key = :sCage0 and stat_key = :sRack0 into :nYStart, :sXStart")
.head 8 +  If SqlFetchNext(hSql, nFetch)
.head 9 +  If sStopCage
.head 10 -  Call SqlPrepareAndExecute(hSql, "select @VALUE(y_pos_label), x_pos_label from gruppe where gruppe_key = :sStopCage and stat_key = :sRack0 into :nYEnd, :sXEnd")
.head 10 -  Call SqlFetchNext(hSql, nFetch)
.head 9 +  If SqlPrepareAndExecute(hSql, "select
 b.gruppe_key, @VALUE(y_pos_label)
from
 bett b, gruppe g
where b.einricht_id =:nEinrichtId
 and b.canceled = 'N'
 and b.stat_key = :sRack0
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into :sCurrentCage, :nY")
.head 10 +  If SqlPrepareAndExecute(hSqlPlan, "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY)
from
 bett_locks b, fall f, gruppe g, STRAIN_N s
where b.einricht_id =:nEinrichtId
 and b.stat_key = :sRack0
 and :dtDt between b.von and @NULLVALUE(b.bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.fall_key = b.planbew_fall
 and f.einricht_id = b.einricht_id
 and f.ID_STRAIN=s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageP, :nYPlan, :sStrainP, :sStrainP1")
.head 11 -  Set sSQL = "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY), min(b.abt_key), max(b.abt_key), min(f.geschl), max(f.geschl)
from
 bewegung b, fall f, gruppe g, STRAIN_N s
where b.einricht_id =:nEinrichtId
 and b.stat_key = :sRack0
 and b.geloescht = 'N'
 and b.ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and :dtDt between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.einricht_id = b.einricht_id
 and f.fall_key = b.fall_key
 and f.ID_STRAIN = s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))"
.head 11 +  If sStopCage
.head 12 -  Set sSQL = sSQL||"
and (@VALUE(y_pos_label)<:nYEnd or (@VALUE(y_pos_label) = :nYEnd and x_pos_label<=:sXEnd))"
.head 11 -  Set sSQL = sSQL||"
group by
 1,2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageR, :nYReal, :sStrainR, :sStrainR1, :sScreen, :sScreen1, :sSexR, :sSexR1"
.head 11 +  If SqlPrepareAndExecute(hSqlReal, sSQL)
.head 12 -  ! detect strain
.head 12 -  Set sStrainP = ""
.head 12 -  Set sStrainP1 = ""
.head 12 -  Set sStrainR = ""
.head 12 -  Set sStrainR1 = ""
.head 12 -  Set sStrainTarget = ""
.head 12 -  Set sSexR = ""
.head 12 -  Set sSexR1 = ""
.head 12 -  Set sSexTarget = ""
.head 12 -  Call SqlFetchNext(hSqlPlan, nFetchPlan)
.head 12 -  Call SqlFetchNext(hSqlReal, nFetchReal)
.head 12 +  If sStopCage and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 13 -  Set bTerminate = FALSE
.head 13 +  If NOT SqlFetchNext(hSql, nFetch)
.head 14 -  Set bTerminate = TRUE
.head 13 +  While NOT bTerminate
.head 14 +  If sCurrentCage = sCurrentCageP
.head 15 -  Set bTerminate = TRUE
.head 14 +  Else
.head 15 +  If sCurrentCage = sCurrentCageR
.head 16 +  If not sSexTarget
.head 17 -  Set sSexTarget = sSexR
.head 16 -  ! If sSexR != sSexR1
.head 16 +  ! Else
.head 17 -  Set sSexTarget = sSexR1
.head 16 -  ! Set bTerminate = TRUE
.head 14 +  If (sScreen0 != sScreen1) or (sScreen0 != sScreen)
.head 15 -  Set bTerminate = TRUE
.head 14 +  If sCurrentCage = sCurrentCageP
.head 15 -  Set bTerminate = TRUE
.head 14 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 15 -  Set bTerminate = TRUE
.head 14 +  If sCurrentCage != sCurrentCageR and not bTerminate
.head 15 -  Set nNumberOfSources = nNumberOfSources+1
.head 15 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 15 -  Set sFrom[nNumberOfSources-1] = sCurrentCageR
.head 15 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 15 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 15 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 14 +  If NOT SqlFetchNext(hSqlReal, nFetchReal)
.head 15 -  Set bTerminate = TRUE
.head 14 +  If NOT SqlFetchNext(hSql, nFetch)
.head 15 -  Set bTerminate = TRUE
.head 13 +  If nNumberOfSources and bMakeAction
.head 14 -  Call LT_OpenTransaction(5,dtDt)
.head 14 -  Call LockSysadmAction("Clos gaps started...")
.head 14 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 14 -  Call LockSysadmAction("...close gaps finished")
.head 14 -  Call LT_CloseLastTransaction()
.head 14 -  Set hStat =  FindChild( FindChild( hRoot, sScreen0 ), sRack0 )
.head 14 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 14 -  Set nChild = EnumChildren( hStat, hChildren )
.head 14 +  If nChild
.head 15 -  Set i = 0
.head 15 +  Loop
.head 16 +  If i >= nChild
.head 17 -  Break
.head 16 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 16 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 16 -  Set i = i + 1
.head 12 +  Else
.head 13 +  If (sStrainR != "")  and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 14 -  Set bTerminate = FALSE
.head 14 +  While (NOT bTerminate) and SqlFetchNext(hSql, nFetch)
.head 15 +  ! If (sScreen0 != sScreen1) or (sScreen0 != sScreen)
.head 16 -  Set bTerminate = TRUE
.head 15 +  If sCurrentCage = sCurrentCageP
.head 16 -  Set bTerminate = TRUE
.head 15 +  Else
.head 16 +  If sCurrentCage = sCurrentCageR
.head 17 +  If (sStrainR1 = sStrainR)
.head 18 -  Set sStrainTarget = sStrainR
.head 18 +  If not sSexTarget
.head 19 -  Set sSexTarget = sSexR
.head 17 +  Else
.head 18 +  If sSexR != sSexR1
.head 19 -  Set sStrainTarget = LitterStrain(  sRack0, sCurrentCage, dtDt  )
.head 18 +  If not sSexTarget
.head 19 -  Set sSexTarget = sSexR1
.head 17 -  Set bTerminate = TRUE
.head 14 +  If sStrainTarget
.head 15 -  Call SqlFetchRow(hSql, 0, nFetch)
.head 15 -  Set bTerminate = FALSE
.head 15 +  While NOT bTerminate
.head 16 +  If sCurrentCage = sCurrentCageP
.head 17 -  Set bTerminate = TRUE
.head 16 +  Else
.head 17 +  If sCurrentCage = sCurrentCageR
.head 18 +  ! If (sStrainR != sStrainTarget) or (sStrainR != sStrainR1)  or (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 19 -  Set bTerminate = TRUE
.head 18 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 19 -  Set bTerminate = TRUE
.head 18 +  Else
.head 19 +  If ((sStrainR = sStrainR1 and sStrainR = sStrainTarget) or (sStrainR != sStrainR1 and LitterStrain(  sRack0, sCurrentCage, dtDt  )= sStrainTarget) ) and (sScreen0 = sScreen1) and (sScreen0 = sScreen)
.head 20 +  If nNumberOfTargets>0
.head 21 -  Set nNumberOfSources = nNumberOfSources+1
.head 21 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 21 -  Set sFrom[nNumberOfSources-1] = sCurrentCage
.head 21 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 21 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 21 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 20 +  If NOT SqlFetchNext(hSqlReal, nFetchReal)
.head 21 -  Set bTerminate = TRUE
.head 19 +  Else
.head 20 -  Set bTerminate = TRUE
.head 17 +  Else
.head 18 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 18 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 18 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 17 +  If NOT SqlFetchNext(hSql, nFetch)
.head 18 -  Set bTerminate = TRUE
.head 15 +  If nNumberOfSources and bMakeAction
.head 16 -  ! Call TransferCages(sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 16 -  Call LT_OpenTransaction(5,dtDt)
.head 16 -  Call LockSysadmAction("Close gaps started...")
.head 16 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 16 -  Call LockSysadmAction("...close gaps finished.")
.head 16 -  Call LT_CloseLastTransaction()
.head 16 -  Set hStat =  FindChild( FindChild( hRoot, sScreen0 ), sRack0 )
.head 16 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 16 -  Set nChild = EnumChildren( hStat, hChildren )
.head 16 +  If nChild
.head 17 -  Set i = 0
.head 17 +  Loop
.head 18 +  If i >= nChild
.head 19 -  Break
.head 18 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 18 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 18 -  Set i = i + 1
.head 16 -  ! Set nFetch = 0
.head 16 -  ! Set sIn = ""
.head 16 -  ! Set nCurrentRes = nSelectedHandle
.head 16 +  ! While nFetch<nNumberOfSources
.head 17 -  ! Set nSelectedHandle = SearchFrom(hCurrentHandle, s[nCount])
.head 17 -  Call MoveCage(sRack, sFrom[nFetch], sScr, sRack, sTo[nFetch], GetTime4Refresh() )
.head 17 -  Set sIn = sIn||sFrom[nFetch]||","||sTo[nFetch]||","
.head 17 -  ! Call SalSendMsg( hWndItem, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 17 -  ! Call CloseGruppe(sScr, sRack, sSources[nCount])
.head 17 -  ! Call OpenGruppe(sScr, sRack, sTargets[nCount],  FALSE, -1)
.head 17 -  Call cSrc[nFetch].Init( sScr, sRack, sTo[nFetch] )
.head 17 -  Set nFetch = nFetch+1
.head 16 -  ! Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 16 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 17 -  Call SalDateToStr( GetTime4Refresh( ), sTmp )
.head 17 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sTmp ) )
.head 17 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sIn ))
.head 16 -  ! Set cDest = cSrc[nNumberOfSources-1]
.head 16 -  ! Call SalArraySetUpperBound(cSrc, 1, nNumberOfSources-1)
.head 16 -  ! Call Move_PrintCageCards( cSrc, cDest)
.head 16 -  ! Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Call SqlDisconnect(hSqlPlan)
.head 7 -  Call SqlDisconnect(hSqlReal)
.head 7 +  If nNumberOfSources and (NOT bMakeAction)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_CGSetSequence, 0, SalHStringToNumber(sTo[0]||","||sFrom[nNumberOfSources-1]))
.head 7 +  Else
.head 8 +  If NOT bMakeAction
.head 9 -  Call SalSendMsg(hWndStar2000, AM_CGSetSequence, 0, SalHStringToNumber(""))
.head 7 -  Call SalArraySetUpperBound(sFrom, 1, -1)
.head 7 -  Call SalArraySetUpperBound(sTo, 1, -1)
.head 7 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 7 -  Return nNumberOfSources
.head 5 +  Function: IsEntireCageSelected
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBound
.head 7 -  Number: hSel
.head 7 -  Number: nNumSel
.head 7 -  Number: i
.head 7 -  Number: nNumBet
.head 7 -  Number: hBet[*]
.head 6 +  Actions
.head 7 -  Call DelNul()
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 7 +  If nBound <= 0 and HandleToPlace[0, 1] =0
.head 8 -  Return FALSE
.head 7 -  Set nNumSel=0
.head 7 -  Set i=0
.head 7 -  Set hSel=0
.head 7 +  While i<= nBound
.head 8 +  If HandleToPlace[i , 1]>0
.head 9 +  If hSel <=0
.head 10 -  Set hSel = GetParent (HandleToPlace[i, 1])
.head 9 +  If GetParent (HandleToPlace[i , 1]) != hSel
.head 10 -  Return FALSE
.head 9 -  Set nNumSel=nNumSel+1
.head 8 -  Set i=i+1
.head 7 -  Set i=0
.head 7 -  Set nNumBet=0
.head 7 -  Set nBound = EnumChildren( hSel, hBet )
.head 7 +  While i< nBound
.head 8 +  If GetFallKey_ByHandle (hBet[i])
.head 9 -  Set nNumBet=nNumBet+1
.head 8 -  Set i=i+1
.head 7 -  Set nBound = SalStrScan( GetItemText( nSelectedHandle ), "[+]" )
.head 7 +  If (nNumBet=nNumSel) and (nNumSel >0) and (nNumBet>0) and  nBound<= 0
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 5 +  Function: DelNul
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: a
.head 7 -  Number: i
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 7 -  Set i=0
.head 7 +  While i<= nBound
.head 8 +  If HandleToPlace[i,1] =0
.head 9 -  Set a=i
.head 9 +  While a<=  nBound
.head 10 -  Set HandleToPlace[a,0]= HandleToPlace[a+1,0]
.head 10 -  Set HandleToPlace[a,1]= HandleToPlace[a+1,1]
.head 10 -  Set a=a+1
.head 9 -  Set nBound=  nBound-1
.head 9 -  Call SalArraySetUpperBound (HandleToPlace, 1, nBound)
.head 9 +  If nBound=0 and HandleToPlace[0,0]= 0
.head 10 -  Call SalArraySetUpperBound (HandleToPlace, 1, -1)
.head 9 -  Break
.head 8 -  Set i=i+1
.head 5 +  Function: RefreshNameCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sGrpKeyD
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hAbt
.head 7 -  Number: hStation
.head 7 -  Number: hGrp
.head 6 +  Actions
.head 7 -  Set hAbt = SearchFrom( hRoot , sAbtKey )
.head 7 +  If hAbt > -1
.head 8 -  Set hStation = SearchFrom( hAbt, sStatKey )
.head 8 +  If hStation > -1
.head 9 -  Set hGrp = SearchFrom( hStation, sGrpKey )
.head 9 +  If hGrp > -1
.head 10 -  Call SetItemText( hGrp, '('||sGrpKeyD||')')
.head 10 +  If bShowPlacesWithContent
.head 11 -  Call ActivatePosition(  hAbt )
.head 11 -  ! Call ActivateSelectedItem()
.head 11 -  Call KHE_RefreshGruppe(hGrp)
.head 10 +  Else
.head 11 -  Call PopulateAndExpand(hGrp, FALSE )
.head 5 +  Function: AddStrBettX
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hpGruppe
.head 7 -  Number: nM
.head 7 -  Number: nW
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlBett
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nGrp
.head 7 -  Number: hGrp
.head 7 -  Number: nIndex
.head 7 -  String: sString
.head 7 -  String: sCageString
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nPosID
.head 6 +  Actions
.head 7 +  If hpGruppe <= 0
.head 8 -  Return 0
.head 7 -  Call GetPosition( hpGruppe, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 -  Call GetPositionID( hpGruppe, nScrID, nRackID, nCageID, nPosID )
.head 7 -  ! Set sSqlGruppe = "
select	 COUNT(b.BETT_KEY)
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'

    and	(
	   		not  exists (
					    select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	bl.EINRICHT_ID =b.EINRICHT_ID 
						and     bl.STAT_KEY = b.STAT_KEY
  						 and       bl.GRUPPE_KEY = b.GRUPPE_KEY
						and       bl.BETT_KEY = b.BETT_KEY
   						 
					)


	)
order 	by b.BETT_KEY
into	:nGrp"


.head 7 -  Set sSqlGruppe = "
select	 COUNT(b.BETT_KEY)
from 	BETT b
where	b.cage_id = :nCageID
   and 	b.CANCELED = 'N'

    and	(
	   		not  exists (
					    select	 bl.BETT_KEY
					from  BETT_LOCKS bl
   					where	bl.pos_id = b.id
   						 
					)


	)
order 	by b.BETT_KEY
into	:nGrp"


.head 7 -  Call SqlExists(sSqlGruppe, bOk)
.head 7 -  !
.head 7 -  Set nGrp=nGrp-(nW+nM)
.head 7 -  Set sString= ' In Cage:'
.head 7 +  If nW>0
.head 8 -  Set sString= sString || ' F: '|| SalNumberToStrX(nW,0)
.head 7 +  If nM>0
.head 8 +  If sString!=' In Cage:'
.head 9 -  Set sString= sString ||','
.head 8 -  Set sString= sString || ' M: '|| SalNumberToStrX(nM,0)
.head 7 +  If nGrp>0
.head 8 +  If sString!=' In Cage:'
.head 9 -  Set sString= sString ||','
.head 8 -  Set sString= sString || ' Empty: [ '|| SalNumberToStrX(nGrp,0)||' ]'
.head 7 +  If nW>0 and nM>0
.head 8 -  Set bMatingCage = TRUE
.head 7 +  If BettIsSummary() and GetItemIndex(nSelectedHandle)>0
.head 8 -  Call SetItemText( nSelectedHandle, '' )
.head 8 -  ! Set nIndex = GetItemIndex( nSelectedHandle )
.head 8 -  ! Call MoveDown (nIndex)
.head 7 +  Else
.head 8 -  ! Set hGrp = KHEAddChild( hpGruppe, hPicFolderCollapsed, '[ '|| SalNumberToStrX(nGrp,0) ||' ]' || '  In Cage:', 0 )
.head 8 -  Call SetItemFont(hGrp, hFontBettsSummary)
.head 8 -  Set hGrp = KHEAddChild( hpGruppe, hPicNull, '', 0 )
.head 8 -  Call KHESetChildChecked(hGrp, TRUE )
.head 7 -  Set sCageString = GetItemText(hpGruppe)
.head 7 +  If nW>0 or nM>0
.head 8 -  Set sString= sString|| " [+]"
.head 7 +  If bMiniSolution
.head 8 +  If nW>0 or nM>0
.head 9 -  Set sString= ' Cage is used'
.head 8 +  Else
.head 9 -  Set sString= ' Cage is not used'
.head 7 -  Call SetItemText( hpGruppe, sCageString || sString )
.head 7 -  Return nGrp
.head 5 +  Function: OpenTempCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hParentCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBett
.head 7 -  Sql Handle: sqlTemp
.head 7 -  String: sSqlTemp
.head 7 -  String: sGrpTemp
.head 7 -  Number: nFetchNext
.head 7 -  Number: nBound
.head 7 -  Number: hTempCage
.head 7 -  String: sDescription
.head 7 -  Number: nIndexP
.head 7 -  Number: nIndexT
.head 7 -  Number: nI
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bShow
.head 7 -  Number: nLeft
.head 7 -  Number: hChildren[*]
.head 7 -  Number: hStation
.head 7 -  String: sType
.head 7 -  String: sRFID
.head 6 +  Actions
.head 7 +  If not GalConnect( sqlTemp )
.head 8 -  Return -1
.head 7 -  Call GetPosition( hParentCage, sAbtKey, sStatKey, sGrpKey, sBett )
.head 7 -  Set sSqlTemp= "
select	g.TYPE, g.RFID
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.Gruppe_Key = '" || sGrpKey || "'
  into	:sType, :sRFID
"
.head 7 -  Set bOk = SqlPrepareAndExecute( sqlTemp, sSqlTemp )
.head 7 -  Call SqlFetchNext( sqlTemp, nFetchNext )
.head 7 -  Set sSqlTemp= "
select	g.GRUPPE_KEY
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || sStatKey || "'
   and	g.CANCELED = 'J'
   and	g.TEMP_CAGE=1
into	:sGrpTemp
"
.head 7 -  Set bOk = SqlPrepareAndExecute( sqlTemp, sSqlTemp )
.head 7 +  If SqlFetchNext( sqlTemp, nFetchNext )
.head 8 -  Set sDescription = "Temp cage to "|| sGrpKey
.head 8 +  If sType = ""
.head 9 -  Call SalMessageBox( "the type of cage"|| sGrpKey ||" is not set", "Warning", 0 )
.head 8 -  Set sSqlTemp = "
update	Gruppe
set	CANCELED = 'N', GRUPPE_BEZ=:sDescription, TYPE=:sType, PARENT_CAGE=:sGrpKey, RFID= :sRFID
where	Einricht_ID = " || StrX( nEinrichtId ) || "
 and	Stat_Key = '" || sStatKey || "'
 and	Gruppe_Key = '" || sGrpTemp || "'
"
.head 8 -  Call CT_SetType(sStatKey, sGrpTemp, sType)
.head 8 -  Set bOk = SqlPrepareAndExecute( sqlTemp, sSqlTemp )
.head 8 -  Set bShow=bShowOnlyOpenCages
.head 8 -  Set bShowOnlyOpenCages=TRUE
.head 8 -  Set nI=0
.head 8 -  Set hStation= GetParent( hParentCage )
.head 8 -  Set nLeft = EnumChildren (hStation, hChildren)
.head 8 +  While nI< nLeft
.head 9 +  If hChildren[nI] = hParentCage
.head 10 -  Set nI = nI + 2
.head 10 -  Break
.head 9 -  Set nI = nI + 1
.head 8 -  Set hTempCage = OpenGruppe(sAbtKey, sStatKey, sGrpTemp, bOk, nI)
.head 8 -  Set bShowOnlyOpenCages=bShow
.head 8 -  Call SalArrayGetUpperBound ( HandleToTemp, 1, nBound ) 
.head 8 +  If bOpenTempCage
.head 9 -  Set HandleToTemp[nBound+1,0]= hParentCage
.head 9 -  Set HandleToTemp[nBound+1,1]= hTempCage
.head 8 +  Else
.head 9 -  Set HandleToTemp[nBound,0]= hParentCage
.head 9 -  Set HandleToTemp[nBound,1]= hTempCage
.head 8 -  Set bOpenTempCage=TRUE
.head 8 -  ! Set nIndexP = GetItemIndex( hParentCage )
.head 8 -  ! Set nIndexT = GetItemIndex( hTempCage )
.head 8 -  ! Set nI=nIndexT- nIndexP
.head 8 +  ! While nI > 0
.head 9 -  Call MoveUp(nIndexT)
.head 9 -  Set nI = nI - 1
.head 9 -  Set nIndexT = GetItemIndex( hTempCage )
.head 7 -  Call SqlDisconnect( sqlTemp )
.head 7 -  Return hTempCage
.head 5 +  Function: CloseCageTemp
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCageParent
.head 7 -  Date/Time: dtGetTime
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Boolean: bEmptyP
.head 7 -  Boolean: bEmptyT
.head 7 -  String: sAbtKeyP
.head 7 -  String: sStatKeyP
.head 7 -  String: sGrpKeyP
.head 7 -  String: sAbtKeyT
.head 7 -  String: sStatKeyT
.head 7 -  String: sGrpKeyT
.head 7 -  String: sBettKey
.head 7 -  String: sSqlTemp
.head 7 -  Boolean: bShow
.head 7 -  Number: nBound
.head 7 -  Boolean: bOk
.head 7 -  String: sRefreshDate
.head 7 -  Number: nIndexParent
.head 6 +  Actions
.head 7 -  Call GetPosition( hCageParent, sAbtKeyP, sStatKeyP, sGrpKeyP, sBettKey )
.head 7 -  Call SalArrayGetUpperBound ( HandleToTemp, 1, nBound ) 
.head 7 -  Set i=0
.head 7 -  Set nIndexParent=nSelectedItem
.head 7 +  While i <= nBound
.head 8 +  If HandleToTemp[i,0]= hCageParent
.head 9 -  Call GetPosition( HandleToTemp[i,1], sAbtKeyT, sStatKeyT, sGrpKeyT, sBettKey )
.head 9 -  Set bEmptyT=CageIsEmpty(sStatKeyT, sGrpKeyT, dtGetTime, TRUE)
.head 9 -  Set bEmptyP = CageIsEmpty(sStatKeyP, sGrpKeyP, dtGetTime, TRUE) 
.head 9 +  If not bEmptyP and  bEmptyT
.head 10 -  Call MoveCage(sAbtKeyT,  sStatKeyT, sGrpKeyT, sAbtKeyP, sStatKeyP, sGrpKeyP,dtGetTime)
.head 10 +  If SalIsWindowVisible( hWndRack2DView )
.head 11 -  Call SalDateToStr( frmAtlantaMain.lbKHELeft.GetTime4Refresh( ), sRefreshDate )
.head 11 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 11 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrpKeyP ))
.head 10 -  Set bEmptyT= FALSE
.head 9 +  If not bEmptyT
.head 10 -  Set bShow=bShowOnlyOpenCages
.head 10 -  Set bShowOnlyOpenCages=TRUE
.head 10 -  Call CloseGruppe(sAbtKeyT, sStatKeyT, sGrpKeyT)
.head 10 -  Set bShowOnlyOpenCages=bShow
.head 10 -  ! Call PopulateGruppeLight(hCageParent, TRUE)
.head 10 +  ! If not bShowPlacesWithContent
.head 11 -  ! Call PopulateAndExpand(hCageParent, TRUE)
.head 10 -  Call SalListSetSelect (hWndKHE, nIndexParent)
.head 10 -  Set nSelectedItem= nIndexParent
.head 10 -  Set nSelectedHandle= hCageParent
.head 10 -  Set nSelectedLevel = KHEL_Gruppe
.head 10 -  Set sSqlTemp = "
update	Gruppe
set	CANCELED = 'J', GRUPPE_BEZ='', PARENT_CAGE='', RFID= ''
where	Einricht_ID = " || StrX( nEinrichtId ) || "
 and	Stat_Key = '" || sStatKeyT || "'
 and	Gruppe_Key = '" || sGrpKeyT || "'
"
.head 10 -  Call SqlExists( sSqlTemp, bOk )
.head 10 +  While i<  nBound
.head 11 -  Set HandleToTemp[i,0]= HandleToTemp[i+1,0]
.head 11 -  Set HandleToTemp[i,1]= HandleToTemp[i+1,1]
.head 11 -  Set i=i+1
.head 10 -  Call SalArraySetUpperBound (HandleToTemp, 1, i-1)
.head 10 -  Call SalArrayGetUpperBound ( HandleToTemp, 1, nBound ) 
.head 10 +  If nBound=0 and HandleToTemp[0,0]= 0
.head 11 -  Call SalArraySetUpperBound (HandleToTemp, 1, -1)
.head 11 -  Set bOpenTempCage=FALSE
.head 10 -  Break
.head 9 +  If bEmptyP and  bEmptyT
.head 10 -  Call SalMessageBox( 'Cage '||sGrpKeyP||' is not empty', 'Error...', 0 )
.head 10 -  Return FALSE
.head 8 -  Set i=i+1
.head 7 -  Return TRUE
.head 5 +  Function: CageIsEmpty_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Date/Time: dtTime
.head 6 +  Actions
.head 7 +  If GetLevel( nSelectedHandle ) != KHEL_Bett and GetLevel( nSelectedHandle ) !=KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 +  If GetLevel( nSelectedHandle ) = KHEL_Bett
.head 8 -  Set nSelectedHandle=GetParent(nSelectedHandle)
.head 7 -  Call GetPosition( nSelectedHandle, sAbt, sStat, sCage, sBett )
.head 7 -  Set dtTime = GetTime4Refresh(  )
.head 7 -  Return CageIsEmpty( sStat, sCage, dtTime, TRUE )
.head 5 +  ! Function: CageIsTemp
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: spStat
.head 7 -  String: spGrp
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Boolean: bOk
.head 7 -  String: sSqlTemp
.head 6 +  Actions 
.head 7 -  Set sSqlTemp= "
select	g.GRUPPE_KEY
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	g.STAT_KEY =  '" || spStat || "'
   and	g.GRUPPE_KEY = '" || spGrp || "'
   and	g.TEMP_CAGE=1

"
.head 7 -  Call SqlExists( sSqlTemp, bOk )
.head 7 -  Return bOk
.head 5 +  Function: CloseAllCageTemp
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bOk2
.head 7 -  String: sSqlTemp
.head 7 -  String: sSqlTemp2
.head 7 -  String: sStatTemp
.head 7 -  String: sGrpTemp
.head 7 -  String: sABTTemp
.head 7 -  Sql Handle: sqlTemp
.head 7 -  Number: nFetch
.head 7 -  Date/Time: dtTime
.head 7 -  String: sGrpParent
.head 7 -  Number: nBound
.head 7 -  Number: hParentCage
.head 7 -  Number: hTempCage
.head 6 +  Actions
.head 7 +  If Not GalConnect( sqlTemp )
.head 8 -  Return FALSE
.head 7 -  Set sSqlTemp= "
select	g.GRUPPE_KEY, g.STAT_KEY, PARENT_CAGE
from 	GRUPPE g
where	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	g.CANCELED = 'N'
   and	g.TEMP_CAGE=1
into	:sGrpTemp, :sStatTemp, :sGrpParent
"
.head 7 -  Set bOk = SqlPrepareAndExecute( sqlTemp, sSqlTemp )
.head 7 +  While bOk and SqlFetchNext( sqlTemp, nFetch )
.head 8 -  Set dtTime = SalDateCurrent(  )
.head 8 +  If not CageIsEmpty(sStatTemp, sGrpTemp, dtTime, TRUE)
.head 9 -  Set sSqlTemp2 = "
update	Gruppe
set	CANCELED = 'J', GRUPPE_BEZ='', PARENT_CAGE='', RFID= ''
where	Einricht_ID = " || StrX( nEinrichtId ) || "
 and	Stat_Key = '" || sStatTemp || "'
 and	Gruppe_Key = '" || sGrpTemp || "'
"
.head 9 -  Call SqlExists( sSqlTemp2, bOk2 )
.head 8 +  Else
.head 9 -  Call SqlExists("select STAT_KEY
from BEN_STATION
where BENUTZER_ID =  " || StrX( nUserId) || "
and 	Einricht_ID = " || StrX( nEinrichtId ) || "
and	Stat_Key = '" || sStatTemp || "'
", bOk2)
.head 9 +  If not bOk2
.head 10 -  Return FALSE
.head 9 -  Call SqlExists("  select	bew.ABT_KEY
from 	 BEWEGUNG bew
where
         bew.STAT_KEY =  '" || sStatTemp || "'
   and       bew.GRUPPE_KEY = '" || sGrpTemp || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <=:dtTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into	:sABTTemp ", bOk2)
.head 9 -  Set hParentCage=OpenGruppe( sABTTemp, sStatTemp, sGrpParent, TRUE, 0 )
.head 9 -  Set hTempCage=OpenGruppe( sABTTemp, sStatTemp, sGrpTemp, TRUE, 0 )
.head 9 -  Call SalArrayGetUpperBound ( HandleToTemp, 1, nBound )
.head 9 +  If bOpenTempCage
.head 10 -  Set HandleToTemp[nBound+1,0]= hParentCage
.head 10 -  Set HandleToTemp[nBound+1,1]= hTempCage
.head 9 +  Else
.head 10 -  Set HandleToTemp[nBound,0]= hParentCage
.head 10 -  Set HandleToTemp[nBound,1]= hTempCage
.head 9 -  Set bOpenTempCage=TRUE
.head 7 -  Call SqlDisconnect( sqlTemp )
.head 7 -  Return TRUE
.head 5 +  Function: GetPOCPort
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sRfid
.head 7 -  Boolean: bBOk
.head 6 +  Actions
.head 7 -  Call GetPosition( hCage, sAbt, sStat, sGrp, sBett )
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call SqlExists( "
select  RFID
from  GRUPPE
where  STAT_KEY = '"||sStat||"'

and	GRUPPE_KEY = '"||sGrp||"'

into :sRfid
", bBOk )
.head 9 +  If sRfid
.head 10 -  Return frmPOC.IsCageOpen(sRfid)
.head 9 +  Else
.head 10 -  Call SqlExists( "
select  l.id_label
from  GRUPPE g 
  left join smart_labels l on (l.cageuniqnr=g.uniq_nr)
where  g.STAT_KEY = '"||sStat||"'

and	g.GRUPPE_KEY = '"||sGrp||"'

into :sRfid
", bBOk )
.head 10 +  If sRfid
.head 11 -  Return frmPOC.IsCageOpen(sRfid)
.head 7 -  Return 0
.head 5 +  Function: TurnLevel
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 7 -  Boolean: bDClickShouldDoExpand
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  String: sLabel
.head 7 -  Number: i
.head 7 -  Number: nBound
.head 6 +  Actions
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  ! If bOpenTempCage
.head 8 +  If nSelectedLevel = KHEL_Gruppe and not bDClickShouldDoExpand
.head 9 -  Call SalArrayGetUpperBound ( HandleToTemp, 1, nBound )
.head 9 -  Set i=0
.head 9 +  While i <= nBound
.head 10 +  If HandleToTemp[i,0]= nSelectedHandle
.head 11 +  If not CloseCageTemp (nSelectedHandle, GetTime4Refresh(  ))
.head 12 -  Return FALSE
.head 11 -  Break 
.head 10 -  Set i=i+1
.head 7 -  Call Refresh_HandleToPlace ()
.head 7 +  If hWnd_POC
.head 8 +  If VisWinIsWindow ( hWnd_POC )
.head 9 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 9 -  Call frmPOC.CloseCageFromKHE( sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp )
.head 7 -  Call KHE_DeleteDescendents (nSelectedHandle)
.head 7 -  Call KHESetPopulated( nSelectedHandle, FALSE )
.head 7 -  ! Call SetItemFont(nSelectedHandle, hFontCommon)
.head 7 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 7 +  ! If not ( hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt ) )  and nSelectedLevel != KHEL_Gruppe
.head 8 -  Call hWndRack2DViewVirt.frmKHE2DViewVirt._UnpressAllButtons ()
.head 7 +  ! If not ( hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView ) )  and nSelectedLevel != KHEL_Gruppe
.head 8 -  Call hWndRack2DView.frmKHE2DView._UnpressAllButtons ()
.head 7 +  If hWndRack2DView and SalIsWindowVisible(hWndRack2DView) and (nSelectedLevel < KHEL_Gruppe)
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_CloseAllCages, 0, 0)
.head 8 -  Call SalHideWindow(hWndRack2DView)
.head 7 +  If hWndRack2DViewVirt and SalIsWindowVisible(hWndRack2DViewVirt) and (nSelectedLevel < KHEL_Gruppe)
.head 8 -  Call SalSendMsg(hWndRack2DViewVirt, AM_CloseAllCages, 0, 0)
.head 8 -  Call SalHideWindow(hWndRack2DViewVirt)
.head 7 -  ! !!!!!
.head 7 +  If nSelectedLevel = KHEL_Gruppe and bShowOnlyOpenCages
.head 8 -  Call Rack2DView_SetButtonState( nSelectedHandle )
.head 8 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Call CloseGruppe (sAbtKey, sStatKey, sGrpKey)
.head 8 -  ! Call DeleteGruppeFromStation (nSelectedHandle)
.head 8 -  ! Set nIndex = GetItemIndex( nSelectedHandle )
.head 8 -  ! Call SalListDelete( hWndItem, nIndex )
.head 8 -  ! Call DeleteChild(nSelectedHandle)
.head 7 +  If nSelectedLevel = KHEL_Gruppe and bShowWithContent
.head 8 -  ! Call Rack2DView_SetButtonState( nSelectedHandle )
.head 8 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 8 -  Call CloseGruppe (sAbtKey, sStatKey, sGrpKey)
.head 7 +  Else
.head 8 -  Set dtTime  = GetTime4Refresh(  )
.head 8 -  Call KHEReAssignPics( nSelectedHandle )
.head 7 -  Call Rack2DView_SetButtonState( nSelectedHandle )
.head 5 +  Function: DischargeService
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Date/Time: dtDate
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtStart
.head 7 -  Date/Time: dtEnd
.head 7 -  Number: nSec
.head 7 -  Sql Handle: hSql
.head 6 +  Actions
.head 7 -  Set dtStart=SalDateConstruct( 2009, 09, 01, 0, 0, 0 )
.head 7 -  Set dtEnd=SalDateConstruct( 2009, 09, 01, 0, 0, 1 )
.head 7 -  Set nSec= dtEnd-dtStart
.head 7 +  If not CageIsEmpty(sRack, sCage, dtDate+nSec, TRUE )
.head 8 +  If GalConnect(hSql)
.head 9 -  Call SqlPrepareAndExecute(hSql,  'update lst_erf set done=1, LST_ERF_BIS=:dtDate where stat_key=:sRack and gruppe_key= :sCage and done=0' )
.head 9 -  Call SqlDisconnect(hSql)
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 +  Function: LitterStrain
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Date/Time: dtDT
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  String: sStrain
.head 7 -  String: sSex0
.head 7 -  String: sSex
.head 7 -  String: sStrain_Mother
.head 7 -  String: sStrain_Father
.head 7 -  String: sStrain_Litter
.head 7 -  String: sSpecies
.head 7 -  Number: nFetch
.head 7 -  Boolean: bStop
.head 7 -  Number: nFall
.head 7 -  Number: nFall_Mother
.head 7 -  Number: nFall_Father
.head 6 +  Actions
.head 7 -  Set sStrain_Litter=""
.head 7 -  Set sSex0=""
.head 7 -  Set bStop = FALSE
.head 7 +  ! If sStrain_Mother=sStrain_Father
.head 8 -  Return sStrain_Mother
.head 7 +  If not GalConnect(hSql)
.head 8 -  Return sStrain_Litter
.head 7 +  If bRealTimeMode
.head 8 -  Call SqlPrepareAndExecute( hSql, "select s.STRAIN_KEY , f.geschl,l.KONFES_KEY, f.fall_key
from
 fall f, gruppe g, le l, strain_n s
where
 f.LAST_stat_key = :sRack
 and f.LAST_gruppe_key = :sCage
 and f.LAST_ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and f.einricht_id = g.einricht_id
 and f.last_stat_key = g.stat_key
 and f.last_gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.le_id=l.le_id
and f.ID_strain = s.ID
group by 2,1,3,4
into :sStrain, :sSex, :sSpecies, :nFall " )
.head 7 +  Else
.head 8 -  Call SqlPrepareAndExecute( hSql, "select s.STRAIN_KEY , f.geschl,l.KONFES_KEY, f.fall_key
from
 bewegung b, fall f, gruppe g, le l, strain_n s
where
 b.stat_key = :sRack
 and b.gruppe_key = :sCage
 and b.geloescht = 'N'
 and b.ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and :dtDT between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.einricht_id = b.einricht_id
 and f.fall_key = b.fall_key
 and f.le_id=l.le_id
 and f.ID_strain = s.ID
group by 2,1,3,4
into :sStrain, :sSex, :sSpecies, :nFall" )
.head 7 +  While SqlFetchNext( hSql, nFetch ) and (NOT  bStop)
.head 8 +  If sSex != sSex0
.head 9 +  If sSex = 'M' 
.head 10 -  Set sStrain_Father = sStrain
.head 10 -  Set nFall_Father = nFall
.head 9 +  Else
.head 10 -  Set sStrain_Mother= sStrain
.head 10 -  Set nFall_Mother = nFall
.head 8 +  Else
.head 9 -  Set bStop=TRUE
.head 8 +  If sSex0 = ""
.head 9 -  Set sSex0 = sSex
.head 7 +  If not bStop and sStrain != STRING_Null
.head 8 -  ! Call SqlPrepareAndExecute( hSql, "select STRAIN_KEY
  from strain_n  
 where
  species_key=:sSpecies
  and str_father = :sStrain_Father
  and str_mother=:sStrain_Mother
 into :sStrain_Litter")
.head 8 -  Call SqlPrepareAndExecute( hSql, "select s.strain_key
  from relship_fall rf1
 join relship_fall rf2 on (rf2.relship_id=rf1.relship_id)
 join relationship r on (r.relship_id=rf1.relship_id)
 left join strain s on (s.id=r.id_str_family)
where rf1.einricht_id=:nEinrichtId 
and rf1.fall_key=:nFall_Mother
and rf1.fallrolle_key='MATE' 
and @nullvalue(rf1.rs_fall_valid,@now+35) > @now
and rf2.einricht_id=:nEinrichtId 
and rf2.fall_key=:nFall_Father
 into :sStrain_Litter")
.head 8 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  Call SqlDisconnect( hSql )
.head 7 -  Return sStrain_Litter
.head 5 +  Function: DischargeFallDoneService
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFall
.head 7 -  Date/Time: dtDate
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlLst
.head 7 -  Sql Handle: hSql
.head 7 -  String: sLstKey
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If not (GalConnect( hSqlLst ) and GalConnect(hSql))
.head 8 -  Return FALSE
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlLst, "select  LST_KEY
from lst_erf
where FALL_KEY = '"||SalNumberToStrX( nFall, 0 )||"'
and done=0 
and exists  (select LST_KEY
		from leistung
		 where Done_Discharge = 1)
into  :sLstKey")
.head 7 +  While bOk and SqlFetchNext( hSqlLst, nFetch )
.head 8 -  Call SqlPrepareAndExecute(hSql,  "update lst_erf  set done=1, LST_ERF_BIS=:dtDate, STORNIERT='N' 
where done=0
and FALL_KEY = '"||SalNumberToStrX( nFall, 0 )||"'
and  LST_KEY= '"||sLstKey||"'" )
.head 8 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 7 +  ! If hWndWorklist and VisWinIsWindow(hWndWorklist)
.head 8 -  Call SalSendMsg( hWndWorklist, AM_Refresh, wParam, lParam )
.head 7 -  Call SqlDisconnect( hSqlLst )
.head 7 -  Call SqlDisconnect( hSql )
.head 5 +  Function: HasOpenedChild
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nHandle
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChilds[*]
.head 7 -  Number: nChildsNumber
.head 7 -  String: sItem
.head 7 -  Number: nItem
.head 7 -  Number: nFlags
.head 7 -  Boolean: bRes
.head 6 +  Actions
.head 7 +  If not KHE_IsOccupied_ByHandle( nHandle, GetTime4Refresh(  ))
.head 8 -  Set nChildsNumber = EnumChildren(nHandle, nChilds)-1
.head 8 +  While (nChildsNumber>=0) and (NOT bRes)
.head 9 -  Call GetItemData(nChilds[nChildsNumber], sItem, nItem, nFlags)
.head 9 +  If nFlags & 0x80000000
.head 10 -  Set bRes = TRUE
.head 9 -  Set nChildsNumber = nChildsNumber-1
.head 7 -  Return bRes
.head 5 +  Function: TempIsPossible
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bMakeAction
.head 7 -  Number: nEntire
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtDT
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: nStartHandle
.head 7 -  Number: nStartLevel
.head 7 -  String: sSrcRacks[*]
.head 7 -  String: sSrcCages[*]
.head 7 -  String: sTargetCages[*]
.head 7 -  String: sVirtRack
.head 7 -  Number: nRacks[*]
.head 7 -  Number: nOfRacks
.head 7 -  Number: nCurrRack
.head 7 -  Number: nCages[*]
.head 7 -  Number: nOfCages
.head 7 -  Number: nCurrCage
.head 7 -  Number: nTmp
.head 7 -  Number: nFlags
.head 7 -  Boolean: bOk
.head 7 -  Number: nAffected
.head 7 -  Number: nAffectedV
.head 7 -  Sql Handle: hSqlV
.head 7 -  String: sRefreshDate
.head 7 -  Number: hOpenCage
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 -  Call GetPosition(nSelectedHandle, sScr, sRack, sCage, sBett)
.head 7 -  ! 1) check if virtual rack is opened
.head 7 +  If NOT SalIsWindowVisible( hWndRack2DViewVirt ) or (frmKHE2DViewVirt.cRack2DLayoutManager.sScreen !=sScr) or (nSelectedLevel < KHEL_Station)
.head 8 -  Return FALSE
.head 7 -  Set sVirtRack = frmKHE2DViewVirt.cRack2DLayoutManager.sRack
.head 7 -  ! 2) take KHE opened cages
.head 7 -  Set nStartLevel = nSelectedLevel
.head 7 -  Set nStartHandle = nSelectedHandle
.head 7 +  If nEntire
.head 8 +  While nStartLevel > KHEL_Abteilung
.head 9 -  Set nStartHandle = GetParent(nStartHandle)
.head 9 -  Set nStartLevel = nStartLevel-1
.head 8 -  Set nOfRacks = EnumChildren(nStartHandle, nRacks)
.head 7 +  Else
.head 8 -  Call SalArraySetUpperBound(nRacks,1,0)
.head 8 +  If nSelectedLevel = KHEL_Station
.head 9 -  Set nRacks[0] = nSelectedHandle
.head 8 +  Else
.head 9 -  Set nRacks[0] = GetParent(nSelectedHandle)
.head 8 -  Set nOfRacks = 1
.head 7 -  Set nCurrRack = 0
.head 7 -  Set bOk = TRUE
.head 7 -  Set dtDT = GetTime4Refresh()
.head 7 -  Set nAffected = 0
.head 7 +  While (nCurrRack<nOfRacks) and bOk
.head 8 +  If NOT GetIsRackVirtual_ByHandle(nRacks[nCurrRack])
.head 9 +  If (NOT nEntire) and (nSelectedLevel = KHEL_Gruppe)
.head 10 -  Call SalArraySetUpperBound(nCages,1,0)
.head 10 -  Set nCages[0] = nSelectedHandle
.head 10 -  Set nOfCages = 1
.head 9 +  Else
.head 10 -  Set nOfCages = EnumChildren(nRacks[nCurrRack], nCages)
.head 9 -  Set nCurrCage = 0
.head 9 +  While (nCurrCage < nOfCages) and bOk
.head 10 -  Call GetPosition(nCages[nCurrCage], sScr, sRack, sCage, sBett)
.head 10 +  If NOT CageIsEmpty(sRack, sCage, dtDT, TRUE)
.head 11 -  Set bOk = FALSE
.head 10 +  Else
.head 11 -  Call GetItemData(nCages[nCurrCage], sBett, nTmp, nFlags)
.head 11 +  If nFlags & ITEM_IsExpanded
.head 12 -  Set nAffected = nAffected+1
.head 12 -  Call SalArraySetUpperBound(sSrcRacks, nAffected, 0)
.head 12 -  Call SalArraySetUpperBound(sSrcCages, nAffected, 0)
.head 12 -  Set sSrcRacks[nAffected-1] = sRack
.head 12 -  Set sSrcCages[nAffected-1] = sCage
.head 10 -  Set nCurrCage = nCurrCage+1
.head 8 -  Set nCurrRack = nCurrRack+1
.head 7 +  If NOT nAffected
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  ! take Virt cages
.head 8 -  Call SalArraySetUpperBound(sTargetCages, nAffected, 0)
.head 8 -  Set nAffectedV = 0
.head 8 -  Call GalConnect(hSqlV)
.head 8 -  Call SqlPrepareAndExecute(hSqlV, "select g.gruppe_key from gruppe g
where g.stat_key =:sVirtRack
and not exists (
select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew
where
   bew.stat_key = g.stat_key
   and bew.gruppe_key =  g.gruppe_key
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <= @NOW
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >@NOW
   and	bew.EINRICHT_ID = 1)
and not exists
(select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew
where
   bew.STAT_KEY = g.stat_key
   and bew.gruppe_key=g.gruppe_key
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit > @NOW
   and	bew.EINRICHT_ID = 1)
and not exists
(select bew.GRUPPE_KEY
  from BETT_LOCKS bew, FALL f,FALL_EXPERIMENT f1
  where bew.STAT_KEY= g.stat_key
     and bew.gruppe_key = g.gruppe_key
     and bew.EINRICHT_ID=1
     and bew.EINRICHT_ID=f.EINRICHT_ID
     and bew.PLANBEW_FALL=f.FALL_KEY
     and f1.FALL_KEY=f.FALL_KEY
     and f1.EINRICHT_ID=f.EINRICHT_ID
     and @NOW < @NULLVALUE(bew.bis, 12-31-2199))
group by 1
into :sTargetCages[nAffectedV]")
.head 8 +  While SqlFetchNext(hSqlV, nTmp) and (nAffectedV<nAffected)
.head 9 -  Set nAffectedV = nAffectedV+1
.head 8 -  Call SqlDisconnect(hSqlV)
.head 8 +  If nAffected != nAffectedV
.head 9 -  Set bOk = FALSE
.head 8 +  If bOk and bMakeAction
.head 9 -  Set nTmp = 0
.head 9 -  Set sRack = frmKHE2DView.cRack2DLayoutManager.sRack
.head 9 -  Set sCage = "" ! now it for real rack refreshing
.head 9 -  Set sBett = "" ! now it for virtual rack refreshing
.head 9 -  Call LT_OpenTransaction(5,dtDT)
.head 9 +  While nTmp<nAffected
.head 10 -  Call MoveCage(sScr, sSrcRacks[nTmp], sSrcCages[nTmp], sScr, sVirtRack, sTargetCages[nTmp], dtDT)
.head 10 +  If NOT nEntire
.head 11 -  Set nCurrRack = nRacks[0]
.head 10 +  Else
.head 11 -  Set nCurrRack = SearchFrom(nStartHandle, sSrcRacks[nTmp])
.head 10 -  Set nCurrCage = SearchFrom(nCurrRack, sSrcCages[nTmp])
.head 10 -  Set hOpenCage = OpenGruppe(sScr, sVirtRack, sTargetCages[nTmp], TRUE, 0)
.head 10 -  Set hCageInVirt = hOpenCage 
.head 10 +  ! If hWnd_POC
.head 11 -  ! Call frmPOC.MoveHandle(nCurrCage, hOpenCage)
.head 10 +  If hWnd_POC
.head 11 -  Call frmPOC.CloseCageFromKHE( sScr, sSrcRacks[nTmp], sSrcCages[nTmp] )
.head 10 -  Call CloseGruppe(sScr, sSrcRacks[nTmp], sSrcCages[nTmp])
.head 10 -  Call KHE_RefreshGruppe(hOpenCage)
.head 10 -  Set nIndex = GetItemIndex( hOpenCage )
.head 10 -  Call SalListSetSelect( hWndItem, nIndex )
.head 10 -  Call ActivateSelectedItem(  )     
.head 10 +  If sSrcRacks[nTmp] = sRack
.head 11 -  Set sCage = sCage||sSrcCages[nTmp]||","
.head 10 -  Set sBett = sBett||sTargetCages[nTmp]||","
.head 10 -  Set nTmp = nTmp+1
.head 9 -  Call LT_CloseLastTransaction()
.head 9 -  Set sCage = SalStrLeftX(sCage, SalStrLength(sCage)-1)
.head 9 -  Set sBett = SalStrLeftX(sBett, SalStrLength(sBett)-1)
.head 9 -  Set dtDT = GetTime4Refresh(  )
.head 9 -  Call SalDateToStr( dtDT, sRefreshDate )
.head 9 +  If SalIsWindowVisible( hWndRack2DView )
.head 10 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 10 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sCage ))
.head 9 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 10 -  Call SalSendMsg( hWndRack2DViewVirt, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 10 -  Call SalSendMsg(hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sBett ))
.head 10 -  Call SalSendMsg(hWndRack2DViewVirt, AM_VirtR2D, 0 ,0)
.head 7 -  Call SalArraySetUpperBound(sSrcRacks,-1,0)
.head 7 -  Call SalArraySetUpperBound(sSrcCages,-1,0)
.head 7 +  If NOT bMakeAction
.head 8 +  If SalIsWindowVisible( hWndRack2DViewVirt ) 
.head 9 +  If nEntire
.head 10 -  Call SalSendMsg(hWndRack2DViewVirt, AM_VirtR2D, bOk,0)
.head 9 +  Else
.head 10 -  Call SalSendMsg(hWndRack2DViewVirt, AM_VirtR2D, TempIsPossible(0,1) ,0)
.head 7 -  Return bOk
.head 5 +  Function: KHE_RefreshAllCages
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nAbt
.head 7 -  Number: nStat
.head 7 -  Number: nCage
.head 7 -  Number: hAbt[*]
.head 7 -  Number: hStat[*]
.head 7 -  Number: hCage[*]
.head 7 -  Number: iAbt
.head 7 -  Number: iStat
.head 7 -  Number: iCage
.head 6 +  Actions
.head 7 -  Set nAbt = EnumChildren( hRoot, hAbt)
.head 7 -  Set iAbt = 0
.head 7 +  While iAbt< nAbt
.head 8 -  Set nStat = EnumChildren( hAbt[iAbt], hStat)
.head 8 -  Set iStat = 0
.head 8 +  While iStat < nStat
.head 9 -  Set nCage = EnumChildren( hStat[iStat], hCage)
.head 9 -  Set iCage = 0
.head 9 +  While iCage < nCage
.head 10 -  Call SalListSetSelect( hWndItem, GetItemIndex( hCage[iCage] ) )
.head 10 -  Call KHE_RefreshGruppe( hCage[iCage] )
.head 10 -  Set iCage = iCage + 1
.head 9 -  Set iStat = iStat + 1
.head 8 -  Set iAbt = iAbt + 1
.head 7 -  Call SalListSetSelect( hWndItem, 0 )
.head 7 -  Set nSelectedItem  = KHEL_Abteilung
.head 7 -  Set nSelectedHandle = hRoot
.head 7 -  Set nSelectedLevel  = KHEL_Einrichtung
.head 7 -  Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )
.head 5 +  Function: SetMassLicense
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: npFall[*]
.head 7 -  String: sAbtKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sLicenseKey
.head 7 -  String: sLicenseRecord 
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 7 -  String: sBackMsg
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nF
.head 7 -  Sql Handle: hSqlE
.head 6 +  Actions
.head 7 -  Call SalArrayGetUpperBound ( npFall, 1, nBound ) 
.head 7 +  If nBound = 0 and npFall[0] = 0 
.head 8 -  Return FALSE
.head 7 -  Call GalConnect(hSqlE)
.head 7 -  Call SqlPrepareAndExecute(hSqlE,"select f.fall_key from EXP_SPECIES s, fall f, fall_experiment e
			where f.fall_key=:npFall[0] and f.fall_key=e.fall_key
			and e.experiment_key=s.experiment_key and end_date is null
			and s.ABT_KEY=:sAbtKey into :nF")
.head 7 +  If SqlFetchNext(hSqlE, nFetch)
.head 8 -  Call SqlDisconnect(hSqlE)
.head 8 -  Return TRUE
.head 7 -  Call SqlDisconnect(hSqlE)
.head 7 +  If not bPlanningMode and Not Request_License( sLicenseKey, sLicenseRecord, sAbtKey )
.head 8 -  Return FALSE
.head 7 -  Set i=0
.head 7 +  While i <= nBound
.head 8 +  If npFall[i]  > 0
.head 9 -  If License_AddCaseMsg( sLicenseKey, sLicenseRecord, npFall[i], '', sBackMsg )
.head 8 -  Set i = i + 1
.head 7 -  Return TRUE
.head 5 +  Function: MoveVirtAndMaiting
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bMakeAction
.head 7 -  Number: nEntire
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFall[*]
.head 7 -  Number: nFallCount
.head 7 -  Number: nI
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: nHandleVirt
.head 6 +  Actions
.head 7 -  Call GetPosition(nSelectedHandle, sScr, sRack, sCage, sBett)
.head 7 -  Set bOk=TRUE
.head 7 -  Set nI=0
.head 7 -  Call SalArraySetUpperBound( nFall, 1, -1 )
.head 7 -  Call SalArrayGetUpperBound( HandleToPlace, 1, nFallCount )
.head 7 +  While nI<=nFallCount
.head 8 -  Set nFall[nI]=HandleToPlace[nI,0]
.head 8 -  Set nI=nI+1
.head 7 -  Set bOk= bOk and TempIsPossible(bMakeAction, nEntire)
.head 7 +  If bOk
.head 8 -  Set nHandleVirt = GetParent( nSelectedHandle )
.head 8 -  Call SalArrayGetUpperBound( HandleToPlace, 1, nI )
.head 8 +  If HandleToPlace[0,0]=0
.head 9 -  Set nI=0
.head 9 +  While nI<=nFallCount
.head 10 -  Set nSelectedHandle = SearchFrom(nHandleVirt , SalNumberToStrX(nFall[nI] , 0 ) )
.head 10 -  Call MultiSelect(  )
.head 10 -  Set nI=nI+1
.head 8 -  Call OpenGruppe( sScr, sRack, sCage, FALSE, 0 )
.head 8 -  Call Paste( TRUE )
.head 7 -  Return bOk
.head 5 +  Function: AddWonBettX
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Date/Time: dtGetTime
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  ! String: sBettLabel
.head 7 -  Sql Handle: hSql
.head 7 -  String: sSqlBtt
.head 7 -  Number: nFetch
.head 7 -  Number: hBett
.head 7 -  ! Number: hGruppe
.head 7 -  ! Number: nIndex
.head 7 -  Boolean: bOk
.head 7 -  ! Number: hAbt
.head 7 -  Number: nBettKey
.head 7 -  Number: nCageID
.head 6 +  Actions
.head 7 -  ! Call GetPosition( nSelectedHandle, sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 7 +  If not sGrpKey
.head 8 -  Return sGrpKey
.head 7 -  ! Set hAbt=SearchFrom( hRoot, sAbtKey )
.head 7 -  ! Set hGruppe=SearchFrom( hAbt, sGrpKey )
.head 7 +  If Not GalConnect( hSql)
.head 8 -  Return ''
.head 7 -  ! Call SalStatusSetText( hWndForm, ' ' )
.head 7 +  If not dtGetTime
.head 8 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set sBettKey = "" 
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "select id from gruppe where einricht_id=:nEinrichtId and   STAT_KEY = :sStatKey and GRUPPE_KEY = :sGrpKey   into :nCageID  " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 7 -  ! Set sSqlBtt = "
select	 b.BETT_KEY
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	b.BETT_KEY not in ( select bew.BETT_KEY
				from 	 BETT b, BEWEGUNG bew, FALL f
  				   where         b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   					and	b.STAT_KEY = '"||sStatKey||"'
   					and	b.GRUPPE_KEY = '"||sGrpKey||"'
   					and 	b.CANCELED = 'N'
   					and	bew.STAT_KEY = b.STAT_KEY

  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					and 		bew.BETT_KEY=b.BETT_KEY
   					
   					and	    bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J')

into	 :sBettKey "


.head 7 +  If bPlanningMode
.head 8 -  ! Set sSqlBtt = "
select	 @VALUE( b.BETT_KEY)
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY
					and 	bew.EINRICHT_ID=b.EINRICHT_ID
  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					 and 	bew.BETT_KEY=b.BETT_KEY
   					
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
   and	not  exists ( select bl.BETT_KEY
				from 	 BETT_LOCKS bl
  				   where         bl.EINRICHT_ID =b.EINRICHT_ID
   					and	bl.STAT_KEY = b.STAT_KEY
   					and	bl.GRUPPE_KEY = b.GRUPPE_KEY
					and 		bl.BETT_KEY=b.BETT_KEY
   					and       bl.VON <=:dtGetTime
   					and       (bl.bis>:dtGetTime or bl.bis is null  ))
					
order by 1
into	 :nBettKey "


.head 8 -  Set sSqlBtt = "
select	 @VALUE( b.BETT_KEY)
from 	BETT b
where       b.cage_id = :nCageID
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY
					and 	bew.pos_id=b.id
   				 	and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	f.Fall_KEY = bew.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
  and      not exists  ( select bl.pos_id from bett_locks bl
					where bl.pos_id=b.id
						and 	bl.VON <=:dtGetTime
   					and       (bl.bis>@now or bl.bis is null  )
)
		
order by 1
into	 :nBettKey "


.head 7 +  Else
.head 8 -  ! Set sSqlBtt = "
select	 min(@VALUE( b.BETT_KEY))
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY
					and 	bew.EINRICHT_ID=b.EINRICHT_ID
  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					 and 	bew.BETT_KEY=b.BETT_KEY
   					
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
 and	not  exists ( select bl.BETT_KEY
				from 	 BETT_LOCKS bl
  				   where         bl.EINRICHT_ID =b.EINRICHT_ID
   					and	bl.STAT_KEY = b.STAT_KEY
   					and	bl.GRUPPE_KEY = b.GRUPPE_KEY
					and 	bl.BETT_KEY=b.BETT_KEY)

into	 :nBettKey "


.head 8 -  ! Set sSqlBtt = "
select	 min(@VALUE( b.BETT_KEY))
from 	BETT b
where	b.CAGE_ID =:nCageID
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where    bew.POS_ID=b.ID
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	f.Fall_KEY = bew.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
 and	not  exists ( select bl.POS_ID
				from 	 BETT_LOCKS bl
  				   where         bl.POS_ID=b.ID )

into	 :nBettKey "


.head 8 -  Set sSqlBtt = "select	  
	min(b.BETT_KEY)
from 	
	sysadm.BETT b left join sysadm.fall f on f.last_cage_id = b.cage_id and f.pos_id = b.id and f.geloescht = 'N' and f.ee_datum is null
where	
	b.CAGE_ID =:nCageID
 	and 	b.CANCELED = 'N'
	and f.fall_key is null

into	 :nBettKey "


.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, sSqlBtt )
.head 7 +  While bOk and SqlFetchNext( hSql, nFetch )
.head 8 -  ! Set hBett = KHEAddChild( hGruppe, hPicFolderFree, sBettLabel  , 0 )
.head 8 -  Break
.head 7 -  ! Call AddStrBett(hGruppe)
.head 7 -  ! Set nSelectedHandle = hBett
.head 7 -  Call SqlDisconnect( hSql )
.head 7 +  If nBettKey>0 and nBettKey != NUMBER_Null
.head 8 -  Set sBettKey = SalNumberToStrX( nBettKey, 0 )
.head 7 -  ! Call SalStatusSetText( hWndForm, '' )
.head 7 -  ! Call PopulateAndExpand( hGruppe, TRUE)
.head 7 -  Return sBettKey
.head 5 +  Function: MoveFemaleAfterPL
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npFall
.head 7 -  Boolean: bStop
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRet
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bPaste
.head 7 -  Boolean: bNeedPrintForSmartLabel
.head 7 -  Number: hAbt
.head 7 -  Number: hFall
.head 7 -  Number: hCage
.head 7 -  FunctionalVar: oPosInfo
.head 8 -  Class: cPositionData
.head 7 -  Sql Handle: hSqlFall
.head 7 -  Number: nFetch
.head 7 -  Number: nNewCageID
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sState
.head 7 -  Date/Time: dtTime
.head 7 -  Number: nCountFemale
.head 7 -  Number: nIndex
.head 7 -  String: sSex
.head 7 -  Number: hNowCage
.head 7 -  Boolean: bPrintAfterMove_Save
.head 7 -  Boolean: bAutoPrint_Save
.head 7 -  ! !
.head 7 -  FunctionalVar: cCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDistinct
.head 8 -  Class: clsLocationCage
.head 7 -  ! Number: hRakc
.head 7 -  ! Number: nChildA
.head 7 -  ! Number: nChildR
.head 7 -  ! Number: nChildC
.head 7 -  ! Number: i
.head 7 -  ! Number: j
.head 7 -  ! Number: k
.head 7 -  ! String: sAbt
.head 7 -  ! String: sBett
.head 7 -  ! Number: nScrID
.head 7 -  ! Number: nRackID
.head 7 -  ! Number: nCageID
.head 7 -  ! Number: nBettID
.head 7 -  ! Number: hChildrenA[*]
.head 7 -  ! Number: hChildrenR[*]
.head 7 -  ! Number: hChildrenC[*]
.head 7 -  ! Number: nCountOpenCages
.head 7 -  ! Boolean: bCollector
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set nRet = 1
.head 7 +  ! If FALSE
.head 8 -  Set hRakc = GetParent( hCage )
.head 8 -  Set nChildR = EnumChildren (hAbt, hChildrenR)
.head 7 -  Set bPaste = FALSE
.head 7 -  Set hFall = SearchFrom( hRoot,  SalNumberToStrX( npFall, 0 ) )
.head 7 +  If hFall = NUMBER_Null or hFall= 0
.head 8 -  Call OpenBettByFallKey( npFall, bAutoScan)
.head 8 -  Set hFall = SearchFrom( hRoot,  SalNumberToStrX( npFall, 0 ) )
.head 7 -  Set hCage = GetParent( hFall )
.head 7 -  Set hAbt = GetParent( GetParent( hCage ) )
.head 7 -  Call _GetPositionID( hCage, oPosInfo )
.head 7 -  Set bNeedPrintForSmartLabel = GalGetProfileBooleanX("SmartLabels","PrintForCollectionCages",TRUE,ATLANTA_INI) and GetBuildParameterB("IncludingSmartLables")  and bUseSmartLabels
.head 7 -  Set dtTime = GetTime4Refresh(  )
.head 7 -  ! Check count open cages
.head 7 +  ! If not bStop
.head 8 -  Set i=0
.head 8 -  Set nCountOpenCages =0
.head 8 +  While i <= nChildA
.head 9 -  Set j = 0
.head 9 -  Set nChildR = EnumChildren (hChildrenA[i], hChildrenR)
.head 9 -  Set nCountOpenCages = nCountOpenCages + nChildR
.head 9 -  Set i = i + 1
.head 8 +  If nCountOpenCages > 2
.head 9 -  Call GalMessageBox( "Warning", "Too many open cages .", MB_Ok )
.head 9 -  Set bOk = FALSE
.head 7 -  ! Call GetPositionID( hCage, nScrID, nRackID, nCageID, nBettID )
.head 7 -  !
.head 7 +  ! If FALSE
.head 8 -  Set nCountFemale = 0
.head 8 -  Set i = 0
.head 7 +  If GalConnect(hSqlFall )
.head 8 +  ! If FALSE
.head 9 +  While bOk and i < nChildR
.head 10 -  Set j = 0
.head 10 -  Set nChildC = EnumChildren (hChildrenR[i], hChildrenC)
.head 10 +  While j < nChildC
.head 11 +  If hChildrenC[j] != hCage
.head 12 -  Set hNowCage = hChildrenC[j]
.head 11 +  If hNowCage
.head 12 -  Call GetPosition( hNowCage, sAbt, sRakc, sCage, sBett )
.head 12 -  Call GetPositionID( hNowCage, nScrID, nRackID, nCageID, nBettID )
.head 12 +  If not CageIsEmpty( sRakc, sCage, dtTime, TRUE )
.head 13 -  Set bPaste = TRUE
.head 13 -  Break 
.head 12 +  If not bStop
.head 13 +  If CheckCageIsCollector(nCageID,dtTime  )
.head 14 -  Set bPaste = TRUE
.head 14 -  Break 
.head 12 +  Else 
.head 13 +  If CheckCageIsStock( nCageID,dtTime , sSex )
.head 14 +  If sSex = 'W'
.head 15 -  Set bPaste = TRUE
.head 15 -  Break 
.head 12 -  Set hNowCage = hWndNULL
.head 11 -  Set j = j + 1
.head 11 -  ! Set nChildC = EnumChildren(hChildrenR[j],hChildrenC)
.head 11 -  ! Set k = 0
.head 11 +  ! While k < nChildC
.head 12 -  Set k = k + 1
.head 10 +  If hNowCage
.head 11 -  Break 
.head 10 -  Set i = i + 1
.head 9 +  If not hNowCage
.head 10 -  Call GetPositionID( hCage, nScrID, nRackID, nCageID, nBettID )
.head 10 -  Set bOk = bOk and  SqlPrepareAndExecute(hSqlFall, "select count(b.fall_key)
 from sysadm.bewegung b
, sysadm.Fall f 
 where       b.cage_id=:nCageID and b.geloescht='N'
    and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
    and       b.bew_zeit <= :dtTime
    and       @nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtTime
    and	f.EINRICHT_ID = b.EINRICHT_ID 
    and	f.FALL_KEY = b.FALL_KEY
    and	f.GESCHL = 'W'
into :nCountFemale ")
.head 10 -  Set bOk = bOk and  SqlFetchNext( hSqlFall, nFetch)
.head 10 +  If nCountFemale > 1
.head 11 -  Set bPaste = FALSE
.head 11 -  Call GalMessageBox( "Warning", "Please don't mix plugged and unplugged females!", MB_Ok )
.head 11 -  Set nRet = 2
.head 8 -  Set bOk = SqlPrepareAndExecute(hSqlFall,"select t.id, g.stat_key, g.gruppe_key, @if(@nullvalue(f.fall_key,0),'F','E'), @if(g.rack_id-:oPosInfo.nRackID,1,0)
 from t_cage t left join gruppe g on (g.id=t.id)
 join station s on (s.id=g.rack_id)
 join abt_stat a on (a.rack_id=s.id and a.scr_id=:oPosInfo.nScreenID)
 left join fall f on(f.last_cage_id=t.id and f.geloescht='N' and ee_datum is null )
where t.id != :oPosInfo.nCageID
 
order by 4 	desc,5,2,3
into :nNewCageID ,:sRack, :sCage, :sState ")
.head 8 -  Set nNewCageID = -100
.head 8 +  While bOk and SqlFetchNext(hSqlFall, nFetch )
.head 9 +  If sState = "F"
.head 10 +  If not bStop
.head 11 +  If CheckCageIsCollector(nNewCageID,dtTime  )
.head 12 -  Set bPaste = TRUE
.head 12 -  Break
.head 10 +  Else
.head 11 +  If CheckCageIsStock( nNewCageID,dtTime , sSex )
.head 12 +  If sSex = 'W'
.head 13 -  Set bPaste = TRUE
.head 13 -  Break
.head 9 +  Else If sState='E'
.head 10 -  Set bPaste = TRUE
.head 10 -  Break
.head 9 -  Set nNewCageID = -100
.head 8 +  If nNewCageID = -100
.head 9 -  Set bOk = bOk and  SqlPrepareAndExecute(hSqlFall, "select count(b.fall_key)
 from sysadm.bewegung b
, sysadm.Fall f 
 where       b.cage_id=:oPosInfo.nCageID and b.geloescht='N'
    and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
    and       b.bew_zeit <= :dtTime
    and       @nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtTime
    and	f.EINRICHT_ID = b.EINRICHT_ID 
    and	f.FALL_KEY = b.FALL_KEY
    and	f.GESCHL = 'W'
into :nCountFemale ")
.head 9 -  Set bOk = bOk and  SqlFetchNext( hSqlFall, nFetch)
.head 9 +  If nCountFemale > 1
.head 10 -  Set bPaste = FALSE
.head 10 -  Call GalMessageBox( "Warning", "Please don't mix plugged and unplugged females!", MB_Ok )
.head 10 -  Set nRet = 2
.head 8 +  Else
.head 9 -  Set hNowCage = FindChild( FindChild (hAbt,sRack), sCage )
.head 8 -  Call SqlDisconnect(hSqlFall)
.head 7 +  ! If not hNowCage 
.head 8 -  Set nChildC = EnumChildren (hCage, hChildrenC)
.head 8 +  If not bStop
.head 9 -  Set i = 0
.head 9 -  Set j = 0
.head 9 +  While i<=nChildC
.head 10 +  If not BettIsSummaryX( hChildrenC[i] ) and GetFallKey_ByHandle( hChildrenC[i]  ) != 0
.head 11 -  Set j = j +1
.head 11 +  If GetSex_ByHandle( hChildrenC[i]  )  = 0
.head 12 -  Set nCountFemale = nCountFemale +1
.head 10 -  Set i = i +1
.head 9 +  If nCountFemale != j
.head 10 -  Call GalMessageBox( "Warning", "No cage opened .", MB_Ok )
.head 10 -  Set bOk = FALSE
.head 9 +  Else 
.head 10 -  Set bPaste = FALSE
.head 9 +  ! Else If j=1
.head 10 -  Set bPaste = FALSE
.head 8 +  Else 
.head 9 -  Set bPaste = FALSE
.head 8 -  ! Return FALSE
.head 7 +  ! If bOk and bPaste
.head 8 -  Call GetPosition( hNowCage, sAbt, sRakc, sCage, sBett )
.head 8 -  Set dtTime = GetTime4Refresh(  )
.head 8 +  If CageIsEmpty( sRakc, sCage, dtTime, TRUE )
.head 9 -  Call GalConnect(  hSqlFall)
.head 9 -  Call SqlPrepareAndExecute( hSqlFall, "
select	bew.FALL_KEY
from 	 sysadm.BEWEGUNG bew, sysadm.FALL f
where
         bew.STAT_KEY =  '" || sRakc || "'
   and       bew.GRUPPE_KEY = '" || sCage || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtTime
   and	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.EINRICHT_ID = bew.EINRICHT_ID 
   and	f.FALL_KEY = bew.FALL_KEY
   and	f.GESCHL = 'M'
" )
.head 9 +  If SqlFetchNext( hSqlFall, nFetch ) or QuantityOfEmptyBett( hNowCage ) = 0
.head 10 -  ! Call SqlDisconnect( hSqlFall )
.head 10 +  If not bStop
.head 11 -  Call GalMessageBox( "Warning", "There is no free bett in cage.", MB_Ok )
.head 10 -  Set bOk = FALSE
.head 10 -  ! Return FALSE
.head 9 +  If bOk
.head 10 -  ! Call SqlExists("
select rf.fall_key
   from sysadm.bewegung bew, sysadm.relship_fall rf left join sysadm.litter l on ((l.place_relship_id=rf.relship_id and @nullvalue(l.miss,0) = 0) )
			 left join sysadm.litter_child lc on(lc.litter_id=l.litter_id  ) ,
   sysadm.FALL f    
  where  bew.STAT_KEY =  '" || sRakc || "'
   and       bew.GRUPPE_KEY = '" || sCage || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtTime
   and	bew.EINRICHT_ID = :nEinrichtId 
   and	f.EINRICHT_ID = bew.EINRICHT_ID 
   and	f.FALL_KEY = bew.FALL_KEY
   and	f.GESCHL != 'M'
   and 	rf.einricht_id=bew.einricht_id
   and        rf.fall_key = bew.fall_key
   and        rf.fallrolle_key='MATE'
 
  and ( @nullvalue(rf.rs_Fall_valid,@datevalue('2222-12-31'))>=:dtTime	
	or (@nullvalue(lc.dead,0)=0 and lc.fall_key is null)	)
" , bCollector)
.head 10 -  Call SqlExists("
select rf.fall_key
   from sysadm.bewegung bew, sysadm.relship_fall rf left join sysadm.litter l on ((l.place_relship_id=rf.relship_id and @nullvalue(l.miss,0) = 0) )
			 left join sysadm.litter_child lc on(lc.litter_id=l.litter_id  ) ,
   sysadm.FALL f    
  where  bew.STAT_KEY =  '" || sRakc || "'
   and       bew.GRUPPE_KEY = '" || sCage || "'
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtTime
   and	bew.EINRICHT_ID = :nEinrichtId 
   and	f.EINRICHT_ID = bew.EINRICHT_ID 
   and	f.FALL_KEY = bew.FALL_KEY
   and	f.GESCHL != 'M'
   and 	rf.einricht_id=bew.einricht_id
   and        rf.fall_key = bew.fall_key
   and        rf.fallrolle_key='MATE'
 and ((( @Nullvalue(rf.RS_FALL_VALID, 01.01.2500)>:dtTime) 
						
     or rf.plugged is not null
     or exists(select lc.litter_id from litter_child lc, litter l where l.place_relship_id=rf.relship_id and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 and (lc.LITTER_REASON !='MISS' or lc.LITTER_REASON is null) and @NULLVALUE(l.miss, 0) 
= 0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id ) )))

" , bCollector)
.head 10 +  If not bStop 
.head 11 +  If not bCollector
.head 12 -  Call GalMessageBox( "Warning", "Need open collector cage.", MB_Ok )
.head 12 -  Set bOk = FALSE
.head 10 +  Else 
.head 11 +  If bCollector
.head 12 -  Set bOk = FALSE
.head 9 -  Call SqlDisconnect( hSqlFall )
.head 7 +  If not bOk 
.head 8 +  ! If bStop
.head 9 -  Call GalMessageBox( "Warning", "No stock cage found .", MB_Ok )
.head 8 +  ! Else
.head 9 -  Call GalMessageBox( "Warning", "No collector cage found .", MB_Ok )
.head 8 -  Set nRet = 0
.head 8 -  ! Set bOk = FALSE
.head 7 +  If not bStop and bOk
.head 8 -  Call RS_SetFemalePlugged(npFall,dtTime )
.head 7 +  If bOk and bPaste
.head 8 -  Set nIndex = GetItemIndex( hFall )
.head 8 -  Call SalListSetSelect( hWndItem, nIndex )
.head 8 -  Call ActivateSelectedItem(  )     
.head 8 +  If not KHE_IsFallSelected( hFall )
.head 9 -  Call MultiSelect(  )
.head 8 -  Set nIndex = GetItemIndex( hNowCage )
.head 8 -  Call SalListSetSelect( hWndItem, nIndex )
.head 8 -  Call ActivateSelectedItem(  )     
.head 8 +  If Paste( FALSE )
.head 9 -  Call T_SetPrintOnCage( nNewCageID, 1 )
.head 9 -  Set nRet = 1
.head 8 +  Else
.head 9 -  Call GalMessageBox("Warning", "Movement was not performed but service is confirmed. 
Probably manual correction will be required!",  0)
.head 9 -  Set nRet = 2
.head 8 +  If bNeedPrintForSmartLabel
.head 9 -  Set bPrintAfterMove_Save = GalGetProfileBooleanX( "Settings", "PrintCageCardsOnMovement", TRUE, sUserINIFileName )
.head 9 -  Set bAutoPrint_Save=GalGetProfileBooleanX( "KHE", "CageCardAutoPrint", FALSE, sUserINIFileName )
.head 9 -  Call GalSetProfileBoolean( "Settings", "PrintCageCardsOnMovement" , TRUE, sUserINIFileName )
.head 9 -  Call GalSetProfileBoolean(  "KHE", "CageCardAutoPrint", TRUE, sUserINIFileName )
.head 9 -  Call cDistinct.Init( oPosInfo.sScreen, sRack, sCage )
.head 9 -  Set cCage[0] = cDistinct
.head 9 -  Call Move_PrintCageCards( cCage, cDistinct )
.head 9 -  Call GalSetProfileBoolean( "Settings", "PrintCageCardsOnMovement" , bPrintAfterMove_Save, sUserINIFileName )
.head 9 -  Call GalSetProfileBoolean(  "KHE", "CageCardAutoPrint", bAutoPrint_Save, sUserINIFileName )
.head 7 -  Return nRet 
.head 5 +  Function: CanStudMailMateOld
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBound
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  Number: hRack
.head 7 -  Number: hScr
.head 7 -  Number: nCountRack
.head 7 -  Number: nCountCage
.head 7 -  Number: nCountBett
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBett[*]
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nA
.head 7 -  String: sText
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  String: sTEMP
.head 7 -  String: sArray[*,2]
.head 7 -  String: sCages[*,2]
.head 7 -  Number: nCount
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  Date/Time: dtpTime
.head 7 -  Boolean: bExists
.head 7 -  Sql Handle: hSQLBase
.head 7 -  Boolean: bOK
.head 7 -  Number: nFetch
.head 7 -  String: sGeshl
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Number: nFemales
.head 6 +  Actions
.head 7 -  Set bOK=TRUE
.head 7 -  Set bF=FALSE
.head 7 -  Set bM=FALSE
.head 7 +  If nSelectedLevel != KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 -  Call DelNul()
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 7 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 7 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 7 -  Set nCount=0
.head 7 +  If nBound!=0
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 -  Set hRack = GetParent( nSelectedHandle )
.head 7 -  Set hScr = GetParent( hRack )
.head 7 -  Call GetItemData( hScr, sText, nValueLoc, nFlags )
.head 7 -  Set sScr = GetKey_FromLable (sText)
.head 7 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 7 -  Set nCountRack = EnumChildren( hScr, hStat )
.head 7 -  Set dtpTime = GetTime4Refresh(  )
.head 7 +  If not GalConnect( hSQLBase)
.head 8 -  Return FALSE
.head 7 +  If nCountRack
.head 8 -  Set nI=0
.head 8 -  Set nA=0
.head 8 +  Loop
.head 9 +  If nI >= nCountRack
.head 10 -  Break
.head 9 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 9 -  Set nCountCage = EnumChildren( hStat[ nI ], hGrp )
.head 9 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 9 -  Set sRack = GetKey_FromLable (sText)
.head 9 +  If nCountCage
.head 10 -  Set nK=0
.head 10 -  Set sTEMP = ''
.head 10 +  Loop
.head 11 +  If nK >= nCountCage
.head 12 -  Break
.head 11 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 11 -  Set nCountBett = EnumChildren( hGrp[ nK ], hBett )
.head 11 +  If nCountBett
.head 12 -  Call GetItemData( hGrp[ nK ], sText, nValueLoc, nFlags )
.head 12 -  Set sText = GetKey_FromLable (sText)
.head 12 +  If not CageIsEmpty( sRack, sText, dtpTime, FALSE )
.head 13 -  Call SqlDisconnect( hSQLBase )
.head 13 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 13 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 13 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 13 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 13 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 13 -  Return FALSE
.head 12 -  Set sTEMP = sTEMP || "'" || sText || "',"
.head 12 -  Set sCages[nCount,0] = sRack
.head 12 -  Set sCages[nCount,1] = sText
.head 12 -  Set nCount=nCount+1
.head 11 -  Set nK=nK+1
.head 10 +  If sTEMP!= STRING_Null
.head 11 -  Set sArray[nA,1]=SalStrLeftX( sTEMP, SalStrLength( sTEMP )-1)
.head 11 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 11 -  Set sArray[nA,0] = GetKey_FromLable (sText)
.head 11 -  Set nA =nA +1
.head 9 -  Set nI=nI+1
.head 8 -  Set nA=nA-1
.head 8 -  Set nCount=nCount-1
.head 8 -  Set nK=0
.head 8 +  Loop
.head 9 +  If nK>nA
.head 10 -  Break
.head 9 -  Set bOK = bOK and SqlPrepareAndExecute( hSQLBase, "select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.STAT_KEY = '" || sArray[nK,0] || "'
  and       bl.GRUPPE_KEY in ( " || sArray[nK,1] || ")
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis > :dtpTime or bl.bis is null )
 union

select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.PLANBEW_FALL in ( select	bew.FALL_KEY
							from 	 BEWEGUNG bew
						where  bew.STAT_KEY =  '" || sArray[nK,0] || "'
						   and       bew.GRUPPE_KEY  in (" || sArray[nK,1] || ")
						   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
						   and       bew.bew_zeit <=:dtpTime
						   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtpTime
						   and	bew.EINRICHT_ID = :nEinrichtId)
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis > :dtpTime or bl.bis is null  )
  into :sText" )
.head 9 +  If SqlFetchNext( hSQLBase, nFetch )
.head 10 -  Set bOK=FALSE
.head 9 -  Set nK=nK+1
.head 8 -  Set bOK = bOK and SqlPrepare( hSQLBase, "select	 bew.GRUPPE_KEY, g.geschl_key, count(g.geschl_key)
			from 	 BEWEGUNG bew, fall f,geschlecht g
		where
   			      bew.STAT_KEY =  :sCages[nCount,0]
  			 and       bew.GRUPPE_KEY  = :sCages[nCount,1]
  			 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   			and       bew.bew_zeit <= :dtpTime
   			and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
			   and	bew.EINRICHT_ID =  :nEinrichtId
   		and        f.EINRICHT_ID=bew.EINRICHT_ID
 			  and        f.fall_key=bew.fall_key
  		 and       f.GESCHL=g.GESCHL_KEY
		 and f.GELOESCHT = 'N'
                	 and bew.GELOESCHT = 'N'

			group by  bew.gruppe_key, g.geschl_key
                               
order by bew.gruppe_key
into :sGrpKeyTmp , :sGeshl, :nValueLoc" )
.head 8 +  While bOK and nCount>=0    !  and SqlFetchNext( hSQLBase, nFetch )
.head 9 -  Set bOK =bOK and SqlExecute( hSQLBase )
.head 9 -  Call SqlFetchNext( hSQLBase, nFetch )
.head 9 +  If sGeshl='M' and nValueLoc>1
.head 10 -  Set bOK=FALSE
.head 9 -  Call SqlGetResultSetCount( hSQLBase, nFlags )
.head 9 +  If nFlags>1
.head 10 -  Set bOK=FALSE
.head 9 +  If sGeshl='M'
.head 10 -  Set bM=TRUE
.head 9 +  If sGeshl='W'
.head 10 -  Set bF=TRUE
.head 10 -  Set nFemales= nFemales+nValueLoc
.head 9 -  Set nCount = nCount-1
.head 8 -  Set bOK = bOK and bM and bF
.head 8 +  If nFem=1
.head 9 -  Set bOK = bOK and (nFemales>1)
.head 7 -  Call SqlDisconnect( hSQLBase )
.head 7 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 7 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 7 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 7 -  Return bOK
.head 5 +  ! Function: CanStudMailMate
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Number: nFem
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: nBound
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  Number: hRack
.head 7 -  Number: hScr
.head 7 -  Number: nCountRack
.head 7 -  Number: nCountCage
.head 7 -  Number: nCountBett
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBett[*]
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nA
.head 7 -  String: sText
.head 7 -  Number: nValueLoc
.head 7 -  Number: nFlags
.head 7 -  String: sTEMP
.head 7 -  String: sArray[*,2]
.head 7 -  String: sCages[*,2]
.head 7 -  Number: nCount
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  Date/Time: dtpTime
.head 7 -  Boolean: bExists
.head 7 -  Sql Handle: hSQLBase
.head 7 -  Sql Handle: hSQLRoling
.head 7 -  Boolean: bOK
.head 7 -  Number: nFetch
.head 7 -  String: sGeshl
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Number: nFemales
.head 7 -  Number: nMale
.head 7 -  Number: nUnLockCages
.head 7 -  Number: nLock
.head 6 +  Actions 
.head 7 -  Set bOK=TRUE
.head 7 -  Set bF=FALSE
.head 7 -  Set bM=FALSE
.head 7 +  If nSelectedLevel != KHEL_Gruppe
.head 8 -  Return FALSE
.head 7 -  Call DelNul()
.head 7 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 7 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 7 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 7 -  Set nCount=0 
.head 7 +  If nBound!=0
.head 8 -  Return FALSE
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 -  Set hRack = GetParent( nSelectedHandle )
.head 7 -  Set hScr = GetParent( hRack )
.head 7 -  Call GetItemData( hScr, sText, nValueLoc, nFlags )
.head 7 -  Set sScr = GetKey_FromLable (sText)
.head 7 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 7 -  Set nCountRack = EnumChildren( hScr, hStat )
.head 7 -  Set dtpTime = GetTime4Refresh(  )
.head 7 +  If not GalConnect( hSQLBase)
.head 8 -  Return FALSE
.head 7 +  If not GalConnect( hSQLRoling)
.head 8 -  Call SqlDisconnect( hSQLBase )
.head 8 -  Return FALSE
.head 7 -  Set bOK = bOK and SqlPrepare( hSQLRoling, "select rf.fall_key 
  from roling_fall rf join sysadm.bewegung b on (   b.einricht_id = :nEinrichtId and rf.fall_key= b.fall_key
						     and b.stat_key=:sRack  and b.gruppe_key = :sText
						     and @nullvalue(b.GELOESCHT,'N') ='N'
   			     and b.ba_key in ('AE','VE','UE','RE')
     			     and 	b.bew_zeit_bis is null )
 left join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
where rf.status = 0  

union

select b.fall_key
 from sysadm.bewegung b 
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.stat_key=:sRack and b.gruppe_key = :sText
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 7 +  If nCountRack
.head 8 -  Set nI=0
.head 8 -  Set nA=0
.head 8 +  Loop 
.head 9 +  If nI >= nCountRack
.head 10 -  Break 
.head 9 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 9 -  Set nCountCage = EnumChildren( hStat[ nI ], hGrp )
.head 9 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 9 -  Set sRack = GetKey_FromLable (sText)
.head 9 +  If nCountCage
.head 10 -  Set nK=0
.head 10 -  Set sTEMP = ''
.head 10 +  Loop 
.head 11 +  If nK >= nCountCage
.head 12 -  Break 
.head 11 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 11 -  Set nCountBett = EnumChildren( hGrp[ nK ], hBett )
.head 11 +  If nCountBett
.head 12 -  Call GetItemData( hGrp[ nK ], sText, nValueLoc, nFlags )
.head 12 -  Set sText = GetKey_FromLable (sText)
.head 12 +  ! If not CageIsEmpty( sRack, sText, dtpTime, FALSE )
.head 13 -  Call SqlDisconnect( hSQLBase )
.head 13 -  Call SqlDisconnect( hSQLRoling )
.head 13 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 13 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 13 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 13 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 13 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 13 -  Return FALSE
.head 12 +  If CageIsEmpty( sRack, sText, dtpTime, FALSE )
.head 13 +  If SqlExecute( hSQLRoling )
.head 14 +  If not SqlFetchNext( hSQLRoling, nFetch )
.head 15 -  Set sTEMP = sTEMP || "'" || sText || "',"
.head 15 -  Set sCages[nCount,0] = sRack
.head 15 -  Set sCages[nCount,1] = sText
.head 15 -  Set nCount=nCount+1
.head 12 +  ! If SqlExecute( hSQLRoling )
.head 13 +  If SqlFetchNext( hSQLRoling, nFetch )
.head 14 -  Call SqlDisconnect( hSQLBase )
.head 14 -  Call SqlDisconnect( hSQLRoling )
.head 14 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 14 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 14 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 14 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 14 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 14 -  Return FALSE
.head 12 -  ! Set sTEMP = sTEMP || "'" || sText || "',"
.head 12 -  ! Set sCages[nCount,0] = sRack
.head 12 -  ! Set sCages[nCount,1] = sText
.head 12 -  ! Set nCount=nCount+1
.head 11 -  Set nK=nK+1
.head 10 +  If sTEMP!= STRING_Null
.head 11 -  Set sArray[nA,1]=SalStrLeftX( sTEMP, SalStrLength( sTEMP )-1)
.head 11 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 11 -  Set sArray[nA,0] = GetKey_FromLable (sText)
.head 11 -  Set nA =nA +1
.head 9 -  Set nI=nI+1
.head 8 -  Set nA=nA-1
.head 8 -  Set nCount=nCount-1
.head 8 -  Set nK=0
.head 8 -  Set nUnLockCages = nCount
.head 8 +  Loop 
.head 9 +  If nK>nA
.head 10 -  Break 
.head 9 -  ! Set bOK = bOK and SqlPrepareAndExecute( hSQLBase, "select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.STAT_KEY = '" || sArray[nK,0] || "'
  and       bl.GRUPPE_KEY in ( " || sArray[nK,1] || ")
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis > :dtpTime or bl.bis is null )
 union

select	 bl.BETT_KEY
from  BETT_LOCKS bl
where	bl.PLANBEW_FALL in ( select	bew.FALL_KEY
							from 	 BEWEGUNG bew
						where  bew.STAT_KEY =  '" || sArray[nK,0] || "'
						   and       bew.GRUPPE_KEY  in (" || sArray[nK,1] || ")
						   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
						   and       bew.bew_zeit <=:dtpTime
						   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtpTime
						   and	bew.EINRICHT_ID = :nEinrichtId)
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis > :dtpTime or bl.bis is null  )
  into :sText" )
.head 9 -  Set bOK = bOK and SqlPrepareAndExecute( hSQLBase, "select	 coun(bl.GRUPPE_KEY)
from  BETT_LOCKS bl
where	bl.STAT_KEY = '" || sArray[nK,0] || "'
  and       bl.GRUPPE_KEY in ( " || sArray[nK,1] || ")
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis > :dtpTime or bl.bis is null )
 union

select	 count(bl.gruppe_KEY)
from  BETT_LOCKS bl
where	bl.PLANBEW_FALL in ( select	bew.FALL_KEY
							from 	 BEWEGUNG bew
						where  bew.STAT_KEY =  '" || sArray[nK,0] || "'
						   and       bew.GRUPPE_KEY  in (" || sArray[nK,1] || ")
						   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
						   and       bew.bew_zeit <=:dtpTime
						   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >:dtpTime
						   and	bew.EINRICHT_ID = :nEinrichtId)
  and       bl.BL_ART in ( 'AE', 'VE', 'UE', 'RE' )
  and       bl.VON <= :dtpTime
  and       (bl.bis > :dtpTime or bl.bis is null  )
  into :nLock " )
.head 9 +  While SqlFetchNext( hSQLBase, nFetch )
.head 10 -  Set nUnLockCages = nUnLockCages - nLock
.head 10 -  ! Set bOK=FALSE
.head 9 -  Set nK=nK+1
.head 8 +  If nUnLockCages<2
.head 9 -  Set bOK=FALSE
.head 8 -  Set bOK = bOK and SqlPrepare( hSQLBase, "select	 bew.GRUPPE_KEY, g.geschl_key, count(g.geschl_key)
			from 	 BEWEGUNG bew, fall f,geschlecht g
		where
   			      bew.STAT_KEY =  :sCages[nCount,0]
  			 and       bew.GRUPPE_KEY  = :sCages[nCount,1]
  			 and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   			and       bew.bew_zeit <= :dtpTime
   			and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
			   and	bew.EINRICHT_ID =  :nEinrichtId
   		and        f.EINRICHT_ID=bew.EINRICHT_ID
 			  and        f.fall_key=bew.fall_key
  		 and       f.GESCHL=g.GESCHL_KEY
		 and f.GELOESCHT = 'N'
                	 and bew.GELOESCHT = 'N'

			group by  bew.gruppe_key, g.geschl_key
                               
order by bew.gruppe_key
into :sGrpKeyTmp , :sGeshl, :nValueLoc" )
.head 8 +  While bOK and nCount>=0    !  and SqlFetchNext( hSQLBase, nFetch )
.head 9 -  Set bOK =bOK and SqlExecute( hSQLBase )
.head 9 -  Call SqlFetchNext( hSQLBase, nFetch )
.head 9 +  If sGeshl='M' and nValueLoc>1
.head 10 -  Set bOK=FALSE
.head 9 -  Call SqlGetResultSetCount( hSQLBase, nFlags )
.head 9 +  ! If nFlags>1
.head 10 -  Set bOK=FALSE
.head 9 +  If sGeshl='M'
.head 10 -  Set bM=TRUE
.head 10 +  If SqlFetchNext(hSQLBase, nFetch)
.head 11 -  Set bOK = bOK and (nValueLoc <= nFem)
.head 9 +  If sGeshl='W' and nFlags=1
.head 10 -  Set bF=TRUE
.head 10 -  Set nFemales= nFemales+nValueLoc
.head 9 +  ! If bOK and nFlags>1
.head 10 +  If sGeshl='M'
.head 11 -  Set bM=TRUE
.head 10 +  If sGeshl='M' and 
.head 11 -  Set bOK=FALSE
.head 9 -  ! Else If bOK and nFlags=1
.head 9 -  Set nCount = nCount-1
.head 8 -  Set bOK = bOK and bM and bF
.head 8 +  If nFem=1
.head 9 -  Set bOK = bOK and (nFemales>1)
.head 7 -  Call SqlDisconnect( hSQLBase )
.head 7 -  Call SqlDisconnect( hSQLRoling )
.head 7 -  Call SalArraySetUpperBound( sArray, 2, -1 )
.head 7 -  Call SalArraySetUpperBound( sCages, 2, -1 )
.head 7 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hGrp, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hBett, 1, -1 )
.head 7 -  Return bOK
.head 5 +  Function: CanStudMailMate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Number: nFtch
.head 7 -  Number: nCageID
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sStatus
.head 7 -  String: sSex
.head 7 -  Number: nCountS
.head 7 -  Boolean: bStockM
.head 7 -  Boolean: bStockF
.head 7 -  Boolean: bEmptyCages
.head 7 -  Boolean: bMPP
.head 7 -  Number: nPrevCage
.head 7 -  String: sStatusCage
.head 7 -  Boolean: bCheck
.head 7 -  Number: nRow
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Number: nCountAnim
.head 7 -  Number: nCountF
.head 7 -  Number: nCount
.head 6 +  Actions
.head 7 +  If GalConnect(hSqlFind)
.head 8 -  Set bEmptyCages = FALSE
.head 8 -  Set bOk =SqlPrepareAndExecute(hSqlFind,"select count(t.id)
into :nCount
 from "|| sUserName ||".t_cage t
where  not exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null   and f.geloescht='N' )
")
.head 8 +  If bOk 
.head 9 +  If SqlFetchNext(hSqlFind,nFtch )
.head 10 +  If nCount > 0
.head 11 -  Set bEmptyCages = TRUE
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlFind,"select  t.id,  f.last_stat_key, f.last_gruppe_key 

  from  " || sUserName || ".T_Cage t
    join sysadm.fall f on (f.geschl='M' and f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null  and ee_time is null)
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key)
where  rf.fall_key is null
and t.id not in (select t2.id from "|| sUserName ||".T_Cage t2
    join sysadm.fall f2 on (f2.geschl='W' and f2.last_cage_id=t2.id and f2.geloescht='N' and f2.culling_id is null) where t2.id=t.id)
group by 1,2,3
having count(f.fall_key)=1
into :nCageID, :sRack, :sCage" )
.head 8 +  If SqlFetchNext(hSqlFind,nFtch )
.head 9 -  Set bStockM = TRUE
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlFind,"select  t.id,  f.last_stat_key, f.last_gruppe_key,count(f.fall_key)

  from   " || sUserName || ".T_Cage t
    join sysadm.fall f on (f.geschl='W' and f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null)
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key)
where  rf.fall_key is null
and t.id not in (select t2.id from  " || sUserName || ".T_Cage t2
    join sysadm.fall f2 on (f2.last_cage_id=t2.id and f2.geschl='M' and f2.geloescht='N' and f2.culling_id is null) where t2.id=t.id)
and t.id not in (select t3.id
  from " || sUserName || ".T_Cage t3
   join sysadm.fall f on (f.last_cage_id=t3.id and f.geschl='W' and f.geloescht='N' and f.culling_id is null  and ee_time is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and (rf.fallrolle_key='PARENT' or (rf.fallrolle_key = 'MATE' and @nullvalue(rf.rs_fall_valid,@now+365)>=@now)))
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id
	 and fall_key is null
	and dead = 0) or not exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id)))
group by 1,2,3

into :nCageID, :sRack, :sCage,:nCountAnim  " )
.head 8 -  Set nCountF = 0
.head 8 +  While SqlFetchNext(hSqlFind,nFtch )
.head 9 -  Set nCountF = nCountF + nCountAnim
.head 8 +  If nCountF >= 1+nFem
.head 9 -  Set bStockF = TRUE
.head 8 +  ! If SqlFetchNext(hSqlFind,nFtch )
.head 9 -  Set bStockF = TRUE
.head 8 +  If nFem = 1
.head 9 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlFind,"select  t.id,  f.last_stat_key, f.last_gruppe_key, f.geschl , count(f.geschl)  

  from  " || sUserName || ".T_Cage t
join sysadm.fall f on (f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='MATE' and rf.rs_fall_valid is null )
    left join sysadm.roling_fall rl on (rl.status=0 and rl.fall_key=f.fall_key)

where rl.fall_key is null
  and t.id not in (select t.id
  from " || sUserName || ".T_Cage t
   join sysadm.fall f on (f.geschl='W' and f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='PARENT')
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id)))

group by 1,2,3,4
having count(f.fall_key)=1
order by 1,4
into :nCageID, :sRack, :sCage , :sSex, :nCountS " )
.head 9 +  While SqlFetchNext(hSqlFind,nFtch )
.head 10 +  If nPrevCage != nCageID
.head 11 +  If not bMPP
.head 12 -  Set bMPP = bF and bM
.head 11 -  Set nPrevCage = nCageID
.head 11 -  Set bM = FALSE
.head 11 -  Set bF = FALSE
.head 11 -  ! Set nRow=1
.head 11 +  ! If sSex = 'M'
.head 12 -  Set bM = TRUE
.head 11 -  ! Set sStatusCage = ""
.head 11 -  ! Set bCheck = TRUE
.head 10 +  If sSex='M' 
.head 11 -  Set bM = TRUE
.head 10 +  Else
.head 11 -  Set bF = TRUE
.head 9 +  If not bMPP
.head 10 -  Set bMPP = bF and bM
.head 8 -  Call SqlDisconnect(hSqlFind)
.head 7 +  Else
.head 8 -  Set bOk = FALSE
.head 7 -  Set bOk = bOk and ((bStockM and bStockF) or (bStockF and bMPP)) and not bEmptyCages
.head 7 -  Return bOk
.head 5 +  ! Function: StudMailMateOLD
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 -  Returns 
.head 6 +  Parameters 
.head 7 -  Number: nFem
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  Number: hRack
.head 7 -  Number: hScr
.head 7 -  String: sScr
.head 7 -  Number: nCountRack
.head 7 -  Number: nCountCage
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nA
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBett[*]
.head 7 -  String: sTEMP
.head 7 -  String: sText
.head 7 -  String: sArray[*,2]
.head 7 -  Sql Handle: hSQLCon
.head 7 -  Sql Handle: hSQLUnreg
.head 7 -  String: sMale[*,2]  ! 0 - Rack, 1 - Cage
.head 7 -  String: sFeMales[*,3]  ! 0 - FallKey, 1 - Rack , 2- Cages
.head 7 -  Date/Time: dtpTime
.head 7 -  String: sStat_key
.head 7 -  String: sGroup_key
.head 7 -  Number: nFetch
.head 7 -  Number: nFallFemale
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nCountM
.head 7 -  Number: nCountF
.head 7 -  Number: nCountBett
.head 7 -  Number: nValueLoc
.head 7 -  String: sBA_Key
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Boolean: bPrint
.head 7 -  FunctionalVar: cCages[*]
.winattr class
.head 8 -  Class: clsLocation
.end
.head 7 -  FunctionalVar: cSourceCage[*]
.winattr class
.head 8 -  Class: clsLocationCage
.end
.head 7 -  FunctionalVar: cDest
.winattr class
.head 8 -  Class: clsLocationCage
.end
.head 7 -  String: sRack
.head 7 -  Boolean: bStudMassMatingFull
.head 6 +  Actions 
.head 7 +  If bStudMailActive
.head 8 -  Return FALSE
.head 7 +  If not GalConnect( hSQLCon ) or not GalConnect( hSQLUnreg)
.head 8 -  Return FALSE
.head 7 -  Set bStudMailActive=TRUE
.head 7 -  Call SalArraySetUpperBound(cSourceCage,1,-1)
.head 7 -  Call SalArraySetUpperBound(cCages,1,-1)
.head 7 -  ! Call SalArraySetUpperBound(cDest,1,-1)
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 -  Set hRack = GetParent( nSelectedHandle )
.head 7 -  Set hScr = GetParent( hRack )
.head 7 -  ! Call GetItemData( hScr, sText, nValueLoc, nFlags )
.head 7 -  ! Set sScr = GetKey_FromLable (sText)
.head 7 -  Set sScr = sAbtKeySrc
.head 7 -  Set nCountRack = EnumChildren( hScr, hStat )
.head 7 -  Set dtpTime = GetTime4Refresh(  )
.head 7 +  If nCountRack
.head 8 -  Set nI=0
.head 8 -  Call SqlPrepare( hSQLUnreg, " Update GRUPPE
		set RFID='',
		      RF_ABT_KEY=''
		Where Stat_Key=:sStatKeyTmp
		and Gruppe_key=:sGrpKeyTmp")
.head 8 -  Set nA=0
.head 8 +  Loop 
.head 9 +  If nI >= nCountRack
.head 10 -  Break 
.head 9 -  Set nCountCage = EnumChildren( hStat[ nI ], hGrp )
.head 9 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 9 -  Set sRack = GetKey_FromLable (sText)
.head 9 +  If nCountCage
.head 10 -  Set nK=0
.head 10 -  Set sTEMP = ''
.head 10 +  Loop 
.head 11 +  If nK >= nCountCage
.head 12 -  Break 
.head 11 -  Set nCountBett = EnumChildren( hGrp[ nK ], hBett )
.head 11 +  If nCountBett
.head 12 -  Call GetItemData( hGrp[ nK ], sText, nValueLoc, nFlags )
.head 12 -  Set sText = GetKey_FromLable (sText)
.head 12 +  If not CageIsEmpty( sRack, sText, dtpTime, FALSE )
.head 13 -  Set bStudMailActive=FALSE
.head 13 -  Return FALSE
.head 12 -  Set sTEMP = sTEMP || "'" || sText || "',"
.head 11 -  Set nK=nK+1
.head 10 +  If sTEMP!= STRING_Null
.head 11 -  Set sArray[nA,1]=SalStrLeftX( sTEMP, SalStrLength( sTEMP )-1)
.head 11 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 11 -  Set sArray[nA,0] = GetKey_FromLable (sText)
.head 11 -  Set nA =nA +1
.head 9 -  Set nI=nI+1
.head 8 -  Set nA=nA-1
.head 8 -  Set nK=0
.head 8 -  Call SalArraySetUpperBound( sMale,2,-1  )
.head 8 -  Call SalArraySetUpperBound( sFeMales,1,-1  )
.head 8 -  Set nI=0
.head 8 -  Set nK=0
.head 8 +  While nA>=0
.head 9 -  Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key
from 	 BEWEGUNG bew, fall f,geschlecht g
where
         bew.STAT_KEY =  '" || sArray[nA,0] || "'
   and       bew.GRUPPE_KEY  in (" || sArray[nA,1] || ")
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and	bew.EINRICHT_ID =  :nEinrichtId
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL=g.GESCHL_KEY
   and       g.GESCHL_KEY='M'
   and       f.GELOESCHT = 'N'
   and       bew.GELOESCHT = 'N'
   into :sStat_key, :sGroup_key
group by   bew.stat_key,bew.gruppe_key, G.GESCHL_ABR
order by bew.gruppe_key" )
.head 9 -  ! Array for male Racks and Cages
.head 9 +  While SqlFetchNext( hSQLCon, nFetch )
.head 10 -  Set sMale[nI,0]=sStat_key
.head 10 -  Set sMale[nI,1]=sGroup_key
.head 10 -  Set nI=nI+1
.head 9 -  Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key,bew.fall_key
from 	 BEWEGUNG bew, fall f,geschlecht g
where
         bew.STAT_KEY =  '" || sArray[nA,0] || "'
   and       bew.GRUPPE_KEY  in (" || sArray[nA,1] || ")
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and	bew.EINRICHT_ID =  :nEinrichtId
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL=g.GESCHL_KEY
   and       g.GESCHL_KEY='W'
   and       f.GELOESCHT = 'N'
   and       bew.GELOESCHT = 'N'
   into :sStat_key, :sGroup_key,:nFallFemale
order by BEW.STAT_KEY,bew.gruppe_key" )
.head 9 -  ! Array for Females
.head 9 +  While SqlFetchNext( hSQLCon, nFetch )
.head 10 -  Set sFeMales[nK,0]=SalNumberToStrX( nFallFemale, 0)
.head 10 -  Set sFeMales[nK,1]=sStat_key
.head 10 -  Set sFeMales[nK,2]=sGroup_key
.head 10 -  Set nK=nK+1
.head 9 -  Set nA=nA-1
.head 8 -  ! Insert Bewegung
.head 8 -  Set nCountM=nI-1
.head 8 -  Set nCountF=nK-1
.head 8 -  Set nI=0
.head 8 -  Set nK=0
.head 8 -  Set nA=0
.head 8 -  Set sBA_Key = 'UE'
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtpTime, sGrund1, sGrund2 )
.head 9 -  Set bStudMailActive=FALSE
.head 9 -  Return FALSE
.head 8 +  If not bPlanningMode
.head 9 -  Call LT_OpenTransaction( 1, dtpTime )
.head 8 -  Set sStatKeyTmp = sFeMales[0,1]
.head 8 -  Set sGrpKeyTmp = sFeMales[0,2]
.head 8 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 8 -  Set sEventTypeName = "STUD_MATING"
.head 8 +  While nI<=nCountM and nK<=nCountF - nFem
.head 9 -  Set nBewNrF = InsertBewegung(SalStrToNumber(sFeMales[nK,0]), 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sMale[nI,0], sMale[nI,1], AddWonBettX( sScr,
sMale[nI,0], sMale[nI,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Return FALSE
.head 9 -  Call cSourceCage[nK+nA].Init(sScr, sMale[nI,0],sMale[nI,1]  )
.head 9 -  Set cCages[nK+nA] = cSourceCage[nK+nA]
.head 9 +  If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call SqlExecute( hSQLUnreg )
.head 10 -  Set nA=nA+1
.head 10 -  Set cCages[nK+nA] = cDest
.head 10 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 10 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Set nK=nK+1
.head 9 +  If nFem=1
.head 10 -  Set nBewNrF1 = InsertBewegung(SalStrToNumber(sFeMales[nK,0]), 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sMale[nI,0], sMale[nI,1], AddWonBettX( sScr,
sMale[nI,0], sMale[nI,1],dtpTime ),"", "", "", "" )
.head 10 +  If nBewNrF1 <0
.head 11 -  Set sEventTypeName = ""
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bStudMailActive=FALSE
.head 11 -  Return FALSE
.head 10 -  Call cSourceCage[nK+nA].Init(sScr, sMale[nI,0],sMale[nI,1]  )
.head 10 -  Set cCages[nK+nA] = cSourceCage[nK+nA]
.head 10 +  If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 11 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 11 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 11 -  Call SqlExecute( hSQLUnreg )
.head 11 -  Set nA=nA+1
.head 11 -  Set cCages[nK+nA] = cDest
.head 11 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 11 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 11 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 10 -  Set nK=nK+1
.head 9 +  If nFem=1
.head 10 -  Call Transfer_AppendToAll (sBA_Key, SalStrToNumber(sFeMales[nK,0]), nBewNrF )
.head 10 -  Call Transfer_AppendToAll (sBA_Key, SalStrToNumber(sFeMales[nK-1,0]), nBewNrF1 )
.head 9 +  Else 
.head 10 -  Call Transfer_AppendToAll (sBA_Key, SalStrToNumber(sFeMales[nK,0]), nBewNrF )
.head 9 -  Call KHE_RefreshGruppe( SearchFrom(hScr , sMale[nI,1] ) )
.head 9 -  Set nI=nI+1
.head 8 -  Set bStudMassMatingFull = GalGetProfileBooleanX("KHE", "StudMaleMatingFull", FALSE, sUserINIFileName)
.head 8 +  If (nCountF-nK+1)=1 and bStudMassMatingFull
.head 9 -  Set nBewNrF = InsertBewegung(SalStrToNumber(sFeMales[nK,0]), 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sMale[nI-1,0], sMale[nI-1,1], AddWonBettX( sScr,
sMale[nI-1,0], sMale[nI-1,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Return FALSE
.head 9 -  Call cSourceCage[nK+nA].Init(sScr, sMale[nI-1,0],sMale[nI-1,1]  )
.head 9 -  Set cCages[nK+nA] = cSourceCage[nI]
.head 9 +  If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call SqlExecute( hSQLUnreg )
.head 10 -  Set nA=nA+1
.head 10 -  Set cCages[nK+nA] = cDest
.head 10 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 10 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Call KHE_RefreshGruppe( SearchFrom(hScr , sMale[nI-1,1] ) )
.head 8 -  Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 8 +  If not CageIsEmpty( sStatKeyTmp, sGrpKeyTmp, dtpTime, FALSE )
.head 9 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 9 -  Call SqlExecute( hSQLUnreg )
.head 8 -  Call LT_CloseLastTransaction(  )
.head 8 -  Call Rack2DView_RefreshCageContents("")
.head 7 -  Set sEventTypeName = ""
.head 7 -  Call SqlPrepareAndExecute( hSQLUnreg, "commit")
.head 7 -  Call SqlDisconnect( hSQLCon )
.head 7 -  Call SqlDisconnect( hSQLUnreg)
.head 7 -  !
.head 7 -  !
.head 7 -  Call SalArrayGetUpperBound( cCages, 1, nI )
.head 7 -  Set cCages[nI+1]=cDest
.head 7 -  If Requst_ListForCageCard( cCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 7 +  If bPrint and cDest.sCageKey != STRING_Null and cDest.sScreenKey != STRING_Null and cDest.sRackKey != STRING_Null
.head 8 -  Call Formular_CageCard_Print( '', '', frmAtlantaMain.lbKHELeft.GetTime4Refresh() )
.head 7 -  Set bStudMailActive=FALSE
.head 5 +  ! Function: StudMailMate__11
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 -  Returns 
.head 6 +  Parameters 
.head 7 -  Number: nFem
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  Number: hRack
.head 7 -  Number: hScr
.head 7 -  String: sScr
.head 7 -  Number: nCountRack
.head 7 -  Number: nCountCage
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nA
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBett[*]
.head 7 -  String: sTEMP
.head 7 -  String: sText
.head 7 -  String: sArray[*,2]
.head 7 -  Sql Handle: hSQLCon
.head 7 -  Sql Handle: hSQLUnreg
.head 7 -  String: sMale[*,2]  ! 0 - Rack, 1 - Cage
.head 7 -  String: sFeMales[*,3]  ! 0 - FallKey, 1 - Rack , 2- Cages
.head 7 -  Date/Time: dtpTime
.head 7 -  String: sStat_key
.head 7 -  String: sGroup_key
.head 7 -  Number: nFetch
.head 7 -  Number: nFallFemale
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nCountM
.head 7 -  Number: nCountF
.head 7 -  Number: nCountBett
.head 7 -  Number: nValueLoc
.head 7 -  String: sBA_Key
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Boolean: bPrint
.head 7 -  FunctionalVar: cCages[*]
.winattr class
.head 8 -  Class: clsLocation
.end
.head 7 -  FunctionalVar: cSourceCage[*]
.winattr class
.head 8 -  Class: clsLocationCage
.end
.head 7 -  FunctionalVar: cDest
.winattr class
.head 8 -  Class: clsLocationCage
.end
.head 7 -  String: sRack
.head 7 -  Boolean: bStudMassMatingFull
.head 7 -  String: sCageMale
.head 7 -  String: sCageNrAll
.head 7 -  Number: nCageNr
.head 7 -  Number: nFExists
.head 7 -  !
.head 6 +  Actions 
.head 7 +  If bStudMailActive
.head 8 -  Return FALSE
.head 7 +  If not GalConnect( hSQLCon ) or not GalConnect( hSQLUnreg)
.head 8 -  Return FALSE
.head 7 -  Set bStudMailActive=TRUE
.head 7 -  Call SalArraySetUpperBound(cSourceCage,1,-1)
.head 7 -  Call SalArraySetUpperBound(cCages,1,-1)
.head 7 -  ! Call SalArraySetUpperBound(cDest,1,-1)
.head 7 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 7 -  Set hRack = GetParent( nSelectedHandle )
.head 7 -  Set hScr = GetParent( hRack )
.head 7 -  ! Call GetItemData( hScr, sText, nValueLoc, nFlags )
.head 7 -  ! Set sScr = GetKey_FromLable (sText)
.head 7 -  Set sScr = sAbtKeySrc
.head 7 -  Set nCountRack = EnumChildren( hScr, hStat )
.head 7 -  Set dtpTime = GetTime4Refresh(  )
.head 7 +  If nCountRack
.head 8 -  Set nI=0
.head 8 -  Call SqlPrepare( hSQLUnreg, " Update GRUPPE
		set RFID='',
		      RF_ABT_KEY=''
		Where Stat_Key=:sStatKeyTmp
		and Gruppe_key=:sGrpKeyTmp")
.head 8 -  Set nA=0
.head 8 +  Loop 
.head 9 +  If nI >= nCountRack
.head 10 -  Break 
.head 9 -  Set nCountCage = EnumChildren( hStat[ nI ], hGrp )
.head 9 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 9 -  Set sRack = GetKey_FromLable (sText)
.head 9 +  If nCountCage
.head 10 -  Set nK=0
.head 10 -  Set sTEMP = ''
.head 10 +  Loop 
.head 11 +  If nK >= nCountCage
.head 12 -  Break 
.head 11 -  Set nCountBett = EnumChildren( hGrp[ nK ], hBett )
.head 11 +  If nCountBett
.head 12 -  Call GetItemData( hGrp[ nK ], sText, nValueLoc, nFlags )
.head 12 -  Set sCageNrAll = sCageNrAll || SalNumberToStrX(GetCageNR_ByHandle( hGrp[ nK ] ) , 0 ) || ","
.head 12 -  Set sText = GetKey_FromLable (sText)
.head 12 +  If not CageIsEmpty( sRack, sText, dtpTime, FALSE )
.head 13 -  Set bStudMailActive=FALSE
.head 13 -  Return FALSE
.head 12 -  Set sTEMP = sTEMP || "'" || sText || "',"
.head 11 -  Set nK=nK+1
.head 10 +  If sTEMP!= STRING_Null
.head 11 -  Set sArray[nA,1]=SalStrLeftX( sTEMP, SalStrLength( sTEMP )-1)
.head 11 -  Call GetItemData( hStat[ nI ], sText, nValueLoc, nFlags )
.head 11 -  Set sArray[nA,0] = GetKey_FromLable (sText)
.head 11 -  Set nA =nA +1
.head 9 -  Set nI=nI+1
.head 8 -  Set nA=nA-1
.head 8 -  Set nK=0
.head 8 +  If sCageNrAll !=STRING_Null
.head 9 -  Set sCageNrAll =SalStrLeftX( sCageNrAll , SalStrLength( sCageNrAll )-1)
.head 8 -  Call SalArraySetUpperBound( sMale,2,-1  )
.head 8 -  Call SalArraySetUpperBound( sFeMales,1,-1  )
.head 8 -  Set nI=0
.head 8 -  Set nK=0
.head 8 -  ! Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key, bew.CAGE_NR
from 	 BEWEGUNG bew, fall f,geschlecht g
where   bew.CAGE_NR   in (" || sCageNrAll || ")
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and	bew.EINRICHT_ID =  :nEinrichtId
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL=g.GESCHL_KEY
   and       g.GESCHL_KEY='M'
   and       f.GELOESCHT = 'N'
   and       bew.GELOESCHT = 'N'
   into :sStat_key, :sGroup_key, :nCageNr
group by   bew.stat_key,bew.gruppe_key, bew.CAGE_NR
order by bew.gruppe_key" )
.head 8 -  Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key, bew.CAGE_NR
from 	 BEWEGUNG bew, fall f, gruppe g
where       bew.EINRICHT_ID =  :nEinrichtId
   and	bew.CAGE_ID = g.ID
   and       g.uniq_nr in (" || sCageNrAll || ") 
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and       bew.GELOESCHT = 'N'
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL='M'

   and       f.GELOESCHT = 'N'

   into :sStat_key, :sGroup_key, :nCageNr
group by   bew.stat_key,bew.gruppe_key, bew.CAGE_NR
order by bew.gruppe_key" )
.head 8 -  ! Array for male Racks and Cages
.head 8 -  Set sCageMale = ""
.head 8 +  While SqlFetchNext( hSQLCon, nFetch )
.head 9 -  Set sMale[nI,0]=sStat_key
.head 9 -  Set sMale[nI,1]=sGroup_key
.head 9 -  Set sCageMale = sCageMale || SalNumberToStrX( nCageNr, 0 ) || ","
.head 9 -  Set nI=nI+1
.head 8 -  Call SalStrLeft( sCageMale, SalStrLength( sCageMale ) - 1, sCageMale)
.head 8 -  Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key,bew.fall_key
from 	 BEWEGUNG bew, fall f, gruppe g
where       bew.EINRICHT_ID =  :nEinrichtId
   and 	bew.CAGE_ID =  g.ID
    and      g.uniq_nr in (" || sCageNrAll || ")  and g.uniq_nr not in (" || sCageMale || ") 
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and       bew.GELOESCHT = 'N'
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL='W'
   and       f.GELOESCHT = 'N'
   into :sStat_key, :sGroup_key,:nFallFemale
order by BEW.STAT_KEY,bew.gruppe_key" )
.head 8 -  ! Array for Females
.head 8 +  While SqlFetchNext( hSQLCon, nFetch )
.head 9 -  Set sFeMales[nK,0]=SalNumberToStrX( nFallFemale, 0)
.head 9 -  Set sFeMales[nK,1]=sStat_key
.head 9 -  Set sFeMales[nK,2]=sGroup_key
.head 9 -  Set nK=nK+1
.head 8 +  ! While nA>=0
.head 9 -  Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key
from 	 BEWEGUNG bew, fall f,geschlecht g
where
         bew.STAT_KEY =  '" || sArray[nA,0] || "'
   and       bew.GRUPPE_KEY  in (" || sArray[nA,1] || ")
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and	bew.EINRICHT_ID =  :nEinrichtId
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL=g.GESCHL_KEY
   and       g.GESCHL_KEY='M'
   and       f.GELOESCHT = 'N'
   and       bew.GELOESCHT = 'N'
   into :sStat_key, :sGroup_key
group by   bew.stat_key,bew.gruppe_key, G.GESCHL_ABR
order by bew.gruppe_key" )
.head 9 -  ! Array for male Racks and Cages
.head 9 -  Set sCageMale = ""
.head 9 +  While SqlFetchNext( hSQLCon, nFetch )
.head 10 -  Set sMale[nI,0]=sStat_key
.head 10 -  Set sMale[nI,1]=sGroup_key
.head 10 -  Set sCageMale = sCageMale || "'" || sGroup_key || "'" || ", "
.head 10 -  Set nI=nI+1
.head 9 -  Call SalStrLeft( sCageMale, SalStrLength( sCageMale ) - 2, sCageMale)
.head 9 -  Call SqlPrepareAndExecute( hSQLCon, "select	 bew.stat_key, bew.gruppe_key,bew.fall_key
from 	 BEWEGUNG bew, fall f,geschlecht g
where
         bew.STAT_KEY =  '" || sArray[nA,0] || "'
   and       bew.GRUPPE_KEY  in (" || sArray[nA,1] || ")
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and	bew.EINRICHT_ID =  :nEinrichtId
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL=g.GESCHL_KEY
   and       g.GESCHL_KEY='W'
   and       f.GELOESCHT = 'N'
   and       bew.GELOESCHT = 'N'
   and       bew.GRUPPE_KEY  not in (" || sCageMale || ")
   into :sStat_key, :sGroup_key,:nFallFemale
order by BEW.STAT_KEY,bew.gruppe_key" )
.head 9 -  ! Array for Females
.head 9 +  While SqlFetchNext( hSQLCon, nFetch )
.head 10 -  Set sFeMales[nK,0]=SalNumberToStrX( nFallFemale, 0)
.head 10 -  Set sFeMales[nK,1]=sStat_key
.head 10 -  Set sFeMales[nK,2]=sGroup_key
.head 10 -  Set nK=nK+1
.head 9 -  Set nA=nA-1
.head 8 -  ! Insert Bewegung
.head 8 -  Set nCountM=nI-1
.head 8 -  Set nCountF=nK-1
.head 8 -  Set nI=0
.head 8 -  Set nK=0
.head 8 -  Set nA=0
.head 8 -  Set sBA_Key = 'UE'
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtpTime, sGrund1, sGrund2 )
.head 9 -  Set bStudMailActive=FALSE
.head 9 -  Return FALSE
.head 8 +  If not bPlanningMode
.head 9 -  Call LT_OpenTransaction( 1, dtpTime )
.head 8 -  Set sStatKeyTmp = sFeMales[0,1]
.head 8 -  Set sGrpKeyTmp = sFeMales[0,2]
.head 8 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 8 -  Set sEventTypeName = "STUD_MATING"
.head 8 -  Call SqlPrepare( hSQLCon, "select	 count(f.fall_key)
from 	 BEWEGUNG bew, fall f
where       bew.EINRICHT_ID =  :nEinrichtId
   and	bew.abt_key = :sScr
   and 	bew.stat_key = :sMale[nI,0]
   and 	bew.gruppe_key = :sMale[nI,1]
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <= :dtpTime
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtpTime
   and       bew.GELOESCHT = 'N'
   and        f.EINRICHT_ID=bew.EINRICHT_ID
   and        f.fall_key=bew.fall_key
   and       f.GESCHL='W'
   and       f.GELOESCHT = 'N'

   into :nFExists" )
.head 8 +  While nI<=nCountM and nK<=nCountF - nFem
.head 9 -  Set nBewNrF = InsertBewegung(SalStrToNumber(sFeMales[nK,0]), 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sMale[nI,0], sMale[nI,1], AddWonBettX( sScr,
sMale[nI,0], sMale[nI,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Return FALSE
.head 9 -  Call cSourceCage[nK+nA].Init(sScr, sMale[nI,0],sMale[nI,1]  )
.head 9 -  Set cCages[nK+nA] = cSourceCage[nK+nA]
.head 9 +  If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call SqlExecute( hSQLUnreg )
.head 10 -  Set nA=nA+1
.head 10 -  Set cCages[nK+nA] = cDest
.head 10 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 10 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Set nK=nK+1
.head 9 -  Call SqlExecute(hSQLCon)
.head 9 -  Call SqlFetchNext(hSQLCon, nFetch)
.head 9 +  If (nFExists = 1) and (nFem=1)
.head 10 -  Set nBewNrF1 = InsertBewegung(SalStrToNumber(sFeMales[nK,0]), 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sMale[nI,0], sMale[nI,1], AddWonBettX( sScr,
sMale[nI,0], sMale[nI,1],dtpTime ),"", "", "", "" )
.head 10 +  If nBewNrF1 <0
.head 11 -  Set sEventTypeName = ""
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bStudMailActive=FALSE
.head 11 -  Return FALSE
.head 10 -  Call cSourceCage[nK+nA].Init(sScr, sMale[nI,0],sMale[nI,1]  )
.head 10 -  Set cCages[nK+nA] = cSourceCage[nK+nA]
.head 10 +  If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 11 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 11 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 11 -  Call SqlExecute( hSQLUnreg )
.head 11 -  Set nA=nA+1
.head 11 -  Set cCages[nK+nA] = cDest
.head 11 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 11 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 11 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 10 -  Set nK=nK+1
.head 9 +  If nFem=1
.head 10 -  Call Transfer_AppendToAll (sBA_Key, SalStrToNumber(sFeMales[nK,0]), nBewNrF )
.head 10 -  Call Transfer_AppendToAll (sBA_Key, SalStrToNumber(sFeMales[nK-1,0]), nBewNrF1 )
.head 9 +  Else 
.head 10 -  Call Transfer_AppendToAll (sBA_Key, SalStrToNumber(sFeMales[nK,0]), nBewNrF )
.head 9 -  Call KHE_RefreshGruppe( SearchFrom(hScr , sMale[nI,1] ) )
.head 9 -  Set nI=nI+1
.head 8 -  Set bStudMassMatingFull = GalGetProfileBooleanX("KHE", "StudMaleMatingFull", FALSE, sUserINIFileName)
.head 8 +  If (nCountF-nK+1)=1 and bStudMassMatingFull
.head 9 -  Set nBewNrF = InsertBewegung(SalStrToNumber(sFeMales[nK,0]), 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sMale[nI-1,0], sMale[nI-1,1], AddWonBettX( sScr,
sMale[nI-1,0], sMale[nI-1,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Return FALSE
.head 9 -  Call cSourceCage[nK+nA].Init(sScr, sMale[nI-1,0],sMale[nI-1,1]  )
.head 9 -  Set cCages[nK+nA] = cSourceCage[nI]
.head 9 +  If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call SqlExecute( hSQLUnreg )
.head 10 -  Set nA=nA+1
.head 10 -  Set cCages[nK+nA] = cDest
.head 10 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 10 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Call KHE_RefreshGruppe( SearchFrom(hScr , sMale[nI-1,1] ) )
.head 8 -  Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 8 +  If not CageIsEmpty( sStatKeyTmp, sGrpKeyTmp, dtpTime, FALSE )
.head 9 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 9 -  Call SqlExecute( hSQLUnreg )
.head 8 -  Call LT_CloseLastTransaction(  )
.head 8 -  Call Rack2DView_RefreshCageContents("")
.head 7 -  Set sEventTypeName = ""
.head 7 -  Call SqlPrepareAndExecute( hSQLUnreg, "commit")
.head 7 -  Call SqlDisconnect( hSQLCon )
.head 7 -  Call SqlDisconnect( hSQLUnreg)
.head 7 -  !
.head 7 -  !
.head 7 -  Call SalArrayGetUpperBound( cCages, 1, nI )
.head 7 -  Set cCages[nI+1]=cDest
.head 7 -  If Requst_ListForCageCard( cCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 7 +  If bPrint and cDest.sCageKey != STRING_Null and cDest.sScreenKey != STRING_Null and cDest.sRackKey != STRING_Null
.head 8 -  Call Formular_CageCard_Print( '', '', frmAtlantaMain.lbKHELeft.GetTime4Refresh() )
.head 7 -  Set bStudMailActive=FALSE
.head 5 +  Function: StudMailMate
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Sql Handle: hSQLUnreg
.head 7 -  Sql Handle: hSQLCage
.head 7 -  Number: nFetch
.head 7 -  ! Number: nCageID
.head 7 -  ! String: sRack
.head 7 -  ! String: sCage
.head 7 -  ! String: sStatus
.head 7 -  ! String: sSex
.head 7 -  ! Number: nCountS
.head 7 -  ! Boolean: bStockM
.head 7 -  ! Boolean: bStockF
.head 7 -  ! Boolean: bMPP
.head 7 -  ! String: sStatusCage
.head 7 -  ! Boolean: bCheck
.head 7 -  ! Number: nRow
.head 7 -  ! String: sFemale
.head 7 -  Number: nFallKey[*,2]
.head 7 -  Number: nF
.head 7 -  String: sCage[*,3]
.head 7 -  Number: nM
.head 7 -  Number: nCageID
.head 7 -  String: sRack
.head 7 -  String: sGruppe
.head 7 -  String: sPrevRack
.head 7 -  String: sPrevGruppe
.head 7 -  String: sSex
.head 7 -  Number: nCountS
.head 7 -  Number: nPrevCage
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  !
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocation
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Boolean: bStudMailActive
.head 7 -  !
.head 7 -  String: sScr
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  !
.head 7 -  Number: nCountF
.head 7 -  Number: nCountM
.head 7 -  String: sBA_Key
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Date/Time: dtpTime
.head 7 -  !
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrF1
.head 7 -  Boolean: bStudMassMatingFull
.head 7 -  Number: nIndCage
.head 7 -  Number: hScr
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bOk
.head 7 -  Number: nRefrCage[*]
.head 6 +  Actions
.head 7 +  If not CanStudMailMate(nFem)
.head 8 -  Return FALSE
.head 7 +  If bStudMailActive
.head 8 -  Return FALSE
.head 7 +  If GalConnect(hSqlFind) and GalConnect( hSQLUnreg) and GalConnect(hSQLCage)
.head 8 -  Set bStudMailActive=TRUE
.head 8 -  Call SalArraySetUpperBound(cSourceCage,1,-1)
.head 8 -  Call SalArraySetUpperBound(cCages,1,-1)
.head 8 -  Call GetPosition( nSelectedHandle, sScr, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 8 -  Set hScr = GetParent( nSelectedHandle )
.head 8 -  Set hScr = GetParent( hScr )
.head 8 -  ! Set bOk = SqlPrepare(hSQLUnreg, " Update GRUPPE
		set RFID='',
		      RF_ABT_KEY=''
		Where id=:nPrevCage ")
.head 8 -  Set bOk = TRUE
.head 8 -  Set bOk = bOk and SqlPrepare(hSQLCage, " select stat_key, gruppe_key from GRUPPE where id=:nPrevCage 
into :sStatKeyTmp , :sGrpKeyTmp")
.head 8 -  ! Female
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlFind,"select  f.Fall_key, t.ID,t.Port_POC

  from   " || sUserName || ".T_Cage t
 join sysadm.fall f on (f.last_cage_id=t.id and f.geschl='W' and f.geloescht='N' and f.culling_id is null and f.ee_time is null )
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key) 
where  rf.fall_key is null
and t.id not in (select t2.id from  " || sUserName || ".T_Cage t2
    join sysadm.fall f2 on (f2.last_cage_id=t2.id and f2.geschl='M' and f2.geloescht='N' and f2.culling_id is null  and f2.ee_time is null)     where t2.id=t.id )
and t.id not in (select t3.id
  from " || sUserName || ".T_Cage t3
      join sysadm.fall f on (f.last_cage_id=t3.id and f.geschl='W' and f.geloescht='N' and f.culling_id is null  and f.ee_time is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and (rf.fallrolle_key='PARENT' or (rf.fallrolle_key = 'MATE' and @nullvalue(rf.rs_fall_valid,@now+365)>=@now)))
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id)))
order by t.Port_POC, t.ID
into :nFallKey[nF,0], :nFallKey[nF,1] "  )
.head 8 -  Set nF = 0
.head 8 +  While SqlFetchNext(hSqlFind, nFetch)
.head 9 -  Set nF = nF + 1
.head 8 -  ! cage with Male
.head 8 -  Set bOk = SqlPrepareAndExecute(hSqlFind,"select  t.id,  f.last_stat_key, f.last_gruppe_key ,t.Port_POC

  from  " || sUserName || ".T_Cage t
      join sysadm.fall f on (f.last_cage_id=t.id and f.geschl='M' and f.geloescht='N' and f.culling_id is null  and f.ee_time is null )
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key)

where  rf.fall_key is null
and t.id not in (select t2.id from "|| sUserName ||".T_Cage t2
 join sysadm.fall f2 on (f2.last_cage_id=t2.id and f2.geschl='W' and f2.geloescht='N' and f2.culling_id is null  and f2.ee_time is null)  where t2.id=t.id )
group by 1,2,3,4
having count(f.fall_key)=1
order by t.Port_POC, t.ID
into :nCageID, :sCage[nM,0], :sCage[nM,1] " )
.head 8 -  Set nM = 0
.head 8 +  While SqlFetchNext(hSqlFind, nFetch)
.head 9 -  Set nM = nM + 1
.head 8 +  If nFem = 1
.head 9 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlFind,"select t.id,  f.last_stat_key, f.last_gruppe_key, f.geschl , count(f.geschl) ,t.Port_POC

  from  " || sUserName || ".T_Cage t
join sysadm.fall f on (f.last_cage_id=t.id and f.geloescht='N' and f.ee_datum is null )
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='MATE' and rf.rs_fall_valid is null )
    left join sysadm.roling_fall rl on (rl.status=0 and rl.fall_key=f.fall_key)

where rl.fall_key is null
  and t.id not in (select t.id
  from " || sUserName || ".T_Cage t
   join sysadm.fall f on (f.last_cage_id=t.id and f.geschl='W' and f.geloescht='N' and f.ee_datum is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='PARENT')
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id) ) )

group by 1,2,3,4,6
having count(f.fall_key)=1
order by t.Port_POC, t.ID,4

into :nCageID, :sRack, :sGruppe , :sSex, :nCountS " )
.head 9 +  While SqlFetchNext(hSqlFind, nFetch)
.head 10 +  If nPrevCage != nCageID
.head 11 +  If bM and bF
.head 12 -  Set sCage[nM,0] = sPrevRack
.head 12 -  Set sCage[nM,1] = sPrevGruppe
.head 12 -  Set sCage[nM,2] = 'SMP'
.head 12 -  Set nM = nM + 1
.head 11 -  Set nPrevCage = nCageID
.head 11 -  Set sPrevRack = ""
.head 11 -  Set sPrevGruppe= ""
.head 11 -  Set bF = FALSE
.head 11 -  Set bM = FALSE
.head 10 -  Set sPrevRack = sRack
.head 10 -  Set sPrevGruppe= sGruppe
.head 10 +  If sSex = 'M'
.head 11 -  Set bM = TRUE
.head 10 +  Else
.head 11 +  If nCountS = 1
.head 12 -  Set bF = TRUE
.head 9 +  If bM and bF
.head 10 -  Set sCage[nM,0] = sPrevRack
.head 10 -  Set sCage[nM,1] = sPrevGruppe
.head 10 -  Set sCage[nM,2] = 'SMP'
.head 10 -  Set nM = nM + 1
.head 8 -  !
.head 8 -  Set nCountF = nF
.head 8 -  Set nCountM = nM
.head 8 -  Set nF=0
.head 8 -  Set nM=0
.head 8 -  Set sBA_Key = 'UE'
.head 8 -  Set nIndCage = 0
.head 8 -  Set nPrevCage = -100
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtpTime, sGrund1, sGrund2 )
.head 9 -  Set bStudMailActive=FALSE
.head 9 -  Return FALSE
.head 8 +  If not bPlanningMode
.head 9 -  Call LT_OpenTransaction( 1, dtpTime )
.head 9 -  Call LockSysadmAction("Perform studmating...")
.head 8 -  Set sEventTypeName = "STUD_MATING"
.head 8 +  While bOk and nM<nCountM and nF<nCountF-nFem
.head 9 +  If nPrevCage = -100
.head 10 -  Set nPrevCage = nFallKey[nF,1] 
.head 10 +  If SqlExecute( hSQLCage )
.head 11 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Set nBewNrF = InsertBewegung(nFallKey[nF,0], 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sCage[nM,0], sCage[nM,1], AddWonBettX( sScr,
sCage[nM,0], sCage[nM,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <=0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Set sEventTypeName = ""
.head 10 -  Set bOk = FALSE
.head 10 -  ! Return FALSE
.head 9 +  If bOk
.head 10 -  Call cSourceCage[nIndCage].Init(sScr, sCage[nM,0],sCage[nM,1]  )
.head 10 -  Set cCages[nIndCage] = cSourceCage[nIndCage]
.head 10 +  If nPrevCage != nFallKey[nF,1] 
.head 11 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 11 +  If SqlExecute( hSQLCage )
.head 12 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 11 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 11 -  ! Call SqlExecute( hSQLUnreg )
.head 11 -  Set nIndCage=nIndCage+1
.head 11 -  Set cCages[nIndCage] = cDest
.head 11 -  Set nPrevCage = nFallKey[nF,1] 
.head 11 +  If SqlExecute( hSQLCage )
.head 12 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 11 -  ! Set sStatKeyTmp = sFeMales[nK,1]
.head 11 -  ! Set sGrpKeyTmp = sFeMales[nK,2]
.head 11 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 10 -  Set nIndCage=nIndCage+1
.head 9 -  ! Set dtpTime = dtpTime + 1/86400
.head 9 -  ! Call SqlExecute(hSQLCon)
.head 9 -  ! Call SqlFetchNext(hSQLCon, nFetch)
.head 9 +  If bOk and (nFem=1) and (nCountF - nF)>=1 and sCage[nM,2] != 'SMP'
.head 10 -  Set nF=nF+1
.head 10 -  Set nBewNrF1 = InsertBewegung(nFallKey[nF,0], 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sCage[nM,0], sCage[nM,1], AddWonBettX( sScr,
sCage[nM,0], sCage[nM,1],dtpTime ),"", "", "", "" )
.head 10 +  If nBewNrF1 <=0
.head 11 -  Set sEventTypeName = ""
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bStudMailActive=FALSE
.head 11 -  Set sEventTypeName = ""
.head 11 -  Set bOk = FALSE
.head 11 -  ! Return FALSE
.head 10 +  If bOk
.head 11 -  Call cSourceCage[nIndCage].Init(sScr, sCage[nM,0],sCage[nM,1]  )
.head 11 -  Set cCages[nIndCage] = cSourceCage[nIndCage]
.head 11 +  If nPrevCage != nFallKey[nF,1] 
.head 12 +  If SqlExecute( hSQLCage )
.head 13 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 12 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 12 -  ! Call SqlExecute( hSQLUnreg )
.head 12 -  Set nIndCage=nIndCage+1
.head 12 -  Set cCages[nIndCage] = cDest
.head 12 -  Set nPrevCage = nFallKey[nF,1] 
.head 12 +  If SqlExecute( hSQLCage )
.head 13 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 12 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 10 -  ! Set dtpTime = dtpTime + 1/86400
.head 10 -  Set nIndCage=nIndCage+1
.head 9 +  If bOk
.head 10 +  If nFem=1
.head 11 -  Call Transfer_AppendToAll (sBA_Key, nFallKey[nF,0], nBewNrF )
.head 11 +  If sCage[nM,2] != 'SMP'
.head 12 -  Call Transfer_AppendToAll (sBA_Key, nFallKey[nF-1,0], nBewNrF1 )
.head 10 +  Else
.head 11 -  Call Transfer_AppendToAll (sBA_Key, nFallKey[nF,0], nBewNrF )
.head 10 -  Call KHE_RefreshGruppe( SearchFrom(SearchFrom(hScr,sCage[nM,0] ) , sCage[nM,1] ) )
.head 9 -  Set nF=nF+1
.head 9 -  Set nM=nM + 1
.head 8 -  Set bStudMassMatingFull = GalGetProfileBooleanX("KHE", "StudMaleMatingFull", FALSE, sUserINIFileName)
.head 8 +  If bOk and (nCountF-nF+1)=1 and bStudMassMatingFull
.head 9 -  Set nBewNrF = InsertBewegung(nFallKey[nF,0], 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sCage[nM,0], sCage[nM,1], AddWonBettX( sScr,
sCage[nM,0], sCage[nM,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <=0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Set sEventTypeName = ""
.head 10 -  ! Return FALSE
.head 10 -  Set bOk = FALSE
.head 9 +  If bOk 
.head 10 -  Call cSourceCage[nIndCage].Init(sScr, sCage[nM,0],sCage[nM,1]  )
.head 10 -  Set cCages[nIndCage] = cSourceCage[nIndCage]
.head 9 +  ! If not (sStatKeyTmp = sFeMales[nK,1] and sGrpKeyTmp = sFeMales[nK,2])
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call SqlExecute( hSQLUnreg )
.head 10 -  Set nA=nA+1
.head 10 -  Set cCages[nK+nA] = cDest
.head 10 -  Set sStatKeyTmp = sFeMales[nK,1]
.head 10 -  Set sGrpKeyTmp = sFeMales[nK,2]
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 +  If bOk and nPrevCage != nFallKey[nF,1] 
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(hScr , sGrpKeyTmp ) )
.head 10 +  If SqlExecute( hSQLCage )
.head 11 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  ! Call SqlExecute( hSQLUnreg )
.head 10 -  Set nIndCage=nIndCage+1
.head 10 -  Set cCages[nIndCage] = cDest
.head 10 -  Set nPrevCage = nFallKey[nF,1] 
.head 10 +  If SqlExecute( hSQLCage )
.head 11 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 10 -  ! Set sStatKeyTmp = sFeMales[nK,1]
.head 10 -  ! Set sGrpKeyTmp = sFeMales[nK,2]
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 +  If bOk
.head 10 -  Call KHE_RefreshGruppe( SearchFrom(SearchFrom(hScr,sCage[nM,0] ) , sCage[nM,1] ) )
.head 8 -  Set nM = nM - 1 
.head 8 -  Set nF = nF - 1
.head 8 +  If bOk and SqlExecute( hSQLCage )
.head 9 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 8 +  If bOk
.head 9 -  Call KHE_RefreshGruppe(SearchFrom(SearchFrom(hScr,sStatKeyTmp) , sGrpKeyTmp ) )
.head 9 +  If not CageIsEmpty( sStatKeyTmp, sGrpKeyTmp, dtpTime, FALSE )
.head 10 -  Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  ! Call SqlExecute( hSQLUnreg )
.head 8 -  Call LockSysadmAction("...studmating performed")
.head 8 -  Call LT_CloseLastTransaction(  )
.head 8 -  Call Rack2DView_RefreshCageContents("")
.head 8 -  Call SqlDisconnect(hSqlFind)
.head 8 -  Call SqlDisconnect(hSQLUnreg)
.head 8 -  Call SqlDisconnect(hSQLCage)
.head 8 -  ! Call SalArrayGetUpperBound( cCages, 1, nIndCage )
.head 8 -  ! Set cCages[nIndCage+1]=cDest
.head 8 +  If not SalArrayIsEmpty( cSourceCage )
.head 9 -  Call Move_PrintCageCards(cSourceCage,cDest)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 0,0)
.head 8 -  ! If Requst_ListForCageCard( cCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 8 +  ! If bPrint and cDest.sCageKey != STRING_Null and cDest.sScreenKey != STRING_Null and cDest.sRackKey != STRING_Null
.head 9 -  Call Formular_CageCard_Print( '', '', frmAtlantaMain.lbKHELeft.GetTime4Refresh() )
.head 8 -  Set bStudMailActive=FALSE
.head 8 -  Set sEventTypeName = ""
.head 8 -  Return TRUE
.head 5 +  Function: GoToItem
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLevel
.head 7 -  Number: nIndex
.head 6 +  Actions
.head 7 -  Set nLevel = 0
.head 7 +  If sBett
.head 8 -  Set nLevel = 4
.head 7 +  Else If sCage
.head 8 -  Set nLevel = 3
.head 7 +  Else If sStat
.head 8 -  Set nLevel = 2
.head 7 +  Else If sAbt
.head 8 -  Set nLevel = 1
.head 7 +  If nLevel <0 or nLevel > 4
.head 8 -  Set nLevel = 0
.head 7 +  Select Case nLevel
.head 8 +  Case KHEL_Bett
.head 9 -  Call GotoBett( sAbt, sStat, sCage, sBett, FALSE )
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Call GotoGruppe( sAbt, sStat, sCage, FALSE )
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Call GoToStat( sAbt, sStat, FALSE )
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Call GoToAbt( sAbt )
.head 9 -  Break
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Call PopulateAndExpand( hRoot, FALSE )
.head 9 -  Set nIndex = GetItemIndex( hRoot )
.head 9 +  If Not SalListSetSelect( hWndItem, nIndex )
.head 10 -  Return FALSE
.head 9 -  Call ActivateSelectedItem(  )
.head 9 -  Break
.head 5 +  Function: GoToCageNR
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: pnCageNR
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlBew
.head 7 -  String: sSelectBew
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Call GalConnect(hSqlBew  )
.head 7 -  Set sSelectBew = "
select ABT_KEY, STAT_KEY, GRUPPE_KEY,  @nullvalue(bew_zeit_bis,@now + 365)
from    bewegung
where  CAGE_NR= " || StrX( pnCageNR ) || " 
and GELOESCHT = 'N'  and ba_key in ( 'AE', 'VE', 'UE', 'RE' ) 
order by 4 desc
into :sAbtKey, :sStatKey, :sGrpKey
"
.head 7 -  Call SqlPrepareAndExecute( hSqlBew, sSelectBew )
.head 7 -  Call SqlFetchNext( hSqlBew, nFetch )
.head 7 -  Call SqlDisconnect( hSqlBew )
.head 7 +  If not sAbtKey or not sStatKey or not sGrpKey
.head 8 -  Return FALSE
.head 7 -  Return GotoGruppe( sAbtKey, sStatKey, sGrpKey, FALSE )
.head 5 +  Function: GetCageNR_ByHandle
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sABT
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Sql Handle: hSqlCageNR
.head 7 -  Number: nCageNR
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If not GalConnect( hSqlCageNR )
.head 8 -  Return 0
.head 7 -  Call GetPosition( hCage, sABT, sRack, sCage, sBett )
.head 7 -  Call SqlPrepareAndExecute( hSqlCageNR, "
select UNIQ_NR
from GRUPPE
where EINRICHT_ID = " || StrX( nEinrichtId ) || "
and  STAT_KEY = '"||sRack||"'
and GRUPPE_KEY = '"||sCage||"'
and CANCELED = 'N'
into :nCageNR
" )
.head 7 -  Call SqlFetchNext( hSqlCageNR, nFetch )
.head 7 -  Call SqlDisconnect( hSqlCageNR )
.head 7 -  Return nCageNR
.head 5 +  Function: GetOpenCages
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nHendelCage
.head 7 -  Receive Number: nOllcage[*] 
.head 7 -  Receive Number: nIndexInArrey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hStat[*]
.head 7 -  Number: hAbt[*]
.head 7 -  Number: hGruppe[*]
.head 7 -  Number: nAbt
.head 7 -  Number: nStat
.head 7 -  Number: nGruppe
.head 7 -  Number: i
.head 7 -  Number: j
.head 7 -  Number: k
.head 7 -  Number: n
.head 6 +  Actions
.head 7 -  Call SalArraySetUpperBound( nOllcage, 1, -1 )
.head 7 -  Set nAbt = EnumChildren( hRoot, hAbt)
.head 7 -  Set n = 0 
.head 7 -  Set nIndexInArrey = -1
.head 7 +  If nAbt > 0 or (nAbt = 0 and  hAbt[0] > 0)
.head 8 -  Set i = 0
.head 8 +  Loop
.head 9 +  If i > nAbt
.head 10 -  Break
.head 9 -  Set nStat = EnumChildren( hAbt[i], hStat)
.head 9 -  Set j = 0
.head 9 +  If nStat > 0 or (nStat = 0 and  hStat[0] > 0)
.head 10 +  Loop
.head 11 +  If j > nStat
.head 12 -  Break
.head 11 -  Set nGruppe = EnumChildren( hStat[j], hGruppe)
.head 11 -  Set k = 0
.head 11 +  If nGruppe > 0 or (nGruppe = 0 and  hGruppe[0] > 0)
.head 12 +  Loop
.head 13 +  If k > nGruppe or (k = nGruppe and hGruppe[k] <1)
.head 14 -  Break
.head 13 -  Set nOllcage[n] = hGruppe[k]
.head 13 +  If hGruppe[k] = nHendelCage
.head 14 -  Set nIndexInArrey = n
.head 13 -  Set k = k + 1
.head 13 -  Set n = n + 1
.head 11 -  Set j = j + 1
.head 11 -  Call SalArraySetUpperBound( hGruppe, 1, -1 )
.head 11 -  Set nGruppe = 0
.head 9 -  Set i = i + 1
.head 9 -  Call SalArraySetUpperBound( hStat, 1, -1 )
.head 9 -  Set nStat = 0
.head 7 -  Call SalArraySetUpperBound( hAbt, 1, -1 )
.head 7 -  Set nAbt = 0 
.head 5 +  Function: Move_CageSelected
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nDirection
.head 7 -  Number: nMove
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nOpenCage[*]
.head 7 -  Number: nIndecsCage
.head 7 -  Number: nCount
.head 7 -  Number: i
.head 7 -  Number: nGo
.head 6 +  Actions
.head 7 +  If nMove <= 0
.head 8 -  Return 0
.head 7 -  Call GetOpenCages( nSelectedHandle, nOpenCage, nIndecsCage )
.head 7 -  Call SalArrayGetUpperBound( nOpenCage, 1, nCount )
.head 7 +  If nIndecsCage < 0 
.head 8 -  Set i=1
.head 8 +  While i <= nCount
.head 9 +  If GetItemIndex( nSelectedHandle ) > GetItemIndex(nOpenCage[i-1]) and GetItemIndex( nSelectedHandle ) < GetItemIndex(nOpenCage[i] )
.head 10 -  Break
.head 9 -  Set i = i + 1
.head 7 +  Select Case nDirection
.head 8 +  Case 0
.head 9 -  Call SalListSetSelect( hWndItem, GetItemIndex(nOpenCage[0]) )
.head 9 -  Call ActivateSelectedItem(  )     
.head 9 -  Break
.head 8 +  Case 1
.head 9 +  If nIndecsCage < 0  
.head 10 -  Set nIndecsCage = i 
.head 9 -  Set nGo = nIndecsCage - nMove
.head 9 +  If nGo >= 0 
.head 10 -  Call SalListSetSelect( hWndItem, GetItemIndex(nOpenCage[nGo]) )
.head 10 -  Call ActivateSelectedItem(  )     
.head 9 -  Break
.head 8 +  Case 2
.head 9 +  If nIndecsCage < 0  
.head 10 -  Set nIndecsCage = i - 1
.head 9 -  Set nGo = nIndecsCage + nMove
.head 9 +  If nGo <= nCount 
.head 10 -  Call SalListSetSelect( hWndItem, GetItemIndex(nOpenCage[nGo]) )
.head 10 -  Call ActivateSelectedItem(  )     
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  Call SalListSetSelect( hWndItem, GetItemIndex(nOpenCage[nCount]) )
.head 9 -  Call ActivateSelectedItem(  )     
.head 9 -  Break
.head 7 -  Call SalArraySetUpperBound( nOpenCage, 1, -1 )
.head 5 +  Function: Move_Selected
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParamVK
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nIndex
.head 7 -  Number: hCildrenHendel[*]
.head 7 -  Number: i
.head 6 +  Actions
.head 7 +  Select Case nParamVK
.head 8 +  Case VK_RIGHT
.head 9 -  Call EnumChildren( nSelectedHandle, hCildrenHendel )
.head 9 +  If hCildrenHendel[0] > 0
.head 10 -  Call SalListSetSelect( hWndItem, GetItemIndex( hCildrenHendel[0]  ) )
.head 9 -  Break
.head 8 +  Case VK_LEFT
.head 9 +  If nSelectedHandle != hRoot and GetParent( nSelectedHandle )
.head 10 -  ! Set nSelectedHandle = GetParent( nSelectedHandle )
.head 10 -  Call SalListSetSelect( hWndItem, GetItemIndex( GetParent( nSelectedHandle ) ) )
.head 9 -  Break
.head 8 +  Case VK_UP
.head 9 -  Set nIndex=GetItemIndex( nSelectedHandle ) -1
.head 9 +  While nIndex > 0
.head 10 +  If GetLevel( GetItemHandle(nIndex) ) = nSelectedLevel
.head 11 -  Call SalListSetSelect( hWndItem, nIndex )
.head 11 -  Break
.head 10 -  Set nIndex = nIndex - 1
.head 9 -  Break
.head 8 +  Case VK_DOWN
.head 9 -  Set nIndex=GetItemIndex( nSelectedHandle ) + 1
.head 9 +  While GetItemHandle(nIndex) > 0
.head 10 +  If GetLevel( GetItemHandle(nIndex) ) = nSelectedLevel
.head 11 -  Call SalListSetSelect( hWndItem, nIndex )
.head 11 -  Break
.head 10 -  Set nIndex = nIndex + 1
.head 9 -  Break
.head 8 +  Default
.head 9 -  Return TRUE
.head 7 -  Call ActivateSelectedItem(  )
.head 7 -  Return FALSE
.head 5 +  Function: MoveCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nDirection
.head 7 -  Number: nDistance
.head 7 -  Number: nTwoDirection
.head 7 -  Number: nTwoDistance
.head 7 -  Boolean: bOnlyCheck
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: hResHandle
.head 7 -  Number: hCurrentHandle
.head 7 -  String: sSources[*]
.head 7 -  String: sTargets[*]
.head 7 -  Number: hChilds[*]
.head 7 -  Number: nChilds
.head 7 -  Number: nNumberOfMovingCages
.head 7 -  Number: nCount
.head 7 -  Boolean: bErrorDetected
.head 7 -  String: sIn
.head 7 -  String: sSrc
.head 7 -  String: sRequest
.head 7 -  Sql Handle: hSql
.head 7 -  String: sFrom
.head 7 -  String: sTo
.head 7 -  Number: nFetch
.head 7 -  Date/Time: dtTime
.head 7 -  Date/Time: dtTimeShift
.head 7 -  FunctionalVar: cSrc[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  String: sRFID
.head 7 -  String: sOrder
.head 7 -  Number: i
.head 7 -  Number: nTemp
.head 6 +  Actions
.head 7 -  ! ! Get active rack and screen; set up root handle
.head 7 +  If (nDistance <= 0) or (NOT nDirection) or ((nTwoDistance > 0) and (NOT nTwoDirection))
.head 8 -  Return FALSE
.head 7 -  Set hCurrentHandle = nSelectedHandle
.head 7 -  Call GetPosition(nSelectedHandle, sScr, sRack, sCage, sBett)
.head 7 -  Set dtTime = GetTime4Refresh()
.head 7 +  If KHE_IsOccupied( sScr, sRack, sCage, sBett, dtTime)
.head 8 -  Return FALSE
.head 7 +  If (sScr != "") and (sRack !="")
.head 8 +  If sBett != ""
.head 9 -  Set hCurrentHandle = GetParent(hCurrentHandle)
.head 8 +  If sCage != ""
.head 9 -  Set hCurrentHandle = GetParent(hCurrentHandle)
.head 8 -  Set nChilds = EnumChildren(hCurrentHandle, hChilds)
.head 8 +  If nChilds>0
.head 9 -  ! fill hSources array
.head 9 -  Set nCount = 0
.head 9 -  Set nNumberOfMovingCages = 0
.head 9 -  Set sIn = ""
.head 9 +  While (nCount<nChilds) and (NOT bErrorDetected)
.head 10 +  If KHE_IsExpanded(hChilds[nCount])
.head 11 +  If KHEGetHasFall(hChilds[nCount])
.head 12 -  Call GetPosition(hChilds[nCount], sScr, sRack, sCage, sBett)
.head 12 -  Set sIn = sIn||"'"||sCage||"',"
.head 12 -  Set nNumberOfMovingCages = nNumberOfMovingCages+1
.head 12 -  ! Call SqlExists("select relship_id from relationship where rs_stat_key = :sRack and rs_gruppe_key= :sCage
and relship_start<:dtTime and (relship_end is null or relship_end>=:dtTime)", bErrorDetected)
.head 11 +  Else
.head 12 -  Set bErrorDetected = TRUE
.head 10 -  Set nCount = nCount+1
.head 9 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 9 +  If (NOT bErrorDetected) and (sIn != "")
.head 10 +  If GalConnect(hSql)
.head 11 -  ! sort src array
.head 11 -  ! Call SqlSetIsolationLevel(hSql, "RL")
.head 11 +  Select Case nDirection
.head 12 +  Case DIR_Up
.head 13 +  If nTwoDirection = DIR_Right
.head 14 -  Set sOrder = "a.y_pos_label, a.x_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.y_pos_label, a.x_pos_label"
.head 13 -  Break
.head 12 +  Case DIR_Down
.head 13 +  If nTwoDirection = DIR_Right
.head 14 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label"
.head 13 -  Break
.head 12 +  Case DIR_Left
.head 13 +  If nTwoDirection = DIR_Down
.head 14 -  Set sOrder = "a.x_pos_label, a.y_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.x_pos_label, a.y_pos_label"
.head 13 -  Break
.head 12 +  Case DIR_Right
.head 13 +  If nTwoDirection = DIR_Down
.head 14 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label"
.head 13 -  Break
.head 11 -  Call SqlPrepareAndExecute(hSql, "select a.gruppe_key from gruppe a where gruppe_key in("||sIn||") and STAT_KEY=:sRack  order by "||sOrder||" into :sFrom")
.head 11 -  Call SalArraySetUpperBound(sSources, 1, nNumberOfMovingCages)
.head 11 -  Call SalArraySetUpperBound(sTargets, 1, nNumberOfMovingCages)
.head 11 -  Set nCount = 0
.head 11 -  Set sIn = ""
.head 11 +  While SqlFetchNext(hSql, nFetch)
.head 12 -  Set sSources[nCount] = sFrom
.head 12 -  Set sIn = sIn||"'"||sFrom||"',"
.head 12 -  Set nCount = nCount+1
.head 11 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 11 -  Set sSrc = sIn
.head 10 +  Else
.head 11 -  Set bErrorDetected = TRUE
.head 9 +  If nCount = nNumberOfMovingCages
.head 10 +  Select Case nDirection
.head 11 +  Case DIR_Up
.head 12 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 12 -  Set sTo = "b.y_pos_label = (select max(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)<@value(a.y_pos_label))"
.head 12 -  Break
.head 11 +  Case DIR_Down
.head 12 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 12 -  Set sTo = "b.y_pos_label = (select min(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)>@value(a.y_pos_label))"
.head 12 -  Break
.head 11 +  Case DIR_Left
.head 12 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 12 -  Set sTo = "b.x_pos_label = (select max(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label<a.x_pos_label)"
.head 12 -  Break
.head 11 +  Case DIR_Right
.head 12 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 12 -  Set sTo = "b.x_pos_label = (select min(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label>a.x_pos_label)"
.head 12 -  Break
.head 10 -  Set sRequest = sFrom||" and "||sTo
.head 10 +  While (nDistance >0) and (NOT bErrorDetected)
.head 11 -  Set nCount = 0
.head 11 -  Call SqlPrepareAndExecute(hSql, "select
 b.gruppe_key
from
 gruppe a, gruppe b
where
 a.gruppe_key in ("||sIn||")
 and a.stat_key=:sRack
 and b.stat_key = a.stat_key
 and "||sRequest||" order by "||sOrder||" into :sTo")
.head 11 -  Set nCount = 0
.head 11 -  Set sIn = ""
.head 11 +  While SqlFetchNext(hSql, nFetch)
.head 12 -  Set sTargets[nCount] = sTo
.head 12 -  Set sIn = sIn||"'"||sTo||"',"
.head 12 -  Set nCount = nCount+1
.head 11 +  If nCount != nNumberOfMovingCages
.head 12 -  Set bErrorDetected = TRUE
.head 11 +  Else
.head 12 -  Set nDistance = nDistance -1
.head 12 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 9 -  ! fill hSources array
.head 9 +  If nTwoDistance
.head 10 -  Set i = 0
.head 10 -  Set sIn = ""
.head 10 +  While (i<nCount) and (NOT bErrorDetected)
.head 11 -  Set sIn = sIn||"'"||sTargets[i]||"',"
.head 11 -  Set i = i + 1
.head 10 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 10 +  If (NOT bErrorDetected) and (sIn != "")
.head 11 +  If GalConnect(hSql)
.head 12 -  ! sort src array
.head 12 -  ! Call SqlSetIsolationLevel(hSql, "RL")
.head 12 +  ! Select Case nTwoDirection
.head 13 +  Case DIR_Up
.head 14 -  Set sOrder = "a.y_pos_label, a.x_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Down
.head 14 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Left
.head 14 -  Set sOrder = "a.x_pos_label, a.y_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Right
.head 14 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label"
.head 14 -  Break
.head 12 +  Select Case nDirection
.head 13 +  Case DIR_Up
.head 14 +  If nTwoDirection = DIR_Right
.head 15 -  Set sOrder = "a.y_pos_label, a.x_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.y_pos_label, a.x_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Down
.head 14 +  If nTwoDirection = DIR_Right
.head 15 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Left
.head 14 +  If nTwoDirection = DIR_Down
.head 15 -  Set sOrder = "a.x_pos_label, a.y_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.x_pos_label, a.y_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Right
.head 14 +  If nTwoDirection = DIR_Down
.head 15 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label"
.head 14 -  Break
.head 12 -  Call SqlPrepareAndExecute(hSql, "select a.gruppe_key from gruppe a where gruppe_key in("||sIn||") and STAT_KEY=:sRack  order by "||sOrder||" into :sFrom")
.head 12 -  Call SalArraySetUpperBound(sSources, 1, nNumberOfMovingCages)
.head 12 -  Call SalArraySetUpperBound(sTargets, 1, nNumberOfMovingCages)
.head 12 -  Set nCount = 0
.head 12 -  Set sIn = ""
.head 12 +  While SqlFetchNext(hSql, nFetch)
.head 13 -  ! Set sSources[nCount] = sFrom
.head 13 -  Set sIn = sIn||"'"||sFrom||"',"
.head 13 -  Set nCount = nCount+1
.head 12 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 12 -  ! Set sSrc = sIn
.head 11 +  Else
.head 12 -  Set bErrorDetected = TRUE
.head 10 +  If nCount = nNumberOfMovingCages
.head 11 +  Select Case nTwoDirection
.head 12 +  Case DIR_Up
.head 13 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 13 -  Set sTo = "b.y_pos_label = (select max(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)<@value(a.y_pos_label))"
.head 13 -  Break
.head 12 +  Case DIR_Down
.head 13 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 13 -  Set sTo = "b.y_pos_label = (select min(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)>@value(a.y_pos_label))"
.head 13 -  Break
.head 12 +  Case DIR_Left
.head 13 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 13 -  Set sTo = "b.x_pos_label = (select max(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label<a.x_pos_label)"
.head 13 -  Break
.head 12 +  Case DIR_Right
.head 13 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 13 -  Set sTo = "b.x_pos_label = (select min(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label>a.x_pos_label)"
.head 13 -  Break
.head 11 -  Set sRequest = sFrom||" and "||sTo
.head 11 +  While (nTwoDistance >0) and (NOT bErrorDetected)
.head 12 -  Set nCount = 0
.head 12 -  Call SqlPrepareAndExecute(hSql, "select
 b.gruppe_key
from
 gruppe a, gruppe b
where
 a.gruppe_key in ("||sIn||")
 and a.stat_key=:sRack
 and b.stat_key = a.stat_key
 and "||sRequest||" order by "||sOrder||" into :sTo")
.head 12 -  Set nCount = 0
.head 12 -  Set sIn = ""
.head 12 +  While SqlFetchNext(hSql, nFetch)
.head 13 -  Set sTargets[nCount] = sTo
.head 13 -  Set sIn = sIn||"'"||sTo||"',"
.head 13 -  Set nCount = nCount+1
.head 12 +  If nCount != nNumberOfMovingCages
.head 13 -  Set bErrorDetected = TRUE
.head 12 +  Else
.head 13 -  Set nTwoDistance = nTwoDistance -1
.head 13 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 9 +  If NOT bErrorDetected
.head 10 -  Call SqlExists("select b.fall_key
from bewegung b, fall f
	where gruppe_key in ("||sIn||") and gruppe_key not in ("||sSrc||")
 and @nullvalue( b.GELOESCHT, 'N' ) != 'J'
 and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
 and	:dtTime >= b.BEW_ZEIT
 and	( :dtTime <= b.BEW_ZEIT_BIS or ( b.BEW_ZEIT_BIS is NULL) )
 and	f.EINRICHT_ID = b.EINRICHT_ID
 and	f.FALL_KEY = b.FALL_KEY
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
union
select f.fall_key
from BETT_LOCKS b, FALL f
where gruppe_key in ("||sIn||") and gruppe_key not in ("||sSrc||")
and b.EINRICHT_ID=1
and b.EINRICHT_ID=f.EINRICHT_ID
and b.PLANBEW_FALL=f.FALL_KEY
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and (b.bis is null or b.bis>:dtTime)
union
select b.fall_key
from BEWEGUNG b, Fall f
where b.BEW_ZEIT> :dtTime
and gruppe_key in ("||sIn||") and gruppe_key not in ("||sSrc||")
 and @nullvalue( b.GELOESCHT, 'N' ) != 'J'
and b.EINRICHT_ID=1
and b.EINRICHT_ID=f.EINRICHT_ID
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and b.FALL_KEY=f.FALL_KEY", bErrorDetected)
.head 10 +  If (NOT bErrorDetected) and (NOT bOnlyCheck)
.head 11 -  ! Movecages ;)
.head 11 -  ! Call TransferCages(sScr, sRack, nNumberOfMovingCages, sSources, sTargets, GetTime4Refresh())
.head 11 -  Set dtTimeShift=GetTime4Refresh()
.head 11 -  Call LT_OpenTransaction(5,dtTimeShift)
.head 11 -  Call LockSysadmAction("Shift cages started...")
.head 11 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScr, sRack, nNumberOfMovingCages, sSources, sTargets, dtTimeShift)
.head 11 -  Call LockSysadmAction("...Shift cages finished")
.head 11 -  Call LT_CloseLastTransaction()
.head 11 -  ! Set sIn = ""
.head 11 -  ! Set frmAtlantaMain.nLockCounter = frmAtlantaMain.nLockCounter+1
.head 11 -  ! Set nCount = 0
.head 11 -  ! Call SalArraySetUpperBound(cSrc, 1, nNumberOfMovingCages*2)
.head 11 -  ! Call SetOutlineRedraw(FALSE)
.head 11 +  ! While nCount <nNumberOfMovingCages
.head 12 -  Set nSelectedHandle = SearchFrom(hCurrentHandle, sSources[nCount])
.head 12 -  Call MoveCage(sRack, sSources[nCount], sScr, sRack, sTargets[nCount], GetTime4Refresh() )
.head 12 -  Set sIn = sIn||sTargets[nCount]||","||sSources[nCount]||","
.head 12 -  Call SalSendMsg( hWndItem, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 12 -  Call CloseGruppe(sScr, sRack, sSources[nCount])
.head 12 -  Call OpenGruppe(sScr, sRack, sTargets[nCount],  FALSE, -1)
.head 12 -  Call cSrc[nCount].Init( sScr, sRack, sTargets[nCount] )
.head 12 -  Set nCount = nCount+1
.head 11 -  ! Set frmAtlantaMain.nLockCounter = frmAtlantaMain.nLockCounter-1
.head 11 -  ! Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 11 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 12 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sIn ))
.head 11 -  ! Set cDest = cSrc[nNumberOfMovingCages-1]
.head 11 -  ! Call SalArraySetUpperBound(cSrc, 1, nNumberOfMovingCages-1)
.head 11 -  ! Call Move_PrintCageCards( cSrc, cDest)
.head 11 -  ! Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 11 -  ! Call SetOutlineRedraw(TRUE)
.head 9 +  ! Else
.head 10 -  Set bErrorDetected = TRUE
.head 8 +  Else
.head 9 -  Set bErrorDetected = TRUE
.head 7 +  Else
.head 8 -  Set bErrorDetected = TRUE
.head 7 +  If hSql
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Call SalArraySetUpperBound(sSources, 1, 0)
.head 7 -  Call SalArraySetUpperBound(sTargets, 1, 0)
.head 7 -  Call SalArraySetUpperBound(cSrc, 1, 0)
.head 7 -  Return NOT bErrorDetected
.head 5 +  Function: DistributionAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCountAnimal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Date/Time: dtKHE
.head 7 -  Number: nBound
.head 7 -  Number: nAnimal
.head 7 -  !
.head 7 -  Number: nAllCages[*]
.head 7 -  Number: nEmptyCages[*]
.head 7 -  Number: nBett[*]
.head 7 -  Number: nFall[*]
.head 7 -  Number: nIndexSelectCage
.head 7 -  Number: nCagesIsEmpty
.head 7 -  Number: nCage
.head 7 -  Number: nFalls
.head 7 -  Number: nCount
.head 7 -  !
.head 7 -  Number: nInd
.head 7 -  Number: nIndEmpty
.head 7 -  !
.head 7 -  Number: hRefreshCage
.head 7 -  !
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nPrintCages
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  String: sScrEmpty
.head 7 -  String: sRackEmpty
.head 7 -  String: sCageEmpty
.head 7 -  String: sBettEmpty
.head 7 -  !
.head 7 -  String: sRefreshRack2D
.head 7 -  Boolean: bDestinationBed
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set nFalls = -1
.head 7 -  Set nCagesIsEmpty = -1
.head 7 -  Set nPrintCages = -1
.head 7 -  Set sRefreshRack2D = ""
.head 7 -  Set bOk = bOk and CanDistributionAnimal( nCountAnimal )
.head 7 +  If bOk
.head 8 -  Call DelNul()
.head 8 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 8 +  If nBound != 0
.head 9 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call GetOpenCages( nSelectedHandle, nAllCages, nIndexSelectCage )
.head 8 +  If nIndexSelectCage > 0
.head 9 -  Set nInd = nIndexSelectCage
.head 9 -  Set nCage = nAllCages[nIndexSelectCage]
.head 9 +  While nInd > 0
.head 10 -  Set nAllCages[nInd] = nAllCages[nInd-1]
.head 10 -  Set nInd = nInd - 1
.head 9 -  Set nAllCages[0] = nCage
.head 8 -  Set nCage = 0
.head 8 -  Call SalArrayGetUpperBound( nAllCages, 1, nIndexSelectCage )
.head 8 +  While bOk and nCage <= nIndexSelectCage
.head 9 -  Set nSelectedHandle = nAllCages[nCage]
.head 9 +  If not CageIsEmpty_ByHandle(  )
.head 10 -  Set nCagesIsEmpty = nCagesIsEmpty + 1
.head 10 -  Set nEmptyCages[nCagesIsEmpty] = nAllCages[nCage]
.head 9 +  Else
.head 10 -  Call EnumChildren( nAllCages[nCage] , nBett )
.head 10 -  Call SalArrayGetUpperBound( nBett, 1, nCount )
.head 10 -  Set nInd =  0
.head 10 +  While nInd <= nCount and GetFallKey_ByHandle(nBett[nInd]) != 0
.head 11 -  Set nFalls = nFalls + 1
.head 11 -  Set nFall [nFalls] = nBett[nInd]
.head 11 -  Set nInd = nInd + 1
.head 9 -  Set nCage = nCage + 1
.head 8 -  Set nCount = 0
.head 8 -  Set nIndEmpty = 0
.head 8 -  Set dtKHE = GetTime4Refresh(  )
.head 8 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 8 -  Call LockSysadmAction("Distribute animals...")
.head 8 +  While bOk and nCount <= nFalls and nIndEmpty <= nCagesIsEmpty and nCountAnimal  > 0
.head 9 -  Set nInd = 0
.head 9 -  Call GetPosition( nEmptyCages[nIndEmpty], sScrEmpty, sRackEmpty, sCageEmpty, sBettEmpty )
.head 9 +  While bOk and nInd < nCountAnimal and nCount <= nFalls
.head 10 +  If hRefreshCage = 0
.head 11 -  Set hRefreshCage = GetParent( nFall [nCount] )
.head 11 -  Call GetPosition( hRefreshCage, sScr, sRack, sCage, sBett )
.head 11 -  ! Set nPrintCages = nPrintCages + 1
.head 11 -  ! Call GetPosition( hRefreshCage, sScr, sRack, sCage, sBett )
.head 11 -  ! Call cSource[nPrintCages].Init( sScr, sRack, sCage )
.head 10 +  Else If hRefreshCage != GetParent( nFall [nCount] )
.head 11 -  Call KHE_RefreshGruppe( hRefreshCage)
.head 11 -  Set nSelectedHandle = hRefreshCage
.head 11 +  If CageIsEmpty_ByHandle(  )
.head 12 -  Set nPrintCages = nPrintCages + 1
.head 12 -  Call cSource[nPrintCages].Init( sScr, sRack, sCage )
.head 12 -  Call KHE_RefreshGruppe( hRefreshCage)
.head 11 +  Else
.head 12 -  Call POC_Unregister( hRefreshCage )
.head 12 -  Call CloseGruppe( sScr, sRack, sCage )
.head 11 -  Set sRefreshRack2D = sRefreshRack2D || sCage || ";" 
.head 11 -  Set hRefreshCage = GetParent( nFall [nCount] )
.head 11 -  Call GetPosition( hRefreshCage, sScr, sRack, sCage, sBett )
.head 10 -  Set sBettEmpty=AddWonBett(dtKHE)
.head 10 +  If sBettEmpty=''
.head 11 -  Set bOk = FALSE
.head 10 +  Else
.head 11 -  Set bDestinationBed = Move_PasteSingleBed_DoIt( 
			nFall [nCount], 
			sScrEmpty, sRackEmpty, sCageEmpty, sBettEmpty,
			"UE", dtKHE )
.head 11 +  If not bDestinationBed 
.head 12 -  Set bOk = FALSE
.head 10 -  Set nInd = nInd + 1
.head 10 -  Set nCount = nCount + 1
.head 9 -  Set nPrintCages = nPrintCages + 1
.head 9 -  Call cSource[nPrintCages].Init( sScrEmpty, sRackEmpty, sCageEmpty )
.head 9 -  Set nIndEmpty = nIndEmpty + 1
.head 9 -  ! Set nSelectedHandle = nEmptyCages[nIndEmpty - 1]
.head 9 -  ! Call Move_PasteGruppe( "UE", dtKHE, FALSE )
.head 9 -  Set sRefreshRack2D = sRefreshRack2D || sCage || ";" 
.head 9 -  Call KHE_RefreshGruppe( nEmptyCages[nIndEmpty - 1] )
.head 9 -  Call UnSelect(  )
.head 8 -  Call LockSysadmAction("...animals distributed")
.head 8 -  Call LT_CloseLastTransaction()
.head 8 -  Call UnSelect(  )
.head 8 -  Call KHE_RefreshGruppe( hRefreshCage)
.head 8 -  Set nSelectedHandle = hRefreshCage
.head 8 -  ! Call GetPosition( hRefreshCage, sScr, sRack, sCage, sBett )
.head 8 +  If CageIsEmpty_ByHandle(  )
.head 9 -  Set nPrintCages = nPrintCages + 1
.head 9 -  Call cSource[nPrintCages].Init( sScr, sRack, sCage )
.head 8 +  Else
.head 9 -  Call POC_Unregister( hRefreshCage )
.head 9 -  Call CloseGruppe( sScr, sRack, sCage )
.head 8 -  Set sRefreshRack2D = sRefreshRack2D || sCage || ";" 
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh,  RACK2D_RefreshTimeChanged ,SalHStringToNumber( sCage ))
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh,  RACK2D_RefreshContent, SalHStringToNumber( sCage ) )
.head 8 -  Set hRefreshCage = GetParent( nFall [nCount] )
.head 8 -  Call DelNul()
.head 8 -  Call cDestination.Init( sScr, sRack, sCage)
.head 8 -  Call Move_PrintCageCards( cSource, cDestination )
.head 7 -  Return bOk
.head 5 +  Function: CanDistributionAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCountAnimal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nBound
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  !
.head 7 -  Number: hRack
.head 7 -  Number: hScr
.head 7 -  !
.head 7 -  Number: hCages[*]
.head 7 -  Number: hChild[*]
.head 7 -  Number: nCountCages
.head 7 -  Number: nCountChild
.head 7 -  Number: nNumCage
.head 7 -  Number: nNumChild
.head 7 -  !
.head 7 -  Boolean: bSex   ! If TRUE -  Male, FALSE- female
.head 7 -  String: sSex
.head 7 -  Number: nAnimal
.head 7 -  Boolean: bIsEmptyExists
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set sSex = ""
.head 7 +  If nSelectedLevel != KHEL_Gruppe
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call DelNul()
.head 8 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 8 +  If nBound != 0
.head 9 -  Set bOk = FALSE
.head 7 +  If bOk and not CageIsEmpty_ByHandle(   )
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 8 -  Set hRack = GetParent( nSelectedHandle )
.head 8 -  Set hScr = GetParent( hRack )
.head 8 -  Call SalSetArrayBounds( hCages, 1, -1 )
.head 8 -  Call GetOpenCages( 0, hCages, nCountCages )
.head 8 -  Call SalArrayGetUpperBound( hCages, 1, nCountCages  )
.head 8 -  Set nNumCage = 0
.head 8 +  While bOk and nNumCage <= nCountCages
.head 9 +  If GetParent( GetParent( hCages[nNumCage] ) ) != hScr
.head 10 -  Set bOk = FALSE
.head 9 +  Else
.head 10 -  Call GetPosition(hCages[nNumCage], sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 10 -  Set bIsEmptyExists = bIsEmptyExists or (NOT CageIsEmpty(sStatKeyTmp, sGrpKeyTmp, GetTime4Refresh(  ), TRUE))
.head 9 -  Set nNumCage = nNumCage + 1
.head 8 -  Set bOk = bOk and bIsEmptyExists
.head 7 +  If bOk
.head 8 -  Call SalSetArrayBounds( hChild, 1, -1 )
.head 8 -  Set nNumCage = 0
.head 8 +  While bOk and nNumCage <= nCountCages
.head 9 -  Call EnumChildren( hCages[nNumCage], hChild )
.head 9 -  Call SalArrayGetUpperBound( hChild, 1, nCountChild  )
.head 9 -  Set nAnimal =  nAnimal + nCountChild
.head 9 +  If SalArrayIsEmpty( hChild )
.head 10 -  Set nCountChild = -1
.head 9 +  Else If nCountChild = 1
.head 10 -  Set bOk = FALSE
.head 9 -  Set nNumChild = 0
.head 9 +  While bOk and nNumChild <= nCountChild and GetFallKey_ByHandle(hChild[nNumChild]) != 0
.head 10 +  If sSex = STRING_Null
.head 11 -  Set bSex = GetSex_ByHandle( hChild[nNumChild] )
.head 11 +  If bSex
.head 12 -  Set sSex = "M"
.head 11 +  Else
.head 12 -  Set sSex = "F"
.head 10 +  Else
.head 11 +  If bSex != GetSex_ByHandle( hChild[nNumChild] )
.head 12 -  Set bOk = FALSE
.head 10 -  Set nNumChild = nNumChild + 1
.head 9 -  Set nNumCage = nNumCage + 1
.head 7 -  Set bOk = bOk and (nAnimal >= nCountAnimal) and (nAnimal > 1)
.head 7 -  Return bOk
.head 5 +  Function: CloseAllButOne
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: spAbtKey
.head 7 -  String: spStatKey
.head 7 -  String: spGrpKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Number: nChildS
.head 7 -  Number: nChildR
.head 7 -  Number: nChildC
.head 7 -  Number: nS
.head 7 -  Number: nR
.head 7 -  Number: nC
.head 7 -  Number: hChildrenS[*]
.head 7 -  Number: hChildrenR[*]
.head 7 -  Number: hChildrenC[*]
.head 6 +  Actions
.head 7 -  Set nChildS = EnumChildren (hRoot , hChildrenS)
.head 7 -  Set nS = 0
.head 7 +  While nS <= nChildS
.head 8 -  Set nChildR = EnumChildren (hChildrenS[nS] , hChildrenR)
.head 8 -  Set nR = 0
.head 8 +  While nR <= nChildR
.head 9 -  Set nChildC = EnumChildren (hChildrenR[nR] , hChildrenC)
.head 9 -  Set nC = 0
.head 9 +  While nC <= nChildC
.head 10 -  Call GetPosition( hChildrenC[nC], sAbtKey, sStatKey, sGrpKey, sBettKey )
.head 10 +  If sAbtKey != spAbtKey or sStatKey != spStatKey or sGrpKey != spGrpKey
.head 11 -  Call CloseGruppe( sAbtKey, sStatKey, sGrpKey )
.head 10 -  Set nC = nC + 1
.head 9 -  Set nR = nR + 1
.head 8 -  Set nS = nS + 1
.head 5 +  Function: OrdersUserAbteilungs
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hScreens[*]
.head 7 -  Number: nCountScreens
.head 7 -  Number: nTop
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlBase
.head 7 -  String: sScreen
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If bOk and GalConnect(hSqlBase)
.head 8 -  Set nCountScreens = EnumChildren( hRoot, hScreens )
.head 8 -  ! Call SalArrayGetUpperBound( hScreens, 1, nCountScreens )
.head 8 -  Call SqlPrepare(hSqlBase, "update user_screen set top=:nTop where user_id = :nUserId and scr_id=(select id from abteilung where abt_key=:sScreen)")
.head 8 -  Set nTop = 1
.head 8 +  While nCountScreens > 0
.head 9 -  Set sScreen = GetKey_ByHandle( hScreens[nCountScreens - 1] )
.head 9 -  Call SqlExecute( hSqlBase )
.head 9 -  Set nCountScreens = nCountScreens -1
.head 9 -  Set nTop = nTop + 1
.head 8 -  Call SqlCommit( hSqlBase )
.head 8 -  Call SqlDisconnect( hSqlBase )
.head 7 +  Else
.head 8 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 +  Function: OrdersUserStations
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hRacks[*]
.head 7 -  Number: nCountRacks
.head 7 -  Number: nTop
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlIns
.head 7 -  Sql Handle: hSqlBase
.head 7 -  String: sRack
.head 7 -  FunctionalVar: oPosInfo
.head 8 -  Class: cPositionData
.head 7 -  Number: nRackID
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If bOk and GalConnect(hSqlBase) and GalConnect(hSqlIns)
.head 8 -  Set nCountRacks = EnumChildren( GetParent(nSelectedHandle), hRacks )
.head 8 -  Call _GetPositionID(nSelectedHandle,oPosInfo)
.head 8 -  ! Call SalArrayGetUpperBound( hScreens, 1, nCountScreens )
.head 8 -  Call SqlPrepareAndExecute(hSqlBase, "delete from tree where user_id=:nUserId and id_parent=:oPosInfo.nScreenID ")
.head 8 -  Call SqlPrepare(hSqlIns, "insert into tree (user_id, id_parent ,id_child ,top ) values (:nUserId, :oPosInfo.nScreenID, :nRackID, :nTop)")
.head 8 -  Call SqlPrepare(hSqlBase, "select id from station where stat_key=:sRack and einricht_id=:nEinrichtId into :nRackID  ")
.head 8 -  Set nTop = 1
.head 8 +  While nCountRacks > 0
.head 9 -  Set sRack = GetKey_ByHandle( hRacks[nCountRacks - 1] )
.head 9 +  If SqlExecute( hSqlBase )
.head 10 +  If SqlFetchNext( hSqlBase, nFetch )
.head 11 -  Call SqlExecute( hSqlIns )
.head 9 -  Set nCountRacks = nCountRacks -1
.head 9 -  Set nTop = nTop + 1
.head 8 -  Call SqlCommit( hSqlBase )
.head 8 -  Call SqlDisconnect( hSqlBase )
.head 7 +  Else
.head 8 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 +  Function: ChangeScreenOrder
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nParent
.head 7 -  Number: nI
.head 7 -  Number: nMax
.head 7 -  Boolean: bExpand
.head 7 -  Number: nItemIndex
.head 7 -  Number: hItem
.head 6 +  Actions
.head 7 -  Call SetOutlineRedraw( FALSE )
.head 7 -  ! Set nI=0
.head 7 -  ! Set nMax=0
.head 7 -  ! Set nItemIndex = SalListQuerySelection(hWndItem )
.head 7 -  ! Set hItem = GetItemHandle(nItemIndex)
.head 7 -  ! Call SalArraySetUpperBound( hExpanded, 1, -1 )
.head 7 +  ! If GetItemFlags( hItem ) & ITEM_IsExpanded
.head 8 -  Set bExpand = TRUE
.head 7 -  ! Call KHE_SaveLevel( GetItemHandle( SalListQuerySelection(hWndItem )), nMax )
.head 7 -  ! Call KHE_SortExpand()
.head 7 -  ! Set nI=nMax-1
.head 7 +  ! While nI > -1
.head 8 -  Call Collapse(GetItemIndex( hExpanded[nI,0] ))
.head 8 -  Set nI = nI - 1
.head 7 +  ! If nMax>0
.head 8 -  Call Collapse(GetItemIndex(hItem ))
.head 8 -  ! Call Expand( SalListQuerySelection(hWndItem ) )
.head 7 +  Select Case nAction
.head 8 +  Case SCREEN_TOP
.head 9 -  Set nParent = GetItemHandle( SalListQuerySelection( hWndItem ) )
.head 9 +  While GetPrevSibling( nParent  )
.head 10 -  Call MoveUp(GetItemIndex( nParent ) )
.head 9 -  Break
.head 8 +  Case SCREEN_UP
.head 9 -  Call MoveUp( SalListQuerySelection(hWndItem)  )
.head 9 -  Break
.head 8 +  Case SCREEN_DOWN
.head 9 -  Call MoveDown( SalListQuerySelection(hWndItem)  )
.head 9 -  Break
.head 8 +  Case SCREEN_BUTTOM
.head 9 -  Set nParent = GetItemHandle( SalListQuerySelection( hWndItem ) )
.head 9 +  While GetNextSibling( nParent  )
.head 10 -  Call MoveDown( GetItemIndex( nParent ) )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 +  If nSelectedLevel = KHEL_Abteilung
.head 8 -  Call OrdersUserAbteilungs(  )
.head 7 +  Else If nSelectedLevel = KHEL_Station
.head 8 -  Call OrdersUserStations(  )
.head 7 -  ! Set nI=0
.head 7 +  ! While nI < nMax
.head 8 -  Call Expand( GetItemIndex( hExpanded[nI,0] ))
.head 8 -  Set nI = nI + 1
.head 7 +  ! If bExpand
.head 8 -  Call Expand( SalListQuerySelection(hWndItem ) )
.head 7 -  ! Call SalArraySetUpperBound( hExpanded, 1, -1 )
.head 7 -  Call SetOutlineRedraw( TRUE )
.head 7 -  Return TRUE
.head 5 +  Function: TransferCageInScreen
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sScrFrom
.head 7 -  String: sScrTo
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  ! Number: nFetch
.head 7 -  String: sEmpty
.head 7 -  ! Number: nBewNr
.head 7 -  ! Number: nFall
.head 7 -  ! Number: nBettKey
.head 7 -  !
.head 7 -  !
.head 7 -  ! Number: nTransferredFalls[*]
.head 7 -  ! Number: nBetts[*]
.head 7 -  Number: nTransferredCount
.head 7 -  !
.head 7 -  String: sBA
.head 7 -  ! String: sSqlBew
.head 6 +  Actions
.head 7 -  Set sEmpty = ""
.head 7 -  Call SalArraySetUpperBound(nTransferredFalls, 1, -1)
.head 7 -  Call SalArraySetUpperBound(nTransferredBetts, 1, -1)
.head 7 +  ! If GalConnect(hSql)
.head 8 +  If bRealTimeMode
.head 9 -  Set sSqlBew = "select f.fall_key, f.last_bett_key from fall f
	where f.einricht_id = :nEinrichtId
	and f.last_gruppe_key = :sCage
	and f.last_stat_key = :sRack
	and f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 8 +  Else 
.head 9 -  Set sSqlBew = "select b.fall_key, bett_key from bewegung b, fall f
	where b.einricht_id = :nEinrichtId and gruppe_key = :sCage and stat_key = :sRack
	and b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and b.geloescht = 'N'
	and bew_zeit<:dtAction
	and (bew_zeit_bis is null or bew_zeit_bis >= :dtAction)
	and f.fall_key=b.fall_key
	and f.einricht_id=b.einricht_id
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 8 +  If SqlPrepareAndExecute(hSql, sSqlBew)
.head 9 -  Set nTransferredCount = 0
.head 9 +  While SqlFetchNext(hSql, nFetch)
.head 10 -  Set nTransferredCount = nTransferredCount+1
.head 10 -  Call SalArraySetUpperBound(nTransferredFalls, 1, nTransferredCount)
.head 10 -  Set nTransferredFalls[nTransferredCount-1] = nFall
.head 10 -  Set nBetts[nTransferredCount-1]=nBettKey
.head 9 +  ! If sScrFrom != sScrTo
.head 10 -  Set sBA = "VES"
.head 9 +  ! Else
.head 10 -  Set sBA="UES"
.head 9 -  Set sBA="VES"
.head 9 +  While nTransferredCount>0
.head 10 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, sRack, sCage, SalNumberToStrX(nBetts[nTransferredCount-1],0),"", "", "", "" )
.head 10 -  Set nTransferredCount = nTransferredCount-1
.head 9 +  If bAskForLicense
.head 10 -  Call SetMassLicense( nTransferredFalls, sScrTo)
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Call PrepareTransferFalls( sRack, sCage, dtAction )
.head 7 -  Set sBA="VES"
.head 7 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 7 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 7 +  While nTransferredCount>0
.head 8 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, sRack, sCage, SalNumberToStrX(nTransferredBetts[nTransferredCount-1],0),"", "", "", "" )
.head 8 -  Set nTransferredCount = nTransferredCount-1
.head 7 +  If GalConnect(hSql)
.head 8 +  If SqlPrepareAndExecute(hSql, "update gruppe set  rf_abt_key=:sScrTo
	where einricht_id = :nEinrichtId and gruppe_key=:sCage and stat_key = :sRack")
.head 9 +  ! If SqlPrepareAndExecute(hSql, "Update lst_erf set  gruppe_key= :sCageTo,  stat_key=:sRackTo where stat_key=:sRackFrom and gruppe_key= :sCageFrom")
.head 10 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 9 -  Call SqlCommit( hSql )
.head 8 +  Else
.head 9 -  Call SqlPrepareAndExecute(hSql, "rollback")
.head 8 -  Call SqlDisconnect( hSql )
.head 7 -  Call LT_CloseLastTransaction()
.head 7 +  If bAskForLicense
.head 8 -  Call SetMassLicense( nTransferredFalls, sScrTo)
.head 7 -  Call SalArraySetUpperBound(nTransferredFalls, 1, 0)
.head 7 -  Call SalArraySetUpperBound(nTransferredBetts, 1, -1)
.head 5 +  Function: TransferCageInScreens
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sScrFrom
.head 7 -  String: sScrTo
.head 7 -  String: sRack
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bAskForLicenseSave
.head 7 -  Sql Handle: hSqlCages
.head 7 -  Number: nFetch
.head 7 -  String: sCage
.head 7 -  String: sCagePrev
.head 7 -  Boolean: bOK
.head 7 -  String: sBA
.head 7 -  Number: nTransferredCount
.head 7 -  Number: nRackID
.head 7 -  Number: nCount
.head 7 -  Number: nI
.head 7 -  Window Handle: hWndProgress
.head 6 +  Actions
.head 7 -  Set bAskForLicenseSave = bAskForLicense
.head 7 -  Set bOK= TRUE
.head 7 -  Call SalArraySetUpperBound(nTransferredFalls, 1, -1)
.head 7 -  Call SalArraySetUpperBound(nTransferredBetts, 1, -1)
.head 7 -  Call SalArraySetUpperBound(asTransferredCage, 1, -1)
.head 7 +  If GalConnect( hSqlCages )
.head 8 +  If not bPlanningMode
.head 9 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 9 -  Set bOK= bOK and  SqlPrepareAndExecute( hSqlCages, "select distinct f.last_gruppe_key, g.rack_id 
 from fall f left join gruppe g on (g.id=f.last_cage_id)
where f.GELOESCHT='N'
   and f.last_ba_key!='EE'
   and f.last_abt_key=:sScrFrom
   and f.last_stat_key=:sRack 
order by f.last_gruppe_key
into :sCage, :nRackID " )
.head 9 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 9 -  Call SqlGetResultSetCount( hSqlCages, nCount )
.head 9 +  If nCount > 0 
.head 10 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nCount  )
.head 9 +  While bOK and  SqlFetchNext( hSqlCages, nFetch )
.head 10 -  ! Call TransferCageInScreen( sScrFrom, sScrTo, sRack, sCage, dtAction )
.head 10 -  Call PrepareTransferFalls( sRack, sCage, dtAction )
.head 10 -  ! Set asTransferredCage[nTransferredCount] = sCage
.head 10 -  ! Set nTransferredCount = nTransferredCount + 1
.head 10 -  Call CloseGruppe(sScrFrom, sRack, sCage)
.head 9 -  Call SqlDisconnect( hSqlCages )
.head 9 -  Set sBA="VES"
.head 9 -  Set sCagePrev = ""
.head 9 -  Set nI = 1
.head 9 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 9 +  While nTransferredCount >0
.head 10 +  If sCagePrev != asTransferredCage[nTransferredCount-1] and hWndProgress
.head 11 -  Set sCagePrev = asTransferredCage[nTransferredCount-1]
.head 11 -  Call dlgProgress.Init( nCount, "Transfer cage " || sCagePrev || " from " || sScrFrom || " to " || sScrTo || " screen")
.head 11 -  Set dlgProgress.nCurrent = nI - 1
.head 11 -  Call dlgProgress.Next(  )
.head 11 -  Set nI = nI + 1
.head 10 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, sRack, asTransferredCage[nTransferredCount-1], SalNumberToStrX(nTransferredBetts[nTransferredCount-1],0),"", "", "", "" )
.head 10 -  Set nTransferredCount = nTransferredCount-1
.head 9 +  If bOK and GalConnect(hSqlCages)
.head 10 +  If SqlPrepare(hSqlCages, "update gruppe set  rf_abt_key=:sScrTo
	where einricht_id = :nEinrichtId and gruppe_key=:asTransferredCage[nTransferredCount-1] and stat_key = :sRack")
.head 11 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 11 +  While nTransferredCount >0 and bOK
.head 12 -  Set bOK =bOK and SqlExecute( hSqlCages )
.head 12 -  Set nTransferredCount = nTransferredCount - 1
.head 11 +  ! If SqlPrepareAndExecute(hSql, "Update lst_erf set  gruppe_key= :sCageTo,  stat_key=:sRackTo where stat_key=:sRackFrom and gruppe_key= :sCageFrom")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 11 +  If bOK
.head 12 -  Call SqlCommit( hSqlCages )
.head 11 +  Else
.head 12 -  Call SqlPrepareAndExecute(hSqlCages, "rollback")
.head 10 -  Call SqlDisconnect( hSqlCages )
.head 9 -  Call SalSendMsg(hWndForm, AM_Refresh, 3 , nRackID )
.head 9 +  If bAskForLicense
.head 10 -  Call SetMassLicense( nTransferredFalls, sScrTo)
.head 9 +  If hWndProgress
.head 10 -  ! Call SalDestroyWindow( hWndProgress )
.head 10 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 10 -  Set hWndProgress = hWndNULL
.head 9 -  Call SalArraySetUpperBound(nTransferredFalls, 1, -1)
.head 9 -  Call SalArraySetUpperBound(nTransferredBetts, 1, -1)
.head 9 -  Call SalArraySetUpperBound(asTransferredCage, 1, -1)
.head 9 -  Call LT_CloseLastTransaction()
.head 8 +  Else
.head 9 -  Set bOK= FALSE
.head 7 +  Else
.head 8 -  Set bOK= FALSE
.head 7 -  Return bOK
.head 5 +  Function: TransferCageBetweenScreens
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sScrFrom
.head 7 -  String: sScrTo
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bAskForLicenseSave
.head 7 -  Sql Handle: hSqlCages
.head 7 -  Sql Handle: hSqlInsert
.head 7 -  Number: nFetch
.head 7 -  String: sCage
.head 7 -  String: sRack
.head 7 -  Boolean: bOK
.head 7 -  String: sBA
.head 7 -  Number: nTransferredCount
.head 7 -  String: sRackPrev
.head 7 -  String: sCagePrev
.head 7 -  Boolean: bExists
.head 7 -  Number: nCount
.head 7 -  Number: nI
.head 7 -  Window Handle: hWndProgress
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 7 -  Number: nScrToID
.head 7 -  Number: nScrFromID
.head 6 +  Actions
.head 7 -  Set bAskForLicenseSave = bAskForLicense
.head 7 -  Set bOK= TRUE
.head 7 -  Set sRackPrev = ""
.head 7 -  Call SalArraySetUpperBound(nTransferredFalls, 1, -1)
.head 7 -  Call SalArraySetUpperBound(nTransferredBetts, 1, -1)
.head 7 -  Call SalArraySetUpperBound(asTransferredCage, 1, -1)
.head 7 -  Call SalArraySetUpperBound(asTransferredRack, 1, -1)
.head 7 +  If GalConnect( hSqlCages ) and GalConnect( hSqlInsert ) 
.head 8 +  If not bPlanningMode
.head 9 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 9 -  Set bOK= bOK and  SqlPrepareAndExecute( hSqlCages, "select id from abteilung where abt_key=:sScrFrom
into :nScrFromID " )
.head 9 -  Set bOK = bOK and SqlFetchNext(hSqlCages, nFetch)
.head 9 -  Set bOK= bOK and  SqlPrepareAndExecute( hSqlCages, "select id from abteilung where abt_key=:sScrTo
into :nScrToID " )
.head 9 -  Set bOK = bOK and SqlFetchNext(hSqlCages, nFetch)
.head 9 -  Set bOK= bOK and  SqlPrepareAndExecute( hSqlCages, "select distinct f.last_gruppe_key,f.last_stat_key, g.id, g.rack_id
 from fall f left join gruppe g on (g.id=f.last_cage_id)
where GELOESCHT='N'
   and last_ba_key!='EE'
   and last_abt_key=:sScrFrom

order by last_gruppe_key
into :sCage , :sRack, :nCageID , :nRackID" )
.head 9 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 9 -  Call SqlPrepare( hSqlInsert, "Insert into screen_rack(scr_id,rack_id,kst_key) values(:nScrToID,:nRackID,1)" )
.head 9 -  Call SqlGetResultSetCount( hSqlCages, nCount )
.head 9 +  While bOK and  SqlFetchNext( hSqlCages, nFetch )
.head 10 -  ! Call TransferCageInScreen( sScrFrom, sScrTo, sRack, sCage, dtAction )
.head 10 +  If sRackPrev != sRack
.head 11 -  Set sRackPrev = sRack
.head 11 -  Call SqlExists( "select * from screen_rack
 where scr_id=:nScrToID and rack_id=:nRackID   ", bExists )
.head 11 +  If not bExists
.head 12 -  Call SqlExecute( hSqlInsert )
.head 10 -  Call PrepareTransferFalls( sRack, sCage, dtAction )
.head 10 -  ! Set asTransferredCage[nTransferredCount] = sCage
.head 10 -  ! Set nTransferredCount = nTransferredCount + 1
.head 10 -  Call CloseGruppe(sScrFrom, sRack, sCage)
.head 9 -  Call SqlCommit( hSqlInsert )
.head 9 -  Call SqlDisconnect( hSqlCages )
.head 9 -  Call SqlDisconnect( hSqlInsert )
.head 9 -  Set sBA="VES"
.head 9 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 9 -  Set sRackPrev = ""
.head 9 -  Set sCagePrev = ""
.head 9 +  If nCount > 0 
.head 10 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nCount  )
.head 9 -  Set nI = 1
.head 9 +  While nTransferredCount >0
.head 10 +  If sCagePrev != asTransferredCage[nTransferredCount-1] and hWndProgress
.head 11 -  Set sCagePrev = asTransferredCage[nTransferredCount-1]
.head 11 -  Call dlgProgress.Init( nCount, "Transfer cage " || sCagePrev || " from " || sScrFrom || " to " || sScrTo || " screen")
.head 11 -  Set dlgProgress.nCurrent = nI - 1
.head 11 -  Call dlgProgress.Next(  )
.head 11 -  Set nI = nI + 1
.head 10 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, asTransferredRack[nTransferredCount-1], asTransferredCage[nTransferredCount-1], SalNumberToStrX(nTransferredBetts[nTransferredCount-1],0),"", "", 
"", "" )
.head 10 -  Set nTransferredCount = nTransferredCount-1
.head 9 -  Call SalSendMsg( hWndStar2000 , AM_TransferBeetwenScreens, nScrFromID, nScrToID )
.head 9 +  If bAskForLicense
.head 10 -  Call SetMassLicense( nTransferredFalls, sScrTo)
.head 9 +  If hWndProgress
.head 10 -  ! Call SalDestroyWindow( hWndProgress )
.head 10 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 10 -  Set hWndProgress = hWndNULL
.head 9 -  Call SalArraySetUpperBound(nTransferredFalls, 1, -1)
.head 9 -  Call SalArraySetUpperBound(nTransferredBetts, 1, -1)
.head 9 -  Call SalArraySetUpperBound(asTransferredCage, 1, -1)
.head 9 -  Call SalArraySetUpperBound(asTransferredRack, 1, -1)
.head 9 -  Call LT_CloseLastTransaction()
.head 8 +  Else
.head 9 -  Set bOK= FALSE
.head 7 +  Else
.head 8 -  Set bOK= FALSE
.head 7 -  Return bOK
.head 5 +  Function: PrepareTransferFalls
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  String: sSqlBew
.head 7 -  Number: nFall
.head 7 -  Number: nBettKey
.head 7 -  Number: nTransferredCount
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If GalConnect(hSql)
.head 8 -  Call SalArrayGetUpperBound( nTransferredFalls, 1, nTransferredCount )
.head 8 +  If bRealTimeMode
.head 9 -  Set sSqlBew = "select f.fall_key, f.last_bett_key from  sysadm.fall f
	where f.einricht_id = :nEinrichtId
	and f.last_gruppe_key = :sCage
	and f.last_stat_key = :sRack
	and f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey "
.head 8 +  Else
.head 9 -  Set sSqlBew = "select b.fall_key, bett_key from sysadm.bewegung b,  sysadm.fall f
	where b.einricht_id = :nEinrichtId and gruppe_key = :sCage and stat_key = :sRack
	and b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and b.geloescht = 'N'
	and bew_zeit<:dtAction
	and (bew_zeit_bis is null or bew_zeit_bis >= :dtAction)
	and f.fall_key=b.fall_key
	and f.einricht_id=b.einricht_id
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 8 +  If SqlPrepareAndExecute(hSql, sSqlBew)
.head 9 -  ! Set nTransferredCount = 0
.head 9 +  While SqlFetchNext(hSql, nFetch)
.head 10 -  Set nTransferredCount = nTransferredCount+1
.head 10 -  Call SalArraySetUpperBound(nTransferredFalls, 1, nTransferredCount)
.head 10 -  Set nTransferredFalls[nTransferredCount-1] = nFall
.head 10 -  Set nTransferredBetts[nTransferredCount-1]=nBettKey
.head 10 -  Set asTransferredCage[nTransferredCount-1] = sCage
.head 10 -  Set asTransferredRack[nTransferredCount-1] = sRack
.head 9 -  ! Set sBA="VES"
.head 9 +  ! While nTransferredCount>0
.head 10 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, sRack, sCage, SalNumberToStrX(nBetts[nTransferredCount-1],0),"", "", "", "" )
.head 10 -  Set nTransferredCount = nTransferredCount-1
.head 9 +  ! If bAskForLicense
.head 10 -  Call SetMassLicense( nTransferredFalls, sScrTo)
.head 8 -  Call SqlDisconnect(hSql)
.head 5 +  Function: CheckRolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCoutSelect
.head 7 -  Number: nFall[*]
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  String: sAbt
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: hRack
.head 7 -  Number: hCage[*]
.head 7 -  Number: hFalls[*]
.head 7 -  Number: nCountCage
.head 7 -  String: sCages
.head 7 -  String: sSex
.head 7 -  Number: nCount
.head 7 -  Number: nCountEmpty
.head 7 -  Number: nCountAnimal
.head 7 -  Number: nCountDead
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Boolean: bCageM
.head 7 -  Number: nFallMale
.head 7 -  String: sCageMale
.head 7 -  String: sCageFemale
.head 7 -  Number: naCage[*]
.head 7 -  Number: hCageF
.head 7 -  String: sText2
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags2
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call DelNul()
.head 7 +  If nSelectedLevel != KHEL_Gruppe  and nSelectedLevel != KHEL_Bett
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk and CageIsSummary(  )  or BettIsSummary(  )
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call GetPosition( nSelectedHandle, sAbt, sRack, sCage, sBett )
.head 8 +  If nSelectedLevel = KHEL_Gruppe
.head 9 -  Set hRack = GetParent( nSelectedHandle )
.head 8 +  Else If nSelectedLevel = KHEL_Bett
.head 9 -  Set hRack = GetParent(GetParent( nSelectedHandle ))
.head 8 -  Call EnumChildren( hRack, hCage )
.head 8 -  Call SalArrayGetUpperBound( hCage, 1, nCountCage )
.head 8 +  If nCountCage != 1
.head 9 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call SalArrayGetUpperBound( HandleToPlace, 1, nCoutSelect )
.head 8 +  If SalArrayIsEmpty( HandleToPlace )
.head 9 +  If bOk
.head 10 -  Set nI = 0
.head 10 -  Set nFallMale = -1
.head 10 -  Set sCageMale = ""
.head 10 -  Set sCageFemale = ""
.head 10 +  While bOk and nI <= nCountCage
.head 11 -  Call EnumChildren( hCage[nI], hFalls )
.head 11 -  Call SalArrayGetUpperBound( hFalls, 1, nCount )
.head 11 -  Set nK = 0
.head 11 +  While bOk and nK <= nCount
.head 12 +  If GetItemText( hFalls[nK] ) != ''
.head 13 -  Call GetItemData( hFalls[nK], sText2, nValueLoc2, nFlags2 )
.head 13 +  If Not SalStrScan(sText2," K ")>0
.head 14 +  If nFallMale > -1
.head 15 +  If GetSex_ByHandle( hFalls[nK] ) = 1
.head 16 -  Set bOk = FALSE
.head 14 +  Else
.head 15 +  If GetSex_ByHandle( hFalls[nK] ) = 1
.head 16 -  Set nFallMale = GetFallKey_ByHandle( hFalls[nK] )
.head 16 -  Set sCageMale = GetKey_ByHandle(  hCage[nI] )
.head 14 +  If GetSex_ByHandle( hFalls[nK] ) = 0
.head 15 +  If sCageFemale = STRING_Null
.head 16 -  Set sCageFemale = GetKey_ByHandle(  hCage[nI] )
.head 15 +  If sCageFemale = sCageMale
.head 16 -  Set bOk = FALSE
.head 12 -  Set nK = nK + 1
.head 11 -  Set nI = nI + 1
.head 8 +  Else
.head 9 +  If nCoutSelect > 0
.head 10 -  Set bOk = FALSE
.head 9 +  Else If nCoutSelect = 0
.head 10 -  Call GetItemData( HandleToPlace[0,1], sText2, nValueLoc2, nFlags2 )
.head 10 +  If bOk and (GetSex_ByHandle( HandleToPlace[0,1] ) != 1 or SalStrScan(sText2," K ")>0)
.head 11 -  Set bOk = FALSE
.head 10 +  If bOk
.head 11 -  Call GetOpenCages(GetParent(HandleToPlace[0,1]), naCage, nCount)
.head 11 -  Call SalArrayGetUpperBound( naCage, 1, nCoutSelect )
.head 11 +  If nCoutSelect != 1
.head 12 -  Set bOk = FALSE
.head 11 +  Else
.head 12 -  Set nI = 0
.head 12 +  While nI <=nCoutSelect and bOk
.head 13 +  If naCage[nI] != GetParent(HandleToPlace[0,1])
.head 14 -  Set nCountAnimal = EnumChildren(naCage[nI], hFalls )
.head 14 -  Set nK = 0
.head 14 -  Set nCountDead = 0
.head 14 -  Set nCountEmpty = 0
.head 14 +  While bOk and nK < nCountAnimal
.head 15 +  If GetItemText( hFalls[nK] ) != ''
.head 16 -  Call GetItemData( hFalls[nK], sText2, nValueLoc2, nFlags2 )
.head 16 +  If SalStrScan(sText2," K ")>0
.head 17 -  Set nCountDead = nCountDead + 1
.head 15 +  Else
.head 16 -  Set nCountEmpty = nCountEmpty + 1
.head 15 -  Set nK = nK + 1
.head 14 +  If nCountDead + nCountEmpty = nCountAnimal
.head 15 -  Set bOk = FALSE
.head 13 -  Set nI = nI + 1
.head 11 -  Set nFallMale = HandleToPlace[0,0]
.head 11 -  Set sCageMale = GetKey_ByHandle( GetParent( HandleToPlace[0,1] ) )
.head 10 +  If bOk
.head 11 +  If nCount =1
.head 12 -  Set hCageF = naCage[0]
.head 11 +  Else
.head 12 -  Set hCageF = naCage[1]
.head 11 -  ! Call GetPosition( hCageF, sAbt, sRack, sCage, sBett )
.head 11 -  Set sCageFemale = GetKey_ByHandle(  hCageF )
.head 11 -  Call SqlExists( "select	 f.fall_key
					from BEWEGUNG bew,fall f, relship_fall rf
					where   bew.EINRICHT_ID=:nEinrichtId
					and       bew.stat_key = :sRack
                                         and	   bew.gruppe_key = :sCageFemale
   					and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <= @now
   					and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
					and	f.einricht_id=bew.einricht_id
   					and	f.Fall_KEY = bew.Fall_KEY
					and   (F.GESCHL = 'M'
							or (F.GESCHL = 'W' and rf.einricht_id = f.einricht_id
  and rf.fall_key = f.fall_key
  and rf.fallrolle_key='MATE'
  and @nullvalue(rf.rs_fall_valid, @now + 1) >= @now))
   					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'", bExists )
.head 11 +  If bExists
.head 12 -  Set bOk = FALSE
.head 10 +  ! If bOk
.head 11 -  Set nFallMale = HandleToPlace[0,0]
.head 11 -  Set sCageMale = GetKey_ByHandle( GetParent( HandleToPlace[0,1] ) )
.head 11 -  Set nI = 0
.head 11 +  While bOk and nI <= nCountCage
.head 12 -  Call EnumChildren( hCage[nI], hFalls )
.head 12 -  Call SalArrayGetUpperBound( hFalls, 1, nCount )
.head 12 -  Set nK = 0
.head 12 +  While bOk and nK <= nCount
.head 13 +  If GetItemText( hFalls[nK] ) != ''
.head 14 +  If GetSex_ByHandle( hFalls[nK] ) = 0
.head 15 +  If sCageFemale = STRING_Null
.head 16 -  Set sCageFemale = GetKey_ByHandle(  hCage[nI] )
.head 14 +  Else 
.head 15 +  If sCageFemale = sCageMale
.head 16 -  Set bOk = FALSE
.head 13 -  Set nK = nK + 1
.head 12 -  Set nI = nI + 1
.head 10 +  ! If bOk
.head 11 -  Call SqlExists( "select fall_key from roling_fall where fall_key = :HandleToPlace[0,0] ", bExists )
.head 11 +  If bExists
.head 12 -  Set bOk = FALSE
.head 11 +  If bOk
.head 12 -  Call SqlExists("select sterile
  from fall f , le l
   where l.le_id=f.Le_id
      and sterile = 1
      and f.einricht_id = :nEinrichtId
      and f.fall_key = :HandleToPlace[0,0] ", bExists)
.head 12 +  If bExists
.head 13 -  Set bOk = FALSE
.head 10 +  ! If bOk
.head 11 -  Set sCages = GetKey_ByHandle( GetParent( HandleToPlace[0,1] ) )
.head 11 -  Call SqlExists( "select	*
					from BEWEGUNG bew,fall f
					where   bew.EINRICHT_ID=:nEinrichtId
					and       bew.stat_key = :sRack
                                         and	   bew.gruppe_key = :sCages
   					and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <= @now
   					and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
					and	f.einricht_id=bew.einricht_id
   					and	f.Fall_KEY = bew.Fall_KEY
					and 	f.geschl != 'M'
   					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
", bExists )
.head 11 +  If bExists
.head 12 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 +  If not (nFallMale > 0 and sCageMale != STRING_Null and sCageFemale != STRING_Null )
.head 9 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call SqlExists( "select fall_key from roling_fall where fall_key = :nFallMale and status=0 ", bExists )
.head 8 +  If bExists
.head 9 -  Set bOk = FALSE
.head 8 +  If bOk
.head 9 -  Call SqlExists("select sterile
  from fall f , le l
   where l.le_id=f.Le_id
      and sterile = 1
      and f.einricht_id = :nEinrichtId
      and f.fall_key = :nFallMale ", bExists)
.head 9 +  If bExists
.head 10 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call SqlExists( "select	 f.fall_key
					from BEWEGUNG bew,fall f, relship_fall rf
					where   bew.EINRICHT_ID=:nEinrichtId
					and       bew.stat_key = :sRack
                                         and	   bew.gruppe_key = :sCageFemale
   					and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <= @now
   					and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
					and	f.einricht_id=bew.einricht_id
   					and	f.Fall_KEY = bew.Fall_KEY
   					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
  and rf.einricht_id = f.einricht_id
  and rf.fall_key = f.fall_key
  and rf.fallrolle_key='MATE'
  and @nullvalue(rf.rs_fall_valid, @now + 1) >= @now", bExists )
.head 8 +  If bExists
.head 9 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 +  Function: RolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlUpd
.head 7 -  Number: nFetch
.head 7 -  Number: nNr
.head 7 -  Boolean: bEx
.head 7 -  Number: nBound
.head 7 -  Number: nFallMale
.head 7 -  Number: hRack
.head 7 -  Number: hCage[*]
.head 7 -  Number: hFalls[*]
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nCount
.head 7 -  Number: hCageMale
.head 7 -  Number: hCageFemale
.head 6 +  Actions
.head 7 -  Set bOk = CheckRolingMatings(  )
.head 7 +  If bOk
.head 8 +  If GalConnect( hSqlUpd )
.head 9 -  Call DelNul(  )
.head 9 +  If SalArrayIsEmpty( HandleToPlace )
.head 10 -  Set nBound = -1
.head 9 +  Else
.head 10 -  Call SalArrayGetUpperBound( HandleToPlace, 1, nBound )
.head 9 -  Set nFallMale = -1
.head 9 +  If nBound > -1
.head 10 +  If GetSex_ByHandle( HandleToPlace[0,1] ) = 1
.head 11 -  Set nFallMale = HandleToPlace[0,0]
.head 11 -  Set nSelectedHandle = HandleToPlace[0,1]
.head 10 +  Else
.head 11 -  Set bOk = FALSE
.head 9 +  Else
.head 10 +  If nSelectedLevel = KHEL_Gruppe
.head 11 -  Set hRack = GetParent( nSelectedHandle )
.head 10 +  Else If nSelectedLevel = KHEL_Bett
.head 11 -  Set hRack = GetParent(GetParent( nSelectedHandle ))
.head 10 +  Else
.head 11 -  Set bOk = FALSE
.head 10 +  If bOk
.head 11 -  Call EnumChildren( hRack, hCage )
.head 11 -  Call SalArrayGetUpperBound( hCage, 1, nBound )
.head 11 -  Set nI = 0
.head 11 +  While bOk and nI <= nBound
.head 12 -  Call EnumChildren( hCage[nI], hFalls )
.head 12 -  Call SalArrayGetUpperBound( hFalls, 1, nCount )
.head 12 -  Set nK=0
.head 12 +  While bOk and nK <= nCount
.head 13 +  If GetSex_ByHandle( hFalls[nK] ) = 1
.head 14 -  Set nFallMale =  GetFallKey_ByHandle( hFalls[nK] )
.head 14 -  Set nSelectedHandle = hFalls[nK]
.head 14 -  Call MultiSelect(  )
.head 14 -  Set nI = nBound + 1
.head 14 -  Set nK = nCount + 1
.head 13 -  Set nK = nK +1
.head 12 -  Set nI = nI +1
.head 9 +  If nFallMale = -1
.head 10 -  Set bOk = FALSE
.head 9 +  If bOk
.head 10 -  Set hCageMale = GetParent( nSelectedHandle )
.head 10 -  Set hRack = GetParent(hCageMale)
.head 10 -  Call EnumChildren( hRack, hCage )
.head 10 -  Call SalArrayGetUpperBound( hCage, 1, nCount )
.head 10 -  Set nI = 0
.head 10 -  Set hCageFemale = -1
.head 10 +  While nI <= nCount
.head 11 +  If hCage[nI] != hCageMale
.head 12 -  Set hCageFemale = hCage[nI]
.head 12 -  Set nI = nCount + 1
.head 11 -  Set nI = nI + 1
.head 10 +  If hCageFemale > -1
.head 11 -  Call SalListSetSelect( hWndKHE, GetItemIndex( hCageFemale ) )
.head 11 -  Call ActivateSelectedItem(  )
.head 10 +  Else
.head 11 -  Set bOk =FALSE
.head 9 +  If bOk
.head 10 -  Call SqlExists("select fall_key from roling_fall where fall_key=:nFallMale and status=0" , bEx)
.head 10 +  If not bEx
.head 11 +  If SqlPrepareAndExecute(hSqlUpd, " Insert into roling_fall(fall_key,status) values(:nFallMale,0)")
.head 12 -  Call SqlCommit(hSqlUpd)
.head 11 +  Else
.head 12 -  Call SqlPrepareAndExecute(hSqlUpd,'rollback')
.head 12 -  Set bOk = FALSE
.head 10 +  If bOk
.head 11 -  Call LockSysadmAction("Rolling requested...")
.head 11 +  If not Move_PasteToCurrent(  )
.head 12 +  If not bEx
.head 13 -  Call SqlPrepareAndExecute(hSqlUpd, "delete from roling_fall where fall_key=:nFallMale and status=0 and relship_id is null" )
.head 11 +  Else
.head 12 -  Call SqlPrepareAndExecute(hSqlUpd, " select	NR
from	LT
where	USER_ID = :nUserId

into	:nNr")
.head 12 -  Call SqlFetchNext( hSqlUpd, nFetch )
.head 12 -  Call SqlPrepareAndExecute(hSqlUpd, "Update	LT
Set STATUS=4
where	NR=:nNr")
.head 10 -  ! Set bRolingMating = FALSE
.head 10 -  Call SqlCommit( hSqlUpd )
.head 10 -  Call SqlDisconnect( hSqlUpd )
.head 8 +  Else
.head 9 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 +  Function: Move_CanRolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: naCage[*]
.head 7 -  Number: nCount
.head 7 -  Number: hCageF
.head 7 -  String: sAbt
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: nCoutSelect
.head 7 -  Number: nFallMale
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  Number: hTemp
.head 7 -  Number: nTempLevel
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If nSelectedLevel != KHEL_Gruppe  and nSelectedLevel != KHEL_Bett
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk and SalArrayIsEmpty( HandleToPlace )
.head 8 -  Set bOk = FALSE
.head 7 -  Call SalArrayGetUpperBound( HandleToPlace, 1, nCoutSelect )
.head 7 +  If bOk and nCoutSelect > 0
.head 8 -  Set bOk = FALSE
.head 7 -  Set nFallMale = HandleToPlace[0,0]
.head 7 +  If bOk and GetSex_ByHandle( HandleToPlace[0,1] ) != 1
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk and not KHE_IsFallInRolingMatings(nFallMale)
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Call GetOpenCages(GetParent(HandleToPlace[0,1]), naCage, nCount)
.head 8 -  Call SalArrayGetUpperBound( naCage, 1, nCoutSelect )
.head 8 +  If nCoutSelect != 1
.head 9 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 +  If nCount =1
.head 9 -  Set hCageF = naCage[0]
.head 8 +  Else
.head 9 -  Set hCageF = naCage[1]
.head 8 -  Call GetPosition( hCageF, sAbt, sRack, sCage, sBett )
.head 8 -  Call SqlExists( "select	 f.fall_key
					from BEWEGUNG bew,fall f, relship_fall rf
					where   bew.EINRICHT_ID=:nEinrichtId
					and       bew.stat_key = :sRack
                                         and	   bew.gruppe_key = :sCage
   					and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <= @now
   					and       (bew.bew_zeit_bis>@now or bew.bew_zeit_bis is null  )
					and	f.einricht_id=bew.einricht_id
   					and	f.Fall_KEY = bew.Fall_KEY
					and   (F.GESCHL = 'M'
							or (F.GESCHL = 'W' and rf.einricht_id = f.einricht_id
  and rf.fall_key = f.fall_key
  and rf.fallrolle_key='MATE'
  and @nullvalue(rf.rs_fall_valid, @now + 1) >= @now))
   					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'", bExists )
.head 8 +  If bExists
.head 9 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Set hTemp = nSelectedHandle
.head 8 -  Set nSelectedHandle = hCageF
.head 8 -  Set nTempLevel = nSelectedLevel
.head 8 -  Set nSelectedLevel = KHEL_Gruppe
.head 8 -  Set bOk = Move_CanPaste()
.head 8 -  Set nSelectedHandle = hTemp
.head 8 -  Set nSelectedLevel = nTempLevel
.head 7 -  Return bOk
.head 5 +  Function: Move_PasteRolingMatings
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: naCage[*]
.head 7 -  Number: nCount
.head 7 -  Number: hCageF
.head 7 -  Number: nCoutSelect
.head 6 +  Actions
.head 7 -  Set hCageF = -1
.head 7 -  Call GetOpenCages(GetParent(HandleToPlace[0,1]), naCage, nCount)
.head 7 -  Call SalArrayGetUpperBound( naCage, 1, nCoutSelect )
.head 7 +  If nCoutSelect = 1
.head 8 +  If nCount =1
.head 9 -  Set hCageF = naCage[0]
.head 8 +  Else
.head 9 -  Set hCageF = naCage[1]
.head 8 +  If hCageF > -1
.head 9 -  Call SalListSetSelect( hWndKHE, GetItemIndex( hCageF ) )
.head 9 -  Call ActivateSelectedItem(  )
.head 9 -  Call Move_PasteToCurrent(  )
.head 5 +  Function: SetPOCPos
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 7 -  Number: nPort
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hPrevious
.head 7 -  String: sPortSubstring
.head 7 -  Number: nVal
.head 7 -  Number: nFlags
.head 7 -  Number: nScr
.head 7 -  Number: nRack
.head 7 -  Number: nCage
.head 7 -  Number: nPos
.head 6 +  Actions
.head 7 -  Call SetOutlineRedraw(FALSE)
.head 7 -  Call GetPositionID(hCage,nScr,nRack,nCage,nPos )
.head 7 -  Call T_SetPortPOC(nCage, nPort )
.head 7 +  If NOT nPort
.head 8 +  Loop
.head 9 -  Set hPrevious = GetNextSibling(hCage)
.head 9 +  If hPrevious = NUMBER_Null
.head 10 -  Break
.head 9 +  If NOT GetItemData(hPrevious, sPortSubstring, nVal, nFlags)
.head 10 -  Break
.head 9 -  Set nVal = SalStrScan(sPortSubstring, "<")
.head 9 -  Set nFlags = SalStrScan(sPortSubstring, " Pos>")
.head 9 +  If (nVal = 0) and (nFlags > nVal)
.head 10 -  Set nFlags = GetItemIndex(hCage)
.head 10 +  If nFlags = LB_Err
.head 11 -  Break
.head 10 -  Call MoveDown(nFlags)
.head 9 +  Else
.head 10 -  Break
.head 7 +  Else
.head 8 +  Loop
.head 9 -  Set hPrevious = GetPrevSibling(hCage)
.head 9 +  If hPrevious = NUMBER_Null
.head 10 -  Break
.head 9 +  If NOT GetItemData(hPrevious, sPortSubstring, nVal, nFlags)
.head 10 -  Break
.head 9 -  Set nVal = SalStrScan(sPortSubstring, "<")
.head 9 -  Set nFlags = SalStrScan(sPortSubstring, " Pos>")
.head 9 +  If (nVal = 0) and (nFlags > nVal)
.head 10 -  Set sPortSubstring = SalStrMidX(sPortSubstring, 1, nFlags -1)
.head 10 -  Set nPos = GetPOCPointNr(sPortSubstring)
.head 10 +  If nPos and (nPos < nPort)
.head 11 -  Break
.head 9 -  Set nFlags = GetItemIndex(hCage)
.head 9 +  If nFlags = LB_Err
.head 10 -  Break
.head 9 -  Call MoveUp(nFlags)
.head 7 -  Call SetOutlineRedraw(TRUE)
.head 5 +  Function: POC_FindCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCage
.head 7 -  Receive String: sAbtKey
.head 7 -  Receive String: sStatKey
.head 7 -  Receive String: sGrpKey
.head 7 -  Receive Number: hGrp
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hScreen[*]
.head 7 -  Number: hRoom[*]
.head 7 -  Number: hGroppe[*]
.head 7 -  Number: nGroppe
.head 7 -  Number: nRoom
.head 7 -  Number: nScreen
.head 7 -  Number: i
.head 7 -  Number: m
.head 7 -  Number: hCurrent
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  Number: j
.head 7 -  String: sBett
.head 7 -  String: sRFID
.head 6 +  Actions
.head 7 -  Set nScreen = EnumChildren( hRoot, hScreen)
.head 7 +  If nScreen
.head 8 -  Set i = 0
.head 8 +  Loop
.head 9 +  If i >= nScreen
.head 10 -  Break
.head 9 -  Call GetItemData( hScreen[ i ], sText, nValueLoc, nFlags )
.head 9 -  ! Set sAbtKey = GetKey_FromLable (sText)
.head 9 -  Set nRoom = EnumChildren( hScreen[ i ], hRoom )
.head 9 +  If nRoom
.head 10 -  Set m= 0
.head 10 +  Loop
.head 11 +  If m>= nRoom
.head 12 -  Break
.head 11 -  Call GetItemData( hRoom[ m ], sText1, nValueLoc1, nFlags1 )
.head 11 -  ! Set sStatKey = GetKey_FromLable (sText1)
.head 11 -  Set nGroppe = EnumChildren( hRoom[ m ], hGroppe )
.head 11 -  Set j = 0
.head 11 +  While j < nGroppe
.head 12 -  Call GetItemData( hGroppe[ j ], sText2, nValueLoc2, nFlags2 )
.head 12 +  If SalStrScan(sText2, "Pos>") = -1
.head 13 -  Call GetPosition(hGroppe[ j ], sAbtKey, sStatKey, sGrpKey, sBett)
.head 13 +  If NOT KHE_IsRFID( sAbtKey,sStatKey,sGrpKey)
.head 14 -  Set hGrp= hGroppe[ j ]
.head 14 -  Return TRUE
.head 12 -  Set j = j + 1
.head 11 -  Set m = m + 1
.head 9 -  Set i = i + 1
.head 7 -  Return FALSE
.head 5 +  Function: GetPOCPointDescr
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nPos
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sRes
.head 6 +  Actions
.head 7 +  If nPos < 3
.head 8 -  Set sRes = SalNumberToStrX(nPos, 0)
.head 7 +  Else
.head 8 +  If nPos = 3
.head 9 -  Set sRes = "3-1"
.head 8 +  Else If nPos = 5
.head 9 -  Set sRes = "5-1"
.head 8 +  Else
.head 9 -  Set sRes = SalNumberToStrX(nPos+1, 0)
.head 9 -  ! Set sRes = "3-"||SalStrRightX(sRes, SalStrLength(sRes)-1)
.head 9 -  Call SalStrReplace(sRes,1,0,'-',sRes)
.head 7 -  Return sRes
.head 5 +  Function: GetPOCPointNr
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sPointDescr
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRes
.head 6 +  Actions
.head 7 -  Set nRes = NUMBER_Null
.head 7 +  If sPointDescr
.head 8 +  If SalStrLeftX(sPointDescr, 2) = "3-"
.head 9 -  Set sPointDescr = SalStrRightX(sPointDescr, SalStrLength(sPointDescr) - 2)
.head 9 +  If sPointDescr and SalStrIsValidNumber(sPointDescr)
.head 10 -  Set nRes = SalStrToNumber(sPointDescr) - 1
.head 10 +  If nRes
.head 11 -  Set nRes = 29 + nRes
.head 10 +  Else
.head 11 -  Set nRes = 3
.head 8 +  Else If SalStrLeftX(sPointDescr, 2) = "5-"
.head 9 -  Set sPointDescr = SalStrRightX(sPointDescr, SalStrLength(sPointDescr) - 2)
.head 9 +  If sPointDescr and SalStrIsValidNumber(sPointDescr)
.head 10 -  Set nRes = SalStrToNumber(sPointDescr) - 1
.head 10 +  If nRes
.head 11 -  Set nRes = 49 + nRes
.head 10 +  Else
.head 11 -  Set nRes = 5
.head 8 +  Else
.head 9 +  If SalStrIsValidNumber(sPointDescr)
.head 10 -  Set nRes = SalStrToNumber(sPointDescr)
.head 7 -  Return nRes
.head 5 +  ! Function: PrintCageCardsBeforeCloseRack
.head 6 -  Description: 
.head 6 -  Returns 
.head 6 +  Parameters 
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sCage
.head 7 -  Number: nCageID[*]
.head 7 -  FunctionalVar: oCages[*]
.winattr class
.head 8 -  Class: clsLocation
.end
.head 7 -  FunctionalVar: oCageTmp[*]
.winattr class
.head 8 -  Class: clsLocationCage
.end
.head 7 -  Number: nI
.head 7 -  Number: nMax
.head 7 -  Boolean: bPrint
.head 6 +  Actions 
.head 7 +  If sRack != STRING_Null
.head 8 +  If GalConnect(hSql)
.head 9 -  Call SqlPrepareAndExecute(hSql,"select  g.gruppe_key, g.id from t_cage t
join sysadm.gruppe g on (g.id=t.id and g.stat_key=:sRack)
where t.print_after_close = 1
into :sCage, :nCageID[nI+1]
")
.head 9 -  Set nI= -1
.head 9 +  While SqlFetchNext(hSql,nFetch)
.head 10 -  Set nI= nI + 1
.head 10 -  Call oCageTmp[nI].Init( sScreen, sRack, sCage )
.head 10 -  Set oCages[nI] = oCageTmp[nI]
.head 9 -  Call SqlDisconnect(hSql)
.head 8 +  If nI > -1
.head 9 -  Set nMax = nI
.head 9 -  Set nI = 0
.head 9 +  While nI <= nMax
.head 10 -  Call T_CloseCage(  nCageID[nI] )
.head 10 -  Set nI = nI + 1
.head 9 +  If Not Requst_ListForCageCard( oCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 10 -  ! user canceled the action
.head 10 -  Return FALSE
.head 9 -  Call GetTime4Refresh( )
.head 9 +  If bPrint
.head 10 -  Call Formular_CageCard_Print( '', '', dtKHK_RefreshTime )
.head 5 +  Function: PrintCardsOnClose
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nScr
.head 7 -  Number: nRack
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sSelect
.head 7 -  String: sScreen
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Number: nCageID
.head 7 -  Number: nI
.head 7 -  FunctionalVar: oCages[*]
.head 8 -  Class: clsLocation
.head 7 -  FunctionalVar: oCageTmp[*]
.head 8 -  Class: clsLocationCage
.head 7 -  ! Number: nMax
.head 7 -  Boolean: bPrint
.head 7 -  Number: nPrint
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If nScr = NUMBER_Null
.head 8 -  Set bOk = FALSE
.head 7 -  Set bOk = bOk and GalConnect(hSql)
.head 7 +  If bOk
.head 8 -  Set sSelect = "select  g.gruppe_key, g.id, g.stat_key, a.abt_key, @nullvalue(t.print_after_close,0) from t_cage t
join sysadm.gruppe g on (g.id=t.id )
left join sysadm.abteilung a on(a.id=t.scr_id)
where 1=1"
.head 8 +  If nScr 
.head 9 -  Set sSelect = sSelect || " and t.scr_id=:nScr "
.head 8 +  If nRack
.head 9 -  Set sSelect = sSelect || " and g.rack_id=:nRack "
.head 8 -  Set sSelect = sSelect || "
into :sCage, :nCageID, :sRack, :sScreen, :nPrint "
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSql,sSelect)
.head 8 -  Set nI = 0
.head 8 +  While bOk and SqlFetchNext(hSql,nFetch)
.head 9 +  If nPrint = 1
.head 10 -  Call oCageTmp[nI].Init( sScreen, sRack, sCage )
.head 10 -  Set oCages[nI] = oCageTmp[nI]
.head 10 -  Set nI = nI  + 1
.head 9 -  Call T_CloseCage(  nCageID )
.head 8 +  If bOk and not SalArrayIsEmpty( oCages )
.head 9 +  If Not Requst_ListForCageCard( oCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 10 -  ! user canceled the action
.head 10 -  Set bOk = FALSE
.head 10 -  ! Return FALSE
.head 9 -  ! Call GetTime4Refresh( )
.head 9 +  If bPrint and bOk
.head 10 -  Call Formular_CageCard_Print( '', '', SalDateCurrent(  ) )
.head 7 +  If hSql
.head 8 -  Call SqlDisconnect( hSql )
.head 7 -  Return bOk
.head 5 +  Function: CheckIsPlugged
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Boolean: bPlugged
.head 6 +  Actions
.head 7 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 7 -  Set bPlugged = FALSE
.head 7 +  If oPos != OBJ_Null
.head 8 +  If oPos.nPosID and nSelectedLevel = KHEL_Bett
.head 9 -  Call SqlExists( "select * 
  from fall f ,relship_fall r 
  where f.POS_ID=:oPos.nPosID  and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and r.einricht_id = f.einricht_id and r.fall_key=f.fall_key  and r.plugged is not null", bPlugged )
.head 8 +  Else If oPos.nCageID and nSelectedLevel = KHEL_Gruppe
.head 9 -  Call SqlExists( "select * 
  from fall f ,relship_fall r 
  where f.LAST_CAGE_ID=:oPos.nCageID  and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   and r.einricht_id = f.einricht_id and r.fall_key=f.fall_key  and r.plugged is not null", bPlugged )
.head 7 -  Return bPlugged
.head 5 +  Function: ClearPlug
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  !
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 6 +  Actions
.head 7 +  If GalConnect(hSql)
.head 8 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 8 +  If oPos != OBJ_Null
.head 9 +  If oPos.nPosID and nSelectedLevel = KHEL_Bett
.head 10 -  Set bOk = SqlPrepareAndExecute( hSql, "Update relship_fall set plugged='' where einricht_id=:nEinrichtId and fall_key = (select f.fall_key from fall f where  f.POS_ID=:oPos.nPosID  and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J' ) " )
.head 9 +  Else If oPos.nCageID and nSelectedLevel = KHEL_Gruppe
.head 10 -  Set bOk = SqlPrepareAndExecute( hSql, "Update relship_fall set plugged='' where einricht_id=:nEinrichtId and fall_key in (select f.fall_key from fall f where  f.LAST_CAGE_ID=:oPos.nCageID  and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J' ) " )
.head 9 +  Else
.head 10 -  Set bOk = TRUE
.head 8 +  Else
.head 9 -  Set bOk = FALSE
.head 8 +  If bOk
.head 9 -  Call SqlCommit( hSql )
.head 8 +  Else
.head 9 -  Call SqlPrepareAndExecute(hSql , "rollback" )
.head 8 +  If bOk
.head 9 -  Call Rack2DView_RefreshCageContents(oPos.sCage)
.head 9 -  Call SalSendMsg(hWndForm,AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 9 -  ! Call clsExplorerLeft.KHEReAssignPics(nSelectedHandle)
.head 9 -  Call cDest.Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 9 -  Set cSourceCage[0] = cDest
.head 9 -  Call Move_PrintCageCards(cSourceCage,cDest)
.head 8 -  Call SqlDisconnect( hSql )
.head 5 +  Function: CanMate
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlRoling
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Number: nFetch
.head 7 -  Number: nBound
.head 7 -  Number: nFallKey
.head 7 -  Number: nCageId
.head 7 -  Number: i
.head 7 -  String: sFalls
.head 7 -  String: sSex
.head 7 -  Number: nCount
.head 7 -  Number: nCountW
.head 7 -  Number: nCountM
.head 7 -  Number: nCountAnimal
.head 7 -  Number: nPrevCageId
.head 7 -  Boolean: bStockMale
.head 7 -  Boolean: bStockFeMale
.head 7 -  String: sPrevSex
.head 7 -  Number: nCountEmptyCage
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set bOk = bOk and nSelectedLevel = KHEL_Gruppe and not CageIsEmpty_ByHandle()
.head 7 -  Set bOk = bOk and GalConnect( hSqlRoling )
.head 7 -  Set bOk = bOk and _GetPositionID(nSelectedHandle, oPos)
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlRoling,"select * from cadavers where rack=:oPos.sRack  and cage=:oPos.sCage  " )
.head 7 +  If bOk and SqlFetchNext( hSqlRoling, nFetch )
.head 8 -  Set bOk = FALSE
.head 7 -  Call DelNul()
.head 7 +  If bOk
.head 8 +  If not SalArrayIsEmpty( HandleToPlace )
.head 9 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 9 -  Call SqlPrepare( hSqlRoling,  "select rf.fall_key
  from roling_fall rf
where rf.status = 0  and rf.fall_key=:nFallKey

union

select b.fall_key
 from sysadm.bewegung b
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.fall_key = :nFallKey
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 9 -  Set i = 0
.head 9 -  Set sFalls = ""
.head 9 +  Loop
.head 10 +  If i > nBound or not bOk
.head 11 -  Break
.head 10 -  Set nFallKey = HandleToPlace[i,0]
.head 10 -  Set sFalls = sFalls || SalNumberToStrX(nFallKey, 0) || ", "
.head 10 +  If SqlExecute( hSqlRoling )
.head 11 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 12 -  ! Call SqlDisconnect( hSqlRoling )
.head 12 -  Set bOk =  FALSE
.head 10 -  Set i = i + 1
.head 9 +  If bOk
.head 10 -  Call SalStrLeft( sFalls, SalStrLength( sFalls ) - 2, sFalls )
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlRoling, "select f.fall_key
  from fall f
  , fall f2   where f.einricht_id=1
    and f.fall_key in (" || sFalls || ")
and f.culling_id is null and f.geloescht = 'N'
and f.geschl='M'
and f2.fall_key in (" || sFalls || ")  and f2.geschl='W'
and f.LAST_CAGE_ID=f2.LAST_CAGE_ID" )
.head 9 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 10 -  Set bOk =  FALSE
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute (hSqlRoling, "select geschl, count(geschl)
  from fall
  where einricht_id=:nEinrichtId
    and fall_key in (" || sFalls || ")
and culling_id is null and geloescht = 'N'
group by 1
into :sSex , :nCount ")
.head 9 +  While bOk and SqlFetchNext(hSqlRoling, nFetch)
.head 10 +  If sSex = 'M'
.head 11 -  Set nCountM = nCount
.head 10 +  Else
.head 11 -  Set nCountW = nCount
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlRoling, "select count(t.id) 
  from "|| sUserName ||".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null )
where f.geschl is null
having  count(f.fall_key)-count(f.culling_id)=0
into :nCountEmptyCage ")
.head 9 -  Set bOk = bOk and SqlFetchNext(hSqlRoling, nFetch)
.head 9 -  Set bOk = bOk and ( (bMassMating and nCountM <= nCountEmptyCage ) or (not bMassMating and (nBound-nFem)=1) ) and ((nFem=1 and nCountW=2*nCountM ) or (nFem=0 and nCountW=nCountM) ) and (nBound = nCountM + nCountW - 1)
.head 9 +  ! If bMassMating
.head 10 -  Set bOk = bOk and nCountM =1 and ((nFem=1 and nBound =2 and nCountW=2 ) or (nFem=0 and nBound =1 and nCountW=1) )
.head 9 +  ! Else
.head 10 -  Set bOk = bOk and nCountM =1 and ((nFem=1 and nBound =2 and nCountW=2 ) or (nFem=0 and nBound =1 and nCountW=1) )
.head 8 +  Else
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlRoling, "select *
  from " || sUserName || ".t_cage t
       join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null and f.culling_id is null),
   relship_fall rf
where
       rf.einricht_id=f.einricht_id
and rf.fall_key=f.fall_KEY
and rf.FALLROLLE_KEY='MATE'
and ( (@Nullvalue(rf.RS_FALL_VALID, 01.01.2500)>@Now)
      or rf.plugged is not null
      or exists (select lc.litter_id from litter_child lc, litter l
                                         where l.place_relship_id=rf.relship_id
                                             and l.FAMILY_RELSHIP_ID in (select r2.relship_id from relship_fall r2
                                                                                                         where r2.einricht_id = f.einricht_id and r2.fall_key = f.fall_key and r2.fallrolle_key = 'PARENT')
                                             and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0
                                             and (lc.LITTER_REASON !='MISS' or lc.LITTER_REASON is null)
                                             and @NULLVALUE(l.miss, 0) = 0 )
     or exists(select kk.place_relship_id from litter kk , relship_fall rf2
                                          where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id )
		                              and rf2.relship_id = kk.FAMILY_RELSHIP_ID
                                              and rf2.einricht_id=f.einricht_id and rf2.fall_key=f.fall_key)
      
)")
.head 9 -  Set bOk = bOk and not SqlFetchNext( hSqlRoling, nFetch )
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlRoling, "select t.id, f.geschl,  count(f.fall_key) - count(f.culling_id) 
  from " || sUserName || ".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null and f.culling_id is null )
group by 1,2
having  count(f.fall_key)-count(f.culling_id)>0
order by 1, 3 desc,  2
into :nCageId, :sSex, :nCountAnimal  ")
.head 9 -  Set nPrevCageId= 0
.head 9 -  Set sPrevSex = ""
.head 9 -  Set nCountW = 0
.head 9 -  Set nCountM = 0
.head 9 -  Set nBound = 0
.head 9 +  While bOk and SqlFetchNext(hSqlRoling, nFetch)
.head 10 +  If nPrevCageId!=nCageId
.head 11 -  Set nPrevCageId=nCageId
.head 11 -  Set sPrevSex = sSex
.head 11 -  Set bStockMale = (nCountM> 0 and nCountW=0) or bStockMale
.head 11 -  Set bStockFeMale =(nCountW> 0 and nCountM=0) or bStockFeMale
.head 11 -  Set bOk = bOk and not(nCountW> 0 and nCountM>0)
.head 11 +  If bOk
.head 12 -  Set nBound = nBound + nCountW
.head 11 +  ! If nCountM> 0 and nCountW=0
.head 12 -  Set bStockMale = TRUE
.head 11 +  ! Else If nCountW >0 and nCountM=0
.head 12 -  Set bStockFeMale = TRUE
.head 11 +  ! Else If CountW> 0 and nCountM>0
.head 12 -  Set bOk = FALSE
.head 11 -  Set nCountW = 0
.head 11 -  Set nCountM = nCountW
.head 10 +  If sSex = 'M' 
.head 11 -  Set nCountM = nCountAnimal
.head 10 +  Else
.head 11 -  Set nCountW = nCountAnimal
.head 9 -  Set bStockMale = (nCountM> 0 and nCountW=0) or bStockMale
.head 9 -  Set bStockFeMale =(nCountW> 0 and nCountM=0) or bStockFeMale
.head 9 -  Set bOk = bOk and not(nCountW> 0 and nCountM>0)
.head 9 +  If bOk
.head 10 -  Set nBound = nBound + nCountW
.head 9 +  ! If bOk
.head 10 +  If nCountM> 0 and nCountW=0
.head 11 -  Set bStockMale = TRUE
.head 10 +  Else If nCountW> 0 and nCountM=0
.head 11 -  Set bStockFeMale = TRUE
.head 10 +  Else If CountW> 0 and nCountM>0
.head 11 -  Set bOk = FALSE
.head 9 -  Set bOk = bOk and bStockMale and bStockFeMale and (nBound - nFem ) > 0
.head 7 +  If hSqlRoling
.head 8 -  Call SqlDisconnect( hSqlRoling )
.head 7 -  Return bOk
.head 7 -  !
.head 7 +  ! If not GalConnect( hSqlRoling )
.head 8 -  Return FALSE
.head 7 -  ! Set bExists = FALSE
.head 7 -  ! Set sGrpKey = GetKey_ByHandle( nSelectedHandle )
.head 7 -  ! Set hSta = GetParent( nSelectedHandle )
.head 7 -  ! Set sStatKey = GetKey_ByHandle( hSta )
.head 7 +  ! If SqlPrepareAndExecute( hSqlRoling, "select * from cadavers where rack=:sStatKey  and cage=:sGrpKey  " )
.head 8 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 9 -  Set bExists = TRUE
.head 7 -  ! Call DelNul()
.head 7 +  ! If not bExists
.head 8 +  If not SalArrayIsEmpty( HandleToPlace )
.head 9 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound )
.head 9 -  Call SqlPrepare( hSqlRoling,  "select rf.fall_key
  from roling_fall rf
where rf.status = 0  and rf.fall_key=:nFallKey

union

select b.fall_key
 from sysadm.bewegung b
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.fall_key = :nFallKey
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 9 +  If bMassMating
.head 10 -  Set nNext=0
.head 10 -  Set bMale=FALSE
.head 10 -  Set bFeMale=FALSE
.head 10 -  Set bFeMale2=FALSE
.head 10 +  If nFem=1 and nBound = 2
.head 11 +  While nNext<=nBound
.head 12 -  Set nFallKey = HandleToPlace[nNext,1]
.head 12 +  If SqlExecute( hSqlRoling )
.head 13 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 14 -  Call SqlDisconnect( hSqlRoling )
.head 14 -  Return FALSE
.head 12 -  Call GetItemData( HandleToPlace[nNext,1], sText2, nValueLoc2, nFlags2 )
.head 12 +  If Not SalStrScan(sText2," T ")>0
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =1
.head 14 -  Set bMale=TRUE
.head 14 +  If not hSourceMale
.head 15 -  Set hSourceMale = GetParent( HandleToPlace[nNext,1] )
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =0
.head 14 +  If bFeMale
.head 15 -  Set bFeMale2=TRUE
.head 15 -  Set hSourceFem2 = GetParent( HandleToPlace[nNext,1] )
.head 14 +  Else 
.head 15 -  Set bFeMale=TRUE
.head 15 -  Set hSourceFem = GetParent( HandleToPlace[nNext,1] )
.head 12 +  Else 
.head 13 -  Return FALSE
.head 12 -  Set nNext=nNext+1
.head 11 +  If bMale and bFeMale and bFeMale2 and hSourceFem != hSourceMale and hSourceFem2 != hSourceMale
.head 12 -  Return TRUE
.head 10 +  If nFem=0 and nBound = 1
.head 11 +  While nNext<=nBound
.head 12 -  Call GetItemData( HandleToPlace[nNext,1], sText2, nValueLoc2, nFlags2 )
.head 12 +  If Not SalStrScan(sText2," T ")>0
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =1
.head 14 -  Set bMale=TRUE
.head 14 +  If not hSourceMale
.head 15 -  Set hSourceMale = GetParent( HandleToPlace[nNext,1] )
.head 13 +  If (GetSex_ByHandle(HandleToPlace[nNext,1])) =0
.head 14 -  Set bFeMale=TRUE
.head 14 +  If not hSourceFem
.head 15 -  Set hSourceFem = GetParent( HandleToPlace[nNext,1] )
.head 12 +  Else 
.head 13 -  Return FALSE
.head 12 -  Set nNext=nNext+1
.head 11 +  If bMale and bFeMale and hSourceFem != hSourceMale
.head 12 -  Return TRUE
.head 9 +  Else 
.head 10 -  Set i = 0
.head 10 +  Loop 
.head 11 +  If i > nBound
.head 12 -  Break 
.head 11 -  Set nFallKey = HandleToPlace[i,1]
.head 11 +  If SqlExecute( hSqlRoling )
.head 12 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 13 -  Call SqlDisconnect( hSqlRoling )
.head 13 -  Return FALSE
.head 11 -  Set i = i + 1
.head 10 -  Call GetItemData( HandleToPlace[0,1], sText2, nValueLoc2, nFlags2 )
.head 10 +  If Not SalStrScan(sText2," T ")>0
.head 11 -  Call GetItemData( HandleToPlace[1,1], sText2, nValueLoc2, nFlags2 )
.head 11 +  If Not SalStrScan(sText2," T ")>0
.head 12 +  If nFem=1 and nBound =2
.head 13 +  If ((GetSex_ByHandle(HandleToPlace[0,1]))+ (GetSex_ByHandle(HandleToPlace[1,1]))+(GetSex_ByHandle(HandleToPlace[2,1])))= 1
.head 14 -  Return TRUE
.head 12 +  If nFem=0 and nBound =1
.head 13 -  Call GetItemData( HandleToPlace[1,1], sText2, nValueLoc2, nFlags2 )
.head 13 +  If Not SalStrScan(sText2," T ")>0
.head 14 +  If ((GetSex_ByHandle(HandleToPlace[0,1])) + (GetSex_ByHandle(HandleToPlace[1,1]))) = 1
.head 15 -  Return TRUE
.head 9 -  Return FALSE
.head 8 +  Else 
.head 9 -  Set sAbtKey = ""
.head 9 -  Set sStatKey = ""
.head 9 -  Set sGrpKey = ""
.head 9 -  Set sGrpKey = GetKey_ByHandle( nSelectedHandle )
.head 9 -  Set hSta = GetParent( nSelectedHandle )
.head 9 -  Set sStatKey = GetKey_ByHandle( hSta )
.head 9 -  Set hAbt = GetParent( hSta )
.head 9 -  Set sAbtKey = GetKey_ByHandle( hAbt )
.head 9 -  Call SqlPrepare( hSqlRoling,  "select rf.fall_key
  from roling_fall rf join sysadm.bewegung b on (   b.einricht_id = :nEinrichtId and rf.fall_key= b.fall_key
						     and b.stat_key=:sStatKey  and b.gruppe_key = :sGrpKey
						     and @nullvalue(b.GELOESCHT,'N') ='N'
   			     and b.ba_key in ('AE','VE','UE','RE')
     			     and 	b.bew_zeit_bis is null )
 left join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
where rf.status = 0

union

select b.fall_key
 from sysadm.bewegung b
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.stat_key=:sStatKey and b.gruppe_key = :sGrpKey
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 9 -  ! ! Chek selected cage
.head 9 +  If TRUE
.head 10 -  Set nBet = EnumChildren( nSelectedHandle, hBet )
.head 10 -  ! If nBet=1
.head 10 -  Set nBet=  QuantityOfEmptyBett(nSelectedHandle)
.head 10 -  Set bE=TRUE
.head 10 +  If nBet
.head 11 -  Set l = 0
.head 11 +  Loop 
.head 12 +  If l >= nBet
.head 13 -  Break 
.head 12 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 12 +  If SalStrScan(sText2,"{") > 0
.head 13 -  Set bE=FALSE
.head 13 -  Break 
.head 12 -  Set l = l + 1
.head 11 -  !
.head 10 +  ! If bE and nBet >= 2+nFem and (not GetIsRackVirtual_ByHandle(hSta) or bPlanningMode)
.head 11 -  Set sMetingSt=sStatKey
.head 11 -  Set sMetingGr=sGrpKey
.head 11 -  Set hTarget=nSelectedHandle
.head 10 +  If bE and nBet >= 2+nFem
.head 11 -  Set sMetingSt=sStatKey
.head 11 -  Set sMetingGr=sGrpKey
.head 11 -  Set hTarget=nSelectedHandle
.head 10 +  Else 
.head 11 -  Return FALSE
.head 9 -  Set nStat = EnumChildren( hAbt, hStat )
.head 9 +  If nStat
.head 10 -  Set i = 0
.head 10 +  Loop 
.head 11 +  If i >= nStat
.head 12 -  Break 
.head 11 -  Call GetItemData( hStat[ i ], sText, nValueLoc, nFlags )
.head 11 -  Set sStatKey = GetKey_FromLable (sText)
.head 11 -  Set nGrp = EnumChildren( hStat[ i ], hGrp )
.head 11 +  If nGrp
.head 12 -  Set k = 0
.head 12 +  Loop 
.head 13 +  If k >= nGrp
.head 14 -  Break 
.head 13 -  Call GetItemData( hGrp[ k ], sText1, nValueLoc1, nFlags1 )
.head 13 +  ! If SalStrScan(sText1, "MTT")>0
.head 14 -  Return FALSE
.head 13 -  ! --------------- chek cage ---------------
.head 13 -  Set sGrpKey = GetKey_FromLable (sText1)
.head 13 +  If SqlExecute( hSqlRoling )
.head 14 +  If SqlFetchNext( hSqlRoling, nFetch )
.head 15 -  Call SqlDisconnect( hSqlRoling )
.head 15 -  Return FALSE
.head 13 -  Set nBet = EnumChildren( hGrp[ k ], hBet )
.head 13 -  Set bF=FALSE
.head 13 -  Set bM=FALSE
.head 13 -  Set hFT=0
.head 13 -  Set hFT1=0
.head 13 -  Set hMT=0
.head 13 +  If nBet
.head 14 -  Set l = 0
.head 14 +  Loop 
.head 15 +  If l >= nBet
.head 16 -  Break 
.head 15 -  Call GetItemData( hBet[ l ], sText2, nValueLoc2, nFlags2 )
.head 15 -  Set sBetKey = GetKey_FromLable (sText2)
.head 15 +  If SalStrScan(sText2,"{") > 0
.head 16 +  If Not SalStrScan(sText2,"(PB)")>0 and Not SalStrScan(sText2," T ")>0
.head 17 +  If SalStrScan(sText2, ", F,")>0
.head 18 -  Set bF=TRUE
.head 18 +  If not hFT1 and nFem=1 and hFT
.head 19 -  Set hFT1=hBet[ l ]
.head 18 +  If not hFT
.head 19 -  Set hFT=hBet[ l ]
.head 17 +  If SalStrScan(sText2, ", M,")>0
.head 18 -  Set bM=TRUE
.head 18 +  If not hMT
.head 19 -  Set hMT=hBet[ l ]
.head 15 -  Set l = l + 1
.head 14 -  !
.head 13 +  If not (bM or bF) and nBet >= 2+nFem and not hTarget
.head 14 +  ! If not GetIsRackVirtual_ByHandle(hStat[ i ]) or bPlanningMode
.head 15 -  Set sMetingSt=sStatKey
.head 15 -  Set sMetingGr=sGrpKey
.head 15 -  Set hTarget=hGrp[ k ]
.head 14 -  Set sMetingSt=sStatKey
.head 14 -  Set sMetingGr=sGrpKey
.head 14 -  Set hTarget=hGrp[ k ]
.head 13 +  If bM and not bF and not hBetMale
.head 14 -  Set hBetMale= hMT
.head 14 -  Set nMale= GetFallKey_ByHandle(hMT)
.head 14 -  Set hSourceMale=hGrp[ k ]
.head 13 +  If bF and not bM and not hBetFem and ( not nFem or hFT1 )
.head 14 -  Set hBetFem= hFT
.head 14 -  Set nFemale= GetFallKey_ByHandle(hFT)
.head 14 -  Set hSourceFem=hGrp[ k ]
.head 14 +  If not nFemale2 and nFem
.head 15 -  Set nFemale2= GetFallKey_ByHandle(hFT1)
.head 15 -  Set hBetFem= hFT1
.head 13 -  ! ------ if all vars found - stop
.head 13 +  If hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 14 -  Break 
.head 13 -  Set k = k + 1
.head 11 -  ! ------ if all vars found - stop
.head 11 +  If hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 12 -  Break 
.head 11 -  Set i = i + 1
.head 9 -  Call SqlDisconnect( hSqlRoling )
.head 9 -  Return hBetMale and hBetFem and hTarget and( not nFem or nFemale2)
.head 7 -  ! Return FALSE
.head 5 +  Function: CanMoveTransferCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Receive Number: nType ! 1 - Move cages ; 2 - Transfer cages
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlCheck
.head 7 -  Number: nFetch
.head 7 -  Number: nScreenTarget
.head 7 -  Number: nScreenSource
.head 7 -  Number: nScreenPrev
.head 7 -  Number: nCount
.head 7 -  Number: nCountTargetCages
.head 7 -  Number: nCountSourceCages
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bOk = FALSE
.head 7 -  Set nType = 2
.head 7 +  If nSelectedHandle ! = KHEL_Einrichtung and nSelectedHandle ! = KHEL_Bett
.head 8 -  Set bOk = TRUE
.head 7 +  If not SalArrayIsEmpty( HandleToPlace )
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk and GalConnect(hSqlCheck)
.head 8 -  Set bOk = TRUE
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlCheck, "select t.scr_id,count(t.id)
into :nScreenTarget, :nCount
 from "|| sUserName ||".t_cage t
where  not exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null   and f.geloescht='N' )
group by 1
")
.head 8 -  Set nScreenPrev = -1000
.head 8 +  While SqlFetchNext(hSqlCheck,nFetch ) and bOk
.head 9 +  If nScreenPrev = -1000
.head 10 -  Set nScreenPrev = nScreenTarget
.head 9 +  Else
.head 10 +  If nScreenPrev != nScreenTarget
.head 11 -  Set bOk = FALSE
.head 9 -  Set nCountTargetCages = nCount
.head 8 -  Set nScreenPrev = -1000
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlCheck, "select t.scr_id,count(t.id)
into :nScreenSource, :nCount
 from "|| sUserName ||".t_cage t
where  exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null and f.geloescht='N' )
group by 1
")
.head 8 +  While SqlFetchNext(hSqlCheck,nFetch ) and bOk
.head 9 +  If nScreenPrev = -1000
.head 10 -  Set nScreenPrev = nScreenSource
.head 9 +  Else
.head 10 +  If nScreenPrev != nScreenSource
.head 11 -  Set bOk = FALSE
.head 9 -  Set nCountSourceCages = nCount
.head 8 -  Set bOk = bOk and (nCountTargetCages=nCountSourceCages) and nCountTargetCages > 0
.head 8 +  If nScreenSource = nScreenTarget
.head 9 -  Set nType = 1
.head 8 -  Call SqlDisconnect( hSqlCheck )
.head 7 -  Return bOk
.head 5 +  Function: MoveTransferCages
.head 6 -  Description: Shift cages between screens and racks
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oSourceCage[*]
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oTargetCage[*]
.head 8 -  Class: cPositionData
.head 7 -  Number: nTCage
.head 7 -  Number: nSCage
.head 7 -  FunctionalVar: oCurPos
.head 8 -  Class: cPositionData
.head 7 -  Number: hScreen[*]
.head 7 -  Number: hRack[*]
.head 7 -  Number: hCage[*]
.head 7 -  Number: nScreens
.head 7 -  Number: nRacks
.head 7 -  Number: nCages
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nJ
.head 7 -  Boolean: bShowDialog
.head 7 -  Window Handle: hWndProgress
.head 7 -  String: sText
.head 7 -  Boolean: bSaveLicence
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nIndCage
.head 7 -  Number: nType
.head 7 -  Sql Handle: hSql
.head 7 -  Number: hStat
.head 7 -  Boolean: bNeedShowSR
.head 7 -  String: sListCages
.head 6 +  Actions
.head 7 +  If CanMoveTransferCages(nType)
.head 8 -  ! Claer Arrays
.head 8 -  Set sListCages = ""
.head 8 -  Call SalSetArrayBounds( nTransferredFalls, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oSourceCage, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oTargetCage, 1, -1 )
.head 8 -  ! Find open cages and save informations 
.head 8 -  Call EnumChildren( hRoot, hScreen )
.head 8 -  Call SalArrayGetUpperBound( hScreen, 1, nScreens )
.head 8 +  If SalArrayIsEmpty( hScreen )
.head 9 -  Set nScreens = -1
.head 8 -  Set nI = 0
.head 8 -  Set nTCage = 0
.head 8 -  Set nSCage = 0
.head 8 +  While nI <= nScreens
.head 9 -  Call EnumChildren( hScreen[nI], hRack )
.head 9 -  Call SalArrayGetUpperBound( hRack, 1, nRacks )
.head 9 +  If SalArrayIsEmpty( hRack )
.head 10 -  Set nRacks = -1
.head 9 -  Set nK=0
.head 9 +  While nK <= nRacks
.head 10 -  Call EnumChildren( hRack[nK], hCage )
.head 10 -  Call SalArrayGetUpperBound( hCage, 1, nCages )
.head 10 +  If SalArrayIsEmpty( hCage )
.head 11 -  Set nCages = -1
.head 10 -  Set nJ=0
.head 10 +  While nJ <= nCages
.head 11 -  Call _GetPositionID( hCage[nJ], oCurPos )
.head 11 -  Set oCurPos.nActHandel = hCage[nJ]
.head 11 +  If not CageIsEmpty( oCurPos.sRack, oCurPos.sCage, SalDateCurrent(  ), TRUE )
.head 12 -  Set oTargetCage[nTCage].nActHandel = oCurPos.nActHandel
.head 12 -  Set oTargetCage[nTCage].nCageID = oCurPos.nCageID
.head 12 -  Set oTargetCage[nTCage].nPosID= oCurPos.nPosID
.head 12 -  Set oTargetCage[nTCage].nRackID = oCurPos.nRackID
.head 12 -  Set oTargetCage[nTCage].nScreenID= oCurPos.nScreenID
.head 12 -  Set oTargetCage[nTCage].sBett= oCurPos.sBett
.head 12 -  Set oTargetCage[nTCage].sCage= oCurPos.sCage
.head 12 -  Set oTargetCage[nTCage].sRack= oCurPos.sRack
.head 12 -  Set oTargetCage[nTCage].sScreen= oCurPos.sScreen
.head 12 -  Set nTCage = nTCage + 1
.head 11 +  Else
.head 12 -  Set oSourceCage[nSCage].nActHandel = oCurPos.nActHandel
.head 12 -  Set oSourceCage[nSCage].nCageID = oCurPos.nCageID
.head 12 -  Set oSourceCage[nSCage].nPosID= oCurPos.nPosID
.head 12 -  Set oSourceCage[nSCage].nRackID = oCurPos.nRackID
.head 12 -  Set oSourceCage[nSCage].nScreenID= oCurPos.nScreenID
.head 12 -  Set oSourceCage[nSCage].sBett= oCurPos.sBett
.head 12 -  Set oSourceCage[nSCage].sCage= oCurPos.sCage
.head 12 -  Set oSourceCage[nSCage].sRack= oCurPos.sRack
.head 12 -  Set oSourceCage[nSCage].sScreen= oCurPos.sScreen
.head 12 -  Set nSCage = nSCage + 1
.head 12 -  Set sListCages = sListCages || oCurPos.sCage || ","
.head 12 +  If bAskForLicense
.head 13 -  Call PrepareTransferFalls( oCurPos.sRack, oCurPos.sCage, SalDateCurrent(  ) )
.head 11 -  Set nJ = nJ +1
.head 10 -  Set nK = nK +1
.head 9 -  Set nI = nI +1
.head 8 -  Set bShowDialog = GetOptionBoolean("KHE", "ShowDialogMoveTransferCages", TRUE  )
.head 8 +  If sListCages != ""
.head 9 -  Call SalStrLeft( sListCages, SalStrLength( sListCages ) - 1 , sListCages )
.head 8 +  If not bPlanningMode and not bShowDialog or SalModalDialog( dlgTransferCages, hWndForm, oSourceCage, oTargetCage, nType ) = IDOK
.head 9 -  Call LockSysadmAction( "Start transfer cages")
.head 9 -  Set bNeedShowSR = FALSE
.head 9 +  If SalIsWindowVisible( hWndRack2DView )
.head 10 -  ! Call SalHideWindow( hWndRack2DView )
.head 10 -  Call VisWinShow (hWndRack2DView, SHOW_Minimized)
.head 10 -  Set bNeedShowSR = TRUE
.head 9 -  Set bSaveLicence = bAskForLicense
.head 9 -  Set bAskForLicense = FALSE
.head 9 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nSCage  )
.head 9 -  Set nI = 0
.head 9 -  Set nIndCage = 0
.head 9 +  While nI < nSCage
.head 10 +  If hWndProgress
.head 11 -  Set sText = "Move cage " ||oSourceCage[nI].sScreen|| "/" ||oSourceCage[nI].sRack ||"/" ||oSourceCage[nI].sCage 
.head 11 -  Set sText = sText || " to  cage" || oTargetCage[nI].sScreen|| "/" || oTargetCage[nI].sRack ||"/" ||oTargetCage[nI].sCage
.head 11 -  Call dlgProgress.Init( nSCage, sText)
.head 11 -  Set dlgProgress.nCurrent = nI
.head 11 -  Call dlgProgress.Next(  )
.head 10 -  Call MoveCage( oSourceCage[nI].sScreen, oSourceCage[nI].sRack, oSourceCage[nI].sCage, oTargetCage[nI].sScreen, oTargetCage[nI].sRack, oTargetCage[nI].sCage, SalDateCurrent() )
.head 10 -  Call CloseGruppe(oSourceCage[nI].sScreen, oSourceCage[nI].sRack, oSourceCage[nI].sCage)
.head 10 -  ! Call KHE_RefreshGruppe(oSourceCage[nI].nActHandel)
.head 10 -  Call KHE_RefreshGruppe(oTargetCage[nI].nActHandel)
.head 10 -  Call cSourceCage[nIndCage].Init( oTargetCage[nI].sScreen, oTargetCage[nI].sRack, oTargetCage[nI].sCage )
.head 10 -  Set nIndCage = nIndCage + 1
.head 10 -  Set nI = nI + 1
.head 9 -  Set cDest = cSourceCage[nIndCage - 1]
.head 9 -  Set bAskForLicense = bSaveLicence
.head 9 +  If GalConnect(hSql)
.head 10 -  Call SqlPrepareAndExecute(hSql, "lock table xlock")
.head 10 -  Call SqlPrepareAndExecute(hSql, "lock table bewegung")
.head 10 -  Call SqlPrepareAndExecute(hSql, "lock table fall")
.head 9 -  ! Call SalHideWindow(hWndRack2DView)
.head 9 -  ! Call SalPause(600)
.head 9 -  Call GetTime4Refresh()
.head 9 -  ! Call GoToStat(oTargetCage[nI-1].sScreen, oTargetCage[nI-1].sRack,TRUE)
.head 9 -  ! Call ActivateSelectedItem(  )
.head 9 +  ! If nType = 1
.head 10 -  Call SalSendMsg( Window_Handle, Number, Number, Number )
.head 10 -  If SalIsWindowVisible( hWndRack2DView )
.head 9 -  ! Call Rack2DView_RefreshCageContents('')
.head 9 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 10 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,0)
.head 9 +  If bAskForLicense and oSourceCage[0].sScreen != oTargetCage[0].sScreen
.head 10 -  Call SetMassLicense( nTransferredFalls, oTargetCage[0].sScreen)
.head 9 +  If not SalArrayIsEmpty( cSourceCage )
.head 10 -  Call Move_PrintCageCards(cSourceCage,cDest)
.head 9 -  ! Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber(sListCages ) )
.head 9 -  ! Call GoToStat(oTargetCage[nI-1].sScreen, oTargetCage[nI-1].sRack,FALSE)
.head 9 -  !
.head 9 -  ! Set hStat = GetParent( oTargetCage[nI-1].nActHandel )
.head 9 +  If TRUE
.head 10 -  Set hStat = FindH_4Station( FindH_4Abteilung( oTargetCage[nI-1].sScreen ), oTargetCage[nI-1].sRack, FALSE )
.head 10 -  Call PopulateAndExpand( hStat, TRUE )
.head 10 -  Set nIndex = GetItemIndex( hStat )
.head 10 -  If SalListSetSelect( hWndItem, nIndex )
.head 10 -  Call ActivateSelectedItem(  )
.head 9 -  ! Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_FullRefresh, SalHStringToNumber(oTargetCage[nI-1].sScreen || ";" || oTargetCage[nI-1].sRack ) )
.head 9 -  ! Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber("" ) )
.head 9 -  Call VisWinShow (hWndRack2DView, SHOW_Normal)
.head 9 -  Call SalPostMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 9 +  If bAskForLicense and oSourceCage[0].sScreen != oTargetCage[0].sScreen
.head 10 -  Call SalPostMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 9 -  ! Call KHE_RefreshAllCages()
.head 9 -  ! Call SalPause(600)
.head 9 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 10 -  Call SalHideWindow( hWndRack2DView )
.head 9 -  ! Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_ForceShow, SalHStringToNumber(oTargetCage[nI-1].sScreen||";"||oTargetCage[nI-1].sRack||";"))
.head 9 -  ! Call SalShowWindow( hWndRack2DView )
.head 9 -  ! Call Rack2DView_ReflectButtonsState()
.head 9 -  ! Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_ForceShow, SalHStringToNumber(oTargetCage[nI-1].sScreen||";"||oTargetCage[nI-1].sRack||";") )
.head 9 -  ! Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_FullRefresh , 0 )
.head 9 -  ! Call SalHideWindow( hWndRack2DView )
.head 9 +  ! If bNeedShowSR
.head 10 -  ! Call SalShowWindow( hWndRack2DView )
.head 10 -  Call VisWinShow (hWndRack2DView, SHOW_Normal)
.head 9 -  ! Call SalPostMsg(hWndStar2000,AM_ForceR2DShow,0,0)
.head 9 -  ! Call Rack2DView_RefreshOnTimeChanged()
.head 9 -  ! Call Rack2DView_CheckState(TRUE)
.head 9 -  ! Call Rack2DView_RefreshCageContents("")
.head 9 -  !
.head 9 +  If hWndProgress
.head 10 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 10 -  Set hWndProgress = hWndNULL
.head 9 +  If hSql
.head 10 -  Call SqlCommit( hSql )
.head 10 -  Call SqlDisconnect(hSql)
.head 9 -  Call LockSysadmAction( "Finish transfer cages")
.head 8 -  Call SalSetArrayBounds( nTransferredFalls, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oSourceCage, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oTargetCage, 1, -1 )
.head 5 +  Function: CanPrintCageCard
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set bOk = (nSelectedLevel = KHEL_Gruppe)
.head 7 -  Set bOk = bOk and not KHE_IsOccupied_ByHandle(nSelectedHandle, GetTime4Refresh())
.head 7 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 7 -  Set bOk = bOk and CageIsEmpty(oPos.sRack, oPos.sCage, SalDateCurrent(  ), TRUE )
.head 7 -  Return bOk
.head 5 +  Function: CanShowShiftButton
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Number: nEmpty
.head 7 -  Number: nFtch
.head 6 +  Actions
.head 7 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 7 -  Set bOk = (nSelectedLevel = KHEL_Gruppe)
.head 7 -  Set bOk = bOk and CageIsEmpty(oPos.sRack, oPos.sCage, SalDateCurrent(  ), TRUE )
.head 7 +  If bOk 
.head 8 -  Set bOk = GalConnect(hSqlFind)
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlFind,"select count(t.id)
into :nEmpty
 from "|| sUserName ||".t_cage t
where  not exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null   and f.geloescht='N' )
")
.head 8 +  If bOk 
.head 9 +  If SqlFetchNext(hSqlFind,nFtch )
.head 10 +  If nEmpty > 0
.head 11 -  Set bOk = FALSE
.head 8 +  If hSqlFind
.head 9 -  Call SqlDisconnect(hSqlFind)
.head 7 -  Return bOk
.head 4 -  List Initialization
.head 4 +  Message Actions
.head 5 +  ! On WM_COMMAND
.head 6 +  If not lParam and wParam >= 0xF000
.head 7 -  Return SalSendMsg( hWndItem, WM_SYSCOMMAND, wParam, GetMessagePos( ) )
.head 6 +  Select Case wParam
.head 7 +  Case 1000
.head 8 -  ! Call hWndKHE.clsKHExplorerLeft.KHE_SelectPurpose()
.head 8 -  Call KHE_SelectPurpose()
.head 8 -  Break 
.head 7 +  Case 1001
.head 8 -  ! Call hWndKHE.clsKHExplorerLeft.KHE_SelectColor()
.head 8 -  Call KHE_SelectColor()
.head 8 -  Break 
.head 7 +  Case 1002
.head 8 -  Call KHE_CageCard( )
.head 8 -  Break 
.head 7 +  Case 1003
.head 8 -  Call KHE_PrintCageCard( )
.head 8 -  Break 
.head 7 +  Case 1004
.head 8 -  Call KHE_CageMemberBarcodes( )
.head 8 -  Break 
.head 7 +  Case 1005
.head 8 -  Call SalPostMsg( hWndForm, AM_KHE_Cut, 0, 0 )
.head 8 -  Break 
.head 5 +  ! On SAM_Create
.head 6 -  Set bShowAllAbtStat = (SalStrUpperX( GalConfig_GetStr( 'KHE', 'ALWAYS SHOW ALL ABT/STAT', 'N', cfgDB ) ) = 'J')
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Set hActiveSession = hWndNULL
.head 6 -  Call LoadSettings()
.head 6 -  Call SalColorSet ( hWndItem, COLOR_IndexWindow, nBGColor)
.head 6 +  Set bUseCurrentTime = TRUE
.head 7 -  ! Set bUseCurrentTime = GalConfig_GetBool( "KHE", "UseCurrentTime", TRUE, cfgUSER )
.head 6 +  If bUseCurrentTime
.head 7 -  Call SalPicSet( hWnd_pbSetTime, KHE_ClockW, PIC_FormatBitmap )
.head 6 +  Else 
.head 7 -  Call SalPicSet( hWnd_pbSetTime, KHE_ClockR, PIC_FormatBitmap )
.head 6 -  Set bShowOnlyRealBew = TRUE
.head 6 -  Set bBedIsFree = FALSE
.head 6 -  Set bPastingMovement = FALSE
.head 6 -  Set bInternalRequestMode = FALSE
.head 6 -  Set nCagesFrom2DNr = 0
.head 6 -  Call T_CageCreate()
.head 6 -  ! Set bShowOnlyOpenCages = TRUE
.head 6 +  If not CheckDBVersion( 6.26 )
.head 7 -  Call SalHideWindow( hWndItem )
.head 5 +  ! On SAM_Destroy
.head 6 +  ! If hWnd_POC
.head 7 -  ! Call POC_Open(  )
.head 7 -  Call SalSendMsg( hWnd_POC, SAM_Close, 0, 0 )
.head 6 -  Call GalConfig_SetBool("KHE","AutoMode",bAutoScan, cfgUSER)
.head 6 -  Call SalSendClassMessage( SAM_Destroy,  wParam, lParam  )
.head 5 +  ! On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click, wParam, lParam)
.head 6 -  Call ActivateSelectedItem(  )
.head 6 -  ! Call SalPostMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 6 -  ! Call SalSendMsg( hWndForm, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 5 +  ! On SAM_DoubleClick
.head 6 -  Call OnDoubleClick( wParam, lParam)
.head 5 +  ! On VTM_RightClick
.head 6 -  ! -- Emulate SAM_Click for making proper selection
.head 6 -  Call SalSendMsg(hWndItem,WM_LBUTTONDOWN,wParam,lParam)
.head 6 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 5 +  ! On SAM_ContextMenu
.head 6 -  Call KHE_TrackContextMenu( )
.head 5 +  ! On SAM_DragCanAutoStart
.head 6 -  Return FALSE
.head 5 +  ! On AM_Refresh
.head 6 +  If bShowPlacesWithContent
.head 7 -  Return KHE_RefreshGruppe(nSelectedHandle)
.head 6 +  Else 
.head 7 -  Return PopulateSelectedItem( FALSE )
.head 5 +  ! On AM_Options
.head 6 -  Call KHE_Options(  )
.head 5 -  !
.head 5 +  ! On AM_KHE_CanCut
.head 6 -  Return Move_CanCut(  )
.head 5 +  ! On AM_KHE_CanPaste
.head 6 -  Return Move_CanPaste(  )
.head 5 +  ! On AM_KHE_ForcedPopulateCurrent
.head 6 +  If bShowPlacesWithContent
.head 7 -  Return KHE_RefreshGruppe(nSelectedHandle)
.head 6 -  Return ForcedPopulateCurrent(  )
.head 5 +  ! On AM_KHE_Cut
.head 6 +  If wParam = 1
.head 7 -  Set bMenuCutFallNrX = TRUE
.head 6 +  Else 
.head 7 -  Set bMenuCutFallNrX = FALSE
.head 6 -  Return Move_CutCurrent(  )
.head 5 +  ! On AM_KHE_Paste
.head 6 -  Return Paste( wParam )
.head 5 +  ! On AM_KHE_CollapseRoot
.head 6 -  Return CollapseRoot(  )
.head 5 +  ! On AM_KHE_ExpandAbt
.head 6 -  Return ExpandAbtLevel(  )
.head 5 +  ! On AM_KHE_ExpandStat
.head 6 -  Return ExpandStatLevel(  )
.head 5 +  ! On AM_KHE_ExpandGruppe
.head 6 -  Return ExpandGrpLevel(  )
.head 5 +  ! On AM_KHE_ExpandBett
.head 6 -  Return ExpandBettLevel(  )
.head 5 +  ! On AM_KHE_AutoManual
.head 6 -  Return SetAutoMode( lParam )
.head 5 +  ! On AM_KHE_GroupRelease
.head 6 -  Return Move_GroupRelease( TRUE )
.head 5 +  ! On AM_KHE_GroupCulling
.head 6 -  Return Move_GroupCulling(  )
.head 5 +  ! On AM_KHE_GotoBedByFall
.head 6 +  If GotoBettByFallKey( GalGetAsWinMsgLParam_Number( lParam ), bAutoScan )
.head 7 -  Call Rack2DView_CheckState(FALSE)
.head 7 -  Call MultiSelect()
.head 7 -  Return TRUE
.head 5 +  ! On AM_KHE_GotoGrpByFall
.head 6 -  Return GotoGruppeByFallKey( GalGetAsWinMsgLParam_Number( lParam ), bAutoScan )
.head 5 +  ! On AM_KHE_GotoGrp
.head 6 -  Return GotoGruppeByString( GalGetAsWinMsgWParam_String( wParam ), bAutoScan )
.head 5 +  ! On AM_KHE_Plan2Real_Bew
.head 6 -  ! lParam - FallKey
.head 6 -  ! wParam - BewPlanNr
.head 6 -  Return KHE_Plan2Real_Bew( GalGetAsWinMsgLParam_Number( lParam ), GalGetAsWinMsgWParam_Number( wParam ) )
.head 5 +  ! On AM_KHE_CloseGrp
.head 6 -  Return CloseGruppeByString( GalGetAsWinMsgWParam_String( wParam ) )
.head 5 +  ! On AM_KHE_Download2Reader
.head 6 -  Call KHE_Download2Reader(  )
.head 5 -  !
.head 5 +  ! On AM_OpenFall
.head 6 -  ! Opens Fall for Selected Item
.head 6 +  If (nSelectedLevel = KHEL_Bett) And bCurrentBettHasFall
.head 7 -  Call SalPostMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( nFallKey_OnCurrentBett ) )
.head 5 +  ! On AM_KHE_GrpNeedsRefresh
.head 6 -  Set bGrpNeedsRefresh = TRUE
.head 5 +  ! On AM_BewChange
.head 6 -  ! lParam is FALL_KEY
.head 6 -  ! wParam is BEW_NR
.head 6 -  Call KHE_UpdateGruppeAttributes( lParam, wParam )
.head 5 +  ! On WM_COPYDATA
.head 6 +  If Not MsgCopyData_Receive( sLocation )
.head 7 -  Return FALSE
.head 6 -  Return KHE_Locations_Add( KHE_Locations_StrToObj( sLocation ).GetCage( ) )
.head 5 +  ! On AM_KHE_RefreshItems
.head 6 -  Call KHE_Locations_DoRefresh( )
.head 5 +  ! On AM_ReloadSettings
.head 6 -  Call LoadSettings()
.head 5 +  ! On AM_KHE_MoveCage
.head 6 -  !
.head 6 -  Call Move_CutCurrent()
.head 6 -  Set bMoveFlag = TRUE
.head 6 -  Call GetPosition( hMove_Source, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 6 +  If (SalModalDialog(dlgAskForMoveScreen, hWndForm, sAbtKeySrc, sStatKeyTmp)) and (sMoveScreen != "") and (sMoveScreen!=sStatKeyTmp)
.head 7 -  ! Call Move_PasteToCurrent()
.head 7 -  Call TransferCageInScreen(sAbtKeySrc,sMoveScreen,sStatKeyTmp, sGrpKeyTmp,GetTime4Refresh(  ))
.head 7 -  Call SalSendMsg(hWndStar2000 ,AM_Refresh,2,oPosition.nCageID)
.head 7 -  Call CloseGruppe(sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp)
.head 7 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
					SalHStringToNumber( sAbtKeySrc || ";" || sStatKeyTmp ) )
.head 6 -  Set bMoveFlag = FALSE
.head 6 -  Set sMoveScreen = ""
.head 5 +  ! On AM_KHE_MoveCages
.head 6 -  !
.head 6 -  ! Call Move_CutCurrent()
.head 6 -  Set bMoveFlag = TRUE
.head 6 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 6 +  If lParam = KHEL_Station
.head 7 +  If (SalModalDialog(dlgAskForMoveScreen, hWndForm, sAbtKeySrc, sStatKeyTmp)) and (sMoveScreen != "") and (sMoveScreen!=sStatKeyTmp)
.head 8 -  ! Call Move_PasteToCurrent()
.head 8 -  Call TransferCageInScreens(sAbtKeySrc,sMoveScreen,sStatKeyTmp, GetTime4Refresh(  ))
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
					SalHStringToNumber( sAbtKeySrc || ";" || sStatKeyTmp ) )
.head 6 +  Else If lParam = KHEL_Abteilung
.head 7 +  If (SalModalDialog(dlgAskForMoveScreen, hWndForm, sAbtKeySrc, sStatKeyTmp)) and (sMoveScreen != "") and (sMoveScreen!=sStatKeyTmp)
.head 8 -  ! Call Move_PasteToCurrent()
.head 8 -  Call TransferCageBetweenScreens( sAbtKeySrc,sMoveScreen, GetTime4Refresh(  ))
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
					SalHStringToNumber( sAbtKeySrc || ";" || sStatKeyTmp ) )
.head 8 -  ! Call PopulateItem(nSelectedHandle, TRUE  )
.head 8 -  Call TurnLevel(  )
.head 6 -  Set bMoveFlag = FALSE
.head 6 -  Set sMoveScreen = ""
.head 5 +  ! On AM_KHE_RefreshGruppe
.head 6 -  Set sTemp = SalNumberToHString( wParam )
.head 6 -  Set nTemp = SalStrTokenize ( sTemp, "", ";", asTemp )
.head 6 +  If nTemp > 2
.head 7 -  Set nTemp = SearchFrom(hRoot, asTemp[3])
.head 6 +  Else 
.head 7 -  Set nTemp = 0
.head 6 -  ! Return KHE_RefreshGruppe()
.head 6 +  If bShowPlacesWithContent
.head 7 +  If nTemp > 0
.head 8 -  Return KHE_RefreshGruppe(nTemp)
.head 7 +  Else 
.head 8 -  Return KHE_RefreshGruppe(nSelectedHandle)
.head 6 +  Else 
.head 7 -  ! Call PopulateAndExpand(nSelectedHandle, TRUE )
.head 7 +  If GetLevel( nSelectedHandle ) = KHEL_Bett
.head 8 -  Set nSelectedHandle=GetParent(nSelectedHandle)
.head 8 -  Set nSelectedLevel  = KHEL_Gruppe
.head 8 -  Call PopulateAndExpand(nSelectedHandle, TRUE )
.head 7 +  Else 
.head 8 -  !
.head 8 -  Call PopulateAndExpand(nSelectedHandle, TRUE )
.head 7 -  Return PopulateSelectedItem( FALSE )
.head 5 +  ! On AM_KHE_PopulateAndExpandLevel
.head 6 -  Return PopulateAndExpand(nSelectedHandle, TRUE)
.head 5 +  ! On AM_KHE_OpenTempCage
.head 6 -  ! ! Return OpenTempCage(nSelectedHandle)
.head 6 -  Return TempIsPossible(TRUE, wParam)
.head 5 +  ! On AM_MoveToVirt
.head 6 -  Return MoveVirtAndMaiting(TRUE, wParam)
.head 5 +  ! On AM_GetPortPoc
.head 6 -  Return SalSendMsg( hWnd_POC, AM_GetPortPoc, wParam, lParam)
.head 5 +  ! On AM_KHE_MoveFemaleAfterPL
.head 6 -  Return MoveFemaleAfterPL( GalGetAsWinMsgLParam_Number( lParam ),wParam )
.head 5 +  ! On AM_KHE_GoToCageNR
.head 6 -  Return GoToCageNR( wParam )
.head 5 +  ! On AM_KHE_MoveSelectedCage
.head 6 -  Call Move_CageSelected( wParam,  lParam)
.head 5 +  ! On WM_KEYDOWN
.head 6 +  If wParam = VK_RIGHT or wParam = VK_LEFT or wParam = VK_UP or wParam = VK_DOWN or wParam = VK_ADD or wParam = VK_Subtract
.head 7 +  If wParam = VK_RIGHT and not KHE_IsExpanded( nSelectedHandle )
.head 8 -  Call SalSendClassMessage( WM_KEYDOWN, VK_ADD, lParam )
.head 7 +  If Move_Selected( wParam )
.head 8 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 6 +  Else 
.head 7 -  Call SalSendMsg(hWndStar2000 , WM_KEYDOWN, wParam, lParam )
.head 5 +  ! On WM_KEYUP
.head 6 +  Select Case wParam
.head 7 +  Case VK_RIGHT
.head 8 +  If Move_Selected( wParam )
.head 9 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 9 -  Return TRUE
.head 8 -  Break 
.head 7 +  Case VK_LEFT
.head 8 +  If nSelectedHandle != hRoot
.head 9 -  Set nSelectedHandle = GetParent( nSelectedHandle )
.head 9 -  Call SalListSetSelect( hWndItem, GetItemIndex( nSelectedHandle ) )
.head 8 +  If Move_Selected( wParam )
.head 9 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 9 -  Return TRUE
.head 8 -  Break 
.head 7 +  Case VK_UP
.head 8 +  If Move_Selected( wParam )
.head 9 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 9 -  Return TRUE
.head 8 -  Break 
.head 7 +  Case VK_DOWN
.head 8 +  If Move_Selected( wParam )
.head 9 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 9 -  Return TRUE
.head 8 -  Break 
.head 7 +  Case VK_ADD
.head 8 +  If Move_Selected( wParam )
.head 9 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 9 -  Return TRUE
.head 7 +  Case VK_Subtract
.head 8 +  If Move_Selected( wParam )
.head 9 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 9 -  Return TRUE
.head 7 +  Default 
.head 8 -  Call SalSendMsg(hWndStar2000 , WM_KEYDOWN, wParam, lParam )
.head 8 -  Return FALSE
.head 8 -  Break 
.head 6 +  ! If wParam = VK_RIGHT or wParam = VK_LEFT or wParam = VK_UP or wParam = VK_DOWN or wParam = VK_ADD or wParam = VK_Subtract
.head 7 +  If Move_Selected( wParam )
.head 8 -  Call SalSendClassMessage( WM_KEYDOWN, wParam, lParam )
.head 8 -  Return TRUE
.head 7 -  Return FALSE
.head 6 +  ! Else
.head 7 -  Call SalSendMsg(hWndStar2000 , WM_KEYDOWN, wParam, lParam )
.head 5 +  ! On AM_Location_Add
.head 6 -  Return KHE_Locations_Add( KHE_Locations_StrToObj( SalNumberToHString( lParam ) ).GetCage( ) )
.head 5 -  !
.head 5 +  ! On AM_KHE_ShowIRServices
.head 6 -  Return KHE_ShowIRServices(SalNumberToHString( wParam ))
.head 5 +  ! On AM_KHE_OpenBettByFallKey
.head 6 +  If lParam = - 1
.head 7 -  Return OpenBettByFallKey( wParam, bAutoScan)
.head 6 +  Else 
.head 7 -  Return OpenBettByFallKey( wParam, lParam)
.head 5 +  ! On AM_Rack2DView_RefreshCageContents
.head 6 -  Return Rack2DView_RefreshCageContents(SalNumberToHString( wParam ))
.head 5 +  ! On AM_KHE_RefreshCages
.head 6 +  If lParam = 0
.head 7 -  Return KHE_RefreshAllCages()
.head 5 +  ! On AM_GoToFall
.head 6 -  Call SalSendMsg(hWndKHE,AM_KHE_OpenBettByFallKey,wParam,-1)
.head 6 -  Call MultiSelect()
.head 6 -  Call KHEReAssignPics(hWndKHE.clsKHExplorerLeft.nSelectedHandle)
.head 5 +  ! On AM_AutoMiceImpExtDelivery
.head 6 -  Call SalStrTokenize( SalNumberToHString( wParam ),"",";",sMsgParam)
.head 6 -  Return AutoMiceImpExtDelivery(SalStrToNumber( sMsgParam[0] ),SalStrToNumber( sMsgParam[1] ),sMsgParam[2] )
.head 5 +  ! On AM_SetActiveSession
.head 6 -  Set hActiveSession = SalNumberToWindowHandle( wParam )
.head 6 -  Return TRUE
.head 3 +  Functional Class: cFERow
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Number: nID_Obj
.head 5 -  Number: nOrder
.head 5 -  Number: nStatusFlags
.head 5 -  String: sLabel
.head 5 -  String: sVal[*]
.head 5 -  Number: nVal[*]
.head 5 -  Date/Time: dtVal[*]
.head 5 -  Number: nCheckRow
.head 5 -  !
.head 5 -  Number: nLabelFlags
.head 5 -  ! Number: nLabelInd[*]
.head 5 -  FunctionalVar: oLevelSetting
.head 6 -  Class: oSettingsFE
.head 5 -  String: sCagePosition
.head 5 -  String: sStrain
.head 5 -  String: sInfo
.head 4 +  Functions
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set nID_Obj = NUMBER_Null
.head 7 -  Set nOrder = NUMBER_Null
.head 7 -  Set sLabel = STRING_Null
.head 7 -  Set nStatusFlags = 0
.head 7 -  Call SalArraySetUpperBound ( sVal, 1, -1 )
.head 7 -  Call SalArraySetUpperBound ( nVal, 1, -1 )
.head 7 -  Call SalArraySetUpperBound ( dtVal, 1, -1 )
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..Clear()
.head 5 +  Function: AddString
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  String: sNewVal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 +  If SalArrayIsEmpty ( sVal )
.head 8 -  Set nI = 0
.head 7 +  Else
.head 8 -  Call SalArrayGetUpperBound ( sVal, 1, nI )
.head 8 -  Set nI = nI + 1
.head 7 -  Set sVal[nI]=sNewVal
.head 5 +  Function: AddNumber
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nNewVal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 +  If SalArrayIsEmpty ( nVal )
.head 8 -  Set nI = 0
.head 7 +  Else
.head 8 -  Call SalArrayGetUpperBound ( nVal, 1, nI )
.head 8 -  Set nI = nI + 1
.head 7 -  Set nVal[nI]=nNewVal
.head 5 +  Function: AddDate
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Date/Time: dtNewVal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 +  If SalArrayIsEmpty ( dtVal )
.head 8 -  Set nI = 0
.head 7 +  Else
.head 8 -  Call SalArrayGetUpperBound ( dtVal, 1, nI )
.head 8 -  Set nI = nI + 1
.head 7 -  Set dtVal[nI]=dtNewVal
.head 5 +  Function: Init
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call Clear()
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..Associate()
.head 7 -  Return TRUE
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nJ
.head 7 -  Number: nMax
.head 7 -  Number: nConst
.head 6 +  Actions
.head 7 -  Set sLabel = ""
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  ! Return ..BuildLabels()
.head 8 +  While nI < oLevelSetting.nCountHints
.head 9 +  If oLevelSetting.IsShow( oLevelSetting.nIndexHints[nI] )
.head 10 -  Set sLabel = sLabel || GetLabelValue(oLevelSetting.nIndexHints[nI])
.head 9 -  Set nI = nI + 1
.head 8 +  If SalStrRightX( sLabel, 1 ) = ','
.head 9 -  Call SalStrLeft( sLabel, SalStrLength( sLabel ) - 1, sLabel )
.head 8 -  Call ..BuildLabels()
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..GetLabelValue(nInd)
.head 5 +  Function: GetLabelClipsValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 7 -  Receive Boolean: bHasValue
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) = "cFERowBett" or SalObjGetType( this ) = "cFERowCage" or SalObjGetType( this ) = "cFERowRack"
.head 8 -  Return ..GetLabelClipsValue(nInd, bHasValue)
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..SetState(nParam)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..GetState(nParam)
.head 7 -  Return FALSE
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..GetSValue(sParam)
.head 7 -  Return ""
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..GetNValue(sParam)
.head 7 -  Return 0
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call BuildLabels()
.head 7 +  If SalObjGetType( this ) != "cFERow"
.head 8 -  Return ..Save()
.head 7 -  Return TRUE
.head 5 +  Function: AddToFlag
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nB_Flag
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set nStatusFlags = nStatusFlags + nB_Flag*(not nStatusFlags&nB_Flag)
.head 3 +  Functional Class: cFERowIns
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sEinrichtKey
.head 5 -  String: sDescr
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sEinrichtKey = sVal[0]
.head 7 -  Set sDescr = sVal[1]
.head 7 -  Return TRUE
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sEinrichtKey = STRING_Null
.head 7 -  Set sDescr = STRING_Null
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  ! If nLabelFlags&1
.head 8 -  Set sLabel = '(' || sEinrichtKey || ')'
.head 7 +  ! If nLabelFlags&2
.head 8 -  Set sLabel = sLabel || sDescr
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sEinrichtKey || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = sDescr 
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return FALSE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sEinrichtKey
.head 7 -  Set sVal[1] = sDescr
.head 7 -  Return TRUE
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return NUMBER_Null
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return ""
.head 3 +  Functional Class: cFERowScr
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sScreen
.head 5 -  String: sDescr
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sScreen = sVal[0]
.head 7 -  Set sDescr = sVal[1]
.head 7 -  Return TRUE
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sScreen = STRING_Null
.head 7 -  Set sDescr = STRING_Null
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  ! If nLabelFlags&1
.head 8 -  Set sLabel = '(' || sScreen || ')'
.head 7 +  ! If nLabelFlags&2
.head 8 -  Set sLabel = sLabel || sDescr 
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sScreen || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = sDescr || ''
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return FALSE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sScreen
.head 7 -  Set sVal[1] = sDescr
.head 7 -  Return TRUE
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sReturn
.head 6 +  Actions
.head 7 -  Set sReturn = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam = "SCREEN"
.head 8 -  Set sReturn = sScreen
.head 7 -  Return sReturn
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return NUMBER_Null
.head 3 +  Functional Class: cFERowRack
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sRack
.head 5 -  String: sDescr
.head 5 -  String: sCurrnum
.head 5 -  String: sPosition
.head 5 -  String: sVirtual
.head 5 -  String: sModelNr
.head 5 -  Number: nCountSlots
.head 5 -  Number: nCountEmptySlots
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sRack = sVal[0]
.head 7 -  Set sDescr = sVal[1]
.head 7 -  Set sCurrnum = sVal[2]
.head 7 -  Set sPosition = sVal[3]
.head 7 -  Set sVirtual = sVal[4]
.head 7 -  Set sModelNr = sVal[5]
.head 7 -  Set nCountSlots = nVal[0]
.head 7 -  Set nCountEmptySlots = nVal[1]
.head 7 -  Return TRUE
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  ! If nLabelFlags&1
.head 8 -  Set sLabel = '(' || sRack || ')'
.head 7 +  ! If nLabelFlags&4 and sCurrnum != ''
.head 8 -  Set sLabel = sLabel || ' Room:'|| sCurrnum
.head 7 +  ! If nLabelFlags&8 and sPosition != ''
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ", "
.head 8 -  Set sLabel = sLabel  || 'Position:'|| sPosition 
.head 7 +  ! If nLabelFlags&2
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ", "
.head 8 -  Set sLabel  = sLabel || sDescr
.head 7 +  ! If nLabelFlags&16 and sVirtual= 'J'
.head 8 -  Set sLabel = sLabel  || ' [V]'
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sRack || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = sDescr || ','
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  Set sText = ' Room:'|| sCurrnum || ','
.head 9 -  Break
.head 8 +  Case 4
.head 9 -  Set sText = 'Position:'|| sPosition  || ','
.head 9 -  Break
.head 8 +  Case 5
.head 9 +  If sVirtual= 'J'
.head 10 -  Set sText = ' [V]'
.head 9 -  Break
.head 8 +  Case 6
.head 9 +  If nStatusFlags&128
.head 10 -  Set sText = ' [C]'
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: GetLabelClipsValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 7 -  Receive Boolean: bHasValue
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 -  Set bHasValue = FALSE
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  ! Set sText = '(' || sRack || ')'
.head 9 -  Set sText = 'rack-number:' || sRack || ';'
.head 9 +  If sRack != ""
.head 10 -  !
.head 10 -  Set bHasValue = TRUE
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  ! Set sText = sDescr || ','
.head 9 -  Set sText = 'description:' || sDescr || ';'
.head 9 +  If sRack != ""
.head 10 -  !
.head 10 -  Set bHasValue = TRUE
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  ! Set sText = ' Room:'|| sCurrnum || ','
.head 9 -  Set sText = 'room:' || sCurrnum || ';'
.head 9 +  If sRack != ""
.head 10 -  !
.head 10 -  Set bHasValue = TRUE
.head 9 -  Break
.head 8 +  Case 4
.head 9 -  ! Set sText = 'Position:'|| sPosition  || ','
.head 9 -  Set sText = 'position:' || sPosition || ';'
.head 9 -  Break
.head 8 +  Case 5
.head 9 +  If sVirtual= 'J'
.head 10 -  ! Set sText = ' [V]'
.head 10 -  Set sText = 'virtual:' || "Yes" || ';'
.head 9 -  Break
.head 8 +  Case 6
.head 9 +  ! If nStatusFlags&128
.head 10 -  Set sText = ' [C]'  NEED to do
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBit
.head 6 +  Actions
.head 7 +  If nParam= RackIsFull
.head 8 -  Set nBit = 1
.head 7 +  Else If nParam = RackIsVirtual
.head 8 -  Set nBit = 2
.head 7 +  Else If nParam = RackIsChaos
.head 8 -  Set nBit = 4
.head 7 +  Else If nParam = Rack_IsIntensiv
.head 8 -  Set nBit = 8
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set nBit = 16
.head 7 +  Else If nParam = IsServise
.head 8 -  Set nBit = 32
.head 7 +  Else If nParam = Rack_NotNeedPrint
.head 8 -  Set nBit = 64
.head 7 +  Else If nParam = Rack_IsCadaver
.head 8 -  Set nBit = 128
.head 7 +  Else If nParam = Rack_OutgoingAdmServ
.head 8 -  Set nBit = 256
.head 7 +  Else If nParam = Rack_IncomingAdmServ
.head 8 -  Set nBit = 512
.head 7 +  Else If nParam = Rack_SlotNeedAssign
.head 8 -  Set nBit = 1024
.head 7 -  Call AddToFlag(nBit)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 +  If nParam= RackIsEmpty
.head 8 -  Set bReturn = not (nStatusFlags &1)
.head 7 +  Else If nParam = RackIsVirtual
.head 8 -  Set bReturn = (nStatusFlags&2)
.head 7 +  Else If nParam = RackIsChaos
.head 8 -  Set bReturn = (nStatusFlags&4)
.head 7 +  Else If nParam = RackIsFull
.head 8 -  Set bReturn = (nStatusFlags&1)
.head 7 +  Else If nParam = Rack_IsIntensiv
.head 8 -  Set bReturn = nStatusFlags&8
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set bReturn = nStatusFlags&16
.head 7 +  Else If nParam = IsServise
.head 8 -  Set bReturn = nStatusFlags&32
.head 7 +  Else If nParam = Rack_NotNeedPrint
.head 8 -  Set bReturn = nStatusFlags&64
.head 7 +  Else If nParam = Rack_IsCadaver
.head 8 -  Set bReturn = nStatusFlags&128
.head 7 +  Else If nParam = Rack_OutgoingAdmServ
.head 8 -  Set bReturn = nStatusFlags&256
.head 7 +  Else If nParam = Rack_IncomingAdmServ
.head 8 -  Set bReturn = nStatusFlags&512
.head 7 +  Else If nParam = Rack_SlotNeedAssign
.head 8 -  Set bReturn = nStatusFlags&1024
.head 7 -  Return bReturn
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sRack
.head 7 -  Set sVal[1] = sDescr
.head 7 -  Set sVal[2] = sCurrnum
.head 7 -  Set sVal[3] = sPosition
.head 7 -  Set sVal[4] = sVirtual
.head 7 -  Set sVal[5] = sModelNr
.head 7 -  Set nVal[0]=nCountSlots
.head 7 -  Set nVal[1]=nCountEmptySlots
.head 7 -  Return TRUE
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sRack = STRING_Null
.head 7 -  Set sDescr = sRack
.head 7 -  Set sCurrnum = sRack
.head 7 -  Set sPosition = sRack
.head 7 -  Set sVirtual = sRack
.head 7 -  Set sModelNr = sRack
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sReturn
.head 6 +  Actions
.head 7 -  Set sReturn = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam = "MODEL"
.head 8 -  Set sReturn = sModelNr
.head 7 -  Return sReturn
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nReturn
.head 6 +  Actions
.head 7 -  Set nReturn = 0
.head 7 +  If sParam = "EMPTY"
.head 8 -  Set nReturn = nCountEmptySlots
.head 7 +  Else If sParam = "COUNT"
.head 8 -  Set nReturn = nCountSlots
.head 7 +  Else If sParam = "FULLSLOTS"
.head 8 -  Set nReturn = nCountSlots - nCountEmptySlots
.head 7 -  Return nReturn
.head 3 +  Functional Class: cFERowCage
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sCage
.head 5 -  String: sDescr
.head 5 -  String: sPurposeKey
.head 5 -  Number: nColor
.head 5 -  Number: nAmountPlace
.head 5 -  Number: nEmptyPlace
.head 5 -  Number: nUniq_Nr
.head 5 -  String: sSlot_Nr
.head 5 -  Number: nMales
.head 5 -  Number: nFemales
.head 5 -  Number: nPortPOS
.head 5 -  String: sRFID
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sCage = sVal[0]
.head 7 -  Set sDescr = sVal[1]
.head 7 -  Set sPurposeKey = sVal[2]
.head 7 -  Set sRFID  = sVal[3]
.head 7 -  Set sSlot_Nr = sVal[4]
.head 7 -  Set nColor = nVal[0]
.head 7 -  Set nAmountPlace = nVal[1]
.head 7 -  Set nUniq_Nr = nVal[2]
.head 7 -  Set nMales = nVal[3]
.head 7 -  Set nFemales = nVal[4]
.head 7 -  Set nPortPOS = nVal[5]
.head 7 -  Set nEmptyPlace = nAmountPlace - nFemales - nMales
.head 7 -  Return TRUE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0]=sCage
.head 7 -  Set sVal[1]=sDescr
.head 7 -  Set sVal[2]=sPurposeKey
.head 7 -  Set sVal[3] = sRFID
.head 7 -  Set sVal[4] = sSlot_Nr
.head 7 -  Set nVal[0]=nColor
.head 7 -  Set nVal[1]=nAmountPlace
.head 7 -  Set nVal[2]=nUniq_Nr
.head 7 -  Set nVal[3]=nMales
.head 7 -  Set nVal[4]=nFemales
.head 7 -  Set nVal[5]=nPortPOS
.head 7 +  If nPortPOS > 0
.head 8 +  If nPortPOS < 10
.head 9 -  Set nOrder = nPortPOS * 10
.head 8 +  Else
.head 9 -  Set nOrder = nPortPOS
.head 7 +  Else
.head 8 -  Set nOrder = 9999
.head 7 -  Return TRUE
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBit
.head 6 +  Actions
.head 7 +  If nParam = CageIsFull
.head 8 -  Set nBit = 1
.head 7 +  Else If nParam = CageWithRFID
.head 8 -  Set nBit = 2
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set nBit = 4
.head 7 +  Else If nParam = IsServise
.head 8 -  Set nBit = 8
.head 7 +  Else If nParam = CageIsOccupied
.head 8 -  Set nBit = 16
.head 7 +  Else If nParam = LitterInCage
.head 8 -  Set nBit = 32
.head 7 +  Else If nParam = CageIsRoling
.head 8 -  Set nBit = 64
.head 7 +  Else If nParam = Cage_LOCKScreen
.head 8 -  Set nBit = 128
.head 7 +  Else If nParam = Cage_LOCKCurrScreen
.head 8 -  Set nBit = 256
.head 7 -  Call AddToFlag(nBit)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 +  If nParam = CageIsFull
.head 8 -  Set bReturn = nStatusFlags&1
.head 7 +  Else If nParam = CageWithRFID
.head 8 -  Set bReturn = nStatusFlags&2
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set bReturn = nStatusFlags&4
.head 7 +  Else If nParam = IsServise
.head 8 -  Set bReturn = nStatusFlags&8
.head 7 +  Else If nParam = CageIsOccupied
.head 8 -  Set bReturn = nStatusFlags&16
.head 7 +  Else If nParam = CageIsEmpty
.head 8 -  Set bReturn = not(nStatusFlags&1)
.head 7 +  Else If nParam = LitterInCage
.head 8 -  Set bReturn = nStatusFlags&32
.head 7 +  Else If nParam = CageIsRoling
.head 8 -  Set bReturn = nStatusFlags&64
.head 7 +  Else If nParam = Cage_LOCKScreen
.head 8 -  Set bReturn = nStatusFlags&128
.head 7 +  Else If nParam = Cage_LOCKCurrScreen
.head 8 -  Set bReturn = nStatusFlags&256
.head 7 -  Return bReturn
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sReturn
.head 6 +  Actions
.head 7 -  Set sReturn = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam = "CAGE"
.head 8 -  Set sReturn = sCage
.head 7 +  Else If sParam = "RFID"
.head 8 -  Set sReturn = sRFID
.head 7 -  Return sReturn
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nReturn
.head 6 +  Actions
.head 7 -  Set nReturn = 0
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam = "MALE"
.head 8 -  Set nReturn = nMales
.head 7 +  Else If sParam = "FEMALE"
.head 8 -  Set nReturn = nFemales
.head 7 +  Else If sParam = "UNIQNR"
.head 8 -  Set nReturn = nUniq_Nr
.head 7 +  Else If sParam = "EMPTY"
.head 8 -  Set nReturn = nEmptyPlace
.head 7 +  Else If sParam = "COUNT"
.head 8 -  Set nReturn = nMales + nFemales
.head 7 +  Else If sParam = "PORT"
.head 8 -  Set nReturn = nPortPOS
.head 7 +  Else If sParam = "SEX" ! 0 - not animal, 1 - only Females, 2- only Males, 3 - hetero cage or mating
.head 8 -  Set nReturn = 0
.head 8 +  If nMales
.head 9 -  Set nReturn = 2
.head 8 +  If nFemales
.head 9 -  Set nReturn = nReturn + 1
.head 7 -  Return nReturn
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If nPortPOS
.head 8 -  Set sLabel = "<" || GetPOCDescr() || " Pos>" || sLabel
.head 7 +  ! If nLabelFlags&1
.head 8 -  Set sLabel = sLabel || '(' || sCage || ')'
.head 7 +  ! If nLabelFlags&2
.head 8 -  Set sLabel = sLabel || sDescr
.head 7 +  ! If nLabelFlags&4 and nUniq_Nr>0
.head 8 -  Set sLabel= sLabel ||'    Cage Nr '||SalNumberToStrX(nUniq_Nr, 0)
.head 7 +  ! If nLabelFlags&8
.head 8 -  Set sLabel = sLabel || " In Cage: "
.head 8 +  If nFemales
.head 9 -  Set sLabel = sLabel || "F: " || SalNumberToStrX( nFemales , 0 )
.head 8 +  If nMales
.head 9 +  If nFemales
.head 10 -  Set sLabel = sLabel || ", " 
.head 9 -  Set sLabel = sLabel || "M: " || SalNumberToStrX( nMales, 0 )
.head 7 +  ! If nLabelFlags&16
.head 8 +  If nFemales or nMales
.head 9 -  Set sLabel = sLabel || "," 
.head 8 -  Set nEmptyPlace = nAmountPlace - nFemales - nMales
.head 8 -  Set sLabel = sLabel || " Empty:[ " || SalNumberToStrX(nEmptyPlace , 0 ) || "]"
.head 7 -  Set nEmptyPlace = nAmountPlace - nFemales - nMales
.head 7 +  If (nMales + nFemales ) > 0
.head 8 -  Call SetState(CageIsFull )
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sCage || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = sDescr || ','
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  Set sText = ' Cage Nr '
.head 9 +  If nUniq_Nr > 0
.head 10 -  Set sText = sText||SalNumberToStrX(nUniq_Nr, 0) 
.head 9 -  Set sText = sText || ','
.head 9 -  Break
.head 8 +  Case 4
.head 9 -  Set sText = " In Cage: "
.head 9 +  If nFemales
.head 10 -  Set sText = sText || "F: " || SalNumberToStrX( nFemales , 0 )
.head 9 +  If nMales
.head 10 +  If nFemales
.head 11 -  Set sText = sText || ", " 
.head 10 -  Set sText = sText || "M: " || SalNumberToStrX( nMales, 0 )
.head 9 -  Set sText = sText || "," 
.head 9 -  Break
.head 8 +  Case 5
.head 9 -  Set nEmptyPlace = nAmountPlace - nFemales - nMales
.head 9 -  Set sText = " Empty:[ " || SalNumberToStrX(nEmptyPlace , 0 ) || "],"
.head 9 -  Break
.head 8 +  Case 6
.head 9 -  Set sText = ' Slot Nr ' || sSlot_Nr
.head 9 -  Set sText = sText || ','
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: GetLabelClipsValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 7 -  Receive Boolean: bHasValue
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 7 -  Number: nAnimals
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 -  Set bHasValue = FALSE
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = 'cage-position:' || sCage || ';'
.head 9 +  If sCage != ""
.head 10 -  !
.head 10 -  Set bHasValue = TRUE
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = 'description:' ||  sDescr || ';'
.head 9 +  If sDescr != ""
.head 10 -  !
.head 10 -  Set bHasValue = TRUE
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  ! Set sText = ' Cage Nr '
.head 9 +  If nUniq_Nr > 0
.head 10 -  Set sText = sText||SalNumberToStrX(nUniq_Nr, 0)
.head 10 -  Set bHasValue = TRUE
.head 9 -  Set sText = 'cage-number:' || sText || ';'
.head 9 -  Break
.head 8 +  Case 4
.head 9 -  ! Set sText = " In Cage: "
.head 9 +  If nFemales
.head 10 -  ! Set sText =  "F-" || SalNumberToStrX( nFemales , 0 )
.head 10 +  If nMales
.head 11 -  ! 1Set sText = sText || ", "
.head 11 -  Set sText = "with-male-and-female; animals-inside:" || SalNumberToStrX( nMales + nFemales , 0 )
.head 10 +  Else
.head 11 -  !
.head 11 -  Set sText = "with-female; animals-inside:" || SalNumberToStrX( nFemales , 0 )
.head 9 +  Else If nMales
.head 10 -  Set sText = "with-male; animals-inside:" || SalNumberToStrX( nMales , 0 )
.head 10 -  ! Set sText = sText || "M-" || SalNumberToStrX( nMales, 0 )
.head 9 +  Else
.head 10 -  !
.head 10 -  Set sText = "empty"
.head 9 -  Set sText = 'occupied:' || sText || ";"
.head 9 -  Break
.head 8 +  Case 5
.head 9 -  Set nEmptyPlace = nAmountPlace - nFemales - nMales
.head 9 -  Set sText = 'empty-places:' || SalNumberToStrX(nEmptyPlace , 0 ) || ";"
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sCage = STRING_Null
.head 7 -  Set sDescr = sCage
.head 7 -  Set sPurposeKey = sCage
.head 7 -  Set sSlot_Nr = sCage
.head 7 -  Set nColor = NUMBER_Null
.head 7 -  Set nAmountPlace = nColor
.head 7 -  Set nUniq_Nr = nColor
.head 7 -  Set nMales = nColor
.head 7 -  Set nFemales = nColor
.head 7 -  Set nEmptyPlace = nColor
.head 7 -  Set nPortPOS = nColor
.head 5 +  Function: GetPOCDescr
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ""
.head 7 +  If nPortPOS < 3
.head 8 -  Set sText = SalNumberToStrX(nPortPOS, 0)
.head 7 +  Else
.head 8 +  If nPortPOS = 3
.head 9 -  Set sText = "3-1"
.head 8 +  Else If nPortPOS = 5
.head 9 -  Set sText = "5-1"
.head 8 +  Else
.head 9 -  Set sText = SalNumberToStrX(nPortPOS + 1, 0)
.head 9 -  Call SalStrReplace(sText,1,0,'-',sText)
.head 7 -  Return sText
.head 3 +  Functional Class: cFERowBett
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sBett
.head 5 -  String: sSex
.head 5 -  String: sSexDescr
.head 5 -  String: sStrain
.head 5 -  String: sBatch
.head 5 -  String: sForeignID
.head 5 -  String: sSV_Nr
.head 5 -  String: sPhenoType
.head 5 -  String: sGenoType
.head 5 -  String: sLE_Info
.head 5 -  String: sEarTag
.head 5 -  String: sExperiment
.head 5 -  Date/Time: dtGebDatum
.head 5 -  Number: nPosID
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sBett = sVal[0]
.head 7 -  Set sSex = sVal[1]
.head 7 -  Set sStrain = sVal[2]
.head 7 -  Set sBatch = sVal[3]
.head 7 -  Set sForeignID = sVal[4]
.head 7 -  Set sSV_Nr = sVal[5]
.head 7 -  Set sPhenoType = sVal[6]
.head 7 -  Set sGenoType = sVal[7]
.head 7 -  Set sLE_Info = sVal[8]
.head 7 -  Set sSexDescr = sVal[9]
.head 7 -  Set sEarTag = sVal[10]
.head 7 -  Set sExperiment = sVal[11]
.head 7 -  Set dtGebDatum = dtVal[0]
.head 7 -  Set nPosID = nVal[0]
.head 7 -  Return TRUE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sBett
.head 7 -  Set sVal[1]= sSex
.head 7 -  Set sVal[2]= sStrain 
.head 7 -  Set sVal[3] = sBatch 
.head 7 -  Set sVal[4] = sForeignID 
.head 7 -  Set sVal[5] = sSV_Nr
.head 7 -  Set sVal[6] = sPhenoType
.head 7 -  Set sVal[7] = sGenoType
.head 7 -  Set sVal[8] = sLE_Info
.head 7 -  Set sVal[9] = sSexDescr
.head 7 -  Set sVal[10] = sEarTag
.head 7 -  Set sVal[11] = sExperiment
.head 7 -  Set dtVal[0] = dtGebDatum
.head 7 -  Set nVal[0] = nPosID
.head 7 -  Return TRUE
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBit
.head 6 +  Actions
.head 7 +  If nParam = AnimalIsPlugged
.head 8 -  Set nBit  = 1
.head 7 +  Else If nParam = AnimalIsDead
.head 8 -  Set nBit  = 2
.head 7 +  Else If nParam = AnimalIsLitter
.head 8 -  Set nBit  = 4
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set nBit  = 8
.head 7 +  Else If nParam = IsServise
.head 8 -  Set nBit  = 16
.head 7 +  Else If nParam = AnimalInPlanBew
.head 8 -  Set nBit  = 32
.head 7 -  Call AddToFlag(nBit)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 +  If nParam = AnimalIsPlugged
.head 8 -  Set bReturn =nStatusFlags&1
.head 7 +  Else If nParam = AnimalIsDead
.head 8 -  Set bReturn =nStatusFlags&2
.head 7 +  Else If nParam = AnimalIsLitter
.head 8 -  Set bReturn =nStatusFlags&4
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set bReturn =nStatusFlags&8
.head 7 +  Else If nParam = IsServise
.head 8 -  Set bReturn =nStatusFlags&16
.head 7 +  Else If nParam = AnimalInPlanBew
.head 8 -  Set bReturn =nStatusFlags&32
.head 7 -  Return bReturn
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  ! Set sLabel = ""
.head 7 +  If GetState(AnimalIsPlugged)
.head 8 -  Set sLabel = "* " || sLabel
.head 7 +  ! If nLabelFlags&1
.head 8 -  Set sLabel = sLabel || '('||sBett||')'
.head 7 +  ! If nID_Obj and nLabelFlags&2
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || '-'
.head 7 +  ! If GetState(AnimalIsDead ) and nLabelFlags&4
.head 8 -  Set sLabel = sLabel || 'K '
.head 7 +  ! If nID_Obj and nLabelFlags&2
.head 8 -  Set sLabel = sLabel || '{' || StrX( nID_Obj ) || '} '
.head 7 +  ! If nLabelFlags&8
.head 8 -  Set sLabel = sLabel || sForeignID
.head 7 +  ! If nLabelFlags&32768
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel || sEarTag
.head 7 +  ! If nLabelFlags&16
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel || sStrain
.head 7 +  ! If sLabel&32 and IsFallHavePlanBew( nFallKeyOnBed )
.head 8 -  Set sLabel = sLabel || ', (PB) '
.head 7 +  ! If nLabelFlags&64
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel || sSV_Nr
.head 7 +  ! If nLabelFlags&128
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel  || sSexDescr
.head 7 +  ! If nLabelFlags&256
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel  || SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy')
.head 7 +  ! If nLabelFlags&512
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel  || sBatch
.head 7 +  ! If nLabelFlags&1024
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel || sPhenoType
.head 7 +  ! If nLabelFlags&2048
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel || sGenoType
.head 7 +  ! If nLabelFlags&4196
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel  || sColor
.head 7 +  ! If nLabelFlags&8192
.head 8 +  If sLabel
.head 9 -  Set sLabel = sLabel || ', '
.head 8 -  Set sLabel = sLabel || ' HS: ' || StrX( HelStat_Get4Fall( nID_Obj, SalDateCurrent(  )  ) )
.head 7 +  ! If nLabelFlags&16384 and sLE_Info
.head 8 -  Set sLabel = sLabel || ' *'
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sBett || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = '{' || StrX( nID_Obj ) || '} ' 
.head 9 -  Break
.head 8 +  Case 3
.head 9 +  If GetState(AnimalIsDead ) 
.head 10 -  Set sText = ' K ' || ','
.head 9 -  Break
.head 8 +  Case 4
.head 9 -  Set sText = sForeignID || ','
.head 9 -  Break
.head 8 +  Case 5
.head 9 -  Set sText = sStrain || "," 
.head 9 -  Break
.head 8 +  Case 6
.head 9 +  ! If IsFallHavePlanBew( nFallKeyOnBed )
.head 10 -  Set sText =  '(PB) '
.head 9 -  Break
.head 8 +  Case 7
.head 9 -  Set sText = sSV_Nr || "," 
.head 9 -  Break
.head 8 +  Case 8
.head 9 -  Set sText = sSexDescr || "," 
.head 9 -  Break
.head 8 +  Case 9
.head 9 -  Set sText = SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy') || "," 
.head 9 -  Break
.head 8 +  Case 10
.head 9 -  Set sText = sBatch || "," 
.head 9 -  Break
.head 8 +  Case 11
.head 9 -  Set sText = sPhenoType || "," 
.head 9 -  Break
.head 8 +  Case 12
.head 9 -  Set sText = sGenoType || "," 
.head 9 -  Break
.head 8 +  Case 13
.head 9 -  Set sText = sColor || "," 
.head 9 -  Break
.head 8 +  Case 14
.head 9 -  Set sText = ' HS: ' || StrX( HelStat_Get4Fall( nID_Obj, SalDateCurrent(  )  ) ) || "," 
.head 9 -  Break
.head 8 +  Case 15
.head 9 +  If sLE_Info
.head 10 -  Set sText = ' *,'
.head 9 -  Break
.head 8 +  Case 16
.head 9 -  Set sText = sEarTag || "," 
.head 9 -  Break
.head 8 +  Case 17
.head 9 +  If GetState(AnimalInPlanBew  ) 
.head 10 -  Set sText = '(PB)' || ','
.head 9 -  Break
.head 8 +  Case 18
.head 9 -  Set sText = sExperiment || "," 
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: GetLabelClipsValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 7 -  Receive Boolean: bHasValue
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = "plan-movement:" || sBett || ';'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = "animal-id:" || StrX( nID_Obj ) || ';'
.head 9 -  Break
.head 8 +  Case 3
.head 9 +  If GetState(AnimalIsDead )
.head 10 -  Set sText = "animal-dead"  ||  ' K ' || ';'
.head 9 -  Break
.head 8 +  Case 4
.head 9 -  Set sText ="foreign-id:" || sForeignID || ';'
.head 9 -  Break
.head 8 +  Case 5
.head 9 -  Set sText = "strain:" || sStrain || ";"
.head 9 -  Break
.head 8 +  Case 6
.head 9 +  ! If IsFallHavePlanBew( nFallKeyOnBed )
.head 10 -  Set sText =  '(PB) '
.head 9 -  Break
.head 8 +  Case 7
.head 9 -  Set sText = "SV_Nr:"  ||  sSV_Nr || ";"
.head 9 -  Break
.head 8 +  Case 8
.head 9 -  Set sText = "sex:" || sSexDescr || ";"
.head 9 -  Break
.head 8 +  Case 9
.head 9 -  Set sText = "date-of-birth:" || SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy') || ";"
.head 9 -  Break
.head 8 +  Case 10
.head 9 -  Set sText = "batch:" || sBatch || ";"
.head 9 -  Break
.head 8 +  Case 11
.head 9 -  Set sText = "phenotype:" || sPhenoType || ";"
.head 9 -  Break
.head 8 +  Case 12
.head 9 -  Set sText = "genotype:" || sGenoType || ";"
.head 9 -  Break
.head 8 +  Case 13
.head 9 -  Set sText = "color:" || sColor || ";"
.head 9 -  Break
.head 8 +  Case 14
.head 9 -  Set sText = "health-status:" || StrX( HelStat_Get4Fall( nID_Obj, SalDateCurrent(  )  ) ) || ";"
.head 9 -  Break
.head 8 +  Case 15
.head 9 +  If sLE_Info
.head 10 -  Set sText = "animal-info"  ||  ' *;'
.head 9 -  Break
.head 8 +  Case 16
.head 9 -  Set sText = "ear-tag:"  ||  sEarTag || ";"
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sValue
.head 6 +  Actions
.head 7 -  Set sValue = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam="SEX"
.head 8 -  Set sValue = sSex
.head 7 +  Else If sParam="STRAIN"
.head 8 -  Set sValue = sStrain
.head 7 +  Else If sParam="BATCH"
.head 8 -  Set sValue = sBatch
.head 7 +  Else If sParam="EARTAG"
.head 8 -  Set sValue = sEarTag
.head 7 +  Else If sParam="EXP"
.head 8 -  Set sValue = sExperiment
.head 7 -  Return sValue
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return NUMBER_Null
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sBett = STRING_Null
.head 7 -  Set sSex = sBett
.head 7 -  Set sStrain = sBett
.head 7 -  Set sBatch = sBett
.head 7 -  Set sForeignID = sBett
.head 7 -  Set sSV_Nr = sBett
.head 7 -  Set sPhenoType = sBett
.head 7 -  Set sGenoType = sBett
.head 7 -  Set sLE_Info = sBett
.head 7 -  Set sSexDescr = sBett
.head 7 -  Set sExperiment = sBett
.head 7 -  Set dtGebDatum = DATETIME_Null
.head 3 -  !
.head 3 +  Functional Class: cAERowRoot
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sName
.head 5 -  String: sDescr
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sName = sVal[0]
.head 7 -  Set sDescr = sVal[1]
.head 7 -  Return TRUE
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sName = STRING_Null
.head 7 -  Set sDescr = STRING_Null
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sName || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = sDescr 
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return FALSE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sName
.head 7 -  Set sVal[1] = sDescr
.head 7 -  Return TRUE
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return NUMBER_Null
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return ""
.head 3 +  Functional Class: cAERowScr
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sScreen
.head 5 -  String: sDescr
.head 5 -  String: sEmail
.head 5 -  Number: nBG_Color
.head 5 -  Number: nTX_Color
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sScreen = sVal[0]
.head 7 -  Set sDescr = sVal[1]
.head 7 -  Set sEmail = sVal[2]
.head 7 -  Return TRUE
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sScreen = STRING_Null
.head 7 -  Set sDescr = STRING_Null
.head 7 -  Set sEmail = STRING_Null
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sScreen || ')'
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  Set sText = sDescr || ','
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  Set sText = sEmail || ','
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBit
.head 6 +  Actions
.head 7 +  If nParam = RackIsVirtual
.head 8 -  Set nBit  = 1
.head 7 -  Call AddToFlag(nBit)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 +  If nParam = RackIsVirtual
.head 8 -  Set bReturn =nStatusFlags&1
.head 7 -  Return bReturn
.head 7 -  Return FALSE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sScreen
.head 7 -  Set sVal[1] = sDescr
.head 7 -  Set sVal[2] = sEmail
.head 7 -  Return TRUE
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sReturn
.head 6 +  Actions
.head 7 -  Set sReturn = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam = "SCREEN"
.head 8 -  Set sReturn = sScreen
.head 7 -  Return sReturn
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return NUMBER_Null
.head 3 +  Functional Class: cAERowAnimal
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sEarTag
.head 5 -  String: sSex
.head 5 -  String: sStrain
.head 5 -  String: sExp
.head 5 -  String: sCage
.head 5 -  String: sRack
.head 5 -  String: sGenotype
.head 5 -  String: sPhenotype
.head 5 -  String: sBreedingNr
.head 5 -  String: sFamily
.head 5 -  String: sForeign
.head 5 -  Number: nBatch
.head 5 -  Number: nAge
.head 5 -  Number: nMateID
.head 5 -  Date/Time: dtBirthDate
.head 5 -  Boolean: bNeedPrefix
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sEarTag = sVal[0]
.head 7 -  Set sSex = sVal[1]
.head 7 -  Set sStrain = sVal[2]
.head 7 -  Set sExp = sVal[3]
.head 7 -  Set sCage = sVal[4]
.head 7 -  Set sRack = sVal[5]
.head 7 -  Set sForeign = sVal[6]
.head 7 -  Set sGenotype = sVal[7]
.head 7 -  Set sPhenotype = sVal[8]
.head 7 -  Set sBreedingNr = sVal[9]
.head 7 -  Set sFamily = sVal[10]
.head 7 -  Set nBatch = nVal[0]
.head 7 -  Set nAge = nVal[1]
.head 7 -  Set nMateID = nVal[2]
.head 7 -  Set dtBirthDate = dtVal[0]
.head 7 -  Return TRUE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sEarTag
.head 7 -  Set sVal[1]= sSex
.head 7 -  Set sVal[2]= sStrain 
.head 7 -  Set sVal[3] = sExp 
.head 7 -  Set sVal[4] = sCage 
.head 7 -  Set sVal[5] = sRack
.head 7 -  Set sVal[6] = sForeign
.head 7 -  Set sVal[7] = sGenotype
.head 7 -  Set sVal[8] = sPhenotype
.head 7 -  Set sVal[9] = sBreedingNr
.head 7 -  Set sVal[10] = sFamily
.head 7 -  Set nVal[0] = nBatch
.head 7 -  Set nVal[1] = nAge
.head 7 -  Set nVal[2] = nMateID
.head 7 -  Set dtVal[0] = dtBirthDate
.head 7 -  Return TRUE
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBit
.head 6 +  Actions
.head 7 +  If nParam = AnimalInMate
.head 8 -  Set nBit  = 1
.head 7 +  Else If nParam = AnimalIsDead
.head 8 -  Set nBit  = 2
.head 7 +  Else If nParam = AnimalInPlanBew
.head 8 -  Set nBit  = 4
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set nBit  = 8
.head 7 +  Else If nParam = IsServise
.head 8 -  Set nBit  = 16
.head 7 -  Call AddToFlag(nBit)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 +  If nParam = AnimalInMate
.head 8 -  Set bReturn =nStatusFlags&1
.head 7 +  Else If nParam = AnimalIsDead
.head 8 -  Set bReturn =nStatusFlags&2
.head 7 +  Else If nParam = AnimalInPlanBew
.head 8 -  Set bReturn =nStatusFlags&4
.head 7 +  Else If nParam = IsAlert
.head 8 -  Set bReturn =nStatusFlags&8
.head 7 +  Else If nParam = IsServise
.head 8 -  Set bReturn =nStatusFlags&16
.head 7 -  Return bReturn
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If GetState(AnimalInPlanBew)
.head 8 -  Set sLabel = sLabel || " [PLAN]"
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 +  Select Case nInd
.head 8 +  Case 1 ! Animal ID
.head 9 -  Set sText = '{' || StrX( nID_Obj ) || '} ' 
.head 9 -  Break
.head 8 +  Case 2 ! Dead status
.head 9 +  If GetState(AnimalIsDead ) 
.head 10 -  Set sText = ' K ' || ','
.head 9 -  Break
.head 8 +  Case 3 ! Strain
.head 9 -  Set sText = sStrain || "," 
.head 9 -  Break
.head 8 +  Case 4 ! sex
.head 9 -  Set sText = sSex || "," 
.head 9 -  Break
.head 8 +  Case 5 ! Experiment
.head 9 +  If bNeedPrefix
.head 10 -  Set sText = "Lic:" || sExp || "," 
.head 9 +  Else
.head 10 -  Set sText = sExp || "," 
.head 9 -  Break
.head 8 +  Case 6 ! Age
.head 9 +  If bNeedPrefix
.head 10 -  Set sText ="Age:" || StrX( nAge ) || ', ' 
.head 9 +  Else
.head 10 -  Set sText =StrX( nAge ) || ', ' 
.head 9 -  Break
.head 8 +  Case 7 ! Cage
.head 9 +  If bNeedPrefix
.head 10 -  Set sText = "Cage:" || sCage || "," 
.head 9 +  Else
.head 10 -  Set sText = sCage || "," 
.head 9 -  Break
.head 8 +  Case 8 ! Rack
.head 9 +  If bNeedPrefix
.head 10 -  Set sText = "Rack:" || sRack || "," 
.head 9 +  Else
.head 10 -  Set sText = sRack || "," 
.head 9 -  Break
.head 8 +  Case 9 ! ForegnID
.head 9 -  Set sText = sForeign || ',' 
.head 9 -  Break
.head 8 +  Case 10! Genotypes
.head 9 -  Set sText = sGenotype || ', ' 
.head 9 -  Break
.head 8 +  Case 11 ! Phenotype
.head 9 -  Set sText = sPhenotype || ', ' 
.head 9 -  Break
.head 8 +  Case 12 ! MatingID
.head 9 +  If nMateID
.head 10 -  Set sText ="[Mate ID " || StrX( nMateID  ) || '] ' 
.head 9 -  Break
.head 8 +  Case 13 ! Breeding
.head 9 +  If nMateID
.head 10 -  Set sText ="Breeding cage: " || sFamily || "/" || sBreedingNr || ', ' 
.head 9 -  Break
.head 8 +  Case 14 ! Batch
.head 9 +  If bNeedPrefix
.head 10 -  Set sText = "Batch: " || StrX( nBatch ) || ', ' 
.head 9 +  Else
.head 10 -  Set sText = StrX( nBatch ) || ', ' 
.head 9 -  Break
.head 8 +  Case 15 ! EarTag
.head 9 -  Set sText = sEarTag || ',' 
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sValue
.head 6 +  Actions
.head 7 -  Set sValue = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam="SEX"
.head 8 -  Set sValue = sSex
.head 7 +  Else If sParam="STRAIN"
.head 8 -  Set sValue = sStrain
.head 7 +  Else If sParam="EARTAG"
.head 8 -  Set sValue = sEarTag
.head 7 +  Else If sParam="EXP"
.head 8 -  Set sValue = sExp
.head 7 +  ! Else If sParam="BATCH"
.head 8 -  Set sValue = sBatch
.head 7 -  Return sValue
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return NUMBER_Null
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sEarTag = STRING_Null
.head 7 -  Set sSex = sEarTag
.head 7 -  Set sStrain = sEarTag
.head 7 -  Set sExp = sEarTag
.head 7 -  Set sCage = sEarTag
.head 7 -  Set sRack = sEarTag
.head 7 -  Set sForeign = sEarTag
.head 7 -  Set sGenotype = sEarTag
.head 7 -  Set sPhenotype = sEarTag
.head 7 -  Set sBreedingNr = sEarTag
.head 7 -  Set sFamily = sEarTag
.head 7 -  Set nBatch = NUMBER_Null
.head 7 -  Set nAge = nBatch
.head 7 -  Set nMateID = nBatch
.head 7 -  Set dtBirthDate = DATETIME_Null
.head 3 +  Functional Class: cAERowService
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sServiceName
.head 5 -  String: sServiceDesc
.head 4 -  Functions
.head 3 +  Functional Class: cAERowStrain
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: cFERow
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sName
.head 5 -  String: sMut1
.head 5 -  String: sMut2
.head 5 -  String: sMut3
.head 5 -  String: sMut4
.head 5 -  String: sMut5
.head 5 -  String: sMut6
.head 5 -  String: sMut7
.head 5 -  String: sMutTotal
.head 5 -  String: sBgStrain
.head 5 -  Number: nBG_Color
.head 5 -  Number: nTX_Color
.head 5 -  Number: nColonyNr
.head 4 +  Functions
.head 5 +  Function: Associate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sName = sVal[0]
.head 7 -  Set sMut1 = sVal[1]
.head 7 -  Set sMut2 = sVal[2]
.head 7 -  Set sMut3 = sVal[3]
.head 7 -  Set sMut4 = sVal[4]
.head 7 -  Set sMut5 = sVal[5]
.head 7 -  Set sMut6 = sVal[6]
.head 7 -  Set sMut7 = sVal[7]
.head 7 -  Set sBgStrain = sVal[8]
.head 7 -  Set nBG_Color = nVal[0]
.head 7 -  Set nTX_Color = nVal[1]
.head 7 -  Set nColonyNr = nVal[2]
.head 7 -  Return TRUE
.head 5 +  Function: Save
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sVal[0] = sName
.head 7 -  Set sVal[1]= sMut1
.head 7 -  Set sVal[2]= sMut2 
.head 7 -  Set sVal[3] = sMut3 
.head 7 -  Set sVal[4] = sMut4
.head 7 -  Set sVal[5] = sMut5
.head 7 -  Set sVal[6] = sMut6
.head 7 -  Set sVal[7] = sMut7
.head 7 -  Set sVal[8] = sBgStrain
.head 7 -  Set nVal[0] = nBG_Color
.head 7 -  Set nVal[1] = nTX_Color
.head 7 -  Set nVal[2] = nColonyNr
.head 7 -  Return TRUE
.head 5 +  Function: GetLabelValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nInd
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Set sText = ''
.head 7 +  Select Case nInd
.head 8 +  Case 1
.head 9 -  Set sText = '(' || sName  || ') ' 
.head 9 -  Break
.head 8 +  Case 2
.head 9 -  ! Set sMutTotal = sMut1 || "," || sMut2 || "," ||sMut3|| "," ||sMut4|| "," ||sMut5|| "," ||sMut6 || "," || sMut7
.head 9 +  If sMut1
.head 10 -  Set sMutTotal = sMut1
.head 9 +  If sMut2
.head 10 +  If sMutTotal
.head 11 -  Set sMutTotal = sMutTotal || ',' || sMut2
.head 10 +  Else
.head 11 -  Set sMutTotal = sMut2
.head 9 +  If sMut3
.head 10 +  If sMutTotal
.head 11 -  Set sMutTotal = sMutTotal || ',' || sMut3
.head 10 +  Else
.head 11 -  Set sMutTotal = sMut3
.head 9 +  If sMut4
.head 10 +  If sMutTotal
.head 11 -  Set sMutTotal = sMutTotal || ',' || sMut4
.head 10 +  Else
.head 11 -  Set sMutTotal = sMut4
.head 9 +  If sMut5
.head 10 +  If sMutTotal
.head 11 -  Set sMutTotal = sMutTotal || ',' || sMut5
.head 10 +  Else
.head 11 -  Set sMutTotal = sMut5
.head 9 +  If sMut6
.head 10 +  If sMutTotal
.head 11 -  Set sMutTotal = sMutTotal || ',' || sMut6
.head 10 +  Else
.head 11 -  Set sMutTotal = sMut6
.head 9 +  If sMut7
.head 10 +  If sMutTotal
.head 11 -  Set sMutTotal = sMutTotal || ',' || sMut7
.head 10 +  Else
.head 11 -  Set sMutTotal = sMut7
.head 9 -  Set sText = "[" || sMutTotal || "] " 
.head 9 -  Break
.head 8 +  Case 3
.head 9 -  Set sText = "Bg:" || sBgStrain  || "," 
.head 9 -  Break
.head 8 +  Case 4
.head 9 +  If GetState( StrainIsGVO )
.head 10 -  Set sText = "GVO," 
.head 9 -  Break
.head 8 +  Case 5
.head 9 +  If GetState( StrainIsVas )
.head 10 -  Set sText = "VAS," 
.head 9 -  Break
.head 8 +  Case 6
.head 9 -  Set sText = "Colony Nr: " || SalNumberToStrX(nColonyNr,0) || ","
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return sText
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sValue
.head 6 +  Actions
.head 7 -  Set sValue = ""
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam="STRAIN"
.head 8 -  Set sValue = sName
.head 7 -  Return sValue
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nVal
.head 6 +  Actions
.head 7 -  Set sParam = SalStrUpperX( sParam )
.head 7 +  If sParam= "COLONY"
.head 8 -  Set nVal =nColonyNr 
.head 7 -  Return nVal
.head 5 +  Function: Clear
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set sName = STRING_Null
.head 7 -  Set sMut1 = sName
.head 7 -  Set sMut2 = sName
.head 7 -  Set sMut3 = sName
.head 7 -  Set sMut4 = sName
.head 7 -  Set sMut5 = sName
.head 7 -  Set sMut6 = sName
.head 7 -  Set sMut7 = sName
.head 7 -  Set sMutTotal = sName
.head 7 -  Set sBgStrain = sName
.head 7 -  Set nBG_Color = NUMBER_Null
.head 7 -  Set nTX_Color = nBG_Color
.head 7 -  Set nColonyNr = nBG_Color
.head 5 +  Function: BuildLabels
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 +  Function: SetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBit
.head 6 +  Actions
.head 7 +  If nParam = StrainIsVas
.head 8 -  Set nBit  = 1
.head 7 +  Else If nParam = StrainIsGVO
.head 8 -  Set nBit  = 2
.head 7 -  Call AddToFlag(nBit)
.head 7 -  Return TRUE
.head 5 +  Function: GetState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 +  If nParam = StrainIsVas
.head 8 -  Set bReturn =nStatusFlags&1
.head 7 +  Else If nParam = StrainIsGVO
.head 8 -  Set bReturn =nStatusFlags&2
.head 7 -  Return bReturn
.head 3 -  !
.head 3 +  Child Table Class: clsNewExplorer
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left:
.head 6 -  Top:
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Class Default
.head 5 -  Discardable? Class Default
.head 4 -  Next Class Child Key: 29
.head 4 -  List in Tool Palette? Yes
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Description:
.head 4 -  Derived From
.head 4 +  Contents
.head 5 +  Column: colTree
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 1
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: TREE
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Left
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colIDObject
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 2
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: ID
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colOrder
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 3
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: order
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCheck
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 4
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Check Box
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colFlags
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 15
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: order
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 5
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 6
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal3
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 7
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal4
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 8
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal5
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 9
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal6
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 10
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal7
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 11
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal8
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 12
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal9
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 13
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal10
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 14
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal11
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 26
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal12
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 27
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 16
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 17
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal3
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 25
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal4
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 18
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal5
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 19
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal6
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 20
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal7
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 21
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal8
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 22
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal9
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 23
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal10
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 24
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 28
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Date/Time
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 29
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Date/Time
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  ! Settings
.head 5 -  FunctionalVar: oSettingsHouse
.head 6 -  Class: oSettingsFE
.head 5 -  FunctionalVar: oSettingsWorkGroup
.head 6 -  Class: oSettingsFE
.head 5 -  FunctionalVar: oSettingsRack
.head 6 -  Class: oSettingsFE
.head 5 -  FunctionalVar: oSettingsCage
.head 6 -  Class: oSettingsFE
.head 5 -  FunctionalVar: oSettingsBett
.head 6 -  Class: oSettingsFE
.head 5 -  !
.head 5 -  Number: nCCSrv
.head 5 -  Boolean: bUseEmail
.head 5 -  Boolean: bPics
.head 5 -  Boolean: bShowOnlyOpenCages
.head 5 -  Boolean: bServicesOnOpenCage
.head 5 -  Boolean: bMassMating
.head 5 -  Boolean: bAskForLicense
.head 5 -  Boolean: bMoveToVirt
.head 5 -  Boolean: bDischargeDead
.head 5 -  Boolean: bPlanningMode
.head 5 -  Boolean: bShowTransferDialog
.head 5 -  Number: nLoadPics
.head 5 -  Number: nBGColor
.head 5 -  String: sAutoStartService
.head 5 -  !
.head 5 -  Number: nRoot
.head 5 -  FunctionalVar: oPosition
.head 6 -  Class: cPositionData
.head 5 -  Number: nSelectedLevel
.head 5 -  Number: nSelectedRow
.head 5 -  ! Select rows
.head 5 -  FunctionalVar: oHandleSelect
.head 6 -  Class: cSelectRowFE
.head 5 -  !
.head 5 -  Window Handle: hWndSCol[*]
.head 5 -  Window Handle: hWndNCol[*]
.head 5 -  Window Handle: hWndDtCol[*]
.head 5 -  !
.head 5 -  Boolean: bAutoSize
.head 5 -  !
.head 5 -  Number: nRowSetCont
.head 4 +  Functions
.head 5 +  Function: InitTable
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Window Handle: hWndCol
.head 7 -  String: sNameCol
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nD
.head 7 -  Number: nPos
.head 6 +  Actions
.head 7 -  Call LoadSettings()
.head 7 -  Call MTblDefineTree( hWndItem , colTree,8, 16 )
.head 7 -  Call MTblSetTreeFlags( hWndItem, MTBL_TREE_FLAG_NO_ROWLINES, TRUE )
.head 7 -  Call MTblSetFlags( hWndItem, MTBL_FLAG_VARIABLE_ROW_HEIGHT, TRUE )
.head 7 -  Call MTblSetFlags( hWndItem, MTBL_FLAG_NO_FREE_COL_AREA_LINES, TRUE )
.head 7 -  Call MTblSetFlags( hWndItem, MTBL_FLAG_NO_FREE_ROW_AREA_LINES | MTBL_FLAG_SORT_RESTORE_TREE, TRUE )
.head 7 -  Call MTblSetColumnFlags( colTree , MTBL_COL_FLAG_NO_COLLINE, TRUE )
.head 7 -  Call MTblSetColumnHdrFlags( colTree, MTBL_COLHDR_FLAG_TXTALIGN_LEFT, TRUE )
.head 7 -  ! Call MTblSetFlags( hWndItem, MTBL_FLAG_SUPPRESS_ROW_SELECTION, TRUE )
.head 7 -  Call SalTblSetTableFlags ( hWndItem, TBL_Flag_SingleSelection, TRUE )
.head 7 -  Call MTblSetTreeFlags( hWndItem, MTBL_TREE_FLAG_AUTO_NORM_HIER , TRUE )
.head 7 -  ! Call MTblSetTreeFlags( hWndItem, MTBL_TREE_FLAG_FLAT_STRUCT, TRUE )
.head 7 -  Call MTblEnableMWheelScroll( hWndItem, TRUE )
.head 7 -  ! Call MTblSetFlags(hWndItem,  MTBL_FLAG_EXPAND_ROW_ON_DBLCLK, TRUE)
.head 7 -  Call SalTblDefineRowHeader (hWndItem , "", 0 ,TBL_RowHdr_Visible , hWndNULL)
.head 7 -  Call MTblSetSelectionColors( hWndItem, COLOR_White, COLOR_Black )
.head 7 -  Call oHandleSelect.Init(  )
.head 7 -  Call SalArraySetUpperBound( hWndSCol, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hWndNCol, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hWndDtCol , 1, -1 )
.head 7 -  Set nPos = 1
.head 7 -  Set nI = 0
.head 7 -  Set nK = nI
.head 7 -  Set nD = nI
.head 7 -  Set hWndCol = SalTblGetColumnWindow( hWndForm, nPos, COL_GetPos )
.head 7 +  Loop
.head 8 +  If hWndCol = hWndNULL
.head 9 -  Break
.head 8 -  Call SalGetItemName ( hWndCol, sNameCol )
.head 8 +  If SalStrScan( sNameCol, "colSVal" )!=-1
.head 9 -  Set hWndSCol[nI] = hWndCol
.head 9 -  Set nI = nI + 1
.head 8 +  Else If SalStrScan( sNameCol, "colNVal" )!=-1
.head 9 -  Set hWndNCol[nK] = hWndCol
.head 9 -  Set nK = nK + 1
.head 8 +  Else If SalStrScan( sNameCol, "colDtVal" )!=-1
.head 9 -  Set hWndDtCol[nD] = hWndCol
.head 9 -  Set nD = nD + 1
.head 8 -  Set nPos = nPos + 1
.head 8 -  Set hWndCol = SalTblGetColumnWindow( hWndForm, nPos, COL_GetPos )
.head 5 +  Function: LoadSettings
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sTmp
.head 7 -  String: sBGColor
.head 7 -  String: sSection
.head 6 +  Actions
.head 7 -  Set sSection = "KHE"
.head 7 -  Call oSettingsHouse.Init("Institute")
.head 7 -  Call oSettingsWorkGroup.Init("WorkGroup")
.head 7 -  Call oSettingsRack.Init("Rack")
.head 7 -  Call oSettingsCage.Init("Cage")
.head 7 -  Call oSettingsBett.Init("Bett")
.head 7 -  !
.head 7 -  Set bPics = GalGetProfileBooleanX( sSection, "LoadPics", FALSE, sUserINIFileName )
.head 7 -  Set bMassMating=  GalGetProfileBooleanX( sSection, "MassMating", TRUE, sUserINIFileName )
.head 7 -  ! Set bDistribution=  GalGetProfileBooleanX( sSection, "Use_Distribution", TRUE, sUserINIFileName )
.head 7 -  Set bShowOnlyOpenCages = GalGetProfileBooleanX( sSection, "ShowOnlyOpenCages", TRUE, sUserINIFileName )
.head 7 -  Set bServicesOnOpenCage = GalGetProfileBooleanX( "KHE", "ShowSevicesAndMR", FALSE, sUserINIFileName )
.head 7 -  Set sAutoStartService = GalGetProfileStringX(  "KHE", "AutoStartService", "ASK", sUserINIFileName)
.head 7 -  Set bShowTransferDialog = GetOptionBoolean("KHE", "ShowDialogMoveTransferCages", TRUE  )
.head 7 -  ! Set bShowMenuOnClosingCage = GalGetProfileBooleanX( sSection, "ShowMenuOnClosingCage", FALSE, sUserINIFileName )
.head 7 -  ! Set bShowDateTimeInKHE = GalConfig_GetBool( sSection, "ShowTime", FALSE, cfgUSER )
.head 7 -  ! Set bColorStrain = GalGetProfileBooleanX('Values','ColorStrain',FALSE, sGHSini_FileName )
.head 7 -  ! Call SetAutoMode( GalGetProfileBooleanX(sSection, "AutoMode", TRUE, sGHSini_FileName ) )
.head 7 -  ! Set sOpenKHKItemOnScan = GalGetProfileStringX("Settings", "OpenKHKItemOnScan" ,"Yes", ATLANTA_INI)
.head 7 -  ! Set bShowMenuOnClosingCage = GalGetProfileBooleanX( sSection, "ShowMenuOnClosingCage", FALSE, sUserINIFileName )
.head 7 -  ! Set bOpenOnDblClick = GalGetProfileBooleanX( sSection, "OpenOnDblClick", TRUE, sUserINIFileName )
.head 7 -  ! Set bShowPlacesWithContent = GalGetProfileBooleanX('KHE','ShowOnlyPlacesWithContent', TRUE, sUserINIFileName )
.head 7 -  ! Set bShowWithContent = GalGetProfileBooleanX('KHE','ShowOnlyCagesWithContent', FALSE, sUserINIFileName )
.head 7 -  ! Set bShowPlannedCages = GalGetProfileBooleanX( sSection, "ShowPlannedCages", FALSE, sUserINIFileName )
.head 7 -  ! Set bShouPics= GalGetProfileBooleanX( sSection, "ShowPicsInKHE", TRUE, sUserINIFileName )
.head 7 -  ! Set bRealTimeMode = GalGetProfileBooleanX( sSection, "RealTimeMode", TRUE, sUserINIFileName )
.head 7 -  Set bDischargeDead = GalGetProfileBooleanX( sSection, "DisCulledAinmals", TRUE, sUserINIFileName )
.head 7 -  ! Set bSelectDead = GalGetProfileBooleanX( sSection, "SelectDisCulledAinmals", TRUE, sUserINIFileName )
.head 7 -  Set bAskForLicense = GalGetProfileBooleanX( "Settings", "AskForLicense", FALSE, sGHSini_FileName )
.head 7 -  Set bMoveToVirt = GalGetProfileBooleanX( sSection, "MoveToVirtualOnOpen", FALSE, sUserINIFileName )
.head 7 -  ! Set bMiniSolution = GalGetProfileBooleanX( "System", "MiniSolution", FALSE, sGHSini_FileName )
.head 7 -  ! Set bShowCageName = GalGetProfileBooleanX( sSection, "ShowCageName", TRUE, sUserINIFileName )
.head 7 -  ! Set bShowCageUniqNr = GalGetProfileBooleanX( sSection, "ShowCageUniqNr", TRUE, sUserINIFileName )
.head 7 -  Set bAutoShowTableSevices = GalGetProfileBooleanX( sSection, "ShowSevicesAndMR", FALSE, sUserINIFileName )
.head 7 -  Set sQuestionOnShowTableServices = SalStrUpperX( GalGetProfileStringX(  sSection, "AutoStartService", "ASK", sUserINIFileName) )
.head 7 -  ! Call LoadPics()
.head 7 +  If GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select value from settings where section = 'EMail' and name = 'Email notification' into :sTmp")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select value from settings where section = 'DEFAULT' and name = 'FacilityColor' into :sBGColor ")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Set nBGColor = SalStrToNumber(sBGColor)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select id from sysadm.leistung where lst_key = 'CCH' into :nCCSrv")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Call SalColorSet ( hWndItem, COLOR_IndexWindow, nBGColor)
.head 7 +  If sTmp = "On"
.head 8 -  Set bUseEmail = TRUE
.head 7 +  Else
.head 8 -  Set bUseEmail = FALSE
.head 7 -  Call GalSetProfileString("Settings", "AddRelshipDef", "YES", sGHSini_FileName)
.head 7 -  Call ReFont()
.head 5 +  Function: ReFont
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 -  Actions
.head 5 +  Function: GetTime4Refresh
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Date/Time:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return SalDateCurrent ( )
.head 5 +  Function: FindObject
.head 6 -  Description: Find RowNr with objectID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nID_Object
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRow
.head 7 -  Number: nChildRow
.head 6 +  Actions
.head 7 -  Set nRow = -1
.head 7 +  If nParent != TBL_MinRow
.head 8 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nParent )
.head 7 +  Else
.head 8 -  Set nChildRow = 0
.head 7 +  While nChildRow != TBL_Error
.head 8 -  Call SalTblSetContext ( hWndForm, nChildRow )
.head 8 +  If colIDObject = nID_Object
.head 9 -  Set nRow = nChildRow
.head 9 -  Break
.head 8 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 7 -  Return nRow
.head 5 +  Function: FE_NewRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewRow
.head 6 +  Actions
.head 7 +  If nParent = -1
.head 8 -  Set nNewRow = SalTblInsertRow ( hWndForm, TBL_MaxRow )
.head 7 +  Else
.head 8 -  Set nNewRow = MTblInsertChildRow( hWndForm, nParent, MTICR_REDRAW )
.head 7 -  Call SalTblSetRowFlags ( hWndForm, nNewRow, ROW_New	, FALSE )
.head 7 -  Call MTblSetRowFlags( hWndItem, nNewRow, MTBL_ROW_NOSELINV_IMAGE | MTBL_ROW_NOSELINV_TEXT, TRUE, MTSRF_REDRAW )
.head 7 -  Return nNewRow
.head 5 +  Function: FE_DelRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nObjDel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowDel
.head 6 +  Actions
.head 7 -  Set nRowDel = FindObject( nParent, nObjDel )
.head 7 +  If nRowDel != -1
.head 8 -  Call MTblDeleteDescRows( hWndForm, nRowDel, TBL_Adjust )
.head 8 -  Call SalTblDeleteRow( hWndForm, nRowDel, TBL_Adjust )
.head 5 +  Function: FE_SetInfo
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  FunctionalVar: _cInfo 
.head 8 -  Class: cFERow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nMax
.head 7 -  Number: nI
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Call SalTblSetContext ( hWndForm, nRow )
.head 7 +  Select Case GetLevel( nRow )
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set _cInfo.oLevelSetting = oSettingsHouse
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set _cInfo.oLevelSetting = oSettingsWorkGroup
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set _cInfo.oLevelSetting = oSettingsRack
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set _cInfo.oLevelSetting = oSettingsCage
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  Set _cInfo.oLevelSetting = oSettingsBett
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Call _cInfo.Save(  )
.head 7 -  Set colTree = _cInfo.sLabel
.head 7 -  Set colIDObject = _cInfo.nID_Obj
.head 7 -  Set colOrder =_cInfo.nOrder
.head 7 -  Set colFlags = _cInfo.nStatusFlags
.head 7 -  Set colCheck = _cInfo.nCheckRow
.head 7 +  If not SalArrayIsEmpty (  _cInfo.sVal )
.head 8 -  Call SalArrayGetUpperBound ( _cInfo.sVal , 1, nMax )
.head 8 -  Set nI = 0
.head 8 +  While nI <= nMax
.head 9 -  Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndSCol[nI] ), _cInfo.sVal[nI] )
.head 9 -  Set nI = nI + 1
.head 7 +  If not SalArrayIsEmpty (  _cInfo.nVal )
.head 8 -  Call SalArrayGetUpperBound ( _cInfo.nVal , 1, nMax )
.head 8 -  Set nI = 0
.head 8 +  While nI <= nMax
.head 9 -  Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndNCol[nI] ),SalNumberToStrX(  _cInfo.nVal[nI],2) )
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal1 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal2 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal3 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal4 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal5 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal6 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal7 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal8 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal9 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 8 +  ! If nI <= nMax
.head 9 -  Set colNVal10 = _cInfo.nVal[nI]
.head 9 -  Set nI = nI + 1
.head 7 +  If not SalArrayIsEmpty (  _cInfo.dtVal )
.head 8 -  Call SalArrayGetUpperBound ( _cInfo.dtVal , 1, nMax )
.head 8 -  Set nI = 0
.head 8 +  While nI <= nMax
.head 9 -  Call SalDateToStr( _cInfo.dtVal[0], sText ) 
.head 9 -  Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndDtCol[nI] ), sText )
.head 9 -  Set nI = nI + 1
.head 7 +  If _cInfo.nID_Obj != -100
.head 8 -  Call ReAssignPic(nRow)
.head 7 +  Else
.head 8 -  Call MTblSetRowFlags( hWndForm, nRow, MTBL_ROW_HIDDEN, TRUE, MTSRF_REDRAW )
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 5 +  Function: FE_GetInfo
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  FunctionalVar:
.head 8 -  Class: cFERow
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: _cInfo 
.head 8 -  Class: cFERow
.head 7 -  Number: nInd
.head 7 -  Number: nMax
.head 7 -  String: sVal
.head 6 +  Actions
.head 7 -  Call SalTblSetContext ( hWndForm, nRow )
.head 7 +  Select Case MTblGetRowLevel( hWndForm, nRow )
.head 8 +  Case FEL_Institute
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowIns" )
.head 9 -  Break
.head 8 +  Case FEL_Workgroup
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowScr" )
.head 9 -  Break
.head 8 +  Case FEL_Rack
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowRack" )
.head 9 -  Break
.head 8 +  Case FEL_Cage
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowCage" )
.head 9 -  Break
.head 8 +  Case FEL_Pos
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowBett" )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Call _cInfo.Init(  )
.head 7 -  Set _cInfo.sLabel = colTree
.head 7 -  Set _cInfo.nID_Obj = colIDObject
.head 7 -  Set _cInfo.nOrder = colOrder
.head 7 -  Set _cInfo.nStatusFlags = colFlags
.head 7 -  Set _cInfo.nCheckRow = colCheck
.head 7 -  Set _cInfo.sCagePosition = colSVal1
.head 7 -  Set _cInfo.sStrain = colSVal3
.head 7 -  Set nInd = 0
.head 7 -  Call SalArrayGetUpperBound( hWndSCol, 1, nMax )
.head 7 +  While nInd <= nMax
.head 8 -  Call SalTblGetColumnText ( hWndForm, SalTblQueryColumnID ( hWndSCol[nInd] ), sVal )
.head 8 -  Call _cInfo.AddString( sVal )
.head 8 -  Set nInd = nInd + 1
.head 7 -  Set nInd = 0
.head 7 -  Call SalArrayGetUpperBound( hWndNCol, 1, nMax )
.head 7 +  While nInd <= nMax
.head 8 -  Call SalTblGetColumnText ( hWndForm, SalTblQueryColumnID ( hWndNCol[nInd] ), sVal )
.head 8 -  Call _cInfo.AddNumber( SalStrToNumber( sVal ) )
.head 8 -  Set nInd = nInd + 1
.head 7 -  Set nInd = 0
.head 7 -  Call SalArrayGetUpperBound( hWndDtCol , 1, nMax )
.head 7 +  While nInd <= nMax
.head 8 -  Call SalTblGetColumnText ( hWndForm, SalTblQueryColumnID ( hWndDtCol[nInd] ), sVal )
.head 8 -  Call _cInfo.AddDate( SalStrToDate ( sVal ) )
.head 8 -  Set nInd = nInd + 1
.head 7 -  Call _cInfo.Associate(  )
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 7 -  Return _cInfo
.head 5 +  Function: FE_ReloadHint
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowReload
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: cInfo 
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set cInfo = FE_GetInfo(nRowReload)
.head 7 +  Select Case GetLevel(nRowReload)
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set cInfo.nLabelFlags = oSettingsHouse.nFlags
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set cInfo.nLabelFlags = oSettingsWorkGroup.nFlags
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set cInfo.nLabelFlags = oSettingsRack.nFlags
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set cInfo.nLabelFlags = oSettingsCage.nFlags
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  Set cInfo.nLabelFlags = oSettingsBett.nFlags
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Call cInfo.BuildLabels()
.head 7 -  Call FE_SetInfo(nRowReload, cInfo)
.head 5 +  Function: FE_GetFlag
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFlag
.head 6 +  Actions
.head 7 +  If nRow = nSelectedRow
.head 8 -  Set nFlag = colFlags
.head 7 +  Else
.head 8 -  Call SalTblSetContext ( hWndForm, nRow )
.head 8 -  Set nFlag = colFlags
.head 8 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 7 -  Return nFlag
.head 5 +  Function: ReAssignPic
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nCurrentRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sMaska
.head 7 -  String: sMaska1
.head 7 -  Number: nLevelLoc
.head 7 -  Number: nPicAssign
.head 7 -  Number: nPicAssignNew
.head 7 -  Number: nFlags
.head 7 -  Number: nRowFlags
.head 7 -  Number: nKoef
.head 7 -  Number: nrHeight
.head 7 -  Number: nSizeFont
.head 7 -  Number: nH_Pic
.head 7 -  Number: nW_Pic
.head 7 -  FunctionalVar: oCheckRow
.head 8 -  Class: cFERow
.head 7 -  Number: nKoefHeightRow
.head 7 -  Number: nFocusRow
.head 7 -  Window Handle: hWndFocusCol
.head 6 +  Actions
.head 7 -  Set nKoefHeightRow = 0.8
.head 7 -  Set oCheckRow = FE_GetInfo( nCurrentRow )
.head 7 -  Call SalTblSetContext(hWndForm,nCurrentRow )
.head 7 -  Set sMaska=''
.head 7 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nCurrentRow )
.head 7 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 7 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 7 +  Select Case nLevelLoc
.head 8 +  Case FEL_Institute
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Einrichtung')
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsHouse.hFont.sName, oSettingsHouse.hFont.nSize, oSettingsHouse.hFont.nEnh, MTSF_REDRAW )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsHouse.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Call oSettingsHouse.cPicture.SetNewHeight( nrHeight )
.head 9 -  Set sMaska='H_Main'
.head 9 -  If oSettingsHouse.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case FEL_Workgroup
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics WorkGroup' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsWorkGroup.hFont.sName, oSettingsWorkGroup.hFont.nSize, oSettingsWorkGroup.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsWorkGroup.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  Call oSettingsWorkGroup.cPicture.SetNewHeight( nrHeight)
.head 9 -  Set sMaska = oCheckRow.GetSValue( "SCREEN" )
.head 9 -  If oSettingsWorkGroup.GetPic(sMaska, nPicAssign)
.head 9 +  If nPicAssign = 0 or nPicAssign = NUMBER_Null
.head 10 -  Set sMaska='W_Main'
.head 10 -  If oSettingsWorkGroup.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case FEL_Rack
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Rack' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsRack.hFont.sName, oSettingsRack.hFont.nSize, oSettingsRack.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsRack.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  Call oSettingsRack.cPicture.SetNewHeight( nrHeight )
.head 9 -  Set sMaska='R'
.head 9 +  If oCheckRow.GetState( RackIsVirtual )
.head 10 -  Set sMaska=sMaska ||'_Virt'
.head 10 -  Set sMaska1 = oCheckRow.GetSValue( "MODEL" )
.head 9 +  Else
.head 10 +  ! If oCheckRow.GetState( RackIsFull  )
.head 11 -  Set sMaska=sMaska ||'_Full'
.head 11 -  Set sMaska1 = oCheckRow.GetSValue( "MODEL" )
.head 10 +  ! Else
.head 11 -  Set sMaska=sMaska ||'_Empty'
.head 10 -  Set sMaska=sMaska ||'_Full'
.head 10 -  Set sMaska1 = oCheckRow.GetSValue( "MODEL" )
.head 9 -  Set nPicAssign = NUMBER_Null
.head 9 +  If sMaska1
.head 10 -  If oSettingsRack.GetPic(sMaska1, nPicAssign)
.head 9 +  If nPicAssign = 0 or nPicAssign = NUMBER_Null
.head 10 -  If oSettingsRack.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case FEL_Cage
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Cage' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsCage.hFont.sName, oSettingsCage.hFont.nSize, oSettingsCage.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsCage.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  Call oSettingsCage.cPicture.SetNewHeight( nrHeight )
.head 9 -  Set sMaska='C'
.head 9 +  If oCheckRow.GetState( CageIsOccupied )
.head 10 -  Set sMaska=sMaska || '_Occupied'
.head 9 +  Else
.head 10 +  If oCheckRow.GetState( CageIsRoling )
.head 11 -  Set sMaska=sMaska || '_Rol'
.head 10 +  Else If oCheckRow.GetState( CageIsFull )
.head 11 -  Set sMaska=sMaska || '_Full'
.head 10 +  Else
.head 11 -  Set sMaska=sMaska || '_Empty'
.head 10 +  If oCheckRow.GetState( CageWithRFID )
.head 11 -  Set sMaska=sMaska || '_RFID'
.head 10 +  If oCheckRow.GetState( IsServise )
.head 11 -  Set sMaska=sMaska || '_Serv'
.head 10 +  If oCheckRow.GetState( IsAlert )
.head 11 -  Set sMaska=sMaska || '_Alert'
.head 9 -  If oSettingsCage.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case FEL_Pos
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Position' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsBett.hFont.sName, oSettingsBett.hFont.nSize, oSettingsBett.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsBett.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  Call oSettingsBett.cPicture.SetNewHeight( nrHeight )
.head 9 -  Set sMaska='M'
.head 9 +  If oCheckRow.GetSValue( "Sex" ) = 'M'
.head 10 -  Set sMaska=sMaska || "_Male"
.head 9 +  Else
.head 10 -  Set sMaska=sMaska || "_Female"
.head 9 +  If oCheckRow.GetState( AnimalIsDead )
.head 10 -  Set sMaska=sMaska || "_Dead"
.head 9 +  If oCheckRow.GetState( AnimalIsLitter )
.head 10 -  Set sMaska=sMaska || "_Pups"
.head 9 +  If oCheckRow.GetState( IsAlert )
.head 10 -  Set sMaska=sMaska || "_Alert"
.head 9 +  If oCheckRow.GetState( IsServise )
.head 10 -  Set sMaska=sMaska || "_Serv"
.head 9 +  If oCheckRow.GetState( AnimalInPlanBew ) and not oCheckRow.GetState( AnimalIsDead )
.head 10 -  Set sMaska=sMaska || "_Plan"
.head 9 +  If colCheck=1
.head 10 -  Set sMaska=sMaska || "_Select"
.head 9 -  If oSettingsBett.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 7 +  If nPicAssign != NUMBER_Null and not bPics
.head 8 -  Call SalTblQueryFocus( hWndForm, nFocusRow, hWndFocusCol )
.head 8 -  Set nPicAssignNew = MImgCreateCopy( nPicAssign )
.head 8 +  If nFocusRow = nCurrentRow
.head 9 -  Call MImgInvert( nPicAssignNew )
.head 8 -  Call MTblSetCellImageExp( colTree, nCurrentRow, nPicAssignNew, nFlags )
.head 8 -  Call MTblSetCellImage( colTree, nCurrentRow, nPicAssignNew, nFlags )
.head 5 +  Function: _GetPositionID
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCurrentRow
.head 7 -  FunctionalVar: oPosInfo
.head 8 -  Class: cPositionData
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Call SalTblSetContext ( hWndForm, nCurrentRow )
.head 7 +  If nCurrentRow =  GetRowID( oPosition.nActHandel)
.head 8 -  Set oPosInfo.nActHandel = oPosition.nActHandel
.head 8 -  Set oPosInfo.nCageID = oPosition.nCageID
.head 8 -  Set oPosInfo.nPosID = oPosition.nPosID
.head 8 -  Set oPosInfo.nRackID = oPosition.nRackID
.head 8 -  Set oPosInfo.nScreenID = oPosition.nScreenID
.head 8 -  Set oPosInfo.sBett = oPosition.sBett
.head 8 -  Set oPosInfo.sCage = oPosition.sCage
.head 8 -  Set oPosInfo.sRack = oPosition.sRack
.head 8 -  Set oPosInfo.sScreen = oPosition.sScreen
.head 8 -  Set oPosInfo.nAnimalID = oPosition.nAnimalID
.head 8 -  Set bOk = TRUE
.head 7 +  Else
.head 8 -  Set oPosInfo.nScreenID = -1
.head 8 -  Set oPosInfo.nRackID = -1
.head 8 -  Set oPosInfo.nCageID = -1
.head 8 -  Set oPosInfo.nActHandel = GetUniqRowID( nCurrentRow)
.head 8 -  Set bOk = TRUE
.head 8 +  Select Case MTblGetRowLevel( hWndForm, nCurrentRow )
.head 9 +  Case KHEL_Einrichtung
.head 10 -  Set oPosInfo.nScreenID = -1
.head 10 -  Set oPosInfo.nRackID = -1
.head 10 -  Set oPosInfo.nCageID = -1
.head 10 -  Set oPosInfo.nPosID = -1
.head 10 -  Set oPosInfo.sScreen = ""
.head 10 -  Set oPosInfo.sRack = ""
.head 10 -  Set oPosInfo.sCage = ""
.head 10 -  Set oPosInfo.sBett = ""
.head 10 -  Break
.head 9 +  Case KHEL_Abteilung
.head 10 -  Set oPosInfo.nScreenID = colIDObject
.head 10 -  Set oPosInfo.nRackID = -1
.head 10 -  Set oPosInfo.nCageID = -1
.head 10 -  Set oPosInfo.nPosID = -1
.head 10 -  Set oPosInfo.sScreen = colSVal1
.head 10 -  Set oPosInfo.sRack = ""
.head 10 -  Set oPosInfo.sCage = ""
.head 10 -  Set oPosInfo.sBett = ""
.head 10 -  Break
.head 9 +  Case KHEL_Station
.head 10 -  Set oPosInfo.nRackID = colIDObject
.head 10 -  Set oPosInfo.nCageID = -1
.head 10 -  Set oPosInfo.nPosID = -1
.head 10 -  Set oPosInfo.sRack = colSVal1
.head 10 -  Set oPosInfo.sCage = ""
.head 10 -  Set oPosInfo.sBett = ""
.head 10 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext ( hWndForm ) ) )
.head 10 -  Set oPosInfo.nScreenID = colIDObject
.head 10 -  Set oPosInfo.sScreen = colSVal1
.head 10 -  Break
.head 9 +  Case KHEL_Gruppe
.head 10 -  Set oPosInfo.nPosID = -1
.head 10 -  Set oPosInfo.sBett = ""
.head 10 -  Set oPosInfo.nCageID = colIDObject
.head 10 -  Set oPosInfo.sCage = colSVal1
.head 10 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext ( hWndForm ) ) )
.head 10 -  Set oPosInfo.nRackID = colIDObject
.head 10 -  Set oPosInfo.sRack = colSVal1
.head 10 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext ( hWndForm ) ) )
.head 10 -  Set oPosInfo.nScreenID = colIDObject
.head 10 -  Set oPosInfo.sScreen = colSVal1
.head 10 -  Break
.head 9 +  Case KHEL_Bett
.head 10 -  Set oPosInfo.nPosID = colNVal1
.head 10 -  Set oPosInfo.nAnimalID = colIDObject
.head 10 -  Set oPosInfo.sBett = colSVal1
.head 10 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext ( hWndForm ) ) )
.head 10 -  Set oPosInfo.nCageID = colIDObject
.head 10 -  Set oPosInfo.sCage = colSVal1
.head 10 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext ( hWndForm ) ) )
.head 10 -  Set oPosInfo.nRackID = colIDObject
.head 10 -  Set oPosInfo.sRack = colSVal1
.head 10 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext ( hWndForm ) ) )
.head 10 -  Set oPosInfo.nScreenID = colIDObject
.head 10 -  Set oPosInfo.sScreen = colSVal1
.head 10 -  Break
.head 9 +  Default
.head 10 -  Set bOk = FALSE
.head 10 -  Break
.head 8 -  !
.head 7 -  Call SalTblSetContext ( hWndForm, GetRowID( oPosition.nActHandel))
.head 7 +  If not bOk
.head 8 -  Set oPosInfo = OBJ_Null
.head 7 -  Return bOk
.head 5 +  Function: GetCurrentPosition
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Receive String: sAbt
.head 7 -  Receive String: sStat
.head 7 -  Receive String: sGrp
.head 7 -  Receive String: sBett
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! Number: hCurrent
.head 7 -  ! Number: nSelectedLevel
.head 6 +  Actions
.head 7 -  Set sAbt = oPosition.sScreen
.head 7 -  Set sStat = oPosition.sRack
.head 7 -  Set sGrp = oPosition.sCage
.head 7 -  Set sBett = oPosition.sBett
.head 7 -  Return TRUE
.head 5 +  Function: ActivatePosition
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Call _GetPositionID( nRow, oPosition )
.head 7 -  Set sText = "Facility Explorer: "
.head 7 +  If oPosition.sScreen
.head 8 -  Set sText = sText || D_GetMessageStatic_w_Nr(5010,1) || oPosition.sScreen
.head 7 +  If oPosition.sRack
.head 8 -  Set sText = sText || D_GetMessageStatic_w_Nr(5010,2) || oPosition.sRack
.head 7 +  If oPosition.sCage
.head 8 -  Set sText = sText || D_GetMessageStatic_w_Nr(5010,3) || oPosition.sCage
.head 7 +  If oPosition.sBett
.head 8 -  Set sText = sText || D_GetMessageStatic_w_Nr(5010,4) || oPosition.sBett
.head 7 +  If MTblGetRowLevel( hWndForm, nRow ) = KHEL_Bett
.head 8 -  Set sText = sText || D_GetMessageStatic_w_Nr(5010,5) || SalNumberToStrX(colIDObject, 0 )
.head 7 -  Call SalTblSetColumnTitle ( colTree , sText)
.head 7 -  Set oPosition.nActHandel = GetUniqRowID(nRow)
.head 7 -  Return TRUE
.head 5 +  Function: SwitchSelectRow
.head 6 -  Description: Select/Unselect row
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 +  If colIDObject != -100
.head 8 +  If colCheck=1
.head 9 -  Set colCheck = 0
.head 9 -  Call oHandleSelect.UnselectRow( GetUniqRowID(nRow), colSVal2 )
.head 8 +  Else
.head 9 -  Set colCheck = 1
.head 9 -  Call oHandleSelect.SelectRow( GetUniqRowID(nRow), colSVal2 )
.head 8 -  Call ReAssignPic(nRow)
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 5 +  Function: UnSelectAll
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 +  While nI < oHandleSelect.nIndex
.head 8 -  Call SalTblSetContext( hWndForm, GetRowID(oHandleSelect.nRow[nI]) )
.head 8 -  Set colCheck = 0
.head 8 -  Call ReAssignPic(GetRowID(oHandleSelect.nRow[nI]))
.head 8 -  Set nI = nI + 1
.head 7 -  Call oHandleSelect.ReInit(  )
.head 5 +  Function: UnselectChild
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: _nParentRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowChild
.head 7 -  FunctionalVar: oRowData
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set nRowChild = MTblGetFirstChildRow( hWndForm, _nParentRow )
.head 7 +  Loop
.head 8 +  If nRowChild = TBL_Error
.head 9 -  Break
.head 8 -  Set oRowData = FE_GetInfo( nRowChild )
.head 8 -  Call oHandleSelect.UnselectRow( GetUniqRowID(nRowChild), oRowData.GetSValue( "Sex" ) )
.head 8 -  Set nRowChild = MTblGetNextChildRow( hWndForm, nRowChild )
.head 7 -  Return TRUE
.head 5 +  Function: GetSelectedAnimals
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Receive String: sAnimals
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nContextRow
.head 7 -  String: sFa
.head 6 +  Actions
.head 7 -  Set nContextRow = SalTblQueryContext( hWndForm )
.head 7 -  Set sAnimals = ""
.head 7 -  Set nI = 0
.head 7 +  While nI < oHandleSelect.nIndex
.head 8 -  Call SalTblSetContext( hWndForm, GetRowID(oHandleSelect.nRow[nI]) )
.head 8 -  Set sAnimals = sAnimals || SalNumberToStrX( colIDObject, 0 ) || ", "
.head 8 -  Set nI = nI + 1
.head 7 +  If nI > 0
.head 8 -  Set sAnimals = SalStrLeftX( sAnimals, SalStrLength( sAnimals )   )
.head 7 -  Call SalTblSetContext( hWndForm, nContextRow )
.head 7 -  Return nI > 0
.head 5 +  Function: GetIdObject
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nID
.head 6 +  Actions
.head 7 +  If nRow = nSelectedRow
.head 8 -  Return colIDObject
.head 7 +  Else
.head 8 -  Call SalTblSetContext( hWndForm, nRow )
.head 8 -  Set nID = colIDObject
.head 8 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return nID
.head 5 +  Function: GetStrKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sKey
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 -  Set sKey = colSVal1
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return sKey
.head 5 +  Function: EnumChildren
.head 6 -  Description: Return array object's ID (screens, racks, cages, animals) 
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nParentRow
.head 7 -  Receive Number: nChild[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildRow
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 +  If MTblIsParentRow( hWndForm, _nParentRow )
.head 8 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, _nParentRow )
.head 8 +  Loop
.head 9 +  If nChildRow = TBL_Error
.head 10 -  Break
.head 9 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 9 +  If colIDObject != -100
.head 10 -  Set nChild[nI] = colIDObject
.head 10 -  Set nI = nI + 1
.head 9 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return nI
.head 5 +  Function: GetParent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nChildRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetParentRow( hWndForm, nChildRow )
.head 5 +  Function: GetNextChildRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetNextChildRow( hWndForm, _nRow )
.head 5 +  Function: GetFirstChildRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetFirstChildRow( hWndForm, _nRow )
.head 5 +  Function: GetUniqRowID
.head 6 -  Description: Gets a row's unique ID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRowID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nURowID
.head 6 +  Actions
.head 7 -  Set nURowID = MTblGetRowID( hWndForm , nRowID )
.head 7 -  Return nURowID
.head 5 +  Function: GetRowID
.head 6 -  Description: Gets a row's number on the basis of it's ID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nURowID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowID
.head 6 +  Actions
.head 7 -  Set nRowID = MTblGetRowFromID( hWndForm , nURowID )
.head 7 -  Return nRowID
.head 5 +  Function: GetLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetRowLevel(hWndForm, _nRow)
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 7 -  String: _sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oRowData
.head 8 -  Class: cFERow
.head 7 -  String: sValue
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, _nRow )
.head 7 -  Set oRowData = FE_GetInfo( _nRow )
.head 7 -  Set sValue = oRowData.GetSValue( _sParam )
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return sValue
.head 5 +  Function: GetOpenCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nParentRow
.head 7 -  Number: nState
.head 7 -  Receive Number: nRowCages[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowW
.head 7 -  Number: nRowR
.head 7 -  Number: nRowC
.head 7 -  Number: nI
.head 7 -  FunctionalVar: oInfo
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set nRowW = - 1
.head 7 -  Set nRowR = - 1
.head 7 -  Set nRowC = - 1
.head 7 -  Set nI = 0
.head 7 +  Select Case GetLevel(nParentRow)
.head 8 +  Case FEL_Institute
.head 9 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 9 +  Loop
.head 10 +  If nRowW = TBL_Error
.head 11 -  Break
.head 10 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 10 +  Loop
.head 11 +  If nRowR = TBL_Error
.head 12 -  Break
.head 11 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 11 +  Loop
.head 12 +  If nRowC = TBL_Error
.head 13 -  Break
.head 12 -  Set oInfo = FE_GetInfo( nRowC )
.head 12 +  If oInfo.nID_Obj != -100 and (oInfo.GetState( nState ) or nState=0)
.head 13 -  Set nRowCages[nI] = nRowC
.head 13 -  Set nI = nI + 1
.head 12 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 11 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 10 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 9 -  Break
.head 8 +  Case FEL_Workgroup
.head 9 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 9 +  Loop
.head 10 +  If nRowR = TBL_Error
.head 11 -  Break
.head 10 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 10 +  Loop
.head 11 +  If nRowC = TBL_Error
.head 12 -  Break
.head 11 -  Set oInfo = FE_GetInfo( nRowC )
.head 11 +  If oInfo.nID_Obj != -100 and (oInfo.GetState( nState ) or nState=0)
.head 12 -  Set nRowCages[nI] = nRowC
.head 12 -  Set nI = nI + 1
.head 11 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 10 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 9 -  Break
.head 8 +  Case FEL_Rack
.head 9 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 9 +  Loop
.head 10 +  If nRowC = TBL_Error
.head 11 -  Break
.head 10 -  Set oInfo = FE_GetInfo( nRowC )
.head 10 +  If oInfo.nID_Obj != -100 and (oInfo.GetState( nState ) or nState=0)
.head 11 -  Set nRowCages[nI] = nRowC
.head 11 -  Set nI = nI + 1
.head 10 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 9 -  Break
.head 8 +  Case FEL_Cage
.head 9 -  Set oInfo = FE_GetInfo( nParentRow )
.head 9 +  If oInfo.nID_Obj != -100 and (oInfo.GetState( nState ) or nState=0)
.head 10 -  Set nRowCages[0] = nParentRow
.head 10 -  Set nI = 1
.head 9 -  Break
.head 7 -  Return nI
.head 5 +  Function: GetWidthTree
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTreeWidth
.head 7 -  Number: nTreeWidthUnits
.head 7 -  Number: nX1
.head 7 -  Number: nY1
.head 7 -  Number: nX2
.head 7 -  Number: nY2
.head 7 -  Number: nWidth
.head 7 -  Number: nWidthVScroll
.head 7 -  Number: nKoef
.head 7 -  Number: nKoefNew
.head 7 -  Number: nTrunc
.head 7 -  Number: nW_Form
.head 7 -  Number: nH_Form
.head 7 -  Number: nDelta
.head 6 +  Actions
.head 7 -  Call SalTblQueryColumnWidth( colTree, nTreeWidthUnits )
.head 7 -  ! Set nTreeWidth = SalFormUnitsToPixels( hWndForm, nTreeWidthUnits, FALSE )
.head 7 -  Call GetClientRect(hWndForm, nX1, nY1, nX2, nY2)
.head 7 -  Set nWidth = nX2 - nX1
.head 7 -  Call GetWindowRect(hWndForm,nX1,nY1,nX2,nY2)
.head 7 -  Set nWidthVScroll = nX2 - nX1 - nWidth
.head 7 -  Set nWidthVScroll = SalPixelsToFormUnits( hWndForm, nWidthVScroll , FALSE )
.head 7 -  Call SalGetWindowSize( hWndForm, nW_Form, nH_Form )
.head 7 -  Set nWidth = nW_Form - nWidthVScroll
.head 7 -  Set nDelta = nWidth
.head 7 +  Loop
.head 8 +  If nWidth > nTreeWidthUnits
.head 9 -  Break
.head 8 -  Set nWidth = nWidth + nDelta - nWidthVScroll
.head 7 +  ! If FALSE
.head 8 +  ! If nWidthVScroll
.head 9 -  Set nWidth = nWidth + 1
.head 8 -  Set nKoef = nTreeWidth/nWidth
.head 8 +  If SalNumberTruncate( nKoef, 4, 10 ) > 0
.head 9 -  Set nKoefNew = SalNumberRound( nKoef )
.head 9 +  If nKoefNew < nKoef
.head 10 -  Set nKoefNew = nKoefNew + 1
.head 9 -  Set nKoef = nKoefNew
.head 8 -  Set nWidth = SalPixelsToFormUnits( hWndForm, (nWidth * nKoef - nWidthVScroll*(nKoef-1)), FALSE )
.head 7 -  Return nWidth
.head 5 +  Function: SetSizeTree
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If not bAutoSize
.head 8 -  Set bAutoSize = TRUE
.head 8 -  Call SalTimerSet( hWndForm, 10, 1100 )
.head 8 -  Call MTblAutoSizeColumn( hWndForm, colTree, MTASC_ALLROWS )
.head 8 -  Call SalTblSetColumnWidth( colTree, GetWidthTree() )
.head 5 +  Function: RowIsChild
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nRowIsChild
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRow
.head 7 -  Boolean: bIsChild
.head 6 +  Actions
.head 7 -  Set bIsChild = FALSE
.head 7 -  Set nRow = MTblGetFirstChildRow( hWndForm, nParent )
.head 7 +  Loop
.head 8 +  If nRow = TBL_Error or bIsChild
.head 9 -  Break
.head 8 +  If nRow = nRowIsChild
.head 9 -  Set bIsChild = TRUE
.head 8 -  Set nRow = MTblGetNextChildRow( hWndForm, nRow )
.head 7 -  Return bIsChild
.head 5 +  Function: RowIsExpand
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowCheck
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblQueryRowFlags( hWndForm, nRowCheck, MTBL_ROW_ISEXPANDED )
.head 5 +  Function: RowIsParent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowCheck
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblIsParentRow( hWndForm, nRowCheck ) 
.head 5 +  Function: GetSelectedAnimalsStr
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  String: sAnimals
.head 6 +  Actions
.head 7 -  Set sAnimals = ""
.head 7 +  If oHandleSelect.bAnySelects
.head 8 -  Set nI = 0
.head 8 +  While nI < oHandleSelect.nIndex
.head 9 -  Set sAnimals = sAnimals || SalNumberToStrX(GetIdObject(GetRowID(oHandleSelect.nRow[nI])),0) || ","
.head 9 -  Set nI = nI + 1
.head 8 +  If sAnimals
.head 9 -  Set sAnimals = sAnimals || SalStrLeftX( sAnimals, SalStrLength( sAnimals ) - 1  )
.head 7 -  Return sAnimals
.head 5 +  Function: CountFemales
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bRet
.head 7 -  FunctionalVar: nRowCheck
.head 8 -  Class: cFERow
.head 7 -  Number: nAnimals
.head 6 +  Actions
.head 7 -  Set bRet = (nSelectedLevel = KHEL_Gruppe)
.head 7 +  If bRet
.head 8 -  Set nRowCheck = FE_GetInfo( nSelectedRow )
.head 8 -  ! Set bRet = bRet and nRowCheck.GetState( CageWithRFID )
.head 8 +  If bRet
.head 9 -  Set nAnimals = 0
.head 9 -  Set nAnimals =nRowCheck.GetNValue( "Male" )
.head 9 -  Set nAnimals =nAnimals + nRowCheck.GetNValue( "FeMale" )
.head 9 -  Call SalMessageBox( "Female", SalNumberToStrX( nRowCheck.GetNValue( "FEMALE" ), 0 ), MB_Ok )
.head 9 -  Call SalMessageBox( "Male", SalNumberToStrX( nRowCheck.GetNValue( "MALE" ), 0 ), MB_Ok )
.head 9 -  Set bRet = bRet and not nAnimals
.head 7 -  Return bRet
.head 5 +  Function: GetPupsSql
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String: sOu
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Receive Number: nFemale
.head 7 -  Receive Number: nMale
.head 7 -  Receive Number: nUnknown
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hMrec
.head 7 -  String: sSqlPups
.head 7 -  Number: nN
.head 7 -  String: sResult
.head 7 -  String: sSex
.head 7 -  Number: nLitterID
.head 7 -  String: sOut
.head 7 -  String: sLvalue
.head 6 +  Actions
.head 7 -  Set sSqlPups = "select c.GESCHLECHT, c.LITTER_ID from litter l , LITTER_CHILD c,
 RELSHIP_FALL f where l.LITTER_ID = c.LITTER_ID and l.FAMILY_RELSHIP_ID = f.RELSHIP_ID and f.FALL_KEY = :nFallKey and DEAD = 0

   and        c.FALL_KEY is null
   and        c.dead=0
   and        @nullvalue(l.miss,0)=0 into :sSex, :nLitterID"
.head 7 -  Call SqlConnect( hMrec )
.head 7 -  Call SqlPrepareAndExecute( hMrec, sSqlPups )
.head 7 -  Set sOut = "Med_Record:"
.head 7 +  While SqlFetchNext( hMrec, nN )
.head 8 -  !
.head 8 +  If sSex = "W"
.head 9 -  Set nFemale = nFemale +1
.head 8 +  Else If sSex = "M"
.head 9 -  !
.head 9 -  Set nMale = nMale +1
.head 8 +  Else
.head 9 -  Set nUnknown = nUnknown + 1
.head 7 +  If nFemale > 0
.head 8 -  Set sResult = "F-" || SalNumberToStrX( nFemale, 0 )
.head 7 +  If nMale > 0
.head 8 -  Set sResult = sResult || " M-" || SalNumberToStrX( nMale, 0 )
.head 7 +  If nUnknown > 0
.head 8 -  Set sResult = sResult || " U-" || SalNumberToStrX( nUnknown, 0 )
.head 7 -  Call SqlDisconnect( hMrec )
.head 7 -  Return sResult
.head 5 +  Function: GetAnimalMedicalRecord
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String: sOu
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hMrec
.head 7 -  String: sSqlMrec
.head 7 -  Number: nN
.head 7 -  String: sResult
.head 7 -  String: sOut
.head 7 -  String: sLvalue
.head 7 -  Number: nBvalue
.head 7 -  String: sBValue
.head 7 -  Number: nIvalue
.head 7 -  String: sIvalue
.head 7 -  Number: nFvalue
.head 7 -  String: sFvalue
.head 7 -  String: sT20_value
.head 7 -  String: sT200_value
.head 7 -  String: sCombined
.head 6 +  Actions
.head 7 -  Set sSqlMrec = "select m.MR_BEZ, f.L_VALUE, f.B_VALUE, f.I_VALUE, f.F_VALUE, f.T20_VALUE, f.T200_VALUE from FALL_MED_REC f,  MF_MED_REC m where f.MR_KEY = m.MR_KEY and f.FALL_KEY = :nFallKey into :sResult, :sLvalue,
:nBvalue, :nIvalue, :nFvalue, :sT20_value, :sT200_value "
.head 7 -  Call SqlConnect( hMrec )
.head 7 -  Call SqlPrepareAndExecute( hMrec, sSqlMrec )
.head 7 -  Set sOut = "Med_Record:"
.head 7 +  While SqlFetchNext( hMrec, nN )
.head 8 -  !
.head 8 +  If nBvalue != NUMBER_Null
.head 9 -  !
.head 9 +  If nBvalue
.head 10 -  Set sBValue = "YES"
.head 9 +  Else
.head 10 -  Set sBValue = "NO"
.head 8 +  If nIvalue != NUMBER_Null
.head 9 -  Set sIvalue = SalNumberToStrX( nIvalue, 0 )
.head 8 +  If nFvalue != NUMBER_Null
.head 9 -  Set sFvalue = SalNumberToStrX( nFvalue, 2 )
.head 8 -  Set sLvalue = SalStrUpperX( sLvalue)
.head 8 -  Set sCombined = sLvalue || sIvalue  || sFvalue || sBValue || sT20_value || sT200_value
.head 8 -  Set sOut =  sOut  ||  sResult || " " || sCombined || "*"
.head 7 -  Call SqlDisconnect( hMrec )
.head 7 -  Return sOut
.head 5 +  Function: GetActiveServices
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String: sOu
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Number: nCageID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hMrec
.head 7 -  String: sSqlMrec
.head 7 -  Number: nN
.head 7 -  String: sResult
.head 7 -  String: sOut
.head 6 +  Actions
.head 7 +  If nCageID = 0
.head 8 -  !
.head 8 -  Set sSqlMrec = "select lk.LST_KEY  from Lst_Erf lk left join srv_cancels scan on scan.fall_key = lk.fall_key and scan.lst_erf_nr = lk.lst_erf_nr, LEISTUNG l, Fall f
where	lk.EINRICHT_ID = 1
     and 	l.EINRICHT_ID = lk.EINRICHT_ID
     and	l.TARIF_KEY = lk.TARIF_KEY
     and	l.LST_KEY = lk.LST_KEY

     and      	f.EINRICHT_ID = lk.EINRICHT_ID
     and	f.FALL_KEY = lk.FALL_KEY
     and	f.GELOESCHT = 'N' and lk.DONE = 0
     and	f.STATUS != 'E'
     and	f.FALL_KEY = :nFallKey  into :sResult "
.head 7 +  Else
.head 8 -  !
.head 8 -  Set sSqlMrec = "select lk.LST_KEY  from Lst_Erf lk left join srv_cancels scan on scan.fall_key = lk.fall_key and scan.lst_erf_nr = lk.lst_erf_nr, LEISTUNG l, Fall f
where	lk.EINRICHT_ID = 1
     and 	l.EINRICHT_ID = lk.EINRICHT_ID
     and	l.TARIF_KEY = lk.TARIF_KEY
     and	l.LST_KEY = lk.LST_KEY

     and      	f.EINRICHT_ID = lk.EINRICHT_ID
     and	f.FALL_KEY = lk.FALL_KEY
     and	f.GELOESCHT = 'N' and lk.DONE = 0
     and	f.STATUS != 'E'
     and lk.CAGE_ID = :nCageID
     and	f.FALL_KEY = :nFallKey  into :sResult "
.head 7 -  Call SqlConnect( hMrec )
.head 7 -  Call SqlPrepareAndExecute( hMrec, sSqlMrec )
.head 7 -  Set sOut = "active_services:"
.head 7 +  While SqlFetchNext( hMrec, nN )
.head 8 -  !
.head 8 -  Set sOut =  sOut  ||  sResult || "*"
.head 7 -  Call SqlDisconnect( hMrec )
.head 7 -  Return sOut
.head 5 +  Function: GetServiceList
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String: sOu
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hMrec
.head 7 -  String: sSqlMrec
.head 7 -  Number: nN
.head 7 -  String: sResult
.head 7 -  String: sOut
.head 6 +  Actions
.head 7 -  Set sSqlMrec = "select M.name,M.id, M.descr
	from  sysadm.mlhalerts_view M left join sysadm.leistung l on (l.id=m.id)
     where @NULLVALUE(l.canceled,'N') = 'N' order by M.id into :sResult "
.head 7 -  Call SqlConnect( hMrec )
.head 7 -  Call SqlPrepareAndExecute( hMrec, sSqlMrec )
.head 7 +  While SqlFetchNext( hMrec, nN )
.head 8 -  !
.head 8 -  Set sOut =  sOut  ||  sResult || ";"
.head 7 -  Call SqlDisconnect( hMrec )
.head 7 -  Return sOut
.head 5 +  Function: GetLicenseFallWithCageID
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nCageID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtDT
.head 7 -  Number: nFKey
.head 7 -  Number: n
.head 7 -  String: sSql
.head 7 -  Sql Handle: hSqlPopulate
.head 6 +  Actions
.head 7 -  Set dtDT = GetTime4Refresh( )
.head 7 -  Set nFKey = 0
.head 7 -  Call SqlConnect( hSqlPopulate )
.head 7 +  If nGCFall_Key=0 or nGCFall_Key=NUMBER_Null
.head 8 -  Set sSql = " select Fall_key
  from fall_experiment fe, experiment e
 where e.experiment_key=fe.experiment_key
 and e.EXP_SIGNED_P2=4
into :nGCFall_Key"
.head 8 +  If SqlPrepareAndExecute(hSqlPopulate, sSql)
.head 9 -  Call SqlFetchNext(hSqlPopulate, n)
.head 7 -  Set sSql = "select @NULLVALUE(f.fall_key, " || SalNumberToStrX( nGCFall_Key, 0 ) || ")
from     BEWEGUNG b left join fall_experiment fe on (b.fall_key = fe.fall_key and fe.end_date is null) left join fall f on (f.name1 = fe.experiment_key)
where
   @nullvalue( b.GELOESCHT, 'N' ) = 'N'
   and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
   and	b.BEW_ZEIT <= :dtDT
   and	( b.BEW_ZEIT_BIS >= :dtDT or ( b.BEW_ZEIT_BIS is NULL ) )
   and 	b.EINRICHT_ID = :nEinrichtId
   and	b.cage_id = :nCageID
group by 1
into :nFKey"
.head 7 +  If SqlPrepareAndExecute(hSqlPopulate, sSql)
.head 8 +  If SqlGetResultSetCount (hSqlPopulate, n)
.head 9 +  If n>1
.head 10 -  Set nFKey=0
.head 9 +  Else
.head 10 -  Call SqlFetchNext(hSqlPopulate, n)
.head 7 -  Call SqlCommit(hSqlPopulate)
.head 7 -  Call SqlDisconnect( hSqlPopulate )
.head 7 -  Return nFKey
.head 5 +  Function: LoadFacts
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  FunctionalVar: (no name)
.head 8 -  Class: cClipsParameters
.head 6 +  Parameters
.head 7 -  Number: nState
.head 7 -  ! Receive Number: nRowCages[*]
.head 7 -  ! Receive Number: nFinCage[*]
.head 7 -  ! Receive Number: nMinCage[*]
.head 7 -  ! Receive Number: nCageID[*]
.head 7 -  ! Receive String: sCagePosition[*]
.head 7 -  ! Receive String: sMedRec
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowW
.head 7 -  Number: nRowR
.head 7 -  Number: nRowC
.head 7 -  Number: nI
.head 7 -  FunctionalVar: oInfo
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oInfo1
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oInfoRack
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oInfoWorkgroup
.head 8 -  Class: cFERow
.head 7 -  Number: nParentRow
.head 7 -  String: sCageStatus[*]
.head 7 -  Number: nF
.head 7 -  Number: nM
.head 7 -  Number: nSelected
.head 7 -  Number: nTest
.head 7 -  String: sTest
.head 7 -  String: sTest2
.head 7 -  Number: nFallKey
.head 7 -  FunctionalVar: Facts
.head 8 -  Class: cClipsParameters
.head 7 -  Number: nN
.head 7 -  Number: nRowM
.head 7 -  Number: nD
.head 7 -  Number: nLevel
.head 7 -  Boolean: bRealCage
.head 7 -  Boolean: bTemp
.head 7 -  Number: nChecked
.head 7 -  Number: nSelAn
.head 7 -  Number: nRowTemp
.head 7 -  Number: nBetRow
.head 7 -  Number: nCageRow
.head 7 -  Number: nRowO
.head 7 -  String: sLitter
.head 7 -  Number: nFemales
.head 7 -  Number: nMales
.head 7 -  Number: nUnknown
.head 7 -  Boolean: bRackHasChildren
.head 7 -  Number: nRackCount
.head 7 -  Boolean: bSelectedCage
.head 7 -  Boolean: bSelectedRack
.head 7 -  Boolean: bSelectedAnimal
.head 7 -  Number: nFallLicience
.head 6 +  Actions
.head 7 -  Set nRowW = - 1
.head 7 -  Set nRowR = - 1
.head 7 -  Set nRowC = - 1
.head 7 -  Set nI = 0
.head 7 -  ! Set nParentRow = GetParent(GetParent(nSelectedRow ))
.head 7 +  Select Case GetLevel(nSelectedRow)
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 9 +  Loop
.head 10 +  If nRowW = TBL_Error
.head 11 -  Break
.head 10 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 10 +  Loop
.head 11 +  If nRowR = TBL_Error
.head 12 -  Break
.head 11 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 11 +  Loop
.head 12 +  If nRowC = TBL_Error
.head 13 -  Break
.head 12 -  ! Set oInfo = FE_GetInfo( nRowC )
.head 12 +  ! If oInfo.nID_Obj != -100 and (oInfo.GetState( CageIsEmpty ) )
.head 13 -  Set Facts.nRowCages[nI] = 1
.head 12 +  ! Else
.head 13 -  !
.head 13 -  Set Facts.nRowCages[nI] = 0
.head 12 -  ! Set Facts.sCagePosition[nI] = oInfo.sCagePosition
.head 12 -  ! Set Facts.nFinCage[nI] = oInfo.GetNValue( "FEMALE" )
.head 12 -  ! Set Facts.nMinCage[nI] = oInfo.GetNValue( "MALE" )
.head 12 -  ! Set Facts.nCageID[nI] = oInfo.nID_Obj
.head 12 -  ! Set nI = nI + 1
.head 12 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 11 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 10 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 9 -  Break
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set nParentRow = nSelectedRow
.head 9 -  Break
.head 8 +  Case KHEL_Station
.head 9 -  Set nParentRow = GetParent(nSelectedRow )
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set nParentRow = GetParent(GetParent(nSelectedRow ))
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  Set nParentRow = GetParent(GetParent(nSelectedRow ))
.head 9 -  Break
.head 7 +  ! If GetLevel(nParentRow ) = KHEL_Station
.head 8 -  !
.head 8 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 8 +  Loop
.head 9 +  If nRowC = TBL_Error
.head 10 -  Break
.head 9 -  Set oInfo = FE_GetInfo( nRowC )
.head 9 +  If oInfo.nID_Obj != -100 and  (oInfo.GetState( CageIsEmpty ) )
.head 10 +  ! If oInfo.GetNValue( "FEMALE" ) > 0 and oInfo.GetNValue( "MALE" ) < 1
.head 11 -  !
.head 11 -  ! Call SalMessageBox( "Female open cages", SalNumberToStrX( nF, 0 ), MB_Ok )
.head 10 -  Set Facts.nRowCages[nI] = 1
.head 9 +  Else
.head 10 -  !
.head 10 -  Set Facts.nRowCages[nI] = 0
.head 9 +  If nRowC = nSelectedRow
.head 10 -  Set nSelected = nI
.head 9 -  Set nTest = SalTblQueryContext( hWndForm )
.head 9 -  ! Set nSelected = nI
.head 9 -  ! Call SalMessageBox( "Station", SalNumberToStrX( nTest, 0 ), MB_Ok )
.head 9 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowC )
.head 9 +  Loop
.head 10 -  !
.head 10 +  If nRowR = TBL_Error
.head 11 -  Break
.head 10 +  If nRowR = nSelectedRow
.head 11 -  Set Facts.nSelected = nI
.head 11 +  If GetLevel(nSelectedRow ) =KHEL_Bett
.head 12 -  !
.head 12 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 12 -  Set nFallKey = colIDObject
.head 12 -  ! Set nChecked = colCheck
.head 12 -  Set Facts.oLevelSettings = oSettingsBett
.head 12 -  Set oInfo1 = FE_GetInfo( nSelectedRow )
.head 12 -  Set nD = 0
.head 12 -  Set sTest = ""
.head 12 +  While nD < Facts.oLevelSettings.nCountHints
.head 13 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 14 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 14 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 13 -  Set nD = nD + 1
.head 12 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 12 -  Set Facts.sActiveServices = GetActiveServices( nFallKey )
.head 12 +  If oInfo1.GetState( AnimalIsLitter )
.head 13 -  Set Facts.bHasLitter = TRUE
.head 13 -  ! Call SalMessageBox( "has litter", "", MB_Ok )
.head 13 -  Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 12 +  ! If oInfo.GetNValue( "FEMALE" ) > 0
.head 13 -  Set Facts.sMedRec = "Selected animal:Female; Strain:"  || Facts.sStrain || ";" || Facts.sMedRec
.head 12 +  ! Else
.head 13 -  !
.head 13 -  Set Facts.sMedRec = "Selected animal:Male; Strain:" || Facts.sStrain || ";" || Facts.sMedRec
.head 12 +  ! If Facts.sSex = "F"
.head 13 -  Set Facts.sMedRec = "Selected animal:Female; Strain:"  || Facts.sStrain || "; Geb_Datum:" ||  Facts.sGebDatum || ";" || Facts.sMedRec|| "; Phenotype:" ||  Facts.sPhenoType || "; Genotype:" ||  Facts.sGenoType
.head 12 -  Set Facts.sSelectedAnimal =""
.head 12 +  ! Else
.head 13 -  !
.head 13 -  Set Facts.sMedRec = "Selected animal:Male; Strain:" || Facts.sStrain || "; Geb_Datum:" ||  Facts.sGebDatum || ";" || Facts.sMedRec|| "; Phenotype:" ||  Facts.sPhenoType || "; Genotype:" ||  Facts.sGenoType
.head 12 +  ! If Facts.sSex = "F"
.head 13 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 12 +  ! Else
.head 13 -  !
.head 13 -  Set Facts.sMedRec = sTest || ';' ||  Facts.sMedRec
.head 12 -  Set Facts.sMedRec = sTest ||  Facts.sMedRec
.head 12 -  Set Facts.sSelectedAnimal = Facts.sMedRec || ';' || Facts.sActiveServices
.head 12 -  Set Facts.aAnimalsSelected[0] = Facts.sSelectedAnimal
.head 12 -  Set nSelAn = 1
.head 12 +  ! If nChecked = 1
.head 13 -  Set Facts.aAnimalsSelected[nN] = Facts.aAnimalsInSelectedCage[nN]
.head 12 -  ! Call SalMessageBox( Facts.sMedRec, "Selected bett", MB_Ok )
.head 11 -  ! Call SalMessageBox( sTest, sTest, MB_Ok )
.head 11 -  Set nSelectedRow = GetParent(GetParent(nSelectedRow ))
.head 11 -  ! Call GetOpenCages2b( nState )
.head 11 -  Set nSelectedRow = nRowR
.head 10 -  ! Call SalMessageBox( "Context row " ||  SalNumberToStrX( nTest, 0 ) ,  "Selected row " || SalNumberToStrX( nSelectedRow, 0 ), MB_Ok )
.head 10 -  ! Call SalMessageBox( "nRowC", SalNumberToStrX( nRowR, 0 ), MB_Ok )
.head 10 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 9 -  Set Facts.sCagePosition[nI] = oInfo.sCagePosition
.head 9 -  Set nD = 0
.head 9 -  Set Facts.oLevelSettingsCage = oSettingsCage
.head 9 -  Set bRealCage = FALSE
.head 9 -  Set sTest = ""
.head 9 +  ! While nD < Facts.oLevelSettingsCage.nCountHints
.head 10 +  If Facts.oLevelSettingsCage.IsClips( Facts.oLevelSettingsCage.nIndexHints[nD] ) or Facts.oLevelSettingsCage.nIndexHints[nD] = 4
.head 11 -  Set sTest = sTest || oInfo.GetLabelClipsValue( Facts.oLevelSettingsCage.nIndexHints[nD], bTemp )
.head 11 +  If bTemp
.head 12 -  Set bRealCage = bTemp
.head 11 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettingsCage.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 10 -  Set nD = nD + 1
.head 9 +  ! If bRealCage
.head 10 -  !
.head 10 -  Set Facts.sCageInfo = sTest
.head 10 -  Set Facts.aOpenedCages[nI] = sTest
.head 9 -  Set nI = nI + 1
.head 9 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 9 -  Set nSelectedRow = GetParent(GetParent(nSelectedRow ))
.head 7 +  If GetLevel(nParentRow ) = KHEL_Station
.head 8 -  !
.head 8 -  Set nBetRow = nSelectedRow
.head 8 -  Set nCageRow = GetParent(nBetRow )
.head 8 -  Set nRowTemp = nSelectedRow
.head 8 -  Set nSelectedRow = GetParent(nSelectedRow )
.head 8 -  Call SalTblSetContext( hWndForm, nSelectedRow  )
.head 8 -  ! Set nParentRow = GetParent((nSelectedRow ))
.head 8 -  Set nParentRow = GetParent(GetParent(nSelectedRow ))
.head 8 -  ! Set nParentRow = GetParent((nParentRow ))
.head 7 -  ! If
.head 7 -  ! If
.head 7 -  ! If
.head 7 +  If GetLevel(nParentRow ) = KHEL_Abteilung or GetLevel(nParentRow ) = KHEL_Station
.head 8 -  !
.head 8 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 8 +  Loop
.head 9 +  If nRowR = TBL_Error
.head 10 -  Break
.head 9 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 9 -  Set bRackHasChildren = FALSE
.head 9 -  Set oInfoRack = FE_GetInfo( nRowR )
.head 9 -  Set Facts.nRackID = oInfoRack.nID_Obj
.head 9 +  Loop
.head 10 +  If nRowC = TBL_Error
.head 11 -  Break
.head 10 -  Set oInfo = FE_GetInfo( nRowC )
.head 10 +  If oInfo.nID_Obj != -100 and  (oInfo.GetState( CageIsEmpty ) )
.head 11 +  ! If oInfo.GetNValue( "FEMALE" ) > 0 and oInfo.GetNValue( "MALE" ) < 1
.head 12 -  !
.head 12 -  ! Call SalMessageBox( "Female open cages", SalNumberToStrX( nF, 0 ), MB_Ok )
.head 11 -  Set Facts.nRowCages[nI] = 1
.head 10 +  Else
.head 11 -  !
.head 11 -  Set Facts.nRowCages[nI] = 0
.head 10 -  Set Facts.nCageID[0] = oInfo.nID_Obj
.head 10 -  Set bSelectedCage = FALSE
.head 10 +  If nRowC = nSelectedRow
.head 11 -  !
.head 11 -  Set bSelectedCage = TRUE
.head 10 -  Set bSelectedAnimal= FALSE
.head 10 +  ! If nRowC = nSelectedRow
.head 11 -  Set Facts.nSelected = nI
.head 11 -  Call SalMessageBox( "nrowc selected row", "nrowc selected row", MB_Ok )
.head 11 -  Set nRowM = MTblGetFirstChildRow( hWndForm, nRowC )
.head 11 -  Set nN = 0
.head 11 -  Set nChecked = 0
.head 11 +  Loop
.head 12 -  !
.head 12 +  If nRowM = TBL_Error
.head 13 -  Break
.head 12 -  ! If GetLevel(nRowM ) =KHEL_Bett
.head 12 -  !
.head 12 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 12 -  Call SalTblSetContext ( hWndForm, nRowM )
.head 12 -  Set nFallKey = colIDObject
.head 12 -  Set nChecked = colCheck
.head 12 -  Call SalMessageBox( "nrowM", "nroM", MB_Ok )
.head 12 -  ! Set Facts.sGebDatum = SalFmtFormatDateTime( colDtVal1, sRegionalFrmDate)
.head 12 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 12 -  Set Facts.sActiveServices = GetActiveServices( nFallKey )
.head 12 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 12 -  Set oInfo1 = FE_GetInfo( nRowM )
.head 12 -  Set Facts.oLevelSettings = oSettingsBett
.head 12 -  Set nD = 0
.head 12 +  If oInfo1.GetState( AnimalIsLitter )
.head 13 -  Set Facts.bHasLitter = TRUE
.head 13 -  ! Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 13 -  ! Set sLitter = "litter:YES;"
.head 13 -  ! Call GetPupsSql( nFallKey, nFemales, nMales, nUnknown )
.head 13 -  Set sLitter = "litter:YES " || GetPupsSql( nFallKey, nFemales, nMales, nUnknown )  || ";"
.head 12 +  Else
.head 13 -  Set sLitter = "litter:NO;"
.head 12 -  Set sTest = ""
.head 12 +  While nD < Facts.oLevelSettings.nCountHints
.head 13 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 14 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 14 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 13 -  Set nD = nD + 1
.head 12 +  ! If Facts.sSex = "F""foreign-id:" || sForeignID || ';'
.head 13 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 12 +  ! Else
.head 13 -  !
.head 13 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 12 -  Set sTest = sTest || sLitter
.head 12 -  Set Facts.sMedRec = sTest || Facts.sMedRec
.head 12 -  Set Facts.aAnimalsInSelectedCage[nN] = Facts.sMedRec || ';' || Facts.sActiveServices|| ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )  || ';'
.head 12 +  If nRowM = nBetRow
.head 13 -  ! Set Facts.aAnimalsSelected
.head 13 -  ! Set Facts.aAnimalsSelected[nSelAn] = 'Selected;' ||  Facts.aAnimalsInSelectedCage[nN]  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 13 -  Set Facts.aAnimalsInSelectedCage[nN] = 'Selected;' || Facts.aAnimalsInSelectedCage[nN]
.head 13 -  Set nSelAn = nSelAn + 1
.head 12 +  Else If nChecked = 1
.head 13 -  ! Set Facts.aAnimalsSelected[nSelAn] = 'Checked;' ||  Facts.aAnimalsInSelectedCage[nN]  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 13 -  Set Facts.aAnimalsInSelectedCage[nN] = 'Checked;' || Facts.aAnimalsInSelectedCage[nN]
.head 13 -  Set nSelAn = nSelAn + 1
.head 12 -  Set nN = nN + 1
.head 12 -  Set nRowM = MTblGetNextChildRow( hWndForm, nRowM )
.head 10 +  ! Else
.head 11 -  ! Call SalMessageBox( SalNumberToStrX(  GetLevel(nRowC ) , 0 ), "Selected bett", MB_Ok )
.head 11 -  Call SalMessageBox( "nrowc NOT selected row", "nrowc NOT selected row", MB_Ok )
.head 11 +  If GetLevel(nRowC ) = KHEL_Station or GetLevel(nRowC ) = KHEL_Gruppe
.head 12 -  !
.head 12 -  Call SalMessageBox( "nrowM1", "nroM1", MB_Ok )
.head 12 -  ! Set Facts.nSelected = nI
.head 12 -  Set nRowM = MTblGetFirstChildRow( hWndForm, nRowC )
.head 12 -  ! Set nN = 0
.head 12 -  Set nChecked = 0
.head 12 +  Loop
.head 13 -  !
.head 13 +  If nRowM = TBL_Error
.head 14 -  Break
.head 13 -  ! If GetLevel(nRowM ) =KHEL_Bett
.head 13 -  !
.head 13 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 13 -  Call SalTblSetContext ( hWndForm, nRowM )
.head 13 -  Set nFallKey = colIDObject
.head 13 -  Set nChecked = colCheck
.head 13 -  ! Set Facts.sGebDatum = SalFmtFormatDateTime( colDtVal1, sRegionalFrmDate)
.head 13 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 13 -  Set Facts.sActiveServices = GetActiveServices( nFallKey )
.head 13 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 13 +  If nChecked = 1
.head 14 -  !
.head 14 -  Set oInfo1 = FE_GetInfo( nRowM )
.head 14 -  Set Facts.oLevelSettings = oSettingsBett
.head 14 -  Set nD = 0
.head 14 +  If oInfo1.GetState( AnimalIsLitter )
.head 15 -  Set Facts.bHasLitter = TRUE
.head 15 -  ! Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 15 -  Set sLitter = "litter:YES;"
.head 14 +  Else
.head 15 -  Set sLitter = "litter:NO;"
.head 14 -  Set sTest = ""
.head 14 +  While nD < Facts.oLevelSettings.nCountHints
.head 15 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 16 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 16 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 15 -  Set nD = nD + 1
.head 14 +  ! If Facts.sSex = "F"
.head 15 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 14 +  ! Else
.head 15 -  !
.head 15 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 14 -  Set sTest = sTest || sLitter
.head 14 -  Set Facts.sMedRec = sTest || Facts.sMedRec
.head 14 -  Set Facts.sSelectedAnimal = Facts.sMedRec || ';' || Facts.sActiveServices
.head 14 +  If nChecked = 1
.head 15 -  Set Facts.aAnimalsSelected[nSelAn] = Facts.sSelectedAnimal  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 15 -  Set nSelAn = nSelAn + 1
.head 13 -  Set nRowM = MTblGetNextChildRow( hWndForm, nRowM )
.head 10 +  If GetLevel(nRowC ) = KHEL_Station or GetLevel(nRowC ) = KHEL_Gruppe
.head 11 -  !
.head 11 -  ! Call SalMessageBox( "nrowM1", "nroM1", MB_Ok )
.head 11 -  ! Set Facts.nSelected = nI
.head 11 -  Set nRowM = MTblGetFirstChildRow( hWndForm, nRowC )
.head 11 -  ! Set nN = 0
.head 11 -  Set nChecked = 0
.head 11 +  Loop
.head 12 -  !
.head 12 +  If nRowM = TBL_Error
.head 13 -  Break
.head 12 -  ! If GetLevel(nRowM ) =KHEL_Bett
.head 12 -  !
.head 12 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 12 -  Call SalTblSetContext ( hWndForm, nRowM )
.head 12 -  Set nFallKey = colIDObject
.head 12 -  Set nChecked = colCheck
.head 12 -  ! Set Facts.sGebDatum = SalFmtFormatDateTime( colDtVal1, sRegionalFrmDate)
.head 12 -  ! Set Facts.sSelectedAnimal = Facts.sMedRec || ';' || Facts.sActiveServices
.head 12 +  If bSelectedCage OR nChecked = 1
.head 13 -  !
.head 13 -  Set Facts.nSelectedCageID = Facts.nCageID[0]
.head 13 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 13 -  Set Facts.sActiveServices = GetActiveServices( nFallKey,0 )
.head 13 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 13 -  Set oInfo1 = FE_GetInfo( nRowM )
.head 13 -  Set Facts.oLevelSettings = oSettingsBett
.head 13 -  Set nD = 0
.head 13 +  If oInfo1.GetState( AnimalIsLitter )
.head 14 -  Set Facts.bHasLitter = TRUE
.head 14 -  ! Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 14 -  ! Set sLitter = "litter:YES;"
.head 14 -  Set sLitter = "litter:Yes " || GetPupsSql( nFallKey, nFemales, nMales, nUnknown )  || ";"
.head 13 +  Else
.head 14 -  Set sLitter = "litter:NO;"
.head 13 -  Set sTest = ""
.head 13 +  While nD < Facts.oLevelSettings.nCountHints
.head 14 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 15 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 15 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 14 -  Set nD = nD + 1
.head 13 +  ! If Facts.sSex = "F"
.head 14 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 13 +  ! Else
.head 14 -  !
.head 14 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 13 -  Set sTest = sTest || sLitter
.head 13 -  Set Facts.sMedRec = sTest || Facts.sMedRec
.head 13 -  Set Facts.aAnimalsSelected[nSelAn] =  Facts.sMedRec || ';' || Facts.sActiveServices  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 13 -  ! Set Facts.sSelAnimalNoMR = sTest || ';' || Facts.sActiveServices  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 13 -  Set Facts.anFallKey[nSelAn] = nFallKey
.head 13 -  Set Facts.aFirstAnimalInCage[nSelAn] = sTest || ';' || Facts.sActiveServices  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 13 +  If nChecked = 1
.head 14 -  Set Facts.aAnimalsSelected[nSelAn] ='Checked;' ||  Facts.aAnimalsSelected[nSelAn]
.head 14 -  ! Set Facts.aAnimalsInSelectedCage[nN] = 'Checked;' || Facts.aAnimalsInSelectedCage[nN]
.head 13 +  If nRowM = nBetRow
.head 14 -  ! Set Facts.aAnimalsSelected
.head 14 -  ! Set Facts.aAnimalsSelected[nSelAn] = 'Selected;' ||  Facts.aAnimalsInSelectedCage[nN]  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 14 -  ! Set Facts.aAnimalsInSelectedCage[nN] = 'Selected;' || Facts.aAnimalsInSelectedCage[nN]
.head 14 -  Set Facts.aAnimalsSelected[nSelAn] = 'Selected;' || Facts.aAnimalsSelected[nSelAn]
.head 14 -  ! Set Facts.sSelAnimalNoMR = 'Selected;' || Facts.sSelAnimalNoMR
.head 14 -  Set Facts.sSelAnimalNoMR = 'Selected;' ||  sTest || ';' || Facts.sActiveServices  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 14 -  Set bSelectedAnimal= TRUE
.head 13 -  Set nSelAn = nSelAn + 1
.head 12 +  Else
.head 13 -  !
.head 13 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 12 +  ! Else If nChecked = 1
.head 13 -  ! Set Facts.aAnimalsSelected[nSelAn] = 'Checked;' ||  Facts.aAnimalsInSelectedCage[nN]  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 13 -  Set Facts.aAnimalsInSelectedCage[nN] = 'Checked;' || Facts.aAnimalsInSelectedCage[nN]
.head 13 -  Set nSelAn = nSelAn + 1
.head 12 -  Set nRowM = MTblGetNextChildRow( hWndForm, nRowM )
.head 10 -  Set nD = 0
.head 10 -  Set Facts.oLevelSettingsCage = oSettingsCage
.head 10 -  Set sTest = ""
.head 10 -  ! OPENED CAGES
.head 10 -  Set bRealCage = FALSE
.head 10 +  While nD < Facts.oLevelSettingsCage.nCountHints
.head 11 +  If Facts.oLevelSettingsCage.IsClips( Facts.oLevelSettingsCage.nIndexHints[nD] ) or Facts.oLevelSettingsCage.nIndexHints[nD] = 4
.head 12 -  Set sTest2 = oInfo.GetLabelClipsValue( Facts.oLevelSettingsCage.nIndexHints[nD] ,bTemp)
.head 12 -  Set sTest = sTest || sTest2
.head 12 +  If bTemp
.head 13 -  Set bRealCage = bTemp
.head 11 -  Set nD = nD + 1
.head 10 +  If bRealCage
.head 11 -  !
.head 11 +  If nFallLicience = 0
.head 12 -  !
.head 12 -  Set nFallLicience = GetLicenseFallWithCageID( Facts.nCageID[0] )
.head 11 -  Set bRackHasChildren = TRUE
.head 11 -  Set Facts.aOpenedCages[nI] = sTest || 'rack-id:' || SalNumberToStrX(  Facts.nRackID , 0 )  || ';'  || GetActiveServices( nFallLicience, Facts.nCageID[0] )  || '; Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 11 +  If bSelectedCage and not bSelectedAnimal
.head 12 -  !
.head 12 -  Set Facts.aOpenedCages[nI] = "value:selected;" ||  Facts.aOpenedCages[nI]
.head 10 -  Set nI = nI + 1
.head 10 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 9 -  ! STATION RACK
.head 9 -  Set bSelectedRack = FALSE
.head 9 +  If nRowR = nSelectedRow
.head 10 -  Set bSelectedRack = TRUE
.head 9 +  If GetLevel(nRowR ) = KHEL_Station and (bRackHasChildren or bSelectedRack)
.head 10 -  !
.head 10 -  Set Facts.oLevelSettingsRack = oSettingsRack
.head 10 -  Set bRealCage = FALSE
.head 10 -  Set nD = 0
.head 10 -  ! Set oInfo = FE_GetInfo( nRowR )
.head 10 -  Set sTest = ""
.head 10 -  Set sTest2 = ""
.head 10 -  Set bRealCage = FALSE
.head 10 +  While nD < Facts.oLevelSettingsRack.nCountHints
.head 11 +  If Facts.oLevelSettingsRack.IsClips( Facts.oLevelSettingsRack.nIndexHints[nD] ) or Facts.oLevelSettingsRack.nIndexHints[nD] = 4
.head 12 -  Set sTest2 = oInfoRack.GetLabelClipsValue( Facts.oLevelSettingsRack.nIndexHints[nD] ,bTemp)
.head 12 -  Set sTest = sTest || sTest2
.head 11 -  Set nD = nD + 1
.head 10 -  ! Set Facts.sRackInfo = sTest
.head 10 -  ! Set Facts.aOpenedCages[nI] = sTest || 'Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 10 -  Set Facts.aOpenedRacks[nRackCount] = sTest || 'rack-id:' || SalNumberToStrX(  Facts.nRackID , 0 )
.head 10 +  If bSelectedRack
.head 11 -  !
.head 11 -  Set Facts.aOpenedRacks[nRackCount]  = "value:selected;" || Facts.aOpenedRacks[nRackCount]
.head 11 -  Set Facts.nSelectedRackID = Facts.nRackID
.head 10 -  ! Call SalMessageBox( sTest,SalNumberToStrX( Facts.oLevelSettingsRack.nCountHints, 0 ), MB_Ok )
.head 10 -  Set nRackCount = nRackCount + 1
.head 9 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 8 +  If GetLevel(nParentRow ) = KHEL_Abteilung
.head 9 -  !
.head 9 -  ! Set Facts.oLevelSettingsRack = oSettingsRack
.head 9 -  ! Set bRealCage = FALSE
.head 9 -  Set oInfoWorkgroup = FE_GetInfo( nParentRow)
.head 9 -  Set nD = 0
.head 9 -  ! Set oInfo = FE_GetInfo( nRowR )
.head 9 -  Set sTest = ""
.head 9 -  Set sTest2 = ""
.head 9 -  Set bRealCage = FALSE
.head 9 +  ! While nD < Facts.oLevelSettingsRack.nCountHints
.head 10 +  If Facts.oLevelSettingsRack.IsClips( Facts.oLevelSettingsRack.nIndexHints[nD] ) or Facts.oLevelSettingsRack.nIndexHints[nD] = 4
.head 11 -  Set sTest2 = oInfoRack.GetLabelClipsValue( Facts.oLevelSettingsRack.nIndexHints[nD] ,bTemp)
.head 11 -  Set sTest = sTest || sTest2
.head 10 -  Set nD = nD + 1
.head 9 -  ! Set Facts.sRackInfo = sTest
.head 9 -  ! Set Facts.aOpenedCages[nI] = sTest || 'Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 9 -  Set Facts.nSelectedWorkgroupID = oInfoWorkgroup.nID_Obj
.head 9 -  ! Set Facts.aOpenedRacks[nRackCount] = sTest || 'rack-id:' || SalNumberToStrX(  Facts.nRackID , 0 )
.head 9 -  Set Facts.sWorkgroup = "(workgroup (name " || oInfoWorkgroup.sVal[0] || "))"
.head 9 +  If nParentRow = nSelectedRow
.head 10 -  !
.head 10 -  Set Facts.sWorkgroup  = "(workgroup (value selected) (name " || oInfoWorkgroup.sVal[0] || "))"
.head 9 -  ! Call SalMessageBox( oInfoWorkgroup.sVal[0],oInfoWorkgroup.sVal[1], MB_Ok )
.head 7 -  ! If
.head 7 -  ! If
.head 7 -  ! If
.head 7 +  ! If GetLevel(nParentRow ) = KHEL_Einrichtung
.head 8 -  !
.head 8 -  Call SalMessageBox( "Einrichtung", "Einrichtung", MB_Ok )
.head 8 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 8 +  Loop
.head 9 +  If nRowR = TBL_Error
.head 10 -  Break
.head 9 -  Set nRowO = MTblGetFirstChildRow( hWndForm, nRowR )
.head 9 +  Loop
.head 10 -  !
.head 10 +  If nRowO = TBL_Error
.head 11 -  Break
.head 10 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowO )
.head 10 +  Loop
.head 11 +  If nRowC = TBL_Error
.head 12 -  Break
.head 11 -  Set oInfo = FE_GetInfo( nRowC )
.head 11 +  If oInfo.nID_Obj != -100 and  (oInfo.GetState( CageIsEmpty ) )
.head 12 +  ! If oInfo.GetNValue( "FEMALE" ) > 0 and oInfo.GetNValue( "MALE" ) < 1
.head 13 -  !
.head 13 -  ! Call SalMessageBox( "Female open cages", SalNumberToStrX( nF, 0 ), MB_Ok )
.head 12 -  Set Facts.nRowCages[nI] = 1
.head 11 +  Else
.head 12 -  !
.head 12 -  Set Facts.nRowCages[nI] = 0
.head 11 -  Set Facts.nCageID[0] = oInfo.nID_Obj
.head 11 -  ! Set nRowCages = oInfo.GetState( Number )
.head 11 +  ! If nRowR = nSelectedRow
.head 12 -  Set Facts.nSelected = nI
.head 12 +  If GetLevel(nSelectedRow ) =KHEL_Bett
.head 13 -  !
.head 13 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 13 -  Set nFallKey = colIDObject
.head 13 -  ! Set nChecked = colCheck
.head 13 -  Set Facts.oLevelSettings = oSettingsBett
.head 13 -  Set oInfo1 = FE_GetInfo( nSelectedRow )
.head 13 -  Set nD = 0
.head 13 -  Set sTest = ""
.head 13 +  While nD < Facts.oLevelSettings.nCountHints
.head 14 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 15 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 15 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 14 -  Set nD = nD + 1
.head 13 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 13 -  Set Facts.sActiveServices = GetActiveServices( nFallKey )
.head 13 +  If oInfo1.GetState( AnimalIsLitter )
.head 14 -  Set Facts.bHasLitter = TRUE
.head 14 -  ! Call SalMessageBox( "has litter", "", MB_Ok )
.head 14 -  Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 13 +  ! If oInfo.GetNValue( "FEMALE" ) > 0
.head 14 -  Set Facts.sMedRec = "Selected animal:Female; Strain:"  || Facts.sStrain || ";" || Facts.sMedRec
.head 13 +  ! Else
.head 14 -  !
.head 14 -  Set Facts.sMedRec = "Selected animal:Male; Strain:" || Facts.sStrain || ";" || Facts.sMedRec
.head 13 +  ! If Facts.sSex = "F"
.head 14 -  Set Facts.sMedRec = "Selected animal:Female; Strain:"  || Facts.sStrain || "; Geb_Datum:" ||  Facts.sGebDatum || ";" || Facts.sMedRec|| "; Phenotype:" ||  Facts.sPhenoType || "; Genotype:" ||  Facts.sGenoType
.head 13 -  Set Facts.sSelectedAnimal =""
.head 13 +  ! Else
.head 14 -  !
.head 14 -  Set Facts.sMedRec = "Selected animal:Male; Strain:" || Facts.sStrain || "; Geb_Datum:" ||  Facts.sGebDatum || ";" || Facts.sMedRec|| "; Phenotype:" ||  Facts.sPhenoType || "; Genotype:" ||  Facts.sGenoType
.head 13 +  ! If Facts.sSex = "F"
.head 14 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 13 +  ! Else
.head 14 -  !
.head 14 -  Set Facts.sMedRec = sTest || ';' ||  Facts.sMedRec
.head 13 -  Set Facts.sMedRec = sTest ||  Facts.sMedRec
.head 13 -  Set Facts.sSelectedAnimal = Facts.sMedRec || ';' || Facts.sActiveServices
.head 13 -  Set Facts.aAnimalsSelected[0] = Facts.sSelectedAnimal
.head 13 -  Set nSelAn = 1
.head 13 +  ! If nChecked = 1
.head 14 -  Set Facts.aAnimalsSelected[nN] = Facts.aAnimalsInSelectedCage[nN]
.head 13 -  ! Call SalMessageBox( Facts.sMedRec, "Selected bett", MB_Ok )
.head 12 -  ! Call SalMessageBox( sTest, sTest, MB_Ok )
.head 12 -  Set nSelectedRow = GetParent(GetParent(nSelectedRow ))
.head 12 -  ! Call GetOpenCages2b( nState )
.head 12 -  Set nSelectedRow = nRowR
.head 11 +  If nRowC = nSelectedRow
.head 12 -  Set Facts.nSelected = nI
.head 12 -  Set nRowM = MTblGetFirstChildRow( hWndForm, nRowC )
.head 12 -  Set nN = 0
.head 12 -  Set nChecked = 0
.head 12 +  Loop
.head 13 -  !
.head 13 +  If nRowM = TBL_Error
.head 14 -  Break
.head 13 -  ! If GetLevel(nRowM ) =KHEL_Bett
.head 13 -  !
.head 13 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 13 -  Call SalTblSetContext ( hWndForm, nRowM )
.head 13 -  Set nFallKey = colIDObject
.head 13 -  Set nChecked = colCheck
.head 13 -  ! Set Facts.sGebDatum = SalFmtFormatDateTime( colDtVal1, sRegionalFrmDate)
.head 13 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 13 -  Set Facts.sActiveServices = GetActiveServices( nFallKey )
.head 13 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 13 -  Set oInfo1 = FE_GetInfo( nRowM )
.head 13 -  Set Facts.oLevelSettings = oSettingsBett
.head 13 -  Set nD = 0
.head 13 +  ! If oInfo1.GetState( AnimalIsLitter )
.head 14 -  Set Facts.bHasLitter = TRUE
.head 14 -  Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 13 +  If oInfo1.GetState( AnimalIsLitter )
.head 14 -  Set Facts.bHasLitter = TRUE
.head 14 -  ! Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 14 -  Set sLitter = "litter:YES;"
.head 13 +  Else
.head 14 -  Set sLitter = "litter:NO;"
.head 13 -  Set sTest = ""
.head 13 +  While nD < Facts.oLevelSettings.nCountHints
.head 14 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 15 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 15 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 14 -  Set nD = nD + 1
.head 13 +  ! If Facts.sSex = "F"
.head 14 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 13 +  ! Else
.head 14 -  !
.head 14 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 13 -  Set sTest = sTest || sLitter
.head 13 -  Set Facts.sMedRec = sTest || Facts.sMedRec
.head 13 -  Set Facts.aAnimalsInSelectedCage[nN] = Facts.sMedRec || ';' || Facts.sActiveServices || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )  || ';'
.head 13 +  If nRowM = nBetRow
.head 14 -  ! Set Facts.aAnimalsSelected
.head 14 -  ! Set Facts.aAnimalsSelected[nSelAn] = 'Selected;' ||  Facts.aAnimalsInSelectedCage[nN]  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 14 -  Set Facts.aAnimalsInSelectedCage[nN] = 'Selected;' || Facts.aAnimalsInSelectedCage[nN]
.head 14 -  Set nSelAn = nSelAn + 1
.head 13 +  Else If nChecked = 1
.head 14 -  ! Set Facts.aAnimalsSelected[nSelAn] = 'Checked;' ||  Facts.aAnimalsInSelectedCage[nN]  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 14 -  Set Facts.aAnimalsInSelectedCage[nN] = 'Checked;' || Facts.aAnimalsInSelectedCage[nN]
.head 14 -  Set nSelAn = nSelAn + 1
.head 13 -  Set nN = nN + 1
.head 13 -  Set nRowM = MTblGetNextChildRow( hWndForm, nRowM )
.head 11 +  Else
.head 12 +  If GetLevel(nRowC ) = KHEL_Station or GetLevel(nRowC ) = KHEL_Gruppe
.head 13 -  !
.head 13 -  ! Set Facts.nSelected = nI
.head 13 -  Set nRowM = MTblGetFirstChildRow( hWndForm, nRowC )
.head 13 -  ! Set nN = 0
.head 13 -  Set nChecked = 0
.head 13 +  Loop
.head 14 -  !
.head 14 +  If nRowM = TBL_Error
.head 15 -  Break
.head 14 -  ! If GetLevel(nRowM ) =KHEL_Bett
.head 14 -  !
.head 14 -  ! Call SalMessageBox( "Selected bett", "Selected bett", MB_Ok )
.head 14 -  Call SalTblSetContext ( hWndForm, nRowM )
.head 14 -  Set nFallKey = colIDObject
.head 14 -  Set nChecked = colCheck
.head 14 -  ! Set Facts.sGebDatum = SalFmtFormatDateTime( colDtVal1, sRegionalFrmDate)
.head 14 -  Set Facts.sMedRec  = GetAnimalMedicalRecord( nFallKey )
.head 14 -  Set Facts.sActiveServices = GetActiveServices( nFallKey )
.head 14 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 14 +  If nChecked = 1
.head 15 -  !
.head 15 -  Set oInfo1 = FE_GetInfo( nRowM )
.head 15 -  Set Facts.oLevelSettings = oSettingsBett
.head 15 -  Set nD = 0
.head 15 +  ! If oInfo1.GetState( AnimalIsLitter )
.head 16 -  Set Facts.bHasLitter = TRUE
.head 16 -  Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 15 +  If oInfo1.GetState( AnimalIsLitter )
.head 16 -  Set Facts.bHasLitter = TRUE
.head 16 -  ! Set Facts.sMedRec  = Facts.sMedRec  || "Litter"
.head 16 -  Set sLitter = "litter:YES;"
.head 15 +  Else
.head 16 -  Set sLitter = "litter:NO;"
.head 15 -  Set sTest = ""
.head 15 +  While nD < Facts.oLevelSettings.nCountHints
.head 16 +  If Facts.oLevelSettings.IsClips( Facts.oLevelSettings.nIndexHints[nD] )
.head 17 -  Set sTest = sTest || oInfo1.GetLabelClipsValue( Facts.oLevelSettings.nIndexHints[nD], bTemp )
.head 17 -  ! Call SalMessageBox( SalNumberToStrX(  Facts.oLevelSettings.nIndexHints[nD] , 0 ), sTest, MB_Ok )
.head 16 -  Set nD = nD + 1
.head 15 +  ! If Facts.sSex = "F"
.head 16 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 15 +  ! Else
.head 16 -  !
.head 16 -  Set Facts.sMedRec =  Facts.sMedRec || ';' || sTest
.head 15 -  Set sTest = sTest || sLitter
.head 15 -  Set Facts.sMedRec = sTest || Facts.sMedRec
.head 15 -  Set Facts.sSelectedAnimal = Facts.sMedRec || ';' || Facts.sActiveServices
.head 15 +  If nChecked = 1
.head 16 -  Set Facts.aAnimalsSelected[nSelAn] = Facts.sSelectedAnimal  || ';Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 16 -  Set nSelAn = nSelAn + 1
.head 14 -  Set nRowM = MTblGetNextChildRow( hWndForm, nRowM )
.head 12 -  ! Call SalMessageBox( SalNumberToStrX(  GetLevel(nRowC ) , 0 ), "Selected bett", MB_Ok )
.head 11 -  Set nD = 0
.head 11 -  Set Facts.oLevelSettingsCage = oSettingsCage
.head 11 -  Set sTest = ""
.head 11 -  Set bRealCage = FALSE
.head 11 +  While nD < Facts.oLevelSettingsCage.nCountHints
.head 12 +  If Facts.oLevelSettingsCage.IsClips( Facts.oLevelSettingsCage.nIndexHints[nD] ) or Facts.oLevelSettingsCage.nIndexHints[nD] = 4
.head 13 -  Set sTest2 = oInfo.GetLabelClipsValue( Facts.oLevelSettingsCage.nIndexHints[nD] ,bTemp)
.head 13 -  Set sTest = sTest || sTest2
.head 13 +  If bTemp
.head 14 -  Set bRealCage = bTemp
.head 12 -  Set nD = nD + 1
.head 11 +  If bRealCage
.head 12 -  !
.head 12 -  ! Set Facts.sCageInfo = sTest
.head 12 -  Set Facts.aOpenedCages[nI] = sTest || 'Cage-id:' || SalNumberToStrX(  Facts.nCageID[0] , 0 )
.head 11 -  ! Call SalMessageBox( "Context row " ||  SalNumberToStrX( nTest, 0 ) ,  "Selected row " || SalNumberToStrX( nSelectedRow, 0 ), MB_Ok )
.head 11 -  Set nI = nI + 1
.head 11 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 10 -  Set nRowO = MTblGetNextChildRow( hWndForm, nRowO )
.head 9 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 7 +  If nRowTemp != 0
.head 8 -  !
.head 8 -  Call SalTblSetContext( hWndForm, nRowTemp  )
.head 8 -  Set nSelectedRow = nRowTemp
.head 7 -  Set Facts.sServicesList = GetServiceList(  )
.head 7 -  Return Facts
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call MTblSubClass( hWndItem )
.head 6 -  Call InitTable(  )
.head 6 -  Set hWndKHE = hWndItem
.head 5 +  On WM_Size
.head 6 -  Call SetSizeTree()
.head 5 +  On SAM_Timer
.head 6 +  If wParam = 10
.head 7 -  Call SalTimerKill ( hWndForm, 10 )
.head 7 -  Set bAutoSize = FALSE
.head 5 +  On AM_GetObjValue
.head 6 +  If wParam = FEL_Workgroup
.head 7 -  Return oPosition.nScreenID
.head 6 +  Else If wParam = FEL_Rack
.head 7 -  Return oPosition.nRackID
.head 6 +  Else If wParam = FEL_Cage
.head 7 -  Return oPosition.nCageID
.head 6 +  Else If wParam = FEL_Pos
.head 7 -  Return oPosition.nPosID
.head 6 +  Else
.head 7 -  Return -1
.head 5 +  ! On WM_MOUSEWHEEL 
.head 6 -  Call MTblLockPaint( hWndForm )
.head 6 -  Call MTblUnlockPaint( hWndForm )
.head 6 -  Call SalInvalidateWindow( hWndForm )
.head 3 +  Child Table Class: clsNewFE
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left:
.head 6 -  Top:
.head 6 -  Width:  1.2"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.833"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: 50000
.head 5 -  Discardable? Class Default
.head 4 -  Next Class Child Key: 31
.head 4 -  List in Tool Palette? Yes
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: clsNewExplorer
.head 4 +  Contents
.head 5 +  Column: colTree
.head 6 -  Class Child Ref Key: 1
.head 6 -  Class ChildKey: 3
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colIDObject
.head 6 -  Class Child Ref Key: 2
.head 6 -  Class ChildKey: 4
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colOrder
.head 6 -  Class Child Ref Key: 3
.head 6 -  Class ChildKey: 5
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCheck
.head 6 -  Class Child Ref Key: 4
.head 6 -  Class ChildKey: 6
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colFlags
.head 6 -  Class Child Ref Key: 15
.head 6 -  Class ChildKey: 17
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal1
.head 6 -  Class Child Ref Key: 5
.head 6 -  Class ChildKey: 7
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal2
.head 6 -  Class Child Ref Key: 6
.head 6 -  Class ChildKey: 8
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal3
.head 6 -  Class Child Ref Key: 7
.head 6 -  Class ChildKey: 9
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal4
.head 6 -  Class Child Ref Key: 8
.head 6 -  Class ChildKey: 10
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal5
.head 6 -  Class Child Ref Key: 9
.head 6 -  Class ChildKey: 11
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal6
.head 6 -  Class Child Ref Key: 10
.head 6 -  Class ChildKey: 12
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal7
.head 6 -  Class Child Ref Key: 11
.head 6 -  Class ChildKey: 13
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal8
.head 6 -  Class Child Ref Key: 12
.head 6 -  Class ChildKey: 14
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal9
.head 6 -  Class Child Ref Key: 13
.head 6 -  Class ChildKey: 15
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal10
.head 6 -  Class Child Ref Key: 14
.head 6 -  Class ChildKey: 16
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal11
.head 6 -  Class Child Ref Key: 26
.head 6 -  Class ChildKey: 28
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal12
.head 6 -  Class Child Ref Key: 27
.head 6 -  Class ChildKey: 29
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal1
.head 6 -  Class Child Ref Key: 16
.head 6 -  Class ChildKey: 18
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal2
.head 6 -  Class Child Ref Key: 17
.head 6 -  Class ChildKey: 19
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal3
.head 6 -  Class Child Ref Key: 25
.head 6 -  Class ChildKey: 27
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal4
.head 6 -  Class Child Ref Key: 18
.head 6 -  Class ChildKey: 20
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal5
.head 6 -  Class Child Ref Key: 19
.head 6 -  Class ChildKey: 21
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal6
.head 6 -  Class Child Ref Key: 20
.head 6 -  Class ChildKey: 22
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal7
.head 6 -  Class Child Ref Key: 21
.head 6 -  Class ChildKey: 23
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal8
.head 6 -  Class Child Ref Key: 22
.head 6 -  Class ChildKey: 24
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal9
.head 6 -  Class Child Ref Key: 23
.head 6 -  Class ChildKey: 25
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal10
.head 6 -  Class Child Ref Key: 24
.head 6 -  Class ChildKey: 26
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal1
.head 6 -  Class Child Ref Key: 28
.head 6 -  Class ChildKey: 30
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal2
.head 6 -  Class Child Ref Key: 29
.head 6 -  Class ChildKey: 31
.head 6 -  Class: clsNewExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Boolean: bRackCreationInProcess
.head 5 -  Session Handle: hSesionFE
.head 5 -  Session Handle: hSesionFEPopulate
.head 5 -  Sql Handle: hSqlPopulate
.head 5 -  Sql Handle: hSqlPopulateW
.head 5 -  Sql Handle: hSqlPopulateR
.head 5 -  Sql Handle: hSqlPopulateC
.head 5 -  Sql Handle: hSqlPopulateP
.head 5 -  Sql Handle: hSqlGetInfo
.head 5 -  Sql Handle: hSqlTransfer
.head 5 -  !
.head 5 -  FunctionalVar: oSqlL1
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL2
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL3
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL4
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL5
.head 6 -  Class: cFE_Sqls
.head 5 -  !
.head 5 -  Boolean: bNeedActivateRow
.head 5 -  Boolean: bMatingActive
.head 5 -  !
.head 5 -  FunctionalVar: oTransferAnimals[*]
.head 6 -  Class: cPositionData
.head 5 -  ! Window Handle: hWnd_POC
.head 5 -  FunctionalVar: oRefreshCages
.head 6 -  Class: cRefreshRow
.head 5 -  FunctionalVar: oGetInfo
.head 6 -  Class: cPositionData
.head 5 -  !
.head 5 -  Window Handle: hWnd_EarTags
.head 5 -  !
.head 5 -  Boolean: bMoveFlag
.head 5 -  String: sMoveScreen
.head 5 -  Number: nMoveScrID
.head 5 -  !
.head 5 -  Boolean: bNotNeedCloseCage
.head 5 -  Boolean: bNotNeedPrintCageCard
.head 5 -  !
.head 5 -  FunctionalVar: oData
.head 6 -  Class: cPositionData
.head 5 -  !
.head 5 -  Boolean: bFreezeRefresh
.head 5 -  Boolean: bFreezeRefreshToolbars
.head 5 -  Boolean: bFreezeMark
.head 5 -  Window Handle: hWnd_POC
.head 4 +  Functions
.head 5 +  Function: PopulateInstitute
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  String: s[2]
.head 7 -  Number: nID
.head 7 -  Number: nFetch
.head 7 -  FunctionalVar: cInfo
.head 8 -  Class: cFERowIns
.head 7 -  String: sSql2Get_AbtKey
.head 7 -  Number: nRow
.head 7 -  !
.head 7 -  Boolean: bUserViewsUsed
.head 7 -  Number: nPositionScreen
.head 7 -  Number: nOrder
.head 6 +  Actions
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Set bOk = TRUE
.head 7 +  If TRUE ! Prepare
.head 8 +  If not oSqlL1.bInit
.head 9 -  Call oSqlL1.SetSession( hSesionFEPopulate )
.head 9 -  Call oSqlL1.InitSqls( 5 )
.head 8 +  If not oSqlL1.bPrepare
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL1.hSql[0], "select	 A.NAME1, A.NAME2, e.EINRICHT_ID
from 	EINRICHTUNG E, ADRESSE a
where	E.ADRESSE_ID = A.ADRESSE_ID
   and	E.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into	:s[0], :s[1], :nID ") 
.head 9 -  !
.head 9 -  Set sSql2Get_AbtKey = "
select	 a.id,@nullvalue(u.TOP,9999)
into	 :nID, :nOrder
from 	ABTEILUNG a, user_screen u
where	a.EINRICHT_ID = :nEinrichtId
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	u.user_ID= :nUserId
   and 	u.scr_id = a.id and @nullvalue(u.hide,0) = 0
 "
.head 9 -  Set sSql2Get_AbtKey = sSql2Get_AbtKey || "
group by	a.id,u.TOP
order by	2 "
.head 9 -  Set bOk  =  bOk and SqlPrepare( oSqlL1.hSql[1], sSql2Get_AbtKey )
.head 9 +  If bOk
.head 10 -  Set oSqlL1.bPrepare = TRUE
.head 7 +  If FALSE
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select	 A.NAME1, A.NAME2, e.EINRICHT_ID
from 	EINRICHTUNG E, ADRESSE a
where	E.ADRESSE_ID = A.ADRESSE_ID
   and	E.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into	:s[0], :s[1], :nID ") 
.head 8 -  Set bOk = bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 7 -  Set bOk = bOk and SqlExecute(oSqlL1.hSql[0])
.head 7 -  Set bOk = bOk and SqlFetchNext(oSqlL1.hSql[0], nFetch)
.head 7 -  !
.head 7 +  If TRUE ! insert info 
.head 8 -  Call cInfo.Init(  )
.head 8 -  Set cInfo.sEinrichtKey = strEinrichtKey
.head 8 -  Set cInfo.sDescr = s[0] || ' ' || s[1]
.head 8 -  Set cInfo.nLabelFlags = oSettingsHouse.nFlags
.head 8 -  Set cInfo.nID_Obj = nID
.head 8 -  Set cInfo.nOrder = 1
.head 8 -  Set nRow = FindObject(TBL_MinRow, nID )
.head 8 +  If nRow = -1
.head 9 -  Set nRow = FE_NewRow(-1)
.head 8 -  Call FE_SetInfo(nRow,cInfo )
.head 8 -  Set nRoot = nRow
.head 7 -  !
.head 7 -  Call Reload_sUsers_AbtStatSet(  )
.head 7 -  Set bOk = bOk and UserRights_IsSet( bUserViewsUsed )
.head 7 +  If FALSE
.head 8 -  Set sSql2Get_AbtKey = "
select	 a.id,u.TOP
into	 :nID, :nOrder
from 	ABTEILUNG a, user_screen u
where	a.EINRICHT_ID = :nEinrichtId
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	u.user_ID= :nUserId
   and 	u.scr_id = a.id
 "
.head 8 -  Set sSql2Get_AbtKey = sSql2Get_AbtKey || "
group by	a.id,u.TOP
order by	u.TOP "
.head 8 -  Set bOk  =  bOk and SqlPrepareAndExecute( hSqlPopulate, sSql2Get_AbtKey )
.head 7 -  Set bOk  =  bOk and SqlExecute( oSqlL1.hSql[1] )
.head 7 -  Set nPositionScreen = 1
.head 7 +  While bOk and SqlFetchNext( oSqlL1.hSql[1] , nFetch )
.head 8 -  !
.head 8 -  Set nRow = FindObject(nRoot, nID )
.head 8 +  If nRow = -1
.head 9 -  Set nRow = FE_NewRow(nRoot)
.head 8 -  Call SalTblSetContext( hWndForm, nRow )
.head 8 -  Set colIDObject =  nID
.head 8 +  If nOrder
.head 9 +  If nOrder > nPositionScreen
.head 10 -  Set colOrder = nPositionScreen
.head 9 +  Else
.head 10 -  Set colOrder = nOrder
.head 8 +  Else
.head 9 -  Set colOrder = nPositionScreen
.head 8 -  Set nPositionScreen = nPositionScreen + 1
.head 7 -  Set nRow = MTblGetFirstChildRow( hWndForm, nRoot )
.head 7 +  While nRow != TBL_Error
.head 8 -  Call SalTblSetContext( hWndForm, nRow )
.head 8 -  Call PopulateWorkGroup( nRow, FALSE )
.head 8 -  Set nRow = MTblGetNextChildRow( hWndForm, nRow )
.head 7 -  ! Call SqlCommit(hSqlPopulate )
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Return bOk
.head 5 +  Function: PopulateWorkGroup
.head 6 -  Description: Reloads the Abteilung's contents
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowWG
.head 7 -  Boolean: bPopulateChildren
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nID
.head 7 -  String: sSql2Get_StatKey
.head 7 -  String: sAbtBez
.head 7 -  String: sAbtKey
.head 7 -  Number: nTop
.head 7 -  Number: nBgColor1
.head 7 -  Number: nTxColor
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  ! cFERow: cWG_Row
.winattr class FunctionalVar:
.head 8 -  Class: cFERow
.end
.head 7 -  FunctionalVar: cWG_Row
.head 8 -  Class: cFERowScr
.head 7 -  FunctionalVar: cR_Row
.head 8 -  Class: cFERow
.head 7 -  Date/Time: dtGetTime
.head 7 -  !
.head 7 -  Number: nStatCount
.head 7 -  Boolean: bUserViewsUsed
.head 7 -  Number: nPositionRack
.head 7 -  !
.head 7 -  Sql Handle: hSqlStat
.head 7 -  Number: nOrder
.head 7 -  Number: nRow
.head 6 +  Actions
.head 7 +  If nRowWG <= 0
.head 8 -  Return FALSE
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Call SalTblSetContext( hWndForm, nRowWG )
.head 7 -  Set nID = colIDObject
.head 7 -  Set bOk = TRUE
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 +  If TRUE ! Prepare
.head 8 +  If not oSqlL2.bInit
.head 9 -  Call oSqlL2.SetSession( hSesionFEPopulate )
.head 9 -  Call oSqlL2.InitSqls( 5 )
.head 8 +  If not oSqlL2.bPrepare
.head 9 -  Set sSql2Get_StatKey = "
select	a.ABT_BEZ, a.ABT_KEY,@NULLVALUE (u.TOP, 0), a.color, a.TEXTCOLOR
into	:sAbtBez, :sAbtKey, :nTop, :nBgColor1,:nTxColor
from 	ABTEILUNG a, user_screen u
where	a.ID = :nID
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	u.USER_ID= :nUserId 
   and 	u.scr_id = a.ID and @nullvalue(u.hide,0) = 0
 "
.head 9 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	a.ABT_BEZ, a.ABT_KEY, u.TOP, a.color, a.TEXTCOLOR
"
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL2.hSql[0], sSql2Get_StatKey)
.head 9 -  !
.head 9 -  Set sSql2Get_StatKey = "
select	s.ID,@nullvalue(t.top,99999)
into	:nID, :nOrder
  from screen_rack a
join user_rack u1 on (u1.rack_id=a.rack_id and u1.user_id=:nUserId and @nullvalue(u1.hide,0) = 0)
left join tree t on (t.user_id=:nUserId and t.id_parent=a.scr_id and id_child=a.rack_id)
join gruppe g on (g.rack_id=a.rack_id  and 	g.CANCELED = 'N')
join station s on (s.id=a.rack_id and s.CANCELED='N')

where	a.scr_id = :cWG_Row.nID_Obj 
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= :dtGetTime)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= :dtGetTime)
 
 "
.head 9 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	s.ID, t.top
order by 2
"
.head 9 -  Set bOk = bOk and SqlPrepare( oSqlL2.hSql[1], sSql2Get_StatKey )	
.head 9 +  If bOk
.head 10 -  Set oSqlL2.bPrepare = TRUE
.head 7 -  !
.head 7 +  If TRUE ! Execute
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL2.hSql[0])
.head 8 -  Set bOk = bOk and SqlFetchNext(oSqlL2.hSql[0], nFetch )
.head 7 -  !
.head 7 +  ! If FALSE
.head 8 -  Set sSql2Get_StatKey = "
select	a.ABT_BEZ, a.ABT_KEY,@NULLVALUE (u.TOP, 0)
into	:sAbtBez, :sAbtKey, :nTop
from 	ABTEILUNG a, user_screen u
where	a.ID = :nID
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	u.USER_ID= :nUserId 
   and 	u.scr_id = a.ID
 "
.head 8 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	a.ABT_BEZ, a.ABT_KEY, u.TOP
"
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulateW, sSql2Get_StatKey)
.head 8 -  Set bOk = bOk and SqlFetchNext(hSqlPopulateW, nFetch )
.head 7 -  Call SalStatusSetText( hWndForm, 'Populate: ' || sAbtKey )
.head 7 +  If bOk ! insert info screen 
.head 8 -  Call cWG_Row.Init()
.head 8 -  Set cWG_Row.nID_Obj = nID
.head 8 -  Set cWG_Row.nOrder = colOrder
.head 8 -  Set cWG_Row.sScreen = sAbtKey
.head 8 -  Set cWG_Row.sDescr = sAbtBez
.head 8 -  Set cWG_Row.nLabelFlags = oSettingsWorkGroup.nFlags
.head 8 -  Call FE_SetInfo(nRowWG,cWG_Row )
.head 8 +  If (nBgColor1 or nTxColor) and nBgColor1!=nTxColor
.head 9 -  Call MTblSetRowTextColor( hWndItem, nRowWG, nTxColor, MTSC_REDRAW )
.head 9 -  Call MTblSetRowBackColor( hWndItem, nRowWG, nBgColor1, MTSC_REDRAW )
.head 8 +  Else
.head 9 -  Call MTblSetRowTextColor( hWndItem, nRowWG, COLOR_Black, MTSC_REDRAW )
.head 9 -  Call MTblSetRowBackColor( hWndItem, nRowWG, nBGColor, MTSC_REDRAW )
.head 7 +  If TRUE
.head 8 -  Call cR_Row.Clear()
.head 8 -  Set cR_Row.sLabel = "Hide"
.head 8 -  Set cR_Row.nID_Obj = -100
.head 8 -  Set cR_Row.nOrder = -100
.head 8 -  Set nRow = FindObject(nRowWG, -100 )
.head 8 +  If nRow = -1
.head 9 -  Set nRow = FE_NewRow(nRowWG)
.head 8 -  Call FE_SetInfo(nRow,cR_Row )
.head 7 +  If bPopulateChildren
.head 8 -  Call Reload_sUsers_AbtStatSet(  )
.head 8 +  If Not UserRights_IsSet( bUserViewsUsed )
.head 9 -  Return FALSE
.head 8 +  ! If FALSE
.head 9 -  Set sSql2Get_StatKey = "
select	s.ID,@nullvalue(t.top,99999)
into	:nID, :nOrder
  from screen_rack a
join user_rack u1 on (u1.rack_id=a.rack_id and u1.user_id=:nUserId)
left join tree t on (t.user_id=:nUserId and t.id_parent=a.scr_id and id_child=a.rack_id)
join gruppe g on (g.rack_id=a.rack_id  and 	g.CANCELED = 'N')
join station s on (s.id=a.rack_id and s.CANCELED='N')

where	a.scr_id = :cWG_Row.nID_Obj 
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= :dtGetTime)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= :dtGetTime)
 
 "
.head 9 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	s.ID, t.top
order by 2
"
.head 9 -  Set bOk = SqlPrepareAndExecute( hSqlPopulateW, sSql2Get_StatKey )	
.head 8 -  ! !! 	L O A D I N G     R A C K S
.head 8 -  Set nStatCount = 0
.head 8 -  Set nPositionRack = 1
.head 8 -  Set bOk = SqlExecute( oSqlL2.hSql[1])	
.head 8 +  While bOk and SqlFetchNext( oSqlL2.hSql[1], nFetch )
.head 9 -  Set nRow = FindObject(nRowWG, nID )
.head 9 +  If nRow = -1
.head 10 -  Set nRow = FE_NewRow(nRowWG)
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Set colIDObject = nID
.head 9 +  If nOrder = 99999
.head 10 -  Set nOrder = nPositionRack
.head 9 +  Else
.head 10 +  If nOrder > nPositionRack
.head 11 -  Set nOrder = nPositionRack
.head 9 -  Set colOrder = nOrder
.head 9 -  Set nPositionRack = nPositionRack + 1
.head 9 -  Set nStatCount = nStatCount + 1
.head 8 -  Set nRow = MTblGetFirstChildRow( hWndForm, nRowWG )
.head 8 +  While nRow != TBL_Error
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Call PopulateRack( nRow, FALSE )
.head 9 -  Set nRow = MTblGetNextChildRow( hWndForm, nRow )
.head 7 -  ! Call SqlCommit(hSqlPopulateW)
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 -  Return bOk
.head 5 +  Function: PopulateRack
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowRack
.head 7 -  Boolean: bPopulateChildren
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: cRack_Row
.head 8 -  Class: cFERowRack
.head 7 -  FunctionalVar: cC_Row
.head 8 -  Class: cFERow
.head 7 -  Number: nRow
.head 7 -  Number: nID
.head 7 -  Number: nIDScr
.head 7 -  String: sSql
.head 7 -  String: sStatKey
.head 7 -  String: sStatBez
.head 7 -  Number: nGruppeAmount
.head 7 -  String: sVirtual
.head 7 -  String: sCurrnum
.head 7 -  String: sPosition
.head 7 -  Number: nOrder
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 7 -  Number: nFlags
.head 7 -  Number: nCageID
.head 7 -  Number: nChaos
.head 7 -  String: sIntensiv
.head 7 -  String: sSrvKey
.head 7 -  Number: nAlert
.head 7 -  String: sNotPrint
.head 7 -  String: sCadaver
.head 7 -  String: sModelNr
.head 7 -  Number: nBgColor1
.head 7 -  Number: nTxColor
.head 7 -  String: sNeedRegSlots
.head 7 -  Number: nCountFullSlots
.head 6 +  Actions
.head 7 -  ! nFlags 1-not Empty Rack , 2 - Virtual, 4 - Chaotic
.head 7 +  If nRowRack <= 0
.head 8 -  Return FALSE
.head 7 -  Call SalTblSetContext( hWndForm, nRowRack )
.head 7 -  Call VisWaitCursor( TRUE )
.head 7 -  Set cC_Row = FE_GetInfo( nRowRack )
.head 7 -  Set nID = cC_Row.nID_Obj
.head 7 -  Call SalTblSetContext( hWndForm, GetParent( nRowRack ) )
.head 7 -  Set nIDScr = colIDObject 
.head 7 -  Call SalTblSetContext( hWndForm, nRowRack )
.head 7 -  Set bOk = TRUE
.head 7 -  Call cRack_Row.Init(  )
.head 7 -  !
.head 7 +  If TRUE ! Prepare
.head 8 +  If not oSqlL3.bInit
.head 9 -  Call oSqlL3.SetSession( hSesionFEPopulate )
.head 9 -  Call oSqlL3.InitSqls( 6 )
.head 8 +  If not oSqlL3.bPrepare
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[0],"select count(distinct f.last_gruppe_key) + count(distinct bl.gruppe_key), count(distinct g.id )
from gruppe g
left join fall f on (f.last_cage_id = g.id  and f.last_scr_id=:nIDScr and f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J' )
left join BETT_LOCKS bl on ( bl.stat_key=g.stat_key and       (bl.bis>@NOW or bl.bis is null ))
where 1=1
   and g.rack_id=:nID and g.canceled='N' into  :nCountFullSlots, :nOrder " )
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(oSqlL3.hSql[1], "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l join fall f on (f.einricht_id=l.einricht_id and f.fall_key=l.fall_key  and f.last_scr_id=:nIDScr)
, sysadm.leistung lst
where g.rack_id = :nID
and l.cage_id = g.id
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
union
select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1 
from	sysadm.FALL f
join sysadm.gruppe g on (g.id=f.last_cage_id)
, sysadm.lst_erf l, sysadm.leistung lst 
	where	f.EINRICHT_ID = :nEinrichtId
       and 	g.rack_id = :nID
       and	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 and l.einricht_id = f.EINRICHT_ID
 and l.fall_key = f.fall_key
 and lst.lst_key = l.lst_key 
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
and f.last_scr_id=:nIDScr
group by 1
order by 2 desc
into :sSrvKey, :nAlert ")
.head 9 -  !
.head 9 -  Set sSql = "
select	s.STAT_KEY, s.STAT_BEZ, count( g.GRUPPE_KEY ), s.Virtual, s.CURRNUM, @IF(@ISNA(position),position_s,position),@nullvalue(t.top,0), @nullvalue(s.chaos,0), s.INTENSIV, @nullvalue(s.notprint,'N'), s.CADAVERS, 
s.modelnr, m.bgcolor, m.textcolor, s.REGSLOTS
into	 :sStatKey, :sStatBez, :nGruppeAmount, :sVirtual, :sCurrnum, :sPosition, :nOrder, :nChaos, :sIntensiv, :sNotPrint,:sCadaver,
:sModelNr, :nBgColor1, :nTxColor, :sNeedRegSlots
  from screen_rack a
join user_rack u1 on (u1.rack_id=a.rack_id and u1.user_id=:nUserId and @nullvalue(u1.hide,0) = 0)
left join tree t on (t.user_id=:nUserId and t.id_parent=a.scr_id and id_child=a.rack_id)
join gruppe g on (g.rack_id=a.rack_id  and 	g.CANCELED = 'N')
join sysadm.station s on (s.id=a.rack_id)
left join modelsrack m on (m.modelnumber=s.modelnr)
where	s.id = :nID 
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= @now)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= @now)
 
 "
.head 9 -  Set sSql = sSql || "
group by	s.ID, s.STAT_KEY, s.STAT_BEZ, s.CURRNUM, s.Virtual, s.POSITION,t.top , s.chaos, s.INTENSIV, s.notprint,s.CADAVERS, s.POSITION_S, s.modelnr, m.bgcolor, m.textcolor, s.REGSLOTS
"
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[2],sSql )
.head 9 -  !
.head 9 -  Set sSql = "
select id from gruppe where rack_id=:nID  and canceled='N'
 into :nCageID
 "
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[3], sSql )
.head 9 -  Set sSql = "select * from bewegung_plan bp
 join fall f on (f.fall_key=bp.fall_key and f.einricht_id=bp.einricht_id)
where bp.bew_zeit<@now and f.last_stat_key =:sStatKey and f.last_scr_id=:nIDScr "
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[4], sSql )
.head 9 -  Set sSql = "select * from bett_locks where stat_key=:sStatKey and von<@now and @nullvalue(bis,@now+35)>@now "
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[5], sSql )
.head 9 +  If bOk 
.head 10 -  Set oSqlL3.bPrepare = TRUE
.head 7 -  !
.head 7 +  If TRUE
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[0])
.head 8 -  Set bOk = bOk and SqlFetchNext( oSqlL3.hSql[0], nFetch )
.head 8 -  Set cRack_Row.nCountSlots = nOrder
.head 8 -  Set cRack_Row.nCountEmptySlots = nOrder - nCountFullSlots
.head 8 +  If nCountFullSlots >0
.head 9 -  Call cRack_Row.SetState( RackIsFull )
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[1])
.head 8 +  If SqlFetchNext( oSqlL3.hSql[1], nFetch )
.head 9 +  If nAlert = 1
.head 10 -  Call cRack_Row.SetState( IsServise)
.head 9 +  Else If nAlert = 2
.head 10 -  Call cRack_Row.SetState( IsAlert)
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[2])
.head 8 -  Set bOk = bOk and SqlFetchNext( oSqlL3.hSql[2], nFetch )
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[4])
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[5])
.head 8 +  If bOk ! insert info rack
.head 9 -  Set cRack_Row.sRack = sStatKey
.head 9 -  Set cRack_Row.sDescr  = sStatBez
.head 9 -  Set cRack_Row.sCurrnum = sCurrnum
.head 9 -  Set cRack_Row.sPosition = sPosition
.head 9 -  Set cRack_Row.nLabelFlags = nFlags
.head 9 -  Set cRack_Row.sVirtual = sVirtual
.head 9 -  Set cRack_Row.sModelNr = sModelNr
.head 9 -  Set cRack_Row.nLabelFlags = oSettingsRack.nFlags
.head 9 +  If sVirtual= 'J'
.head 10 -  Call cRack_Row.SetState( RackIsVirtual )
.head 9 +  If sNotPrint!= 'N'
.head 10 -  Call cRack_Row.SetState( Rack_NotNeedPrint )
.head 9 +  If sCadaver= 'J'
.head 10 -  Call cRack_Row.SetState( Rack_IsCadaver)
.head 9 +  If nChaos = 1
.head 10 -  Call cRack_Row.SetState( RackIsChaos )
.head 9 +  If sIntensiv
.head 10 -  Call cRack_Row.SetState( Rack_IsIntensiv )
.head 9 +  If sNeedRegSlots = 'J'
.head 10 -  Call cRack_Row.SetState( Rack_SlotNeedAssign )
.head 9 +  If bOk
.head 10 +  If SqlFetchNext( oSqlL3.hSql[4], nFetch )
.head 11 -  Call cRack_Row.SetState( Rack_OutgoingAdmServ )
.head 10 +  If SqlFetchNext( oSqlL3.hSql[5], nFetch )
.head 11 -  Call cRack_Row.SetState( Rack_IncomingAdmServ )
.head 9 -  Set cRack_Row.nID_Obj = nID
.head 9 -  Set cRack_Row.nOrder = colOrder
.head 9 -  Call FE_SetInfo(nRowRack,cRack_Row )
.head 9 +  If (nBgColor1 or nTxColor) and nBgColor1!=nTxColor
.head 10 -  Call MTblSetRowTextColor( hWndItem, nRowRack, nTxColor, MTSC_REDRAW )
.head 10 -  Call MTblSetRowBackColor( hWndItem, nRowRack, nBgColor1, MTSC_REDRAW )
.head 9 +  Else
.head 10 -  Call MTblSetRowTextColor( hWndItem, nRowRack, COLOR_Black, MTSC_REDRAW )
.head 10 -  Call MTblSetRowBackColor( hWndItem, nRowRack, nBGColor, MTSC_REDRAW )
.head 7 -  !
.head 7 +  ! If FALSE
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulateR,"select count(*) from fall f, gruppe g 
where g.rack_id=:nID and g.canceled='N' and f.last_scr_id=:nIDScr
   and f.last_cage_id = g.id and f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nOrder " )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSqlPopulateR, nFetch )
.head 8 +  If nOrder>0
.head 9 -  Call cRack_Row.SetState( RackIsFull )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulateR, "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.rack_id = :nID
and l.cage_id = g.id
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
union
select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1 
from	sysadm.FALL f
join sysadm.gruppe g on (g.id=f.last_cage_id)
, sysadm.lst_erf l, sysadm.leistung lst 
	where	f.EINRICHT_ID = :nEinrichtId
       and 	g.rack_id = :nID
       and	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 and lst.lst_key = l.lst_key 
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
   and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
order by 2 desc
into :sSrvKey, :nAlert ")
.head 8 +  If SqlFetchNext( hSqlPopulateR, nFetch )
.head 9 +  If nAlert = 1
.head 10 -  Call cRack_Row.SetState( IsServise)
.head 9 +  Else If nAlert = 2
.head 10 -  Call cRack_Row.SetState( IsAlert)
.head 8 -  Set sSql = "
select	s.STAT_KEY, s.STAT_BEZ, count( g.GRUPPE_KEY ), s.Virtual, s.CURRNUM, s.POSITION,@nullvalue(t.top,0), @nullvalue(s.chaos,0), s.INTENSIV, s.notprint, s.CADAVERS
into	 :sStatKey, :sStatBez, :nGruppeAmount, :sVirtual, :sCurrnum, :sPosition, :nOrder, :nChaos, :sIntensiv, :sNotPrint,:sCadaver
  from screen_rack a
left join user_rack u1 on (u1.rack_id=a.rack_id)
left join tree t on (t.user_id=:nUserId and t.id_parent=a.scr_id and id_child=a.rack_id)
join gruppe g on (g.rack_id=a.rack_id  and 	g.CANCELED = 'N')
join station s on (s.id=a.rack_id)

where	s.id = :nID 
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= @now)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= @now)
 
 "
.head 8 -  Set sSql = sSql || "
group by	s.ID, s.STAT_KEY, s.STAT_BEZ, s.CURRNUM, s.Virtual, s.POSITION,t.top , s.chaos, s.INTENSIV, s.notprint,s.CADAVERS
"
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulateR,sSql )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSqlPopulateR, nFetch )
.head 8 +  If bOk ! insert info rack
.head 9 -  Set cRack_Row.sRack = sStatKey
.head 9 -  Set cRack_Row.sDescr  = sStatBez
.head 9 -  Set cRack_Row.sCurrnum = sCurrnum
.head 9 -  Set cRack_Row.sPosition = sPosition
.head 9 -  Set cRack_Row.nLabelFlags = nFlags
.head 9 -  Set cRack_Row.sVirtual = sVirtual
.head 9 -  Set cRack_Row.nLabelFlags = oSettingsRack.nFlags
.head 9 +  If sVirtual= 'J'
.head 10 -  Call cRack_Row.SetState( RackIsVirtual )
.head 9 +  If sNotPrint= 'J'
.head 10 -  Call cRack_Row.SetState( Rack_NotNeedPrint )
.head 9 +  If sCadaver= 'J'
.head 10 -  Call cRack_Row.SetState( Rack_IsCadaver)
.head 9 +  If nChaos = 1
.head 10 -  Call cRack_Row.SetState( RackIsChaos )
.head 9 +  If sIntensiv
.head 10 -  Call cRack_Row.SetState( Rack_IsIntensiv )
.head 9 -  Set cRack_Row.nID_Obj = nID
.head 9 -  Set cRack_Row.nOrder = colOrder
.head 9 -  Call FE_SetInfo(nRowRack,cRack_Row )
.head 7 -  !
.head 7 +  If TRUE
.head 8 -  Call cC_Row.Clear()
.head 8 -  Set cC_Row.sLabel = "Hide"
.head 8 -  Set cC_Row.nID_Obj = -100
.head 8 -  Set cC_Row.nOrder = -100
.head 8 -  Set nRow = FindObject(nRowRack, -100 )
.head 8 +  If nRow = -1
.head 9 -  Set nRow = FE_NewRow(nRowRack)
.head 8 -  Call FE_SetInfo(nRow,cC_Row )
.head 7 +  If not bShowOnlyOpenCages and bPopulateChildren
.head 8 +  ! If FALSE
.head 9 -  Set sSql = "
select id from gruppe where rack_id=:nID  and canceled='N'
 into :nCageID
 "
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulateR, sSql )
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[3] )
.head 8 +  While bOk and SqlFetchNext(oSqlL3.hSql[3] ,nFetch)
.head 9 -  Set nRow =  FindObject(nRowRack, nCageID )
.head 9 +  If nRow=-1
.head 10 -  Set nRow = FE_NewRow(nRowRack)
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Set colIDObject = nCageID
.head 8 -  Set nRow = MTblGetFirstChildRow( hWndForm, nRowRack )
.head 8 +  While nRow != TBL_Error
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Call PopulateCage( nRow, FALSE )
.head 9 -  Set nRow = MTblGetNextChildRow( hWndForm, nRow )
.head 8 -  ! Call SqlCommit(hSqlPopulateR)
.head 7 -  Call VisWaitCursor( FALSE )
.head 5 +  Function: PopulateCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowCage
.head 7 -  Boolean: bPopulateChildren
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: cCAGE
.head 8 -  Class: cFERowCage
.head 7 -  FunctionalVar: cPos
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oCage
.head 8 -  Class: cPositionData
.head 7 -  Sql Handle: hSql
.head 7 -  Date/Time: dtGetTime
.head 7 -  String: sStatusTextG
.head 7 -  String: sSqlGruppe
.head 7 -  Number: nCageID
.head 7 -  String: sCageKey
.head 7 -  String: sDescr
.head 7 -  String: sPurposeKey
.head 7 -  Number: nColor
.head 7 -  Number: nScrAssign
.head 7 -  Number: nBettAmount
.head 7 -  Number: nUniq_Nr
.head 7 -  Boolean: bOk
.head 7 -  Number: nFtch
.head 7 -  Number: nRow
.head 7 -  Number: nAlert
.head 7 -  String: sSrvKey
.head 7 -  Number: nChilds[*]
.head 7 -  !
.head 7 -  String: sBettKey
.head 7 -  String: sStrain
.head 7 -  String: sName3
.head 7 -  String: sSV_Nr
.head 7 -  String: sSex
.head 7 -  String: sSexDescr
.head 7 -  String: sPhenoType
.head 7 -  String: sLE_Info
.head 7 -  String: sTelefaxOrigin
.head 7 -  String: sColor
.head 7 -  String: sBatch
.head 7 -  String: sGenoType
.head 7 -  String: sForeignID
.head 7 -  Number: nStrainColor
.head 7 -  Number: nFallKeyOnBed
.head 7 -  Date/Time: dtGebDatum
.head 7 -  Date/Time: dtTodDatum
.head 7 -  Boolean: bPlugged
.head 7 -  Number: nSexM
.head 7 -  Number: nSexF
.head 7 -  Number: nI
.head 7 -  Number: nFlags
.head 7 -  String: sRFID
.head 7 -  Number: _nScrID
.head 7 -  Number: nRolState
.head 7 -  String: sSlotNr
.head 6 +  Actions
.head 7 -  ! nFlags 1-not Empty Cage , 2 - RFID, 4 - with Service,  8 - with Alert ,16-Occupied
.head 7 +  If nRowCage <= 0
.head 8 -  Return FALSE
.head 7 -  Call SalTblSetContext( hWndForm, nRowCage )
.head 7 -  Set cCAGE = FE_GetInfo(nRowCage)
.head 7 -  Call _GetPositionID( nRowCage, oCage )
.head 7 -  Set nCageID = cCAGE.nID_Obj
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set nSexM = 0
.head 7 -  Set bOk = TRUE
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 +  If TRUE ! Prepare
.head 8 +  If not oSqlL4.bInit
.head 9 -  Call oSqlL4.SetSession( hSesionFEPopulate )
.head 9 -  Call oSqlL4.InitSqls( 6 )
.head 8 +  If not oSqlL4.bPrepare
.head 9 -  Set sSqlGruppe = "
select	g.GRUPPE_KEY, g.GRUPPE_BEZ, 
	g.PURPOSE_KEY, g.COLOR, count( b.BETT_KEY), g.UNIQ_NR, g.RFID, g.CageNName, @nullvalue(g.scrid_lock,0)
from 	sysadm.GRUPPE g, sysadm.BETT b
where	g.ID = :nCageID
     and	g.CANCELED = 'N'
     and	b.CAGE_ID = g.ID
     and	b.CANCELED = 'N'
group by	g.GRUPPE_KEY, g.GRUPPE_BEZ, 
	g.PURPOSE_KEY, g.COLOR, g.UNIQ_NR, g.Y_POS_LABEL, g.X_POS_LABEL, g.RFID, g.CageNName,g.scrid_lock
order by   g.Y_POS_LABEL, g.X_POS_LABEL
into	:sCageKey, :sDescr, :sPurposeKey, :nColor, :nBettAmount, :nUniq_Nr, :sRFID, :sSlotNr, :nScrAssign  "
.head 9 -  Set bOk = bOk and SqlPrepare( oSqlL4.hSql[0], sSqlGruppe )
.head 9 -  !
.head 9 -  Set bOk = bOk and SqlPrepare( oSqlL4.hSql[1], "select	l.GESCHL, f.LAST_SCR_ID,@nullvalue(rf.status,-1), count(f.Fall_key)
from 	 fall f
left join sysadm.roling_fall rf on (rf.fall_key=f.fall_key and rf.status=0)
left join le l on (f.le_id = l.LE_ID)
where
 		f.LAST_CAGE_ID = :nCageID
   and      f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
group by 1,2,3
into :sSex , :_nScrID, :nRolState, :nSexF" )
.head 9 -  !
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL4.hSql[2], "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.id = :nCageID
and l.cage_id = g.id
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
union
select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1 
from	sysadm.FALL f, sysadm.lst_erf l, sysadm.leistung lst
	where	f.EINRICHT_ID = :nEinrichtId
       and 	f.last_cage_id = :nCageID
       and	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 and lst.lst_key = l.lst_key 
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
   and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
order by 2 desc
into :sSrvKey, :nAlert ")
.head 9 -  !
.head 9 -  Set bOk = bOk and SqlPrepare( oSqlL4.hSql[3], "
select 
                    l.litter_id
                 from
                    fall f, relship_fall rf,
                    litter l
                 where
          	     1=1      
	and f.LAST_CAGE_ID = :nCageID
   	and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   	and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
                    and f.geschl = 'W'
	    and rf.einricht_id = f.einricht_id
                    and rf.fall_key = f.fall_key
	    and rf.fallrolle_key = 'PARENT'
                    and l.family_relship_id = rf.relship_id
	    and @NULLVALUE(l.miss,0) = 0
                    and ((l.geb_datum<=@NOW))
           and ( exists(select lc1.litter_id from litter_child lc1 where  lc1.litter_id=l.litter_id and lc1.fall_key is null and lc1.dead=0)
                      or not exists(select lc2.litter_id from litter_child lc2 where  lc2.litter_id=l.litter_id) )
    into :nAlert
")
.head 9 -  !
.head 9 -  Set sSqlGruppe = "
select	f.Fall_key, l.GESCHL
from 	 fall f
left join le l on (f.le_id = l.LE_ID)
where
 		f.LAST_CAGE_ID = :nCageID
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by f.LAST_BETT_KEY
into	  :nFallKeyOnBed, :sSex"
.head 9 -  Set bOk = bOk and SqlPrepare( oSqlL4.hSql[4], sSqlGruppe )
.head 9 +  If bOk 
.head 10 -  Set oSqlL4.bPrepare = TRUE
.head 7 +  If TRUE ! Execute
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[0])
.head 8 -  Set bOk = bOk and SqlFetchNext( oSqlL4.hSql[0], nFtch )
.head 7 +  If TRUE ! insert info Cage
.head 8 -  Call cCAGE.Init(  )
.head 8 -  Set cCAGE.sCage = sCageKey
.head 8 -  Set cCAGE.sDescr = sDescr
.head 8 -  Set cCAGE.sPurposeKey = sPurposeKey
.head 8 -  Set cCAGE.nColor = nColor
.head 8 -  Set cCAGE.nAmountPlace = nBettAmount
.head 8 -  Set cCAGE.nUniq_Nr= nUniq_Nr
.head 8 -  Set cCAGE.nLabelFlags = oSettingsCage.nFlags
.head 8 -  Set cCAGE.sSlot_Nr = sSlotNr
.head 8 +  If nScrAssign
.head 9 -  Call cCAGE.SetState( Cage_LOCKScreen )
.head 9 +  If nScrAssign = oCage.nScreenID 
.head 10 -  Call cCAGE.SetState( Cage_LOCKCurrScreen )
.head 9 +  Else
.head 10 -  Call cCAGE.SetState( CageIsOccupied )
.head 8 +  If sRFID
.head 9 -  Call cCAGE.SetState( CageWithRFID )
.head 9 -  Set cCAGE.sRFID = sRFID
.head 9 +  If hWnd_POC
.head 10 -  Set cCAGE.nPortPOS = frmPOC.IsCageOpen(sRFID)
.head 7 -  !
.head 7 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[1])
.head 7 +  While bOk and SqlFetchNext( oSqlL4.hSql[1], nFtch )
.head 8 +  If sSex = "M"
.head 9 -  Set cCAGE.nMales =nSexF 
.head 9 -  Set nSexM = nSexF
.head 8 +  Else
.head 9 -  Set cCAGE.nFemales =nSexF 
.head 8 +  If _nScrID != oCage.nScreenID
.head 9 -  Call cCAGE.SetState( CageIsOccupied )
.head 8 +  If nRolState = 0
.head 9 -  Call cCAGE.SetState( CageIsRoling )
.head 7 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[2])
.head 7 +  If SqlFetchNext( oSqlL4.hSql[2], nFtch )
.head 8 +  If nAlert = 1
.head 9 -  Call cCAGE.SetState( IsServise)
.head 8 +  Else If nAlert = 2
.head 9 -  Call cCAGE.SetState( IsAlert)
.head 7 -  Set nAlert = -1
.head 7 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[3])
.head 7 +  If SqlFetchNext( oSqlL4.hSql[3], nFtch )
.head 8 -  Call cCAGE.SetState( LitterInCage )
.head 7 -  Set cCAGE.nID_Obj = nCageID
.head 7 -  Call FE_SetInfo(nRowCage,cCAGE )
.head 7 -  !
.head 7 -  !
.head 7 +  If FALSE
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateC, "select	l.GESCHL, f.LAST_SCR_ID,@nullvalue(rf.status,-1), count(f.Fall_key)
from 	 fall f
left join sysadm.roling_fall rf on (rf.fall_key=f.fall_key and rf.status=0)
left join le l on (f.le_id = l.LE_ID)
where
 		f.LAST_CAGE_ID = :nCageID
   and      f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
group by 1,2,3
into :sSex , :_nScrID, :nRolState, :nSexF" )
.head 8 +  While bOk and SqlFetchNext( hSqlPopulateC, nFtch )
.head 9 +  If sSex = "M"
.head 10 -  Set cCAGE.nMales =nSexF 
.head 10 -  Set nSexM = nSexF
.head 9 +  Else
.head 10 -  Set cCAGE.nFemales =nSexF 
.head 9 +  If _nScrID != oCage.nScreenID
.head 10 -  Call cCAGE.SetState( CageIsOccupied )
.head 9 +  If nRolState = 0
.head 10 -  Call cCAGE.SetState( CageIsRoling )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulateC, "select lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1
from sysadm.gruppe g, sysadm.lst_erf l, sysadm.leistung lst
where g.id = :nCageID
and l.cage_id = g.id
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
union
select	lst.lst_key, @NULLVALUE(max(lst.isalert),0)+1 
from	sysadm.FALL f, sysadm.lst_erf l, sysadm.leistung lst
	where	f.EINRICHT_ID = :nEinrichtId
       and 	f.last_cage_id = :nCageID
       and	f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
       and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
 and lst.lst_key = l.lst_key 
 and lst.tarif_key = l.tarif_key
 and lst.einricht_id=l.einricht_id
   and l.fall_key = f.fall_key
and l.done != 1
and @NULLVALUE(l.storniert, 'N') = 'N'
and l.lst_erf_von<=@now
group by 1
order by 2 desc
into :sSrvKey, :nAlert ")
.head 8 +  If SqlFetchNext( hSqlPopulateC, nFtch )
.head 9 +  If nAlert = 1
.head 10 -  Call cCAGE.SetState( IsServise)
.head 9 +  Else If nAlert = 2
.head 10 -  Call cCAGE.SetState( IsAlert)
.head 8 -  !
.head 8 -  Set nAlert = -1
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateC, "
select 
                    l.litter_id
                 from
                    fall f, relship_fall rf,
                    litter l
                 where
          	     1=1      
	and f.LAST_CAGE_ID = :nCageID
   	and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   	and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
                    and f.geschl = 'W'
	    and rf.einricht_id = f.einricht_id
                    and rf.fall_key = f.fall_key
	    and rf.fallrolle_key = 'PARENT'
                    and l.family_relship_id = rf.relship_id
	    and @NULLVALUE(l.miss,0) = 0
                    and ((l.geb_datum<=@NOW))
           and ( exists(select lc1.litter_id from litter_child lc1 where  lc1.litter_id=l.litter_id and lc1.fall_key is null and lc1.dead=0)
                      or not exists(select lc2.litter_id from litter_child lc2 where  lc2.litter_id=l.litter_id) )
    into :nAlert
")
.head 8 +  If SqlFetchNext( hSqlPopulateC, nFtch )
.head 9 -  Call cCAGE.SetState( LitterInCage )
.head 8 -  Set cCAGE.nID_Obj = nCageID
.head 8 -  Call FE_SetInfo(nRowCage,cCAGE )
.head 7 -  !
.head 7 -  !
.head 7 -  Call UnselectChild(nRowCage)
.head 7 -  Call MTblDeleteDescRows( hWndForm, nRowCage, TBL_Adjust  )
.head 7 +  If bPopulateChildren and not cCAGE.GetState( CageIsOccupied  ) and cCAGE.GetState( CageIsFull  )
.head 8 -  Call MTblExpandRow( hWndForm, nRowCage, MTM_ExpandRow )
.head 8 +  If FALSE
.head 9 -  Set sSqlGruppe = "
select	f.Fall_key, l.GESCHL
from 	 fall f
left join le l on (f.le_id = l.LE_ID)
where
 		f.LAST_CAGE_ID = :nCageID
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by f.LAST_BETT_KEY
into	  :nFallKeyOnBed, :sSex"
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateC, sSqlGruppe )
.head 8 -  Set sStatusTextG = 'Populate: ' || cCAGE.sVal[0]
.head 8 -  Call SalStatusSetText( hWndForm, sStatusTextG )
.head 8 -  Set nSexM=0
.head 8 -  Set nSexF=0
.head 8 -  Set bOk = bOk and SqlExecute( oSqlL4.hSql[4] )
.head 8 +  While bOk and SqlFetchNext( oSqlL4.hSql[4], nFtch )
.head 9 -  Set nRow = FE_NewRow(nRowCage)
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Set colIDObject = nFallKeyOnBed
.head 9 +  If sSex ='M'
.head 10 -  Set nSexM=nSexM+1
.head 9 +  Else
.head 10 -  Set nSexF=nSexF+1
.head 8 -  Set nRow = MTblGetFirstChildRow( hWndForm, nRowCage )
.head 8 +  While nRow != TBL_Error
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Call PopulateBett( nRow )
.head 9 -  Set nRow = MTblGetNextChildRow( hWndForm, nRow )
.head 8 -  Call MTblAutoSizeRows( hWndForm, MTASR_ALLROWS | MTASR_HIDDENROWS )
.head 7 +  Else
.head 8 +  If TRUE
.head 9 -  Call cPos.Clear(  )
.head 9 -  Set cPos.sLabel = "Hide"
.head 9 -  Set cPos.nID_Obj = -100
.head 9 -  Set cPos.nOrder = -100
.head 9 -  Set nRow = FindObject(nRowCage, -100 )
.head 9 +  If nRow = -1
.head 10 -  Set nRow = FE_NewRow(nRowCage)
.head 9 -  Call FE_SetInfo(nRow,cPos )
.head 7 -  ! Call SqlCommit(hSqlPopulateC)
.head 7 -  !
.head 7 -  Call VisWaitCursor(FALSE)
.head 7 -  Return bOk
.head 5 +  Function: PopulateBett
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowBett
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: cPos
.head 8 -  Class: cFERowBett
.head 7 -  Number: nFallKey
.head 7 -  Date/Time: dtGetTime
.head 7 -  String: sSQL
.head 7 -  Sql Handle: hSqlSel
.head 7 -  Number: nFtch
.head 7 -  String: sBettKey
.head 7 -  String: sStrain
.head 7 -  String: sSV_Nr
.head 7 -  String: sSex
.head 7 -  String: sSexDescr
.head 7 -  String: sPhenoType
.head 7 -  String: sLE_Info
.head 7 -  String: sColor
.head 7 -  String: sBatch
.head 7 -  String: sGenoType
.head 7 -  String: sForeignID
.head 7 -  Number: nStrainColor
.head 7 -  Date/Time: dtGebDatum
.head 7 -  Date/Time: dtTodDatum
.head 7 -  Boolean: bPlugged
.head 7 -  Boolean: bOk
.head 7 -  Number: nFlags
.head 7 -  Number: nAlert
.head 7 -  String: sEarTags
.head 7 -  Number: nPosID
.head 7 -  String: sExpKey
.head 6 +  Actions
.head 7 +  If nRowBett <= 0
.head 8 -  Return FALSE
.head 7 -  Call SalTblSetContext( hWndForm, nRowBett )
.head 7 -  Call VisWaitCursor(TRUE)
.head 7 -  Set nFallKey = colIDObject
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set bOk = TRUE
.head 7 -  Set nFlags = 0
.head 7 -  Call cPos.Init(  )
.head 7 +  If TRUE ! first Prepare sql statements
.head 8 +  If not oSqlL5.bInit
.head 9 -  Call oSqlL5.SetSession( hSesionFEPopulate )
.head 9 -  Call oSqlL5.InitSqls( 6 )
.head 8 +  If not oSqlL5.bPrepare
.head 9 -  ! Chech Plugged
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL5.hSql[0], "select * from relship_fall
 where fall_key=:nFallKey and plugged is not null")
.head 9 -  ! check Plan Movement
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL5.hSql[1], "select * from BEWEGUNG_PLAN
 where 	EINRICHT_ID = :nEinrichtId and fall_key=:nFallKey")
.head 9 -  ! check litter
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL5.hSql[2], "select  *
from  sysadm.relship_fall rf, sysadm.litter l, sysadm.Fall F
where  rf.EINRICHT_ID = :nEinrichtId
and rf.fall_key = :nFallKey
and rf.fallrolle_key = 'PARENT'
and rf.EINRICHT_ID = f.EINRICHT_ID
and rf.fall_key=f.fall_key
and f.geschl='W'				
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0
				
and @now >= @NULLVALUE(l.geb_datum, 12-31-2199)

and (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id)) ")
.head 9 -  ! Check Alerts
.head 9 -  Set sSQL = "select  @NULLVALUE(max(lst.isAlert), 0)+1
from  sysadm.LST_ERF l, sysadm.leistung lst
where  l.FALL_KEY= :nFallKey
and	l.done= 0
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and @NULLVALUE(l.storniert, 'N') = 'N'
and 	l.LST_ERF_VON<@now
group by lst.lst_key
order by 1 desc
into :nAlert "
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL5.hSql[3], sSQL)
.head 9 -  !
.head 9 -  ! Set sSQL = "
select	f.LAST_BETT_KEY,  f.name1,
 	s.strain_key,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,g.geschl_abr,
	l.PHENOTYPE, l.INFO, l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR, f.pos_id, fe.experiment_key
from 	 fall f
left join fall_experiment fe on (fe.einricht_id=f.einricht_id and fe.fall_key=f.fall_key and start_date < @now and @nullvalue(end_date ,@now + 36) > @now),
 LE l
join geschlecht g on (g.geschl_key= l.geschl), STRAIN s
where
 		f.fall_key=:nFallKey
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
    and      f.le_id = l.LE_ID
    and	s.ID = l.id_strain
order 	by f.LAST_BETT_KEY
into	 :sBettKey, :sEarTags, 
	:sStrain, 
	:dtGebDatum, :dtTodDatum,
	:sSV_Nr,  :sSex, :sSexDescr,
	:sPhenoType,:sLE_Info, :sColor, :sBatch, :sForeignID,
	:sGenoType, :nStrainColor, :nPosID,:sExpKey "
.head 9 -  Set sSQL = "
select	f.LAST_BETT_KEY,  f.name1,
 	s.strain_key,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,g.geschl_abr,
	l.PHENOTYPE, l.INFO, l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR, f.pos_id, fe.experiment_key
from 	 fall f
join LE l on (l.LE_ID = f.le_id)
join geschlecht g on (g.geschl_key= l.geschl)
join  STRAIN s on (s.ID = l.id_strain)
left join fall_experiment fe on (fe.einricht_id=f.einricht_id and fe.fall_key=f.fall_key and start_date < @now and @nullvalue(end_date ,@now + 36) > @now)
where
 		f.fall_key=:nFallKey
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
order 	by f.LAST_BETT_KEY
into	 :sBettKey, :sEarTags, 
	:sStrain, 
	:dtGebDatum, :dtTodDatum,
	:sSV_Nr,  :sSex, :sSexDescr,
	:sPhenoType,:sLE_Info, :sColor, :sBatch, :sForeignID,
	:sGenoType, :nStrainColor, :nPosID,:sExpKey "
.head 9 -  Set bOk = bOk and SqlPrepare(oSqlL5.hSql[4], sSQL)
.head 9 +  If bOk 
.head 10 -  Set oSqlL5.bPrepare = TRUE
.head 7 +  If TRUE ! Fetch data
.head 8 -  Set bOk = bOk and SqlExecute( oSqlL5.hSql[0] )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext( oSqlL5.hSql[0], nFtch )
.head 10 -  Call cPos.SetState( AnimalIsPlugged  )
.head 8 -  Set bOk = bOk and SqlExecute( oSqlL5.hSql[1] )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext( oSqlL5.hSql[1], nFtch )
.head 10 -  Call cPos.SetState( AnimalInPlanBew )
.head 8 -  Set bOk = bOk and SqlExecute( oSqlL5.hSql[2] )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext( oSqlL5.hSql[2] , nFtch )
.head 10 -  Call cPos.SetState( AnimalIsLitter  )
.head 8 -  Set nAlert = 0
.head 8 -  Set bOk = bOk and SqlExecute( oSqlL5.hSql[3] )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext(oSqlL5.hSql[3],nFtch )
.head 10 +  If nAlert = 1
.head 11 -  Call cPos.SetState( IsServise  )
.head 10 +  Else If nAlert = 2
.head 11 -  Call cPos.SetState( IsAlert  )
.head 8 -  Set bOk = bOk and SqlExecute( oSqlL5.hSql[4] )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext(oSqlL5.hSql[4], nFtch)
.head 10 +  If TRUE ! info animal
.head 11 -  Set cPos.sBett = sBettKey
.head 11 -  Set cPos.sSex = sSex
.head 11 -  Set cPos.sStrain = sStrain
.head 11 -  Set cPos.sEarTag = sEarTags
.head 11 -  Set cPos.sBatch = sBatch
.head 11 -  Set cPos.sForeignID = sForeignID
.head 11 -  Set cPos.sSV_Nr = sSV_Nr
.head 11 -  Set cPos.sPhenoType = sPhenoType
.head 11 -  Set cPos.sGenoType = sGenoType
.head 11 -  Set cPos.nID_Obj = nFallKey
.head 11 -  Set cPos.nLabelFlags = oSettingsBett.nFlags
.head 11 -  Set cPos.sSexDescr = sSexDescr 
.head 11 -  Set cPos.sLE_Info = sLE_Info
.head 11 -  Set cPos.dtGebDatum = dtGebDatum
.head 11 -  Set cPos.nPosID = nPosID
.head 11 -  Set cPos.sExperiment = sExpKey
.head 11 +  If (dtTodDatum And dtTodDatum <= dtGetTime)
.head 12 -  Call cPos.SetState( AnimalIsDead  )
.head 11 +  If oHandleSelect.RowIsSelected(GetUniqRowID( nRowBett ))
.head 12 -  Set cPos.nCheckRow = 1
.head 10 -  Call FE_SetInfo(nRowBett,cPos )
.head 8 -  ! Call SqlCommit( oSqlL5.hSql[4] )
.head 7 +  ! If TRUE
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateP, "select * from relship_fall
 where fall_key=:nFallKey and plugged is not null" )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext( hSqlPopulateP, nFtch )
.head 10 -  Call cPos.SetState( AnimalIsPlugged  )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateP, "select * from BEWEGUNG_PLAN
 where 	EINRICHT_ID = :nEinrichtId and fall_key=:nFallKey" )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext( hSqlPopulateP, nFtch )
.head 10 -  Call cPos.SetState( AnimalInPlanBew )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateP, "select  *
from  sysadm.relship_fall rf, sysadm.litter l, sysadm.Fall F
where  rf.EINRICHT_ID = :nEinrichtId
and rf.fall_key = :nFallKey
and rf.fallrolle_key = 'PARENT'
and rf.EINRICHT_ID = f.EINRICHT_ID
and rf.fall_key=f.fall_key
and f.geschl='W'				
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0
				
and @now >= @NULLVALUE(l.geb_datum, 12-31-2199)

and (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id)) " )
.head 8 +  If bOk
.head 9 +  If SqlFetchNext( hSqlPopulateP, nFtch )
.head 10 -  Call cPos.SetState( AnimalIsLitter  )
.head 8 -  Set nAlert = 0
.head 8 -  Set sSQL = "select  @NULLVALUE(max(lst.isAlert), 0)+1
from  sysadm.LST_ERF l, sysadm.leistung lst
where  l.FALL_KEY= :nFallKey
and	l.done= 0
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and @NULLVALUE(l.storniert, 'N') = 'N'
and 	l.LST_ERF_VON<@now
group by lst.lst_key
order by 1 desc
into :nAlert "
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlPopulateP, sSQL )
.head 8 -  Set bOk = bOk and SqlFetchNext(hSqlPopulateP,nFtch )
.head 8 +  If nAlert = 1
.head 9 -  ! Set nFlags = nFlags + 16
.head 9 -  Call cPos.SetState( IsServise  )
.head 8 +  Else If nAlert = 2
.head 9 -  ! Set nFlags = nFlags + 8
.head 9 -  Call cPos.SetState( IsAlert  )
.head 8 -  Set sSQL = "
select	f.LAST_BETT_KEY,  f.name1,
 	s.strain_key,
	l.GEB_DATUM, l.TOD_DATUM,
	l.SV_NR,l.GESCHL,g.geschl_abr,
	l.PHENOTYPE, l.INFO, l.COLOR, l.batch, f.geburtsname,
		s.MUTATION1||' '|| l.GENOTYPE ||','|| s.MUTATION2||' '|| l.GENOTYPE2 ||','
	|| s.MUTATION3 ||' '|| l.GENOTYPE3 ||','|| s.MUTATION4 ||' '||l.GENOTYPE4,
	s.STRAIN_COLOR, f.pos_id
from 	 fall f, LE l
join geschlecht g on (g.geschl_key= l.geschl), STRAIN s
where
 		f.fall_key=:nFallKey
   and       f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
    and      f.le_id = l.LE_ID
    and	s.ID = l.id_strain
order 	by f.LAST_BETT_KEY
into	 :sBettKey, :sEarTags, 
	:sStrain, 
	:dtGebDatum, :dtTodDatum,
	:sSV_Nr,  :sSex, :sSexDescr,
	:sPhenoType,:sLE_Info, :sColor, :sBatch, :sForeignID,
	:sGenoType, :nStrainColor, :nPosID "
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlPopulateP, sSQL )
.head 8 +  If SqlFetchNext(hSqlPopulateP, nFtch)
.head 9 +  If TRUE ! info animal
.head 10 -  Set cPos.sBett = sBettKey
.head 10 -  Set cPos.sSex = sSex
.head 10 -  Set cPos.sStrain = sStrain
.head 10 -  Set cPos.sEarTag = sEarTags
.head 10 -  Set cPos.sBatch = sBatch
.head 10 -  Set cPos.sForeignID = sForeignID
.head 10 -  Set cPos.sSV_Nr = sSV_Nr
.head 10 -  Set cPos.sPhenoType = sPhenoType
.head 10 -  Set cPos.sGenoType = sGenoType
.head 10 -  Set cPos.nID_Obj = nFallKey
.head 10 -  Set cPos.nLabelFlags = oSettingsBett.nFlags
.head 10 -  Set cPos.sSexDescr = sSexDescr 
.head 10 -  Set cPos.sLE_Info = sLE_Info
.head 10 -  Set cPos.dtGebDatum = dtGebDatum
.head 10 -  Set cPos.nPosID = nPosID
.head 10 +  If (dtTodDatum And dtTodDatum <= dtGetTime)
.head 11 -  Call cPos.SetState( AnimalIsDead  )
.head 10 +  If oHandleSelect.RowIsSelected(GetUniqRowID( nRowBett ))
.head 11 -  Set cPos.nCheckRow = 1
.head 9 +  ! If TRUE
.head 10 +  If nFlags &1
.head 11 -  Set cPos.sLabel = "* "
.head 10 +  If oSettingsBett.nFlags&1
.head 11 -  Set cPos.sLabel = cPos.sLabel || '('||sBettKey||')'
.head 10 +  If nFallKey and oSettingsBett.nFlags&2
.head 11 -  Set cPos.sLabel = cPos.sLabel || '-'
.head 10 +  If (dtTodDatum And dtTodDatum <= dtGetTime) and oSettingsBett.nFlags&4
.head 11 -  Set cPos.sLabel = cPos.sLabel || 'K '
.head 11 -  Set nFlags = nFlags + 2
.head 10 +  If nFallKey and oSettingsBett.nFlags&2
.head 11 -  Set cPos.sLabel = cPos.sLabel || '{' || StrX( nFallKey ) || '} '
.head 10 +  If oSettingsBett.nFlags&8
.head 11 -  Set cPos.sLabel = cPos.sLabel || sForeignID
.head 10 +  If oSettingsBett.nFlags&16
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel || sStrain
.head 10 +  ! If oSettingsBett.nFlags&32 and IsFallHavePlanBew( nFallKeyOnBed )
.head 11 -  Set cPos.sLabel = cPos.sLabel || ', (PB) '
.head 10 +  If oSettingsBett.nFlags&64
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel || sSV_Nr
.head 10 +  If oSettingsBett.nFlags&128
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel  || sSexDescr
.head 10 +  If oSettingsBett.nFlags&256
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel  || SalFmtFormatDateTime( dtGebDatum, 'dd.MM.yyyy')
.head 10 +  If oSettingsBett.nFlags&512
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel  || sBatch
.head 10 +  If oSettingsBett.nFlags&1024
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel || sPhenoType
.head 10 +  If oSettingsBett.nFlags&2048
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel || sGenoType
.head 10 +  If oSettingsBett.nFlags&4196
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel  || sColor
.head 10 +  If oSettingsBett.nFlags&8192
.head 11 +  If cPos.sLabel
.head 12 -  Set cPos.sLabel = cPos.sLabel || ' ,'
.head 11 -  Set cPos.sLabel = cPos.sLabel || ' HS: ' || StrX( HelStat_Get4Fall( nFallKey, dtGetTime ) )
.head 10 +  If oSettingsBett.nFlags&16384 and sLE_Info
.head 11 -  Set cPos.sLabel = cPos.sLabel || ' *'
.head 9 -  Call FE_SetInfo(nRowBett,cPos )
.head 9 -  ! Call ReAssignPic(nRowBett)
.head 8 -  Call SqlCommit( hSqlPopulateP )
.head 7 -  Call VisWaitCursor(FALSE)
.head 5 +  Function: PopulateRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oData
.head 8 -  Class: cPositionData
.head 7 -  Number: nFlags
.head 7 -  Number: nRowFlags
.head 6 +  Actions
.head 7 -  ! Call MTblLockPaint( hWndForm )
.head 7 -  Set bAutoSize = TRUE
.head 7 +  If not MTblQueryRowFlags( hWndForm, nRow, MTBL_ROW_ISEXPANDED )
.head 8 +  Select Case MTblGetRowLevel( hWndForm, nRow )
.head 9 +  Case KHEL_Einrichtung
.head 10 -  Call PopulateInstitute()
.head 10 -  Break
.head 9 +  Case KHEL_Abteilung
.head 10 -  Call PopulateWorkGroup(nRow,TRUE)
.head 10 -  Break
.head 9 +  Case KHEL_Station
.head 10 -  Call PopulateRack(nRow,TRUE)
.head 10 +  ! If hWndRack2DView and VisWinIsWindow(hWndRack2DView) 
.head 11 -  Call SalSendMsg(hWndRack2DView, AM_CloseAllCages, 0, 0)
.head 11 -  Call SalHideWindow(hWndRack2DView)
.head 10 +  ! If hWndRack2DViewVirt and VisWinIsWindow(hWndRack2DViewVirt) 
.head 11 -  Call SalSendMsg(hWndRack2DViewVirt, AM_CloseAllCages, 0, 0)
.head 11 -  Call SalHideWindow(hWndRack2DViewVirt)
.head 10 -  Break
.head 9 +  Case KHEL_Gruppe
.head 10 -  Call PopulateCage(nRow,TRUE)
.head 10 -  Break
.head 9 +  Case KHEL_Bett
.head 10 -  Call PopulateBett(nRow)
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 8 -  Call MTblExpandRow( hWndForm, nRow, MTM_ExpandRow )
.head 7 +  Else
.head 8 +  If MTblGetRowLevel( hWndForm, nRow ) = KHEL_Gruppe
.head 9 -  Call CloseCageByRow(nRow)
.head 8 +  Else
.head 9 -  Call CloseAllCagesOnCollapse(nRow)
.head 9 -  Call MTblCollapseRow( hWndForm, nRow, MTM_CollapseRow )
.head 9 -  Call MTblSetRowFlags( hWndForm, nRow, MTBL_ROW_ISEXPANDED, FALSE, MTSRF_REDRAW )
.head 7 -  Set bAutoSize = FALSE
.head 7 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 7 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 7 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 7 -  Call SetSizeTree()
.head 7 -  ! Call MTblUnlockPaint( hWndForm )
.head 7 -  Call SalInvalidateWindow( hWndForm )
.head 5 +  Function: RepopulateWorkgroup
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowW
.head 7 -  Number: nRowDel
.head 7 -  Number: nChildObj[*]
.head 7 -  Number: nCount
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nI
.head 7 -  Number: nFtch
.head 7 -  String: sSql2Get_StatKey
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set dtGetTime = GetTime4Refresh()
.head 7 -  Set sSql2Get_StatKey = "
select	s.ID,@nullvalue(t.top,99999)

  from screen_rack a
join user_rack u1 on (u1.rack_id=a.rack_id and u1.user_id=:nUserId)
left join tree t on (t.user_id=:nUserId and t.id_parent=a.scr_id and id_child=a.rack_id)
join gruppe g on (g.rack_id=a.rack_id  and 	g.CANCELED = 'N')
join station s on (s.id=a.rack_id and s.CANCELED='N')

where	a.scr_id = :nID and s.id=:nChildObj[nI]
   and	(a.BIS_DATUM is NULL or a.BIS_DATUM >= :dtGetTime)
   and	(a.VON_DATUM is NULL or a.VON_DATUM <= :dtGetTime)
 
 "
.head 7 -  Set sSql2Get_StatKey = sSql2Get_StatKey || "
group by	s.ID, t.top
order by 2
"
.head 7 -  Set nRowW = FindObject( nRoot , nID )
.head 7 +  If nRowW != -1 
.head 8 -  Set nCount = EnumChildren( nRowW, nChildObj )
.head 8 -  Set nI = 0
.head 8 -  Set bOk = SqlPrepare(hSqlPopulateW, sSql2Get_StatKey)
.head 8 +  While nI < nCount and bOk
.head 9 -  Set bOk = SqlExecute(hSqlPopulateW)
.head 9 +  If bOk
.head 10 +  If not SqlFetchNext(hSqlPopulateW, nFtch)
.head 11 -  Call FE_DelRow(nRowW, nChildObj[nI])
.head 9 -  Set nI = nI + 1
.head 8 -  Call SqlCommit(hSqlPopulateW)
.head 8 +  If bOk
.head 9 -  Call PopulateWorkGroup( nRowW, TRUE )
.head 5 +  Function: RepopulateRack
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowW
.head 7 -  Number: nRowR
.head 7 -  Number: nChildObj[*]
.head 7 -  Number: nCount
.head 7 -  Number: nScrID
.head 7 -  Date/Time: dtGetTime
.head 7 -  Number: nI
.head 7 -  Number: nFtch
.head 7 -  String: sSql2Get_StatKey
.head 7 -  String: sSql
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  !
.head 7 -  Set sSql= "select a.SCR_ID from screen_rack a
join user_rack u1 on (u1.rack_id=a.rack_id and u1.user_id=:nUserId)
join station s on (s.id=a.rack_id and s.CANCELED='N')
where a.rack_id=:nID 
into :nScrID "
.head 7 +  If SqlPrepareAndExecute( hSqlGetInfo , sSql )
.head 8 +  While SqlFetchNext( hSqlGetInfo, nFtch )
.head 9 -  Set nRowW = FindObject( nRoot, nScrID ) 
.head 9 +  If nRowW != -1
.head 10 -  Set nRowR = FindObject( nRowW, nID ) 
.head 10 +  If nRowR = -1
.head 11 -  Set nRowR = FE_NewRow( nRowW )
.head 11 -  Call SalTblSetContext( hWndForm, nRowR )
.head 11 -  Set colOrder = 99999
.head 10 -  Call SalTblSetContext( hWndForm, nRowR )
.head 10 -  Set colIDObject = nID
.head 10 -  Call PopulateRack( nRowR, TRUE )
.head 7 -  !
.head 5 -  !
.head 5 +  Function: Start
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowWG
.head 7 -  Number: nRowRack
.head 7 -  Number: nCountW
.head 7 -  Number: nCountR
.head 7 -  Number: nI
.head 7 -  Number: nFlags
.head 7 -  Number: nRowFlags
.head 6 +  Actions
.head 7 +  If hWndStartInfoDlg And VisWinIsWindow( hWndStartInfoDlg )
.head 8 -  Call SalDestroyWindow( hWndStartInfoDlg )
.head 8 -  Set hWndStartInfoDlg = hWndNULL
.head 7 -  Call PopulateInstitute()
.head 7 -  Set nRowWG = MTblGetFirstChildRow( hWndForm, nRoot )
.head 7 -  Set nCountW = MTblGetChildRowCount( hWndForm, nRoot )
.head 7 +  If nCountW > 0 
.head 8 -  Call dlgProgress.Init( nCountW, D_GetMessageStatic(5009) )
.head 7 +  While nRowWG != TBL_Error
.head 8 +  If hWndProgress
.head 9 -  Call dlgProgress.Next(  )
.head 8 -  Call PopulateWorkGroup(nRowWG,TRUE)
.head 8 -  Set nRowRack = MTblGetFirstChildRow( hWndForm, nRowWG )
.head 8 +  While nRowRack != TBL_Error
.head 9 -  Call PopulateRack(nRowRack,FALSE)
.head 9 -  Set nRowRack = MTblGetNextChildRow( hWndForm, nRowRack )
.head 8 -  Set nRowWG = MTblGetNextChildRow( hWndForm, nRowWG )
.head 7 -  Call MTblExpandRow( hWndForm, nRoot, MTM_ExpandRow )
.head 7 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 7 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 7 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 7 -  Call ActivateRow( nRoot )
.head 5 +  Function: ActivateSelectedItem
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sLab
.head 7 -  String: sSelectedAbtKey_Res
.head 7 -  String: sSelectedStatKey_Res
.head 6 +  Actions
.head 7 -  Set sSelectedAbtKey_Res = oPosition.sScreen
.head 7 -  Set sSelectedStatKey_Res = oPosition.sRack
.head 7 -  Set nSelectedRow = SalTblQueryContext ( hWndForm ) 
.head 7 -  Set nSelectedLevel = MTblGetRowLevel( hWndForm, nSelectedRow )
.head 7 -  Call ActivatePosition(  nSelectedRow )
.head 7 -  Call SalTblClearSelection( hWndForm )
.head 7 -  Call SalTblSetRowFlags ( hWndForm, nSelectedRow, ROW_Selected, TRUE )
.head 7 +  If not bFreezeRefreshToolbars
.head 8 -  Call Rack2DView_CheckState( FALSE )
.head 8 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 0, 0)
.head 8 +  If (nSelectedLevel = KHEL_Station) and ((oPosition.sScreen != sSelectedAbtKey_Res) or (oPosition.sRack != sSelectedStatKey_Res))
.head 9 -  Call SalSendMsg(hWndStar2000, AM_Automate, 0, SalHStringToNumber(oPosition.sScreen||";"||oPosition.sRack))
.head 8 +  If (nSelectedLevel = KHEL_Gruppe or nSelectedLevel = KHEL_Bett)
.head 9 -  Call SalSendMsg(hWndStar2000, AM_SetFocusDL, SalHStringToNumber(oPosition.sRack), SalHStringToNumber(oPosition.sCage))
.head 5 +  Function: ActivateRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nActivateRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nContextRow
.head 6 +  Actions
.head 7 -  Call SalTblSetFocusRow( hWndForm, nActivateRow )
.head 7 -  Set nContextRow = GetRowID( nRowSetCont )
.head 7 +  If nContextRow != nActivateRow 
.head 8 -  Call ReAssignPic(nContextRow)
.head 7 -  Call ReAssignPic(nActivateRow)
.head 7 -  Set nRowSetCont = GetUniqRowID( nActivateRow)
.head 7 -  Call SalTblSetContext( hWndForm, nActivateRow )
.head 7 -  Call ActivateSelectedItem()
.head 5 +  Function: ActivateUniqRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nActivateRowU
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return ActivateRow(GetRowID( nActivateRowU ))
.head 5 +  Function: Rack2DView_CheckState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bForceWindowCreation
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bShouldBeShown
.head 7 -  Boolean: bShouldBeCreated
.head 7 -  Boolean: bCreateAutomatically
.head 7 -  Boolean: bShowAutoSR
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sRefreshDate
.head 7 -  Number: nRefreshStatus
.head 6 +  Actions
.head 7 -  Set bCreateAutomatically = GalGetProfileBooleanX( "Rack 2D View", "Auto_Open", TRUE, sUserINIFileName )
.head 7 -  Set bShowAutoSR = GalGetProfileBooleanX( "Rack 2D View", "Auto_Show", TRUE, sUserINIFileName )
.head 7 +  If Not bCreateAutomatically And Not bForceWindowCreation 
.head 8 +  If CheckStatusObj(nSelectedRow, RackIsVirtual )
.head 9 +  If Not SalIsWindowVisible( hWndRack2DViewVirt )
.head 10 -  Return TRUE
.head 8 +  Else
.head 9 +  If Not SalIsWindowVisible( hWndRack2DView )
.head 10 -  Return TRUE
.head 7 -  Set bShouldBeShown = bForceWindowCreation Or ( nSelectedLevel >= KHEL_Station )
.head 7 -  Set bShouldBeCreated = bForceWindowCreation Or ( nSelectedLevel >= KHEL_Station )
.head 7 +  If Not bShouldBeShown
.head 8 +  If SalIsWindowVisible( hWndRack2DView )
.head 9 -  Call SalHideWindow( hWndRack2DView )
.head 8 -  ! For Virtual Rack!
.head 8 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 9 -  Call SalHideWindow( hWndRack2DViewVirt )
.head 7 +  Else
.head 8 +  If NOT bRackCreationInProcess
.head 9 -  Set bRackCreationInProcess = TRUE
.head 9 -  Set sScreenKey = oPosition.sScreen
.head 9 -  Set sRackKey = oPosition.sRack
.head 9 +  If bShouldBeCreated
.head 10 -  ! For Virtual Rack!
.head 10 +  If CheckStatusObj(nSelectedRow, RackIsVirtual )
.head 11 +  If hWndRack2DViewVirt = hWndNULL Or Not VisWinIsWindow( hWndRack2DViewVirt )
.head 12 -  Set hWndRack2DViewVirt = SalCreateWindow( frmKHE2DViewVirt, hWndStar2000)
.head 11 +  If bShouldBeShown And Not SalIsWindowVisible( hWndRack2DViewVirt ) and VisWinIsWindow( hWndRack2DViewVirt )
.head 12 +  If not frmKHE2DViewVirt.cRack2DLayoutManager.bNotShow and bShowAutoSR
.head 13 -  Call SalShowWindow( hWndRack2DViewVirt )
.head 12 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 12 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 13 -  ! Call Rack2DView_ReflectButtonsState( )
.head 10 +  Else
.head 11 +  If hWndRack2DView = hWndNULL Or Not VisWinIsWindow( hWndRack2DView )
.head 12 -  Set hWndRack2DView = SalCreateWindow( frmKHE2DView, hWndStar2000)
.head 11 +  If bShouldBeShown And Not SalIsWindowVisible( hWndRack2DView ) and VisWinIsWindow( hWndRack2DView )
.head 12 +  If not frmKHE2DView.cRack2DLayoutManager.bNotShow and bShowAutoSR
.head 13 -  Call SalShowWindow( hWndRack2DView )
.head 12 -  ! !!!! IB 21.01.2007 UNPRESS2D
.head 12 +  ! If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 13 -  Call Rack2DView_ReflectButtonsState( )
.head 9 -  ! refresh Data
.head 9 +  If sScreenKey And sRackKey 
.head 10 +  If CheckStatusObj(nSelectedRow, RackIsVirtual )
.head 11 +  If VisWinIsWindow( hWndRack2DViewVirt )
.head 12 +  If (SalIsWindowVisible( hWndRack2DViewVirt ) or frmKHE2DViewVirt.cRack2DLayoutManager.bNotShow)
.head 13 -  ! refresh Data
.head 13 +  If frmKHE2DViewVirt.cRack2DLayoutManager.sRack != sRackKey or frmKHE2DViewVirt.cRack2DLayoutManager.sScreen != sScreenKey 
.head 14 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 14 -  Call SalSendMsg(hWndRack2DViewVirt, AM_Refresh, AM_KHE_SetRefreshTime, SalHStringToNumber( sRefreshDate ))
.head 14 -  Set hWndStar2000.nLockCounter = 0
.head 14 -  Set nRefreshStatus = SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_FullRefresh,
					SalHStringToNumber( sScreenKey || ";" || sRackKey ) )
.head 14 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 15 -  ! Call Rack2DView_ReflectButtonsState( )
.head 13 +  Else
.head 14 -  Call Rack2DView_ReflectButtonsState( )
.head 10 +  Else
.head 11 +  If VisWinIsWindow( hWndRack2DView )
.head 12 +  If (SalIsWindowVisible( hWndRack2DView ) or frmKHE2DView.cRack2DLayoutManager.bNotShow) 
.head 13 -  ! refresh Data
.head 13 +  If frmKHE2DView.cRack2DLayoutManager.sRack != sRackKey or frmKHE2DView.cRack2DLayoutManager.sScreen != sScreenKey
.head 14 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 14 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, AM_KHE_SetRefreshTime, SalHStringToNumber( sRefreshDate ))
.head 14 -  Set hWndStar2000.nLockCounter = 0
.head 14 -  Set nRefreshStatus = SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_FullRefresh,
					SalHStringToNumber( sScreenKey || ";" || sRackKey ) )
.head 14 -  ! Set nRefreshStatus = SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
					SalHStringToNumber( sRefreshDate ) )
.head 14 +  If nRefreshStatus != RACK2D_AlreadyRefreshed
.head 15 -  Call Rack2DView_ReflectButtonsState( )
.head 13 +  Else
.head 14 -  Call Rack2DView_ReflectButtonsState()
.head 9 -  Set bRackCreationInProcess = FALSE
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_ReflectButtonsState
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRackRow
.head 7 -  Number: nCageRow
.head 7 -  FunctionalVar: oPosRack
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oCageRefresh
.head 8 -  Class: cFERowCage
.head 7 -  Boolean: bV_Rack
.head 7 -  Boolean: bExpanded
.head 7 -  String: sCageKey
.head 6 +  Actions
.head 7 +  If Not SalIsWindowVisible( hWndRack2DView ) and Not SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Return TRUE
.head 7 +  If nSelectedLevel < KHEL_Station
.head 8 -  Return TRUE
.head 7 +  Select Case nSelectedLevel
.head 8 +  Case KHEL_Station
.head 9 -  Set nRackRow = nSelectedRow
.head 9 -  Break
.head 8 +  Case KHEL_Gruppe
.head 9 -  ! Set nRackRow = GetParent( nSelectedRow )
.head 9 -  Set nRackRow = GetParent(GetRowID(oPosition.nActHandel ))
.head 9 -  Break
.head 8 +  Case KHEL_Bett
.head 9 -  ! Set nRackRow = GetParent( GetParent( nSelectedRow ) )
.head 9 -  Set nRackRow = GetParent(GetParent(GetRowID(oPosition.nActHandel )))
.head 9 -  Break
.head 7 -  !
.head 7 -  Call _GetPositionID( nRackRow, oPosRack )
.head 7 -  Set bV_Rack = CheckStatusObj( nRackRow, RackIsVirtual )
.head 7 -  Set nCageRow = MTblGetFirstChildRow( hWndForm, nRackRow )
.head 7 +  Loop
.head 8 +  If nCageRow = TBL_Error
.head 9 -  Break
.head 8 -  Set bExpanded = MTblQueryRowFlags( hWndForm, nCageRow, MTBL_ROW_ISEXPANDED )
.head 8 -  Set oCageRefresh = FE_GetInfo( nCageRow )
.head 8 -  Set sCageKey = oCageRefresh.GetSValue( "Cage" )
.head 8 +  If oPosRack.sScreen And oPosRack.sRack  And sCageKey
.head 9 +  If bV_Rack
.head 10 +  If SalIsWindowVisible( hWndRack2DViewVirt ) 
.head 11 -  Call SalSendMsg( hWndRack2DViewVirt, AM_SetState, bExpanded,
			SalHStringToNumber( oPosRack.sScreen || ";" || oPosRack.sRack || ";" || sCageKey ) )
.head 9 +  Else
.head 10 +  If SalIsWindowVisible( hWndRack2DView ) 
.head 11 -  Call SalSendMsg( hWndRack2DView, AM_SetState, bExpanded,
			SalHStringToNumber( oPosRack.sScreen || ";" || oPosRack.sRack || ";" || sCageKey ) )
.head 8 -  Set nCageRow = MTblGetNextChildRow( hWndForm, nCageRow )
.head 7 -  Return TRUE
.head 5 +  Function: Rack2DView_RefreshCageContents
.head 6 -  Description: Refreshes content for all cages in the 2D View
Dont have enough time to implement this only for changed cagesRACK2D_RefreshTimeChanged
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sCagesList
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sRefreshDate
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sRefreshDate ) )
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sCagesList ))
.head 7 +  If SalIsWindowVisible( hWndRack2DViewVirt )
.head 8 -  Call SalDateToStr( GetTime4Refresh( ), sRefreshDate )
.head 8 -  Call SalSendMsg(hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshTimeChanged, SalHStringToNumber( sRefreshDate ))
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sCagesList ))
.head 7 -  Return TRUE
.head 5 +  ! Function: Rack2DView_SetButtonState
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Number: hHandle
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Boolean: bExpanded
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sPlace
.head 6 +  Actions 
.head 7 -  Call GetPosition( hHandle, sScreenKey, sRackKey, sCageKey, sPlace )
.head 7 +  If sScreenKey And sRackKey And sCageKey
.head 8 +  If GetIsRackVirtual_ByHandle(hHandle)
.head 9 +  If nSelectedLevel = KHEL_Gruppe And SalIsWindowVisible( hWndRack2DViewVirt )
.head 10 -  Set bExpanded = KHE_IsExpanded( hHandle )
.head 10 -  ! set state
.head 10 -  Call SalSendMsg( hWndRack2DViewVirt, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 8 +  Else 
.head 9 +  If nSelectedLevel = KHEL_Gruppe And SalIsWindowVisible( hWndRack2DView )
.head 10 -  Set bExpanded = KHE_IsExpanded( hHandle )
.head 10 -  ! set state
.head 10 -  Call SalSendMsg( hWndRack2DView, AM_SetState, bExpanded,
			SalHStringToNumber( sScreenKey || ";" || sRackKey || ";" || sCageKey ) )
.head 7 -  Return TRUE
.head 5 +  ! Function: GetIsRackVirtual_ByHandle
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  Number: nCurrentRow
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Boolean: bV
.head 7 -  Number: nLevelLoc
.head 6 +  Actions 
.head 7 -  Set bV=FALSE
.head 7 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nCurrentRow )
.head 7 +  Select Case nLevelLoc
.head 8 +  Case KHEL_Abteilung
.head 9 -  Return FALSE
.head 9 -  Break 
.head 8 +  Case KHEL_Station
.head 9 -  Set bV=colFlags&2
.head 9 -  Break 
.head 8 +  Case KHEL_Gruppe
.head 9 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, nCurrentRow ) )
.head 9 -  Set bV=colFlags&2
.head 9 -  Call SalTblSetContext ( hWndForm, nCurrentRow )
.head 9 -  Break 
.head 8 +  Case KHEL_Bett
.head 9 -  Call SalTblSetContext ( hWndForm, MTblGetParentRow( hWndForm, MTblGetParentRow( hWndForm, nCurrentRow ) ) )
.head 9 -  Set bV=colFlags&2
.head 9 -  Call SalTblSetContext ( hWndForm, nCurrentRow )
.head 9 -  Break 
.head 7 -  Return bV
.head 5 +  Function: AddWonBettX
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Date/Time: dtGetTime
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  ! String: sBettLabel
.head 7 -  Sql Handle: hSql
.head 7 -  String: sSqlBtt
.head 7 -  Number: nFetch
.head 7 -  Number: hBett
.head 7 -  ! Number: hGruppe
.head 7 -  ! Number: nIndex
.head 7 -  Boolean: bOk
.head 7 -  ! Number: hAbt
.head 7 -  Number: nBettKey
.head 7 -  Number: nCageID
.head 6 +  Actions
.head 7 +  If not SqlCreateStatement( hSesionFE, hSql ) 
.head 8 -  Return ""
.head 7 +  If not sGrpKey
.head 8 -  Return sGrpKey
.head 7 +  If not dtGetTime
.head 8 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 -  Set sBettKey = "" 
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "select id from gruppe where einricht_id=:nEinrichtId and   STAT_KEY = :sStatKey and GRUPPE_KEY = :sGrpKey   into :nCageID  " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 7 +  ! If bPlanningMode
.head 8 -  ! Set sSqlBtt = "
select	 @VALUE( b.BETT_KEY)
from 	BETT b
where	b.EINRICHT_ID =" || StrX( nEinrichtId ) || "
   and	b.STAT_KEY = '" || sStatKey || "'
   and	b.GRUPPE_KEY = '" || sGrpKey || "'
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY
					and 	bew.EINRICHT_ID=b.EINRICHT_ID
  					 and       bew.GRUPPE_KEY = b.GRUPPE_KEY
					 and 	bew.BETT_KEY=b.BETT_KEY
   					
   					and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	bew.Fall_KEY = f.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
   and	not  exists ( select bl.BETT_KEY
				from 	 BETT_LOCKS bl
  				   where         bl.EINRICHT_ID =b.EINRICHT_ID
   					and	bl.STAT_KEY = b.STAT_KEY
   					and	bl.GRUPPE_KEY = b.GRUPPE_KEY
					and 		bl.BETT_KEY=b.BETT_KEY
   					and       bl.VON <=:dtGetTime
   					and       (bl.bis>:dtGetTime or bl.bis is null  ))
					
order by 1
into	 :nBettKey "


.head 8 -  Set sSqlBtt = "
select	 @VALUE( b.BETT_KEY)
from 	BETT b
where       b.cage_id = :nCageID
   and 	b.CANCELED = 'N'
   and	not  exists ( select bew.BETT_KEY
				from 	  BEWEGUNG bew, FALL f
  				   where         	bew.STAT_KEY = b.STAT_KEY
					and 	bew.pos_id=b.id
   				 	and	bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   					and       bew.bew_zeit <=:dtGetTime
   					and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
					and	f.Fall_KEY = bew.Fall_KEY
					and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   					and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J')
  and      not exists  ( select bl.pos_id from bett_locks bl
					where bl.pos_id=b.id
						and 	bl.VON <=:dtGetTime
   					and       (bl.bis>@now or bl.bis is null  )
)
		
order by 1
into	 :nBettKey "


.head 7 +  ! Else
.head 8 -  Set sSqlBtt = "select	  
	min(b.BETT_KEY)
from 	
	sysadm.BETT b left join sysadm.fall f on f.last_cage_id = b.cage_id and f.pos_id = b.id and f.geloescht = 'N' and f.ee_datum is null
where	
	b.CAGE_ID =:nCageID
 	and 	b.CANCELED = 'N'
	and f.fall_key is null

into	 :nBettKey "


.head 7 -  Set sSqlBtt = "select	  
	min(b.BETT_KEY)
from 	
	sysadm.BETT b left join sysadm.fall f on f.last_cage_id = b.cage_id and f.pos_id = b.id and f.geloescht = 'N' and f.ee_datum is null
where	
	b.CAGE_ID =:nCageID
 	and 	b.CANCELED = 'N'
	and f.fall_key is null

into	 :nBettKey "


.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, sSqlBtt )
.head 7 +  While bOk and SqlFetchNext( hSql, nFetch )
.head 8 -  Break
.head 7 -  Call SqlDisconnect( hSql )
.head 7 +  If nBettKey>0 and nBettKey != NUMBER_Null
.head 8 -  Set sBettKey = SalNumberToStrX( nBettKey, 0 )
.head 7 -  Return sBettKey
.head 5 +  Function: GetPlaceFormString
.head 6 -  Description: Get position data from string "Screen;Rack;Cage"
.head 6 +  Returns
.head 7 -  FunctionalVar:
.head 8 -  Class: cPositionData
.head 6 +  Parameters
.head 7 -  String: sPlaceString
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oCageData
.head 8 -  Class: cPositionData
.head 7 -  String: sValues[*]
.head 7 -  Number: nFtch
.head 6 +  Actions
.head 7 -  Call SalStrTokenize( sPlaceString, "", ";", sValues )
.head 7 -  Set oGetInfo.sScreen = sValues[0]
.head 7 -  Set oGetInfo.sRack = sValues[1]
.head 7 -  Set oGetInfo.sCage = sValues[2]
.head 7 +  If SqlPrepareAndExecute(hSqlGetInfo, "select distinct a.id , s.id , g.id  from abteilung a 
left join station s on (s.stat_key=:oGetInfo.sRack)
left join gruppe g on (g.rack_id=s.id  and g.gruppe_key=:oGetInfo.sCage)
where a.abt_key=:oGetInfo.sScreen
into :oGetInfo.nScreenID, :oGetInfo.nRackID, :oGetInfo.nCageID")
.head 8 -  Call SqlFetchNext( hSqlGetInfo, nFtch )
.head 8 -  Set oCageData.sScreen = oGetInfo.sScreen
.head 8 -  Set oCageData.nScreenID = oGetInfo.nScreenID
.head 8 -  Set oCageData.sRack = oGetInfo.sRack
.head 8 -  Set oCageData.nRackID = oGetInfo.nRackID
.head 8 -  Set oCageData.sCage = oGetInfo.sCage
.head 8 -  Set oCageData.nCageID = oGetInfo.nCageID
.head 7 -  ! If SqlExecute(hSqlGetInfo)
.head 7 +  ! If SqlPrepareAndExecute( hSqlPopulate, "select id from abteilung where abt_key=:sValues[0] into :oCageData.nScreenID " )
.head 8 -  Call SqlFetchNext( hSqlPopulate, nFtch )
.head 8 -  Set oCageData.sScreen = sValues[0]
.head 7 +  ! If SqlPrepareAndExecute( hSqlPopulate, "select rack_id, id  from gruppe where stat_key=:sValues[1] and gruppe_key=:sValues[2] into :oCageData.nRackID , :oCageData.nCageID " )
.head 8 -  Call SqlFetchNext( hSqlPopulate, nFtch )
.head 8 -  Set oCageData.sRack = sValues[1]
.head 8 -  Set oCageData.sCage = sValues[2]
.head 7 -  ! Call SqlCommit( hSqlGetInfo )
.head 7 -  Return oCageData
.head 5 +  Function: OpenRack
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowScreen
.head 7 -  Number: nRowRack
.head 7 -  Number: nRow
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  ! Find Screen
.head 7 -  Set bOk =FALSE
.head 7 +  If nScrID>0 and nRackID>0
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk
.head 8 -  Set nRowScreen = FindObject(nRoot,nScrID) 
.head 8 +  If nRowScreen = -1
.head 9 -  Call PopulateRow(nRoot)
.head 9 -  Set nRowScreen = FindObject(nRoot,nScrID) 
.head 9 +  If nRowScreen = -1
.head 10 -  Set bOk = FALSE
.head 7 +  If bOk and not MTblQueryRowFlags( hWndForm, nRoot, MTBL_ROW_ISEXPANDED )
.head 8 -  Call MTblExpandRow( hWndForm, nRoot, MTM_ExpandRow )
.head 7 -  ! Find Rack
.head 7 +  If bOk
.head 8 -  Set nRowRack = FindObject(nRowScreen,nRackID) 
.head 8 +  If nRowRack = -1
.head 9 -  Call PopulateRow(nRowScreen)
.head 9 -  Set nRowRack = FindObject(nRowScreen,nRackID) 
.head 9 +  If nRowRack = -1
.head 10 -  Set bOk = FALSE
.head 8 +  If bOk and not MTblQueryRowFlags( hWndForm, nRowScreen, MTBL_ROW_ISEXPANDED )
.head 9 -  Call MTblExpandRow( hWndForm, nRowScreen, MTM_ExpandRow )
.head 8 +  If bOk and nRowRack>0
.head 9 -  Call ActivateRow(nRowRack)
.head 5 +  Function: OpenCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowScreen
.head 7 -  Number: nRowRack
.head 7 -  Number: nRowCage
.head 7 -  Number: nRow
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oCageOpen
.head 8 -  Class: cPositionData
.head 7 -  Boolean: bOpened
.head 7 -  FunctionalVar: cCage
.head 8 -  Class: clsWFElement
.head 7 -  FunctionalVar: oCageRow
.head 8 -  Class: cFERow
.head 7 -  Number: nRowRackParent
.head 6 +  Actions
.head 7 -  ! Find Screen
.head 7 -  Set bOk =FALSE
.head 7 +  If nScrID>0 and nRackID>0 and nCageID>0
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk
.head 8 -  Set nRowScreen = FindObject(nRoot,nScrID) 
.head 8 +  If nRowScreen = -1
.head 9 -  Call PopulateRow(nRoot)
.head 9 -  Set nRowScreen = FindObject(nRoot,nScrID) 
.head 9 +  If nRowScreen = -1
.head 10 -  Set bOk = FALSE
.head 7 +  If bOk and not MTblQueryRowFlags( hWndForm, nRoot, MTBL_ROW_ISEXPANDED )
.head 8 -  Call MTblExpandRow( hWndForm, nRoot, MTM_ExpandRow )
.head 7 -  ! Find Rack
.head 7 +  If bOk
.head 8 -  Set nRowRack = FindObject(nRowScreen,nRackID) 
.head 8 +  If nRowRack = -1
.head 9 -  Call PopulateRow(nRowScreen)
.head 9 -  Set nRowRack = FindObject(nRowScreen,nRackID) 
.head 9 +  If nRowRack = -1
.head 10 -  Set bOk = FALSE
.head 8 +  If bOk and not MTblQueryRowFlags( hWndForm, nRowScreen, MTBL_ROW_ISEXPANDED )
.head 9 -  Call MTblExpandRow( hWndForm, nRowScreen, MTM_ExpandRow )
.head 7 -  ! Find Cage
.head 7 +  If bOk
.head 8 -  Call MTblExpandRow( hWndForm, nRowRack, MTM_ExpandRow )
.head 8 -  Set nRowCage = FindObject(nRowRack,nCageID) 
.head 8 +  If nRowCage = -1
.head 9 -  Set nRowCage = FE_NewRow(nRowRack)
.head 9 -  Set bOpened = FALSE
.head 8 +  Else
.head 9 -  Set bOpened = FALSE
.head 9 +  If MTblQueryRowFlags( hWndForm, nRowCage, MTBL_ROW_ISEXPANDED )
.head 10 -  Set bOpened = TRUE
.head 9 -  ! Call MTblCollapseRow( hWndForm, nRowCage, MTM_CollapseRow )
.head 8 -  Call SalTblSetContext( hWndForm, nRowCage )
.head 8 -  Set colIDObject = nCageID
.head 8 +  If bOpened
.head 9 -  Call PopulateCage(nRow,FALSE)
.head 8 +  Else
.head 9 -  ! Call PopulateCage(nRow,TRUE)
.head 9 -  Call PopulateRow(nRowCage)
.head 8 -  !
.head 8 -  Set oCageRow = FE_GetInfo( nRowCage )
.head 8 +  If not bOpened and not CheckStatusObj(nRowCage, CageIsOccupied )
.head 9 -  Call SalSendMsg(hWndStar2000, AM_AddCage, nRowCage, 0)
.head 9 -  Call _GetPositionID( nRowCage, oCageOpen )
.head 9 -  Call T_OpenCage( oCageOpen.nCageID, oCageOpen.nScreenID, 0 )
.head 9 +  If NOT CheckStatusObj(nRowCage, RackIsVirtual )
.head 10 +  If bDischargeDead 
.head 11 +  ! If bDeadInCage
.head 12 +  If nCountDead > -1
.head 13 +  If GalMessageBox( D_GetMessageStatic( 10033 ), D_GetMessageStatic( 11060 ) , MB_YesNo) =IDYES
.head 14 -  Set hTemp = nSelectedHandle
.head 14 +  While nCountDead > -1
.head 15 -  Set nSelectedHandle = nFallDeadHandle[nCountDead]
.head 15 -  Call MultiSelect(  )
.head 15 -  Set nCountDead = nCountDead -1
.head 14 -  Set nSelectedHandle = hTemp
.head 14 -  Call CullingAndDischarge(TRUE)
.head 14 -  Set nCountDead = -1
.head 13 +  Else 
.head 14 -  Call UnSelectAll(  )
.head 12 +  Else 
.head 13 +  If GalMessageBox( D_GetMessageStatic( 10033 ), D_GetMessageStatic( 11061) , MB_YesNo)  =IDYES
.head 14 -  Call CullingAndDischarge(TRUE)
.head 13 +  Else 
.head 14 -  Call UnSelectAll(  )
.head 11 -  Set nRowRackParent = GetParent( nRowCage )
.head 11 +  If SelectDeadAnimal(nRowCage) > 0 
.head 12 +  If GalMessageBox( D_GetMessageStatic( 10033 ), D_GetMessageStatic( 11061) , MB_YesNo)  =IDYES
.head 13 -  Call CullingAndDischarge(TRUE)
.head 13 +  If not CheckStatusObj(nRowCage, CageIsFull)
.head 14 -  Set nRowCage = nRowRackParent
.head 12 +  Else
.head 13 -  Call UnSelectAll(  )
.head 10 +  If bServicesOnOpenCage  and not bFreezeWorkFlow and nRowCage != nRowRackParent !   (NOT bPlanningMode)  and not bOpenCageFromWorkList 
.head 11 +  If SalStrUpperX( sAutoStartService ) = "ON" 
.head 12 -  Set cCage = SalObjCreateFromString("clsCageServices")
.head 12 -  Call cCage.Init( oCageOpen.sScreen||";"||oCageOpen.sRack||";"||oCageOpen.sCage )
.head 11 +  Else If SalStrUpperX( sAutoStartService ) = "ASK" 
.head 12 +  If GalMessageBox("Service Workflow" , "Perform services for cage " || RemoveLead0(  oCageOpen.sCage ) || " in rack " || RemoveLead0(oCageOpen.sRack) || " ?", MB_YesNo ) = IDYES
.head 13 -  Set cCage = SalObjCreateFromString("clsCageServices")
.head 13 -  Call cCage.Init(   oCageOpen.sScreen||";"||oCageOpen.sRack||";"||oCageOpen.sCage )
.head 11 +  Else
.head 12 -  Set cCage.bIsEmpty = TRUE
.head 11 -  ! Set bAutoShowTableSevices = FALSE
.head 10 +  Else
.head 11 -  Set cCage.bIsEmpty = TRUE
.head 10 -  Call SalPostMsg( hWndBreedingBook, AM_Breeding_OpenDL, oCageRow.GetNValue( "UniqNr" ), 0 )
.head 10 +  ! If bMoveToVirt and ((cCage = OBJ_Null) or cCage.bIsEmpty)
.head 11 +  If TempIsPossible(FALSE,0)
.head 12 -  If SalSendMsg( hWndKHE, AM_KHE_OpenTempCage, 0, 0 )
.head 12 -  Set hGrp = hCageInVirt
.head 12 -  Set hCageInVirt = 0
.head 10 +  If hWndRack2DViewVirt and SalIsWindowVisible( hWndRack2DViewVirt ) and bMoveToVirt and CheckStatusObj(nRowCage, CageIsFull)
.head 11 -  Set bNotNeedPrintCageCard = TRUE
.head 11 +  If MoveToVirt( oCageOpen.nCageID, KHEL_Gruppe )
.head 12 -  Set nRowCage = TBL_Error
.head 11 -  Set bNotNeedPrintCageCard = FALSE
.head 8 +  If nRowCage != TBL_Error
.head 9 -  Call ActivateRow(nRowCage)
.head 9 -  Set nRowCage = GetUniqRowID( nRowCage )
.head 7 -  Return nRowCage
.head 5 +  Function: CloseCageByRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowCloseCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowWithFocus
.head 7 -  Number: nUniqRowClose
.head 7 -  FunctionalVar: oCageClose
.head 8 -  Class: cPositionData
.head 7 -  Number: nPort
.head 7 -  Number: nNeedPrint
.head 7 -  FunctionalVar: cDistinct
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nRowB
.head 6 +  Actions
.head 7 +  If nRowCloseCage != -1
.head 8 +  If nRowCloseCage = nSelectedRow
.head 9 -  Set nRowWithFocus = GetUniqRowID( GetParent( nRowCloseCage ))
.head 8 +  Else
.head 9 -  Set nRowWithFocus = GetUniqRowID(nSelectedRow)
.head 9 +  If nSelectedLevel = KHEL_Bett
.head 10 +  If GetParent( nSelectedRow) = nRowCloseCage
.head 11 -  Set nRowWithFocus = GetUniqRowID(GetParent( nRowCloseCage ))
.head 10 +  Else If not RowIsChild(GetParent( nRowCloseCage),GetParent( nSelectedRow))
.head 11 -  Set nRowWithFocus = GetUniqRowID(GetParent( nRowCloseCage ))
.head 9 +  Else If nSelectedLevel = KHEL_Gruppe
.head 10 +  If not RowIsChild(GetParent( nRowCloseCage),nSelectedRow)
.head 11 -  Set nRowWithFocus = GetUniqRowID(GetParent( nRowCloseCage ))
.head 9 +  Else If nSelectedLevel = KHEL_Station and nSelectedRow!=GetParent( nRowCloseCage)
.head 10 -  Set nRowWithFocus = GetUniqRowID(GetParent( nRowCloseCage ))
.head 8 -  Set nUniqRowClose = GetUniqRowID( nRowCloseCage )
.head 8 -  Call _GetPositionID( nRowCloseCage, oCageClose )
.head 8 -  Call T_GetStateCage(oCageClose.nCageID,nPort, nNeedPrint )
.head 8 +  If nNeedPrint
.head 9 -  Call cDistinct.Init( oCageClose.sScreen, oCageClose.sRack, oCageClose.sCage )
.head 9 -  Set cCage[0] = cDistinct
.head 9 -  Call PrintCageCards( cCage, cDistinct )
.head 8 -  ! Found selected Row
.head 8 -  Set nRowB = MTblGetFirstChildRow( hWndForm, nRowCloseCage )
.head 8 +  Loop
.head 9 +  If nRowB = TBL_Error
.head 10 -  Break
.head 9 -  Call SalTblSetContext( hWndForm, nRowB )
.head 9 +  If colCheck = 1
.head 10 -  Call oHandleSelect.UnselectRow( GetUniqRowID(nRowB), colSVal2 )
.head 10 -  Set colCheck = 0
.head 9 -  Set nRowB = MTblGetNextChildRow( hWndForm, nRowB )
.head 8 -  Call SalTblSetContext( hWndForm, nRowCloseCage )
.head 8 -  !
.head 8 -  Call T_CloseCage( oCageClose.nCageID )
.head 8 -  Call SalSendMsg(hWndStar2000, AM_RemoveCage, nRowCloseCage, 0)
.head 8 +  If hWnd_POC
.head 9 +  If VisWinIsWindow ( hWnd_POC )
.head 10 -  Call frmPOC.CloseCageFromKHE( oCageClose.sScreen , oCageClose.sRack , oCageClose.sCage )
.head 8 -  Set nRowCloseCage = GetRowID( nUniqRowClose )
.head 8 +  If CheckStatusObj( nRowCloseCage, RackIsVirtual )
.head 9 +  If SalIsWindowVisible( hWndRack2DViewVirt ) 
.head 10 -  Call SalSendMsg( hWndRack2DViewVirt, AM_SetState, FALSE,
			SalHStringToNumber( oCageClose.sScreen || ";" || oCageClose.sRack || ";" || oCageClose.sCage  ) )
.head 8 +  Else
.head 9 -  ! If SalIsWindowVisible( hWndRack2DView ) 
.head 9 -  Call SalSendMsg( hWndRack2DView, AM_SetState, FALSE,
			SalHStringToNumber( oCageClose.sScreen || ";" || oCageClose.sRack || ";" || oCageClose.sCage ) )
.head 8 -  !
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 -  ! Call MTblLockPaint( hWndForm )
.head 8 +  If bShowOnlyOpenCages
.head 9 -  Call MTblDeleteDescRows( hWndForm, nRowCloseCage, TBL_NoAdjust )
.head 9 -  Call SalTblDeleteRow( hWndForm, nRowCloseCage, TBL_NoAdjust )
.head 9 -  ! Call MTblDeleteDescRows( hWndForm, nRowCloseCage, TBL_Adjust )
.head 9 -  ! Call SalTblDeleteRow( hWndForm, nRowCloseCage, TBL_Adjust )
.head 8 +  Else
.head 9 +  If MTblQueryRowFlags( hWndForm, nRowCloseCage, MTBL_ROW_ISEXPANDED )
.head 10 -  Call MTblCollapseRow( hWndForm, nRowCloseCage, MTM_CollapseRow )
.head 10 -  Call MTblSetRowFlags( hWndForm, nRowCloseCage, MTBL_ROW_ISEXPANDED, FALSE, MTSRF_REDRAW )
.head 8 -  Set bNeedActivateRow = TRUE
.head 8 +  If GetRowID( nRowWithFocus) != TBL_Error
.head 9 -  Call ActivateRow(GetRowID( nRowWithFocus) )
.head 8 -  Call SetSizeTree()
.head 8 -  ! Call MTblUnlockPaint( hWndForm )
.head 8 -  ! Call SalInvalidateWindow( hWndForm )
.head 5 +  Function: CloseCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowS
.head 7 -  Number: nRowR
.head 7 -  Number: nRowC
.head 7 -  Number: nRowB
.head 7 -  !
.head 6 +  Actions
.head 7 -  ! Set nRowWithFocus = nSelectedRow
.head 7 -  Set nRowS = -1
.head 7 -  Set nRowR = -1
.head 7 -  Set nRowC = -1
.head 7 -  Set nRowS = FindObject(nRoot,nScrID )
.head 7 +  If nRowS!=-1
.head 8 -  Set nRowR = FindObject(nRowS,nRackID )
.head 8 +  If nRowR!=-1
.head 9 -  Set nRowC = FindObject(nRowR,nCageID )
.head 7 -  Return CloseCageByRow(nRowC)
.head 5 +  Function: OpenCageByString
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sPosition
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oData
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set oData = GetPlaceFormString(sPosition)
.head 7 -  Return OpenCage(oData.nScreenID, oData.nRackID , oData.nCageID)
.head 5 +  Function: CloseCageByString
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sPosition
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oData
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set oData = GetPlaceFormString(sPosition)
.head 7 -  Return CloseCage(oData.nScreenID,oData.nRackID, oData.nCageID)
.head 5 +  Function: CloseAllCagesOnCollapse
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowCollapse
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLevel
.head 7 -  Number: nCountCages
.head 7 -  Number: nI
.head 7 -  FunctionalVar: oCagePos
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set nLevel = GetLevel( nRowCollapse )
.head 7 -  Call oRefreshCages.Init(  )
.head 7 +  If nLevel <= KHEL_Gruppe
.head 8 -  Set nCountCages = GetOpenCages( nRowCollapse, 0, oRefreshCages.nRow )
.head 8 -  Set oRefreshCages.nInd = nCountCages
.head 7 +  If nCountCages > 0
.head 8 -  Call oRefreshCages.PrepareRefresh(  )
.head 7 -  ! \
.head 7 -  Set nI = 0
.head 7 +  While nI<nCountCages
.head 8 -  Call CloseCageByRow( GetRowID( oRefreshCages.nRow[nI] ) )
.head 8 -  Set nI = nI + 1
.head 7 -  Call oRefreshCages.Init(  )
.head 5 +  Function: Refresh
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nMode ! 1 - full refresh, 2-refresh cage and children, 10 - refresh selected row,   8 - refresh all Open cages, 6-refresh rack and children, 9 - refresh hints settings
.head 7 -  Number: nIDObject
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRow
.head 7 -  Number: nRowW
.head 7 -  Number: nRowR
.head 7 -  Number: nRowC
.head 7 -  Number: nRowB
.head 7 -  Number: nLevelLoc
.head 7 -  Boolean: bFindRow
.head 7 -  FunctionalVar: cRowCheck
.head 8 -  Class: cFERow
.head 7 -  Number: nRowRefresh
.head 7 -  Boolean: bExpand
.head 7 -  Boolean: bIsParent
.head 7 -  Number: nID_ObjInFocus
.head 7 -  String: sRefreshDate
.head 7 -  FunctionalVar: oRefreshPos
.head 8 -  Class: cPositionData
.head 7 -  Number: nFRow
.head 7 -  Window Handle: hWndFCol
.head 7 -  Number: nRowActivate
.head 7 -  Number: nIdObjFocus
.head 6 +  Actions
.head 7 -  ! Call MTblLockPaint( hWndForm )
.head 7 -  Set bFindRow = FALSE
.head 7 +  If nMode = 1
.head 8 -  Set nRowActivate = GetUniqRowID( nSelectedRow )
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 -  Call PopulateInstitute(  )
.head 8 -  ! Refresh Screen and Racks
.head 8 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nRoot )
.head 8 +  Loop
.head 9 +  If nRowW = TBL_Error
.head 10 -  Break
.head 9 -  Set bIsParent = MTblIsParentRow( hWndForm, nRowW )
.head 9 -  Set bExpand = MTblQueryRowFlags( hWndForm, nRowW, MTBL_ROW_ISEXPANDED )
.head 9 -  Call SalTblSetContext( hWndForm, nRowW )
.head 9 -  Call PopulateWorkGroup( nRowW, TRUE )
.head 9 +  If bExpand
.head 10 -  Call MTblExpandRow( hWndForm, nRowW, MTCR_BY_USER )
.head 9 +  Else
.head 10 -  Call MTblCollapseRow( hWndForm, nRowW, MTCR_BY_USER )
.head 9 +  If MTblIsParentRow( hWndForm, nRowW )
.head 10 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 10 +  Loop
.head 11 +  If nRowR = TBL_Error 
.head 12 -  Break
.head 11 -  Set bIsParent = MTblIsParentRow( hWndForm, nRowR )
.head 11 -  Set bExpand = MTblQueryRowFlags( hWndForm, nRowR, MTBL_ROW_ISEXPANDED )
.head 11 -  Call SalTblSetContext( hWndForm, nRowR )
.head 11 -  Call PopulateRack( nRowR, TRUE )
.head 11 +  If bExpand
.head 12 -  Call MTblExpandRow( hWndForm, nRowR, MTCR_BY_USER )
.head 11 +  Else
.head 12 -  Call MTblCollapseRow( hWndForm, nRowR, MTCR_BY_USER )
.head 11 +  If MTblIsParentRow( hWndForm, nRowR )
.head 12 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 12 +  Loop
.head 13 +  If nRowC = TBL_Error
.head 14 -  Break
.head 13 -  Set bIsParent = MTblIsParentRow( hWndForm, nRowC )
.head 13 -  Set bExpand = MTblQueryRowFlags( hWndForm, nRowC, MTBL_ROW_ISEXPANDED )
.head 13 -  Call SalTblSetContext( hWndForm, nRowC )
.head 13 +  If MTblIsParentRow( hWndForm, nRowC )
.head 14 +  If MTblGetChildRowCount( hWndForm, nRowC ) > 1
.head 15 -  Call PopulateCage( nRowC, TRUE )
.head 14 +  Else
.head 15 +  If bShowOnlyOpenCages
.head 16 -  Call PopulateCage( nRowC, TRUE )
.head 15 +  Else
.head 16 -  Call PopulateCage( nRowC, FALSE )
.head 13 +  If bExpand
.head 14 -  Call MTblExpandRow( hWndForm, nRowC, MTCR_BY_USER )
.head 13 +  Else
.head 14 -  Call MTblCollapseRow( hWndForm, nRowC, MTCR_BY_USER )
.head 13 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 11 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 9 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 8 -  Set nRowActivate =  GetRowID( nRowActivate )
.head 8 +  ! If nRowActivate!=TBL_Error 
.head 9 -  Call ActivateRow(nRowActivate)
.head 8 +  ! Else
.head 9 -  Call ActivateRow(nRoot)
.head 8 -  ! Call ActivateRow(SalTblQueryFocus( hWndForm, Number, Window_Handle ) )
.head 8 -  Set bNeedActivateRow = TRUE
.head 8 -  ! Refresh Rack and cages
.head 8 -  ! Set nRowW = MTblGetFirstChildRow( hWndForm, nRoot )
.head 8 +  ! Loop
.head 9 +  If nRowW = TBL_Error
.head 10 -  Break 
.head 8 +  ! If MTblIsParentRow( hWndForm, nRowW )
.head 9 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 9 +  Loop 
.head 10 +  If nRowR = TBL_Error 
.head 11 -  Break 
.head 10 -  Set bExpand = MTblIsParentRow( hWndForm, nRowR )
.head 10 -  Call PopulateRack( nRowR, TRUE )
.head 10 +  If bExpand
.head 11 -  Call MTblExpandRow( hWndForm, nRowR, MTCR_BY_USER )
.head 10 +  Else 
.head 11 -  Call MTblCollapseRow( hWndForm, nRowR, MTCR_BY_USER )
.head 10 +  If MTblIsParentRow( hWndForm, nRowR )
.head 11 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 11 +  Loop 
.head 12 +  If nRowC = TBL_Error
.head 13 -  Break 
.head 12 -  Set bExpand = MTblIsParentRow( hWndForm, nRowC )
.head 12 +  If MTblIsParentRow( hWndForm, nRowC )
.head 13 +  If MTblGetChildRowCount( hWndForm, nRowC ) > 1
.head 14 -  Call PopulateCage( nRowC, TRUE )
.head 13 +  Else 
.head 14 -  Call PopulateCage( nRowC, FALSE )
.head 12 +  If bExpand
.head 13 -  Call MTblExpandRow( hWndForm, nRowC, MTCR_BY_USER )
.head 12 +  Else 
.head 13 -  Call MTblCollapseRow( hWndForm, nRowC, MTCR_BY_USER )
.head 12 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 10 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 7 +  Else If nMode = 2
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 -  Set nRowActivate = GetUniqRowID( nSelectedRow )
.head 8 -  Set nIdObjFocus = GetIdObject( nSelectedRow )
.head 8 -  ! Call SalTblQueryFocus( hWndForm, nFRow, hWndFCol )
.head 8 +  ! If oPosition.nCageID = nIDObject and nFRow=nSelectedRow
.head 9 +  If colIDObject = nIDObject
.head 10 -  Set bFindRow = TRUE
.head 10 -  Set nRowRefresh = nSelectedRow
.head 9 +  If not bFindRow
.head 10 -  Set nRowC = MTblGetParentRow( hWndForm, nSelectedRow ) 
.head 10 -  Set cRowCheck = FE_GetInfo(nRowC )
.head 10 +  If cRowCheck.nID_Obj = nIDObject
.head 11 -  Set bFindRow = TRUE
.head 11 -  Set nRowRefresh = nRowC
.head 8 -  ! Else
.head 8 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nRoot )
.head 8 +  If nLevelLoc = KHEL_Einrichtung
.head 9 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nRoot )
.head 9 +  Loop
.head 10 +  If nRowW = TBL_Error or bFindRow
.head 11 -  Break
.head 10 +  If MTblIsParentRow( hWndForm, nRowW )
.head 11 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 11 +  Loop
.head 12 +  If nRowR = TBL_Error or bFindRow
.head 13 -  Break
.head 12 +  If MTblIsParentRow( hWndForm, nRowR )
.head 13 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 13 +  Loop
.head 14 +  If nRowC = TBL_Error or bFindRow
.head 15 -  Break
.head 14 -  Set cRowCheck = FE_GetInfo( nRowC )
.head 14 +  If cRowCheck.nID_Obj = nIDObject
.head 15 -  Set bFindRow = TRUE
.head 15 -  Set nRowRefresh = nRowC
.head 14 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 12 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 10 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 8 +  If bFindRow and nRowRefresh
.head 9 -  Call _GetPositionID( nRowRefresh, oRefreshPos )
.head 9 +  If MTblIsParentRow( hWndForm, nRowRefresh )
.head 10 -  Call PopulateCage( nRowRefresh, TRUE )
.head 10 -  Call MTblExpandRow( hWndForm, nRowRefresh, MTCR_BY_USER )
.head 9 +  Else
.head 10 -  Call PopulateCage( nRowRefresh, FALSE )
.head 9 -  Call PopulateRack(GetParent(nRowRefresh),FALSE)
.head 9 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 1, SalHStringToNumber(  oRefreshPos.sCage) )
.head 8 -  Set nRowActivate =  GetRowID( nRowActivate )
.head 8 -  ! Call SalTblFindNextRow( hWndForm,nSelectedRow , ROW_Selected, 0 )
.head 8 -  ! Call SalTblSetContext( hWndForm, nSelectedRow )
.head 8 -  Set bNeedActivateRow = TRUE
.head 8 +  If nRowActivate>0 and nRowActivate != TBL_Error
.head 9 -  Call ActivateRow(nRowActivate)
.head 8 +  Else
.head 9 -  Set nRowActivate = FindObject(nRowRefresh,nIdObjFocus   )
.head 9 +  If nRowActivate != -1
.head 10 -  Call ActivateRow(nRowActivate)
.head 9 +  Else
.head 10 -  Call ActivateRow(nSelectedRow)
.head 7 +  Else If nMode = 10
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 +  If nSelectedLevel = KHEL_Gruppe
.head 9 +  If MTblGetChildRowCount( hWndForm, nSelectedRow ) > 0
.head 10 -  Set bExpand = MTblQueryRowFlags( hWndForm, nSelectedRow, MTBL_ROW_ISEXPANDED )
.head 10 -  Call PopulateCage( nSelectedRow, TRUE )
.head 10 +  If bExpand
.head 11 -  Call MTblExpandRow( hWndForm, nSelectedRow, MTER_BY_USER )
.head 9 +  Else
.head 10 -  Call PopulateCage( nSelectedRow, FALSE )
.head 9 -  Set cRowCheck = FE_GetInfo( nSelectedRow )
.head 9 +  If not bFreezeRefreshToolbars
.head 10 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 1, SalHStringToNumber(  cRowCheck.GetSValue( "Cage" )) )
.head 8 +  Else If nSelectedLevel = KHEL_Bett
.head 9 -  Call PopulateBett( nSelectedRow )
.head 8 +  Else If nSelectedLevel = KHEL_Station
.head 9 -  Set bExpand = MTblQueryRowFlags( hWndForm, nSelectedRow, MTBL_ROW_ISEXPANDED )
.head 9 -  Call PopulateRack( nSelectedRow, TRUE )
.head 9 +  If bExpand
.head 10 -  Call MTblExpandRow( hWndForm, nSelectedRow, MTER_BY_USER )
.head 8 -  Call ActivateRow(nSelectedRow)
.head 8 -  Set bNeedActivateRow = TRUE
.head 7 +  Else If nMode = 8
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 -  Set nID_ObjInFocus = colIDObject
.head 8 -  Set nRowRefresh = -1
.head 8 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nRoot )
.head 8 +  If nLevelLoc = KHEL_Einrichtung
.head 9 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nRoot )
.head 9 +  Loop
.head 10 +  If nRowW = TBL_Error
.head 11 -  Break
.head 10 +  If RowIsParent(nRowW ) and RowIsExpand( nRowW )
.head 11 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 11 +  Loop
.head 12 +  If nRowR = TBL_Error
.head 13 -  Break
.head 12 +  If RowIsParent( nRowR )and RowIsExpand( nRowR )
.head 13 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 13 +  Loop
.head 14 +  If nRowC = TBL_Error
.head 15 -  Break
.head 14 -  Set cRowCheck = FE_GetInfo( nRowC )
.head 14 +  If nID_ObjInFocus = cRowCheck.nID_Obj
.head 15 -  Set nRowRefresh = nRowC
.head 14 +  If cRowCheck.nID_Obj != -100
.head 15 +  If RowIsParent( nRowC )
.head 16 -  Call PopulateCage( nRowC, TRUE )
.head 16 -  Call MTblExpandRow( hWndForm, nRowC, MTCR_BY_USER )
.head 15 +  Else
.head 16 -  Call PopulateCage( nRowC, FALSE )
.head 14 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 12 -  Call PopulateRack( nRowR, FALSE )
.head 12 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 10 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 8 +  If nRowRefresh = -1
.head 9 -  Set nRowRefresh = nSelectedRow
.head 8 -  Call ActivateRow(nRowRefresh)
.head 8 -  Set bNeedActivateRow = TRUE
.head 8 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 10, SalHStringToNumber( oPosition.sScreen || ";" || oPosition.sRack) )
.head 7 +  Else If nMode = 6
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 +  If oPosition.nRackID = nIDObject
.head 9 +  If colIDObject = nIDObject
.head 10 -  Set bFindRow = TRUE
.head 10 -  Set nRowRefresh = nSelectedRow
.head 9 +  If not bFindRow
.head 10 -  Set nRowC = MTblGetParentRow( hWndForm, nSelectedRow ) 
.head 10 -  Set cRowCheck = FE_GetInfo(nRowC )
.head 10 +  If cRowCheck.nID_Obj = nIDObject
.head 11 -  Set bFindRow = TRUE
.head 11 -  Set nRowRefresh = nRowC
.head 10 +  If not bFindRow
.head 11 -  Set nRowC = MTblGetParentRow( hWndForm, nRowC ) 
.head 11 -  Set cRowCheck = FE_GetInfo(nRowC )
.head 11 +  If cRowCheck.nID_Obj = nIDObject
.head 12 -  Set bFindRow = TRUE
.head 12 -  Set nRowRefresh = nRowC
.head 8 +  Else
.head 9 -  Set oRefreshPos = GetPlaceFormString(SalNumberToHString( nIDObject ))
.head 9 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nRoot )
.head 9 +  If nLevelLoc = KHEL_Einrichtung
.head 10 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nRoot )
.head 10 +  Loop
.head 11 +  If nRowW = TBL_Error or bFindRow
.head 12 -  Break
.head 11 +  If MTblIsParentRow( hWndForm, nRowW ) and oRefreshPos.nScreenID= GetIdObject( nRowW )
.head 12 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 12 +  Loop
.head 13 +  If nRowR = TBL_Error or bFindRow
.head 14 -  Break
.head 13 +  If oRefreshPos.nRackID = GetIdObject( nRowR )
.head 14 -  Set bFindRow = TRUE
.head 14 -  Set nRowRefresh = nRowR
.head 13 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 11 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 8 +  If bFindRow and nRowRefresh
.head 9 -  ! Call _GetPositionID( nRowRefresh, oRefreshPos )
.head 9 -  Set cRowCheck = FE_GetInfo( nRowRefresh )
.head 9 +  If MTblIsParentRow( hWndForm, nRowRefresh )
.head 10 -  ! Call PopulateCage( nRowRefresh, TRUE )
.head 10 +  If cRowCheck.nID_Obj != -100
.head 11 -  Call PopulateRack( nRowRefresh, TRUE )
.head 11 -  Call MTblExpandRow( hWndForm, nRowRefresh, MTCR_BY_USER )
.head 9 +  Else
.head 10 +  If cRowCheck.nID_Obj != -100
.head 11 -  Call PopulateRack( nRowRefresh, FALSE )
.head 9 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowRefresh )
.head 9 +  Loop
.head 10 +  If nRowC = TBL_Error
.head 11 -  Break
.head 10 -  Set cRowCheck = FE_GetInfo( nRowC )
.head 10 +  If cRowCheck.nID_Obj != -100
.head 11 +  If MTblIsParentRow( hWndForm, nRowC )
.head 12 -  Call PopulateCage( nRowC, TRUE )
.head 12 -  Call MTblExpandRow( hWndForm, nRowC, MTCR_BY_USER )
.head 11 +  Else
.head 12 -  Call PopulateCage( nRowC, FALSE )
.head 10 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 9 -  ! Call SalSendMsg(hWndStar2000, AM_Refresh, 1, SalHStringToNumber(  oRefreshPos.sCage) )
.head 8 -  Call ActivateRow(nSelectedRow)
.head 8 -  Set bNeedActivateRow = TRUE
.head 7 +  Else If nMode = 9
.head 8 -  Set nRowActivate = GetUniqRowID( nSelectedRow )
.head 8 -  Set bNeedActivateRow = FALSE
.head 8 -  Call FE_ReloadHint(nRoot)
.head 8 -  Set nRowW = MTblGetFirstChildRow( hWndForm, nRoot )
.head 8 +  Loop
.head 9 +  If nRowW = TBL_Error
.head 10 -  Break
.head 9 -  Set bIsParent = MTblIsParentRow( hWndForm, nRowW )
.head 9 -  Set bExpand = MTblQueryRowFlags( hWndForm, nRowW, MTBL_ROW_ISEXPANDED )
.head 9 -  Call FE_ReloadHint(nRowW)
.head 9 +  If bExpand
.head 10 +  If MTblIsParentRow( hWndForm, nRowW )
.head 11 -  Set nRowR = MTblGetFirstChildRow( hWndForm, nRowW )
.head 11 +  Loop
.head 12 +  If nRowR = TBL_Error 
.head 13 -  Break
.head 12 -  Set bIsParent = MTblIsParentRow( hWndForm, nRowR )
.head 12 -  Set bExpand = MTblQueryRowFlags( hWndForm, nRowR, MTBL_ROW_ISEXPANDED )
.head 12 -  Call FE_ReloadHint(nRowR)
.head 12 +  If bExpand
.head 13 +  If MTblIsParentRow( hWndForm, nRowR )
.head 14 -  Set nRowC = MTblGetFirstChildRow( hWndForm, nRowR )
.head 14 +  Loop
.head 15 +  If nRowC = TBL_Error
.head 16 -  Break
.head 15 -  Set bIsParent = MTblIsParentRow( hWndForm, nRowC )
.head 15 -  Set bExpand = MTblQueryRowFlags( hWndForm, nRowC, MTBL_ROW_ISEXPANDED )
.head 15 -  Call FE_ReloadHint(nRowC)
.head 15 +  If bExpand
.head 16 -  Set nRowB = MTblGetFirstChildRow( hWndForm, nRowC )
.head 16 +  Loop
.head 17 +  If nRowB = TBL_Error
.head 18 -  Break
.head 17 -  Call FE_ReloadHint(nRowB)
.head 17 -  Set nRowB = MTblGetNextChildRow( hWndForm, nRowB )
.head 15 -  Set nRowC = MTblGetNextChildRow( hWndForm, nRowC )
.head 12 -  Set nRowR = MTblGetNextChildRow( hWndForm, nRowR )
.head 9 -  Set nRowW = MTblGetNextChildRow( hWndForm, nRowW )
.head 8 -  !
.head 8 -  Set nRowActivate =  GetRowID( nRowActivate )
.head 8 -  Set bNeedActivateRow = TRUE
.head 7 -  ! Call MTblUnlockPaint( hWndForm )
.head 7 -  ! Call SalInvalidateWindow( hWndForm )
.head 5 +  Function: CheckStatusObj
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  Number: nStatusObj
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bStatus
.head 7 -  Number: nLevelLoc
.head 7 -  FunctionalVar: oDataRow
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set bStatus=FALSE
.head 7 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nRow )
.head 7 +  If nStatusObj>=RackIsFull and nStatusObj< CageIsFull
.head 8 -  Set oDataRow =  SalObjCreateFromString( "cFERowRack" )
.head 8 +  Select Case nLevelLoc
.head 9 +  Case FEL_Rack
.head 10 -  Set oDataRow.nStatusFlags = FE_GetFlag(nRow)
.head 10 -  Break
.head 9 +  Case FEL_Cage
.head 10 -  Set oDataRow.nStatusFlags = FE_GetFlag(MTblGetParentRow( hWndForm, nRow ))
.head 10 -  Break
.head 9 +  Case FEL_Pos
.head 10 -  Set oDataRow.nStatusFlags = FE_GetFlag(MTblGetParentRow( hWndForm, MTblGetParentRow(hWndForm, nRow )))
.head 10 -  Break
.head 9 +  Default
.head 10 -  Set oDataRow.nStatusFlags = 0
.head 10 -  Break
.head 8 -  Set bStatus = oDataRow.GetState( nStatusObj )
.head 7 +  Else If (nStatusObj>=CageIsFull and nStatusObj < AnimalIsPlugged ) or nStatusObj=IsAlert or nStatusObj=IsServise
.head 8 -  Set oDataRow =  SalObjCreateFromString( "cFERowCage" )
.head 8 +  Select Case nLevelLoc
.head 9 +  Case FEL_Cage
.head 10 -  Set oDataRow.nStatusFlags = FE_GetFlag( nRow )
.head 10 -  Break
.head 9 +  Case FEL_Pos
.head 10 -  Set oDataRow.nStatusFlags = FE_GetFlag(MTblGetParentRow( hWndForm, nRow ))
.head 10 -  Break
.head 9 +  Default
.head 10 -  Set oDataRow.nStatusFlags = 0
.head 10 -  Break
.head 8 -  Set bStatus = oDataRow.GetState( nStatusObj )
.head 7 +  Else If nStatusObj>=AnimalIsPlugged and nStatusObj < StrainIsVas
.head 8 -  Set oDataRow =  SalObjCreateFromString( "cFERowBett" )
.head 8 +  Select Case nLevelLoc
.head 9 +  Case FEL_Pos
.head 10 -  Set oDataRow.nStatusFlags = FE_GetFlag( nRow )
.head 10 -  Break
.head 9 +  Default
.head 10 -  Set oDataRow.nStatusFlags = 0
.head 10 -  Break
.head 8 -  Set bStatus = oDataRow.GetState( nStatusObj )
.head 7 +  Else
.head 8 +  Select Case nLevelLoc
.head 9 +  Case FEL_Institute
.head 10 -  Set oDataRow =  SalObjCreateFromString( "cFERowIns" )
.head 10 -  Break
.head 9 +  Case FEL_Workgroup
.head 10 -  Set oDataRow =  SalObjCreateFromString( "cFERowScr" )
.head 10 -  Break
.head 9 +  Case FEL_Rack
.head 10 -  Set oDataRow =  SalObjCreateFromString( "cFERowRack" )
.head 10 -  Break
.head 9 +  Case FEL_Cage
.head 10 -  Set oDataRow =  SalObjCreateFromString( "cFERowCage" )
.head 10 -  Break
.head 9 +  Case FEL_Pos
.head 10 -  Set oDataRow =  SalObjCreateFromString( "cFERowBett" )
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 8 -  Set oDataRow.nStatusFlags = FE_GetFlag(nRow)
.head 8 -  Set bStatus = oDataRow.GetState( nStatusObj )
.head 7 -  Return bStatus
.head 5 -  !
.head 5 +  Function: SelectDeadAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRowCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowA
.head 7 -  FunctionalVar: oAnimal
.head 8 -  Class: cFERow
.head 7 -  Number: nCount
.head 6 +  Actions
.head 7 -  Set nCount = 0
.head 7 +  If MTblGetRowLevel( hWndForm, nRowCage ) = KHEL_Gruppe
.head 8 -  Set nRowA = MTblGetFirstChildRow( hWndForm, nRowCage )
.head 8 +  Loop
.head 9 +  If nRowA = TBL_Error
.head 10 -  Break
.head 9 -  Set oAnimal = FE_GetInfo( nRowA )
.head 9 +  If oAnimal.GetState( AnimalIsDead )
.head 10 +  If nCount = 0 
.head 11 -  Call UnSelectAll(  )
.head 10 -  Call SwitchSelectRow(nRowA)
.head 10 -  Set nCount = nCount + 1
.head 9 -  Set nRowA = MTblGetNextChildRow( hWndForm, nRowA )
.head 7 -  Return nCount
.head 5 +  Function: GoToCageNR
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: pnCageNR
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlBew
.head 7 -  String: sSelectBew
.head 7 -  Number: nFetch
.head 7 -  Number: nScr
.head 7 -  Number: nRack
.head 7 -  Number: nCage
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bOk = SqlCreateStatement( hSesionFE , hSqlBew )
.head 7 -  Set sSelectBew = "
select scr_id, rack_id,cage_id,  @nullvalue(bew_zeit_bis,@now + 365)
from    bewegung
where  CAGE_NR= " || StrX( pnCageNR ) || " 
and GELOESCHT = 'N'  and ba_key in ( 'AE', 'VE', 'UE', 'RE' ) 
order by 4 desc
into :nScr, :nRack, :nCage
"
.head 7 -  Set bOk = bOk and  SqlPrepareAndExecute( hSqlBew, sSelectBew )
.head 7 -  Set bOk = bOk and  SqlFetchNext( hSqlBew, nFetch )
.head 7 +  If hSqlBew
.head 8 -  Call SqlDisconnect( hSqlBew )
.head 7 +  If not nScr or not nRack or not nCage
.head 8 -  Return FALSE
.head 7 -  Return OpenCage( nScr, nRack, nCage )
.head 5 +  Function: GotoCageByFallKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtGetTime
.head 7 -  Sql Handle: hSqlGGBFK
.head 7 -  Number: ni
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bOk = SqlCreateStatement( hSesionFE , hSqlGGBFK )
.head 7 -  Call SalArraySetUpperBound ( n, 1, -1 )
.head 7 -  Call SqlPrepareAndExecute( hSqlGGBFK, "
select f.last_scr_id, f.last_cage_id, g.rack_id
from	FALL f
left join Gruppe g on (g.id=f.last_cage_id)
where	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.FALL_KEY = " || StrX( nFallKey ) || "
   and	f.LAST_BA_KEY in ('AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
into	:n[1], :n[3], :n[2] " )
.head 7 -  ! If bRealTimeMode
.head 7 +  ! Else
.head 8 -  Set dtGetTime = GetTime4Refresh(  )
.head 8 +  ! If not DoImmediate("
select	bew.ABT_KEY, bew.STAT_KEY, bew.GRUPPE_KEY
from	FALL f, BEWEGUNG bew
where	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.FALL_KEY = " || StrX( nFallKey ) || "
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
  and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
  and	bew.Fall_KEY = f.Fall_KEY
  and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
  and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   
into	:s[1], :s[2], :s[3] ")
.head 9 -  Return FALSE
.head 8 -  Call SqlPrepareAndExecute( hSqlGGBFK, "
select	bew.ABT_KEY, bew.STAT_KEY, bew.GRUPPE_KEY
from	FALL f, BEWEGUNG bew
where	bew.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	bew.FALL_KEY = " || StrX( nFallKey ) || "
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and       bew.bew_zeit <=:dtGetTime
  and       (bew.bew_zeit_bis>:dtGetTime or bew.bew_zeit_bis is null  )
  and	bew.Fall_KEY = f.Fall_KEY
  and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
  and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   
into	:s[1], :s[2], :s[3] " )
.head 7 -  Call SqlFetchNext( hSqlGGBFK, ni )
.head 7 -  Call SqlDisconnect( hSqlGGBFK )
.head 7 -  Return OpenCage( n[1], n[2], n[3] )
.head 7 -  ! Return GotoGruppe( s[1], s[2], s[3], bForceScan )
.head 5 +  Function: ActivatePosFallKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtGetTime
.head 7 -  Sql Handle: hSqlGGBFK
.head 7 -  Number: ni
.head 7 -  Boolean: bOk
.head 7 -  Number: nRow
.head 6 +  Actions
.head 7 -  Set bOk = SqlCreateStatement( hSesionFE , hSqlGGBFK )
.head 7 -  Call SqlPrepareAndExecute( hSqlGGBFK, "
select f.last_scr_id, f.last_cage_id, g.rack_id
from	FALL f
left join Gruppe g on (g.id=f.last_cage_id)
where	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.FALL_KEY = " || StrX( nFallKey ) || "
   and	f.LAST_BA_KEY in ('AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
into	:n[1], :n[3], :n[2] " )
.head 7 -  Call SqlFetchNext( hSqlGGBFK, ni )
.head 7 -  Call SqlDisconnect( hSqlGGBFK )
.head 7 -  Set nRow = FindObject(  nRoot , n[1] )
.head 7 +  If nRow != -1
.head 8 -  Set nRow = FindObject(  nRow , n[2] )
.head 8 +  If nRow != -1
.head 9 -  Set nRow = FindObject(  nRow , n[3] )
.head 9 +  If nRow != -1
.head 10 -  Set nRow = FindObject(  nRow , nFallKey )
.head 7 +  If nRow != -1
.head 8 -  Call ActivateRow( nRow )
.head 7 -  Return nRow
.head 7 -  ! Return GotoGruppe( s[1], s[2], s[3], bForceScan )
.head 5 +  Function: OpenPosByFallKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExist
.head 7 -  Number: hStation
.head 7 -  String: sABT
.head 7 -  String: sStat
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: nRow
.head 7 -  !
.head 6 +  Actions
.head 7 -  Set bOk = DoImmediateSingle( "
select	FALL_KEY 
from	FALL
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY = " || StrX( nFallKey ) || "
   and	GELOESCHT = 'N' 
", bExist )
.head 7 +  If bOk And Not bExist
.head 8 -  Call ErrorMessageBox( 137 )
.head 8 -  Set bOk = FALSE
.head 7 +  If Not bOk
.head 8 -  Return FALSE
.head 7 +  If bOk 
.head 8 -  Set nRow = GotoCageByFallKey(nFallKey)
.head 8 +  If nRow 
.head 9 -  Set nRow = FindObject(  GetRowID(nRow), nFallKey )
.head 9 +  If nRow 
.head 10 -  Call ActivateRow( nRow )
.head 10 -  Set colCheck = 0
.head 10 -  Call SwitchSelectRow(nRow)
.head 8 +  Else
.head 9 -  Call SalPostMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( nFallKey ) )
.head 9 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 -  ! actions functions
.head 5 +  Function: ChangeOrder
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nParentRow
.head 7 -  Number: nChildRow
.head 7 -  Number: nRowContext
.head 7 -  Number: nStartRow
.head 7 -  Number: nFinishRow
.head 7 -  Number: nLastOrder
.head 7 -  Number: nStartOrder
.head 7 -  Window Handle: hCol[*]
.head 7 -  Number: nColSort[*]
.head 7 -  String: sSQL
.head 7 -  Number: nIDParent
.head 7 -  Boolean: bOk
.head 7 -  Number: nFindSelectOrder
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set nRowContext = SalTblQueryContext( hWndForm )
.head 7 -  Set nParentRow = MTblGetParentRow( hWndForm, nSelectedRow )
.head 7 -  Call SalTblSetContext( hWndForm, nParentRow )
.head 7 -  Set nIDParent = colIDObject
.head 7 -  Call SalTblSetContext( hWndForm, nRowContext )
.head 7 -  ! Find first and last row in selected level
.head 7 -  Set nStartRow = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 7 -  Set nChildRow = nStartRow
.head 7 +  Loop
.head 8 +  If nChildRow=TBL_Error
.head 9 -  Break
.head 8 -  Set nFinishRow = nChildRow
.head 8 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 7 -  ! Change Order
.head 7 +  Select Case nAction
.head 8 +  Case SCREEN_TOP
.head 9 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 9 -  Set nLastOrder = colOrder
.head 9 +  Loop
.head 10 +  If nChildRow=TBL_Error
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If colOrder = nLastOrder
.head 11 -  Set colOrder = 1
.head 11 -  Set nFindSelectOrder = colOrder
.head 11 -  Break
.head 10 +  If colOrder != -100 and colOrder != nLastOrder
.head 11 -  Set colOrder = colOrder + 1
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Break
.head 8 +  Case SCREEN_UP
.head 9 -  Set colOrder = colOrder - 1
.head 9 -  Set nFindSelectOrder = colOrder
.head 9 -  Set nChildRow = MTblGetPrevChildRow( hWndForm, nRowContext )
.head 9 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 9 -  Set colOrder = colOrder + 1
.head 9 -  Break
.head 8 +  Case SCREEN_DOWN
.head 9 -  Set colOrder = colOrder + 1
.head 9 -  Set nFindSelectOrder = colOrder
.head 9 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nRowContext )
.head 9 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 9 -  Set colOrder = colOrder - 1
.head 9 -  Break
.head 8 +  Case SCREEN_BUTTOM
.head 9 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 9 -  Set nStartOrder = colOrder
.head 9 -  Set nLastOrder = MTblGetChildRowCount( hWndForm, nParentRow )
.head 9 +  Loop
.head 10 +  If nChildRow=TBL_Error
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If colOrder = -100
.head 11 -  Set nLastOrder = nLastOrder - 1
.head 10 +  If colOrder = nStartOrder
.head 11 -  Set colOrder = nLastOrder
.head 11 -  Set nFindSelectOrder = colOrder
.head 11 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 11 -  Break
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 +  Loop
.head 10 +  If nChildRow=TBL_Error
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If colOrder != -100
.head 11 -  Set colOrder = colOrder - 1
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  ! Sorting level 
.head 7 -  Set nRowContext = GetUniqRowID( nRowContext )
.head 7 -  Set hCol[0] = colOrder
.head 7 -  Set nColSort[0] = MTS_ASC | MTS_DT_DEFAULT
.head 7 -  Call MTblSortRange( hWndForm, hCol, nColSort, nStartRow, nFinishRow )
.head 7 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 7 -  Set nFetch = 1
.head 7 +  Loop
.head 8 +  If nChildRow=TBL_Error
.head 9 -  Break
.head 8 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 8 -  Set colOrder = nFetch 
.head 8 -  Set nFetch = nFetch + 1
.head 8 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 7 -  ! save information
.head 7 +  If nSelectedLevel = KHEL_Abteilung
.head 8 -  Set sSQL = "update user_screen set top=:colOrder where user_id = :nUserId and scr_id=:colIDObject"
.head 7 +  Else If nSelectedLevel = KHEL_Station
.head 8 -  Set sSQL = "update tree set top=:colOrder where user_id = :nUserId and id_parent=:nIDParent and id_child=:colIDObject "
.head 7 -  Set bOk = SqlPrepareAndExecute(hSqlPopulate, "lock table xlock")
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "lock table user_screen")
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "lock table tree ")
.head 7 -  Set bOk = bOk and SqlPrepare(hSqlPopulate, sSQL)
.head 7 +  If nSelectedLevel = KHEL_Station
.head 8 -  Set bOk = bOk and SqlPrepare( hSqlPopulateC, "Select * from tree where user_id = :nUserId and id_parent=:nIDParent and id_child=:colIDObject" )
.head 8 -  Set bOk = bOk and SqlPrepare( hSqlPopulateP , "Insert into tree(user_id, id_parent, id_child, top) values(:nUserId, :nIDParent, :colIDObject, :colOrder )" )
.head 7 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nParentRow )
.head 7 +  Loop
.head 8 +  If nChildRow=TBL_Error
.head 9 -  Break
.head 8 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 8 +  ! If nFindSelectOrder = colOrder
.head 9 -  Set nRowContext = nChildRow
.head 8 +  If colOrder != -100
.head 9 +  If nSelectedLevel = KHEL_Station
.head 10 +  If SqlExecute(hSqlPopulateC) and SqlFetchNext( hSqlPopulateC, nFetch )
.head 11 -  Set bOk = bOk and SqlExecute(hSqlPopulate)
.head 10 +  Else
.head 11 -  Set bOk = bOk and SqlExecute(hSqlPopulateP)
.head 9 +  Else
.head 10 -  Set bOk = bOk and SqlExecute(hSqlPopulate)
.head 8 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 8 -  Set nFinishRow = nChildRow
.head 7 +  If bOk 
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulate, "commit" )
.head 7 +  Else
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulate, "rollback" )
.head 7 -  !
.head 7 -  Call ActivateRow(GetRowID( nRowContext) )
.head 5 +  Function: Cage2Experiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sExpParam
.head 7 -  String: sRecParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKey2Trans[*]
.head 7 -  String: sLicenseKey
.head 7 -  String: sLicenseRecord
.head 7 -  Number: nInd
.head 7 -  Number: nI
.head 7 -  Number: nIndPrint
.head 7 -  Number: nCountSuccess
.head 7 -  Boolean: bOk
.head 7 -  String: sBackMsg
.head 7 -  String: sResultMsg
.head 7 -  FunctionalVar: oRowInfo
.head 8 -  Class: cFERow
.head 7 -  ! *****
.head 7 -  FunctionalVar: oPosSelected
.head 8 -  Class: cPositionData
.head 7 -  !
.head 7 -  String: sCage
.head 6 +  Actions
.head 7 -  Call oRefreshCages.Init(  )
.head 7 +  If oHandleSelect.bAnySelects
.head 8 -  Set nInd = 0
.head 8 -  Set nI = 0
.head 8 -  Set nIndPrint = 0
.head 8 +  While nInd < oHandleSelect.nIndex
.head 9 +  If GetLevel(GetRowID(oHandleSelect.nRow[nInd])) = KHEL_Bett
.head 10 -  Set oRowInfo = FE_GetInfo( GetRowID(oHandleSelect.nRow[nInd]) )
.head 10 -  Call _GetPositionID( GetRowID(oHandleSelect.nRow[nInd]), oPosSelected )
.head 10 +  If oRowInfo.nID_Obj!=-100
.head 11 -  Set nFallKey2Trans[nI] = oRowInfo.nID_Obj
.head 11 +  If SalStrScan(sCage,oPosSelected.sCage )
.head 12 -  Set sCage = sCage || oPosSelected.sCage || ","
.head 11 -  Set nI = nI + 1
.head 10 -  Call oRefreshCages.AddRow( GetParent( GetRowID(oHandleSelect.nRow[nInd]) ) )
.head 9 -  Set nInd = nInd + 1
.head 8 -  Call SalStrLeft( sCage, SalStrLength( sCage ) - 1, sCage )
.head 7 +  Else
.head 8 +  If not EnumChildren( nSelectedRow, nFallKey2Trans )
.head 9 -  Return FALSE
.head 8 -  Call oRefreshCages.AddRow( nSelectedRow )
.head 8 -  Set sCage = sCage || oPosSelected.sCage 
.head 8 -  Set nI = 1
.head 7 +  If sExpParam and sRecParam
.head 8 -  Set sLicenseKey = sExpParam
.head 8 -  Set sLicenseRecord = sRecParam
.head 7 +  Else
.head 8 +  If Not Request_License( sLicenseKey, sLicenseRecord, oPosSelected.sScreen )
.head 9 -  Return FALSE
.head 7 -  Set bOk = TRUE
.head 7 -  Call LockSysadmAction("Add to group...")
.head 7 -  Set nCountSuccess = 0
.head 7 -  Set nInd = 0
.head 7 -  Set bOk = bOk and SqlPrepare(hSqlPopulate, "update fall_experiment set end_date=@now  where fall_key=:nFallKey2Trans[nInd] and experiment_key!=:sLicenseKey and end_date is null  ")
.head 7 +  While bOk and nFallKey2Trans[nInd]
.head 8 -  Set sBackMsg = ''
.head 8 -  Set bOk = bOk and SqlExecute( hSqlPopulate ) 
.head 8 +  If License_AddCaseMsg_ForSession( hSesionFE,  sLicenseKey, sLicenseRecord, nFallKey2Trans[nInd], '', sBackMsg )
.head 9 -  Set nCountSuccess = nCountSuccess + 1
.head 8 +  Else
.head 9 +  If sBackMsg = ''	! means SqlError happened
.head 10 -  Set bOk = FALSE 
.head 9 +  Else
.head 10 -  Set sResultMsg = sResultMsg || "
" || sBackMsg
.head 8 -  Set nInd = nInd + 1
.head 7 +  If bOk
.head 8 -  Call SqlCommit( hSqlPopulate )
.head 7 +  Else
.head 8 -  Call SqlPrepareAndExecute(hSqlPopulate, "rollback")
.head 7 +  If bOk
.head 8 -  Call LockSysadmAction("...added to group")
.head 8 -  Set sResultMsg = StrX( nCountSuccess ) || " " || GetMessageFromSection( "FALL_GROUPS", 12060, "cases assigned to the License" ) || " " || sLicenseKey  || "
---------------------------------------------------------------------
" || sResultMsg
.head 8 -  ! *****
.head 8 -  Call GalTimedMessageBox( hWndForm, sResultMsg, GetMessage( 202 ), 1000 )
.head 8 -  Call RefreshCages(  )
.head 7 +  Else
.head 8 -  Call LockSysadmAction("...not added to group")
.head 7 -  Return bOk
.head 5 +  Function: GetLicenseFall
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtDT
.head 7 -  FunctionalVar: oSelectedPos
.head 8 -  Class: cPositionData
.head 7 -  Number: nFKey
.head 7 -  Number: n
.head 7 -  String: sSql
.head 6 +  Actions
.head 7 -  Call _GetPositionID( nSelectedRow, oSelectedPos )
.head 7 -  Set dtDT = GetTime4Refresh( )
.head 7 -  Set nFKey = 0
.head 7 +  If nSelectedLevel = KHEL_Gruppe
.head 8 +  If not CheckStatusObj(nSelectedRow,CageIsOccupied) and not CheckStatusObj(nSelectedRow,CageIsEmpty)
.head 9 +  If nGCFall_Key=0 or nGCFall_Key=NUMBER_Null
.head 10 -  Set sSql = " select Fall_key 
  from fall_experiment fe, experiment e
 where e.experiment_key=fe.experiment_key
 and e.EXP_SIGNED_P2=4
into :nGCFall_Key"
.head 10 +  If SqlPrepareAndExecute(hSqlPopulate, sSql)
.head 11 -  Call SqlFetchNext(hSqlPopulate, n)
.head 9 -  Set sSql = "select @NULLVALUE(f.fall_key, " || SalNumberToStrX( nGCFall_Key, 0 ) || ")
from     BEWEGUNG b left join fall_experiment fe on (b.fall_key = fe.fall_key and fe.end_date is null) left join fall f on (f.name1 = fe.experiment_key)
where
   @nullvalue( b.GELOESCHT, 'N' ) = 'N'
   and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
   and	b.BEW_ZEIT <= :dtDT
   and	( b.BEW_ZEIT_BIS >= :dtDT or ( b.BEW_ZEIT_BIS is NULL ) )
   and 	b.EINRICHT_ID = :nEinrichtId
   and 	b.scr_id = :oSelectedPos.nScreenID
   and	b.cage_id = :oSelectedPos.nCageID
group by 1
into :nFKey"
.head 9 +  If SqlPrepareAndExecute(hSqlPopulate, sSql)
.head 10 +  If SqlGetResultSetCount (hSqlPopulate, n)
.head 11 +  If n>1
.head 12 -  Set nFKey=0
.head 11 +  Else
.head 12 -  Call SqlFetchNext(hSqlPopulate, n)
.head 9 -  Call SqlCommit(hSqlPopulate)
.head 7 +  Else If nSelectedLevel = KHEL_Bett
.head 8 -  Set nFKey = GetIdObject(nSelectedRow)
.head 7 -  !
.head 7 -  Return nFKey
.head 5 +  Function: CutCurrent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nHandles[*]
.head 7 -  Number: nHandlesIR[*]
.head 7 -  Number: nBound
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: hBet[*]
.head 7 -  ! Number: nBound
.head 7 -  Number: nFall
.head 7 -  Number: nBet
.head 7 -  Number: q
.head 7 -  Boolean: bSelect
.head 7 -  Boolean: bNotSelect
.head 7 -  Date/Time: dtDate
.head 7 -  !
.head 7 -  Number: nChildRow
.head 7 -  Number: nChildRow1
.head 6 +  Actions
.head 7 -  Set bSelect = FALSE
.head 7 +  Select Case nSelectedLevel
.head 8 +  Case FEL_Pos
.head 9 -  Call SwitchSelectRow(nSelectedRow)
.head 9 -  Break
.head 8 +  Case FEL_Cage
.head 9 +  If not MTblQueryRowFlags( hWndForm, nSelectedRow, MTBL_ROW_ISEXPANDED )
.head 10 -  Call MTblExpandRow( hWndForm, nSelectedRow, MTER_BY_USER )
.head 9 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error or bSelect
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If colCheck != 1 and colIDObject != -100
.head 11 -  Set bSelect = TRUE
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If (bSelect and colCheck != 1) or (not bSelect and colCheck = 1 )
.head 11 -  Call SwitchSelectRow(nChildRow)
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Call ActivateRow( nSelectedRow )
.head 8 +  Case FEL_Rack
.head 9 +  If not MTblQueryRowFlags( hWndForm, nSelectedRow, MTBL_ROW_ISEXPANDED )
.head 10 -  Call MTblExpandRow( hWndForm, nSelectedRow, MTER_BY_USER )
.head 9 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error or bSelect
.head 11 -  Break
.head 10 -  Set nChildRow1 = MTblGetFirstChildRow( hWndForm, nChildRow )
.head 10 +  Loop
.head 11 +  If nChildRow1 = TBL_Error  or bSelect
.head 12 -  Break
.head 11 -  Call SalTblSetContext( hWndForm, nChildRow1 )
.head 11 +  If colCheck != 1 and colIDObject != -100
.head 12 -  Set bSelect = TRUE
.head 11 -  Set nChildRow1 = MTblGetNextChildRow( hWndForm, nChildRow1 )
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error
.head 11 -  Break
.head 10 -  Set nChildRow1 = MTblGetFirstChildRow( hWndForm, nChildRow )
.head 10 +  Loop
.head 11 +  If nChildRow1 = TBL_Error
.head 12 -  Break
.head 11 -  Call SalTblSetContext( hWndForm, nChildRow1 )
.head 11 +  If (bSelect and colCheck != 1) or (not bSelect and colCheck = 1 )
.head 12 -  Call SwitchSelectRow(nChildRow1)
.head 11 -  Set nChildRow1 = MTblGetNextChildRow( hWndForm, nChildRow1 )
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Call ActivateRow( nSelectedRow )
.head 8 -  Default
.head 7 -  Return TRUE
.head 5 +  Function: CullingAndDischarge
.head 6 -  Description: kill animal or discharge animal
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bMakeDischarge
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGroupRelease
.head 7 -  Boolean: bOk
.head 7 -  !
.head 7 -  Number: nRowCage
.head 7 -  Number: nRowAnimal
.head 7 -  Number: nCageRefresh[*]
.head 7 -  FunctionalVar: oCageRefresh
.head 8 -  Class: cFERowCage
.head 7 -  FunctionalVar: oPosObj
.head 8 -  Class: cPositionData
.head 7 -  Date/Time: dtEE_Datum
.head 7 -  Boolean: bCulling
.head 7 -  Number: nInd
.head 7 -  Number: i
.head 7 -  Number: nTmp
.head 7 -  !
.head 7 -  FunctionalVar: oCullingData
.head 8 -  Class: cCullingData
.head 7 -  !
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  Boolean: bShowDischargeDialog
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  !
.head 7 -  Number: nFallKey2Trans[ * ]
.head 7 -  Number: n2Trans
.head 7 -  !
.head 7 -  String: sFallList
.head 7 -  !
.head 7 -  Number: nFall
.head 7 -  Number: nBewNr2Trans[ * ]
.head 7 -  Number: hBeds2Trans[ * ]
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cNullLocation
.head 8 -  Class: clsLocationCage
.head 7 -  !
.head 7 -  Boolean: bPrintCage
.head 7 -  Number: nMax
.head 7 -  Number: nCount
.head 7 -  Number: nRowRack
.head 6 +  Actions
.head 7 +  If hWndDlgEntlasung = hWndNULL
.head 8 -  Call oRefreshCages.Init(  )
.head 8 -  Set hGroupRelease = nSelectedRow
.head 8 +  If CheckStatusObj(hGroupRelease, CageIsOccupied )
.head 9 -  Return FALSE
.head 8 +  If oHandleSelect.nIndex>0
.head 9 -  Set nInd = 0
.head 9 -  Set nMax = 0
.head 9 +  If nSelectedLevel = KHEL_Bett
.head 10 -  Set nRowCage = GetParent(hGroupRelease )
.head 10 -  Set nRowRack = GetParent( nRowCage )
.head 9 +  Else
.head 10 -  Set nRowRack = GetParent( hGroupRelease )
.head 9 +  While nInd < oHandleSelect.nIndex
.head 10 -  Set nFallKey2Trans[ nInd ] =  GetIdObject( GetRowID(oHandleSelect.nRow[nInd]) )
.head 10 +  If nFallKey2Trans[ nInd ] 
.head 11 -  ! Set sBettKey2Trans[ nInd ] = GetKey_ByHandle( HandleToPlace[ nInd, 1] )
.head 11 +  If nMax=0
.head 12 -  Set nCageRefresh[nMax] = GetParent(GetRowID(oHandleSelect.nRow[nInd]) )
.head 12 -  Call oRefreshCages.AddRow( nCageRefresh[nMax] )
.head 12 -  Set nMax = nMax + 1
.head 11 +  Else
.head 12 -  Set i= 0
.head 12 +  While i<nMax
.head 13 +  If nCageRefresh[i]!=GetParent(GetRowID(oHandleSelect.nRow[nInd]) )
.head 14 -  Set nCageRefresh[nMax] = GetParent(GetRowID(oHandleSelect.nRow[nInd]) )
.head 14 -  Call oRefreshCages.AddRow( nCageRefresh[nMax] )
.head 14 -  Set nMax = nMax + 1
.head 14 -  Break
.head 13 -  Set i=i+1
.head 11 -  Set hBeds2Trans[ nInd ] =  GetRowID(oHandleSelect.nRow[nInd])
.head 11 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[ nInd ]
.head 10 +  If nSelectedLevel = KHEL_Bett
.head 11 +  If nRowCage = GetParent(GetRowID(oHandleSelect.nRow[nInd]))
.head 12 -  Call ActivateRow( nRowCage )
.head 10 -  Set nInd = nInd + 1
.head 9 -  Set n2Trans = nInd
.head 9 -  ! Sorting in descr
.head 9 -  Set i = 0
.head 9 +  While (i+1)< nMax
.head 10 -  Set nInd = i + 1
.head 10 +  While nInd < nMax
.head 11 +  If nCageRefresh[i] < nCageRefresh[nInd]
.head 12 -  Set nTmp = nCageRefresh[i]
.head 12 -  Set nCageRefresh[i] = nCageRefresh[nInd]
.head 12 -  Set nCageRefresh[nInd] = nTmp
.head 11 -  Set nInd = nInd + 1
.head 10 -  Set i = i + 1
.head 8 +  Else If nSelectedLevel = KHEL_Gruppe
.head 9 -  Set nCageRefresh[0] = hGroupRelease
.head 9 -  Set nRowRack = GetParent( hGroupRelease )
.head 9 -  Call oRefreshCages.AddRow( nCageRefresh[0] )
.head 9 -  Set nMax =1
.head 9 -  Set n2Trans = EnumChildren( hGroupRelease, nFallKey2Trans )
.head 9 -  Set nInd = 0
.head 9 +  While nInd < n2Trans
.head 10 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[nInd]
.head 10 -  Set nInd = nInd + 1
.head 9 -  Set nInd = 0
.head 9 -  Set nRowAnimal = MTblGetFirstChildRow( hWndForm, hGroupRelease )
.head 9 +  Loop
.head 10 +  If nRowAnimal = TBL_Error
.head 11 -  Break
.head 10 -  Set hBeds2Trans[ nInd ] = nRowAnimal 
.head 10 -  Set nRowAnimal = MTblGetNextChildRow( hWndForm, nRowAnimal )
.head 10 -  Set nInd = nInd + 1
.head 8 +  Else If nSelectedLevel = KHEL_Bett
.head 9 -  Set nFallKey2Trans[0] = GetIdObject( hGroupRelease )
.head 9 -  Set hBeds2Trans[ 0 ] = nSelectedRow 
.head 9 -  Set nCageRefresh[0] = GetParent( hGroupRelease )
.head 9 -  Set nRowRack = GetParent( nCageRefresh[0] )
.head 9 -  Call oRefreshCages.AddRow( nCageRefresh[0] )
.head 9 -  Set nMax =1
.head 9 -  Set n2Trans = 1
.head 9 -  Set oCullingData.nAnimals[nInd] = nFallKey2Trans[0]
.head 8 -  Set dtEE_Datum = GetTime4Refresh(  )
.head 8 -  Set bShowDischargeDialog = GalGetProfileBooleanX( "Settings", "ShowDischargDialog", TRUE, sUserINIFileName )
.head 8 -  Set bOk = TRUE
.head 8 -  !
.head 8 +  If bMakeDischarge
.head 9 +  If not bShowDischargeDialog
.head 10 +  If GalConnect(hSql)
.head 11 -  Set bOk = bOk and SqlPrepareAndExecute(hSql, "select bg1_key
from Bew_Grund1
where
 Einricht_ID = 1
 and	BA_Key = 'EE'
 and tod = 1
order by BG1_Key
into :sGrund1")
and SqlFetchNext(hSql, nFetch)
.head 11 -  Set bOk = bOk and SqlPrepareAndExecute(hSql, "select bg2_key
from	Bew_Grund2
where	Einricht_ID = 1 and BA_Key = 'EE'
order by BG2_Key
into :sGrund2")
and SqlFetchNext(hSql, nFetch)
.head 11 -  Call SqlDisconnect(hSql)
.head 11 +  If NOT bOk
.head 12 -  Call GalMessageBox("Death reason(s) not specified correctly! You cannot proceed without discharge dialog.", "Error", MB_Ok)
.head 12 -  Return FALSE
.head 9 +  Else
.head 10 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, 'EE', dtEE_Datum, sGrund1, sGrund2 )
.head 11 -  Return FALSE
.head 8 +  Else
.head 9 -  Set bCulling = TRUE
.head 8 -  Set oCullingData.sDischargeReason1 = sGrund1
.head 8 -  Set oCullingData.sDischargeReason2 = sGrund2
.head 8 -  Set oCullingData.dtCulling = dtEE_Datum
.head 8 -  Set sFallList=''
.head 8 -  Set nInd = 0
.head 8 -  ! if reason is DEATH and animals not culling - start dlgculling
.head 8 +  If sGrund1= 'DEATH'
.head 9 +  While nInd < n2Trans
.head 10 +  If nFallKey2Trans[ nInd ] ! And sBettKey2Trans[ nInd ]
.head 11 -  Set nFall = nFallKey2Trans[ nInd ] 
.head 11 +  If nFall
.head 12 +  If not CheckStatusObj(hBeds2Trans[ nInd ], AnimalIsDead )
.head 13 -  Set bCulling= TRUE
.head 11 +  If sFallList
.head 12 -  Set sFallList = sFallList || ','
.head 11 -  Set sFallList = sFallList || StrX( nFall )
.head 10 -  Set nInd = nInd + 1
.head 8 +  If bCulling
.head 9 +  If IDOK != SalModalDialog( dlgCulling_Prepare, hWndForm, sFallList, (NOT bShowDischargeDialog or bPOC), dtEE_Datum, oCullingData )
.head 10 -  Return FALSE
.head 8 -  Set dtKHK_RefreshTime = dtEE_Datum
.head 8 -  !
.head 8 +  If bMakeDischarge
.head 9 -  Call LT_OpenTransaction( 2, SalDateCurrent(  ) ) 
.head 8 +  Else
.head 9 -  Call LT_OpenTransaction( 9, SalDateCurrent(  ) ) 
.head 8 +  If bOk
.head 9 -  Set bOk = DoCulling(nEinrichtId, oCullingData)
.head 9 +  If bMakeDischarge
.head 10 -  Set nInd = 0
.head 10 -  Call LockSysadmAction("Perform discharge...")
.head 10 +  While bOk And nInd <= n2Trans
.head 11 +  If nFallKey2Trans[ nInd ] ! And sBettKey2Trans[ nInd ]
.head 12 -  Call _GetPositionID( hBeds2Trans[nInd], oPosObj )
.head 12 -  Set nBewNr2Trans[ nInd ] = __InsertBewegungX(
	sCurrentName, nEinrichtId, nFallKey2Trans[ nInd ], 0,
	dtEE_Datum, 'EE', sGrund1, sGrund2,
	oPosObj.sScreen , oPosObj.sRack , oPosObj.sCage, oPosObj.sBett,
	'', '', '', '', 0 )
.head 12 -  Set bOk = nBewNr2Trans[ nInd ]
.head 12 -  Call cSource[nInd].Init( oPosObj.sScreen , oPosObj.sRack , oPosObj.sCage )
.head 11 -  Set nInd = nInd + 1
.head 10 +  If bOk
.head 11 -  Call LockSysadmAction("...discharge performed")
.head 10 +  Else
.head 11 -  Call LockSysadmAction("...discharge failed")
.head 8 -  Call LT_CloseLastTransaction(  )
.head 8 -  !
.head 8 -  Call UnSelectAll(  )
.head 8 -  ! If POC open
.head 8 +  ! If hWndPOC
.head 9 -  Set nRowCage = MTblGetFirstChildRow( hWndForm, GetParent( nCageRefresh[0] ) )
.head 9 +  Loop 
.head 10 +  If nRowCage = TBL_Error
.head 11 -  Break 
.head 10 -  Set oCageRefresh = FE_GetInfo( nRowCage )
.head 10 +  If oCageRefresh.sRFID and oCageRefresh.nPortPOS
.head 11 -  Call oRefreshCages.AddRow( nRowCage )
.head 10 -  Set nRowCage = MTblGetNextChildRow( hWndForm, nRowCage )
.head 8 +  If oCullingData.nWeanLit[0]
.head 9 -  Set bNotNeedCloseCage = TRUE
.head 8 -  Call RefreshCages(  )
.head 8 +  ! If bMakeDischarge
.head 9 -  Call Rack2DView_RefreshCageContents("")
.head 8 -  Set bNotNeedCloseCage = FALSE
.head 8 -  Set nRowCage = MTblGetFirstChildRow( hWndForm, nRowRack  )
.head 8 +  If EnumChildren( nRowRack, nCageRefresh ) > 0
.head 9 -  Call ActivateRow( FindObject( nRowRack, nCageRefresh[0] ) )
.head 8 +  Else
.head 9 -  Call ActivateRow( nRowRack )
.head 8 -  Call SalPostMsg( hWndStar2000, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 8 -  Call SalSendMsg(hWndStar2000, AM_WeanAfterCulling,0,0)
.head 8 -  Call VisWaitCursor( FALSE )
.head 8 -  ! printing the cagecards 
.head 8 +  ! If bOk
.head 9 -  Set nInd = 0
.head 9 -  Set bPrintCage = FALSE
.head 9 +  While nInd<nMax
.head 10 -  Call _GetPositionID( nCageRefresh[nInd] , oPosObj )
.head 10 +  If CheckStatusObj( nCageRefresh[nInd], CageIsFull )
.head 11 -  Set bPrintCage = TRUE
.head 11 -  Call cSource[nInd].Init( oPosObj.sScreen, oPosObj.sRack,oPosObj.sCage )
.head 11 +  If SalStrScan( sCagesWRSClose, "("||oPosObj.sRack||")"||oPosObj.sCage )>-1
.head 12 -  Call cSource[nInd].SetRepeatType( "L" )
.head 10 +  Else 
.head 11 -  ! Call POC_CloseAndUnregister(hGruppe[nInd])
.head 11 -  Call CloseCage( oPosObj.nScreenID, oPosObj.nRackID, oPosObj.nCageID )
.head 10 -  Set nInd = nInd + 1
.head 9 +  If bPrintCage
.head 10 -  Call Move_PrintCageCards( cSource, cNullLocation )
.head 9 +  If nSelectedLevel = KHEL_Station
.head 10 -  Set nRowCage = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 10 +  Loop 
.head 11 +  If nRowCage = TBL_Error
.head 12 -  Break 
.head 11 -  Set oCageRefresh = FE_GetInfo( nRowCage )
.head 11 +  If oCageRefresh.nID_Obj != -100
.head 12 -  Call ActivateRow( nRowCage )
.head 12 -  Break 
.head 11 -  Set nRowCage = MTblGetNextChildRow( hWndForm, nRowCage )
.head 9 +  Else 
.head 10 -  Call ActivateRow( FindObject(FindObject(FindObject( nRoot, oPosition.nScreenID ) , oPosition.nRackID) , oPosition.nCageID ) )
.head 8 +  If hWndWorklist and VisWinIsWindow(hWndWorklist)
.head 9 -  Call SalSendMsg( hWndWorklist, AM_Refresh, wParam, lParam )
.head 8 -  Return bOk
.head 7 +  Else
.head 8 -  Return FALSE
.head 5 +  Function: Fall_Litter 
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtKHEDate
.head 7 -  Boolean: bOk
.head 7 -  Number: nMatingAge
.head 7 -  FunctionalVar: oRowData
.head 8 -  Class: cFERow
.head 7 -  Number: nFallKey
.head 7 -  Number: nRowA
.head 7 -  Boolean: bExist
.head 7 -  Number: nCageID
.head 7 -  !
.head 6 +  Actions
.head 7 -  Set dtKHEDate = GetTime4Refresh(  )
.head 7 -  Set bOk = TRUE
.head 7 -  Set nMatingAge = SalStrToNumber(GalGetProfileStringX( "KHE", "MatingAge", "30", sUserINIFileName ))
.head 7 +  If nSelectedLevel = KHEL_Bett
.head 8 -  Set oRowData = FE_GetInfo( nSelectedRow )
.head 8 +  If oRowData.GetSValue( "Sex" ) = "W"
.head 9 -  Set nFallKey = GetIdObject( nSelectedRow )
.head 9 +  If GetOptionBooleanUW( "LitterWidget", "VisibleLitterWidget", FALSE )
.head 10 +  If OpenLitterWidget( hSesionFE,0, nFallKey,-1 , hWndRack2DView) = IDCANCEL
.head 11 -  Set bOk = FALSE
.head 9 +  Else
.head 10 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( nFallKey) )
.head 10 -  Call SalPostMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data CLASSPROPSSIZE
0000: 1600
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.head 7 +  Else If nSelectedLevel = KHEL_Gruppe
.head 8 -  Set nRowA = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 8 -  Set nCageID = GetIdObject( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nRowA = TBL_Error
.head 10 -  Break
.head 9 -  Set oRowData = FE_GetInfo( nRowA )
.head 9 +  If oRowData.GetSValue( "Sex" ) = "W"
.head 10 -  Set nFallKey= GetIdObject( nRowA )
.head 10 -  Call SqlExists( "select r.RELSHIP_ID
 from relationship r,relship_fall rf,RELSHIP_TYPE rt
  where
   rf.EINRICHT_ID = :nEinrichtId
   and  rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.PLACE = 'J'
   and rf.RELSHIP_ID=r.RELSHIP_ID
   and rf.fall_key= :nFallKey
   and (@nullvalue(r.RELSHIP_END, (:dtKHEDate))>=((:dtKHEDate)-@timevalue(:dtKHEDate) - (:nMatingAge))
or exists(select lc.litter_id from litter_child lc, litter l, relship_fall rff where l.place_relship_id=rf.relship_id and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id )))", bExist )
.head 10 +  If bExist 
.head 11 +  If GetOptionBooleanUW( "LitterWidget", "VisibleLitterWidget", FALSE )
.head 12 +  If OpenLitterWidget(hSesionFE,nCageID, nFallKey, -1, hWndRack2DView  ) = IDCANCEL
.head 13 -  Set bOk = FALSE
.head 11 +  Else
.head 12 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( nFallKey) )
.head 12 -  Call SalPostMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data INHERITPROPS
0000: 0100
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.data CLASSPROPSSIZE
0000: 1600
.enddata
.head 11 -  Break
.head 9 -  Set nRowA = MTblGetNextChildRow( hWndForm, nRowA )
.head 7 +  !
.head 8 -  Set nBet= EnumChildren( nSelectedHandle, hBet )
.head 8 -  Call _GetPositionID( nSelectedHandle, oPos )
.head 8 +  If nBet
.head 9 -  Set i=0
.head 9 +  Loop 
.head 10 +  If i >=nBet
.head 11 -  Break 
.head 10 -  Call GetItemData( hBet[i], sText, nValueLoc, nFlags )
.head 10 +  If SalStrScan(sText, ', F,')>0 
.head 11 -  Set nFallKey= GetFallKey_ByHandle( hBet[i] )
.head 11 -  Call SqlExists( "select r.RELSHIP_ID
 from relationship r,relship_fall rf,RELSHIP_TYPE rt
  where
   rf.EINRICHT_ID = :nEinrichtId
   and  rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.PLACE = 'J'
   and rf.RELSHIP_ID=r.RELSHIP_ID
   and rf.fall_key= :nFallKey
   and (@nullvalue(r.RELSHIP_END, (:dtKHEDate))>=((:dtKHEDate)-@timevalue(:dtKHEDate) - (:nMatingAge))
or exists(select lc.litter_id from litter_child lc, litter l, relship_fall rff where l.place_relship_id=rf.relship_id and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id )))", bExist )
.head 11 +  If bExist 
.head 12 -  ! Set nIndex = GetItemIndex(  hBet[i] )
.head 12 +  ! If Not SalListSetSelect( hWndItem, nIndex )
.head 13 -  Return FALSE
.head 12 -  ! Set nSelectedLevel = KHEL_Bett
.head 12 -  ! Call ActivateSelectedItem(  )     
.head 12 +  If GalGetProfileBooleanX( "LitterWidget", "VisibleLitterWidget", FALSE, sUserINIFileName )
.head 13 +  ! If SalModalDialog( dlgChooseLitterEdit, hWndForm, GetFallKey_ByHandle(hBet[i]),-1) = IDCANCEL
.head 14 -  Set bOk = FALSE
.head 13 -  ! Call _GetPositionID( nSelectedHandle, oPosition )
.head 13 +  If OpenLitterWidget(hActiveSession,oPos.nCageID, GetFallKey_ByHandle(hBet[i]), -1, hWndRack2DView  ) = IDCANCEL
.head 14 -  Set bOk = FALSE
.head 12 +  Else 
.head 13 -  Call SalSendMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( GetFallKey_ByHandle(hBet[i])) )
.head 13 -  Call SalPostMsg( hWndFall, AM_Menu, 1, FMenu_Bearb_Neugeb )
.data CLASSPROPSSIZE
0000: 1600
.enddata
.data CLASSPROPS
0000: 4F4C455F4D454E55 5F47524F55500004 000000000000
.enddata
.head 12 -  Break 
.head 10 +  Else If i =nBet
.head 11 -  Set bOk = FALSE
.head 10 -  Set i=i+1
.head 8 -  !
.head 7 -  Return bOk
.head 5 +  Function: DistributionAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCountAnimal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nrEmptyCages[*]
.head 7 -  Number: nrStockCages[*]
.head 7 -  Number: nEmptyCages
.head 7 -  Number: nStockCages
.head 7 -  Date/Time: dtKHE
.head 7 -  Number: nInd
.head 7 -  Number: nIndEmpty
.head 7 -  Number: nI
.head 7 -  Number: nFall[*]
.head 7 -  Number: nChilds
.head 7 -  FunctionalVar: oSourceData
.head 8 -  Class: cPositionData
.head 7 -  !
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set bOk = bOk and CanDistributionAnimal( nCountAnimal )
.head 7 +  If bOk 
.head 8 -  Set nStockCages = GetOpenCages( GetParent(GetParent(nSelectedRow )), CageIsFull , nrStockCages )
.head 8 -  Set nEmptyCages = GetOpenCages( GetParent(GetParent(nSelectedRow )), CageIsEmpty, nrEmptyCages )
.head 8 -  !
.head 8 -  Call oRefreshCages.Init(  )
.head 8 -  !
.head 8 -  Set nInd = 0 
.head 8 +  While nInd<nStockCages
.head 9 +  If nrStockCages[nI] = nSelectedRow
.head 10 -  Set nrStockCages[nI] = nrStockCages[0]
.head 10 -  Set nrStockCages[0] = nSelectedRow
.head 10 -  Set nInd = nStockCages
.head 9 -  Set nInd = nInd + 1 
.head 8 -  !
.head 8 -  Set dtKHE = GetTime4Refresh(  )
.head 8 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 8 -  Call LockSysadmAction("Distribute animals...")
.head 8 -  Set nInd = 0 
.head 8 -  Set nI = 0 
.head 8 -  Set nChilds = 0 
.head 8 -  Set nIndEmpty = 0 
.head 8 +  While nInd < nStockCages and nIndEmpty<nEmptyCages
.head 9 +  If nChilds = nI
.head 10 -  Set nChilds = EnumChildren( nrStockCages[nInd], nFall )
.head 10 -  Call oRefreshCages.AddRow( nrStockCages[nInd] )
.head 10 -  Set nInd = nInd + 1
.head 10 -  Set nI = 0
.head 9 +  While nI<nChilds and nIndEmpty<nEmptyCages
.head 10 -  Call _GetPositionID( nrEmptyCages[nIndEmpty], oSourceData )
.head 10 -  Call InsertBewegung( nFall[nI] , 0, dtKHE, "UE","", "", oSourceData.sScreen, oSourceData.sRack, oSourceData.sCage, "1","", "", "", "" )
.head 10 -  Call oRefreshCages.AddRow( nrEmptyCages[nIndEmpty] )
.head 10 -  Set nI = nI + 1
.head 10 -  Set nIndEmpty = nIndEmpty + 1
.head 8 -  !
.head 8 -  ! Refresh cages 
.head 8 -  Call RefreshCages()
.head 8 -  Call LockSysadmAction("...animals distributed")
.head 8 -  Call LT_CloseLastTransaction()
.head 7 -  Return bOk
.head 5 +  Function: CollectAnimals
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nStockCages
.head 7 -  Number: nrStockCages[*]
.head 7 -  Number: nI_SC
.head 7 -  Number: nI
.head 7 -  Number: nChilds
.head 7 -  Number: nFall[*]
.head 7 -  FunctionalVar: oSourceData
.head 8 -  Class: cPositionData
.head 7 -  Date/Time: dtKHE
.head 6 +  Actions
.head 7 -  Set bOk = CanCollect(  )
.head 7 +  If bOk
.head 8 -  Call LockSysadmAction("Collect animals...")
.head 8 -  Call oRefreshCages.Init(  )
.head 8 -  Set nStockCages = GetOpenCages( GetParent(GetParent(nSelectedRow )), CageIsFull , nrStockCages )
.head 8 -  Call _GetPositionID( nSelectedRow , oSourceData )
.head 8 -  Call oRefreshCages.AddRow( nSelectedRow)
.head 8 -  Set dtKHE = GetTime4Refresh(  )
.head 8 -  Set nI_SC = 0
.head 8 -  Set nChilds = 0
.head 8 +  While nI_SC < nStockCages
.head 9 +  If nSelectedRow != nrStockCages[nI_SC]
.head 10 -  Set nChilds = EnumChildren( nrStockCages[nI_SC], nFall )
.head 10 +  If nChilds
.head 11 -  Call oRefreshCages.AddRow( nrStockCages[nI_SC] )
.head 10 -  Set nI = 0
.head 10 +  While nI < nChilds
.head 11 -  Call InsertBewegung( nFall[nI] , 0, dtKHE, "UE","", "", oSourceData.sScreen, oSourceData.sRack, oSourceData.sCage, AddWonBettX( oSourceData.sScreen, oSourceData.sRack, oSourceData.sCage,dtKHE ),"", "", "", "" )
.head 11 -  Set nI = nI + 1
.head 9 -  Set nI_SC = nI_SC + 1
.head 8 -  Call RefreshCages()
.head 8 -  Call LockSysadmAction("...animals collected")
.head 7 -  Return bOk
.head 5 +  Function: LitterStrain
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Date/Time: dtDT
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  String: sStrain
.head 7 -  String: sSex0
.head 7 -  String: sSex
.head 7 -  String: sStrain_Mother
.head 7 -  String: sStrain_Father
.head 7 -  String: sStrain_Litter
.head 7 -  String: sSpecies
.head 7 -  Number: nFetch
.head 7 -  Boolean: bStop
.head 7 -  Number: nFall
.head 7 -  Number: nFall_Mother
.head 7 -  Number: nFall_Father
.head 6 +  Actions
.head 7 -  Set sStrain_Litter=""
.head 7 -  Set sSex0=""
.head 7 -  Set bStop = FALSE
.head 7 +  ! If sStrain_Mother=sStrain_Father
.head 8 -  Return sStrain_Mother
.head 7 +  ! If not GalConnect(hSql)
.head 8 -  Return sStrain_Litter
.head 7 +  If TRUE ! bRealTimeMode
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulateR , "select s.STRAIN_KEY , f.geschl,l.KONFES_KEY, f.fall_key
from
 fall f, gruppe g, le l, strain_n s
where
 f.LAST_stat_key = :sRack
 and f.LAST_gruppe_key = :sCage
 and f.LAST_ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and f.einricht_id = g.einricht_id
 and f.last_stat_key = g.stat_key
 and f.last_gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.le_id=l.le_id
and f.ID_strain = s.ID
group by 2,1,3,4
into :sStrain, :sSex, :sSpecies, :nFall " )
.head 7 +  ! Else
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulateR, "select s.STRAIN_KEY , f.geschl,l.KONFES_KEY, f.fall_key
from
 bewegung b, fall f, gruppe g, le l, strain_n s
where
 b.stat_key = :sRack
 and b.gruppe_key = :sCage
 and b.geloescht = 'N'
 and b.ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and :dtDT between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.einricht_id = b.einricht_id
 and f.fall_key = b.fall_key
 and f.le_id=l.le_id
 and f.ID_strain = s.ID
group by 2,1,3,4
into :sStrain, :sSex, :sSpecies, :nFall" )
.head 7 +  While SqlFetchNext( hSqlPopulateR, nFetch ) and (NOT  bStop)
.head 8 +  If sSex != sSex0
.head 9 +  If sSex = 'M' 
.head 10 -  Set sStrain_Father = sStrain
.head 10 -  Set nFall_Father = nFall
.head 9 +  Else
.head 10 -  Set sStrain_Mother= sStrain
.head 10 -  Set nFall_Mother = nFall
.head 8 +  Else
.head 9 -  Set bStop=TRUE
.head 8 +  If sSex0 = ""
.head 9 -  Set sSex0 = sSex
.head 7 +  If not bStop and sStrain != STRING_Null
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulateR, "select s.strain_key
  from relship_fall rf1
 join relship_fall rf2 on (rf2.relship_id=rf1.relship_id)
 join relationship r on (r.relship_id=rf1.relship_id)
 left join strain s on (s.id=r.id_str_family)
where rf1.einricht_id=:nEinrichtId 
and rf1.fall_key=:nFall_Mother
and rf1.fallrolle_key='MATE' 
and @nullvalue(rf1.rs_fall_valid,@now+35) > @now
and rf2.einricht_id=:nEinrichtId 
and rf2.fall_key=:nFall_Father
 into :sStrain_Litter")
.head 8 -  Call SqlFetchNext( hSqlPopulateR, nFetch )
.head 7 -  ! Call SqlDisconnect( hSql )
.head 7 -  Return sStrain_Litter
.head 5 +  Function: CloseGaps0
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Boolean: bMakeAction
.head 7 -  Boolean: bTerminateBySex
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sTmp
.head 7 -  Date/Time: dtNow
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sStopCage
.head 7 -  Number: nRackHandle
.head 7 -  Number: hCages[*]
.head 7 -  Number: nOfCages
.head 7 -  Number: nCount
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sCagesList
.head 7 -  Boolean: bNeedNext
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oPosC
.head 8 -  Class: cPositionData
.head 7 -  Number: nRow
.head 7 -  Number: nStopCageID
.head 7 -  Number: nStartCageID
.head 6 +  Actions
.head 7 -  ! ********** silly values ******
.head 7 -  Set dtNow = GetTime4Refresh()
.head 7 -  Call _GetPositionID( nSelectedRow, oPos )
.head 7 -  Set sCage = oPos.sCage
.head 7 -  Set nStartCageID = oPos.nCageID
.head 7 -  Set nRackHandle = GetParent(nSelectedRow)
.head 7 -  !
.head 7 -  Set sStopCage = ""
.head 7 -  Set sCagesList = ""
.head 7 -  Set nOfCages = 0
.head 7 -  Set nRow= MTblGetFirstChildRow( hWndForm, nRackHandle )
.head 7 +  Loop
.head 8 +  If nRow = TBL_Error
.head 9 -  Break
.head 8 +  If MTblQueryRowFlags( hWndForm, nRow, MTBL_ROW_ISEXPANDED )
.head 9 -  Call _GetPositionID( nRow, oPosC )
.head 9 +  If sCagesList
.head 10 -  Set sCagesList = sCagesList||","
.head 9 -  Set sCagesList = sCagesList||"'"||oPosC.sCage||"'"
.head 9 -  Set nOfCages = nOfCages + 1
.head 8 -  Set nRow= MTblGetNextChildRow( hWndForm, nRow )
.head 7 +  If sCagesList
.head 8 -  Call SqlPrepareAndExecute(hSqlPopulate , "select 
gruppe_key , id
from 
gruppe 
where stat_key =:oPosC.sRack
and gruppe_key in ("||sCagesList||")
order by y_pos_label, x_pos_label
into :sStopCage, :nStopCageID   ")
.head 8 -  Set bNeedNext = FALSE
.head 8 +  While SqlFetchNext(hSqlPopulate, nFetch)
.head 9 +  If bNeedNext
.head 10 -  Break
.head 9 +  If nOfCages=2
.head 10 -  Set sCage = sStopCage
.head 10 -  Set nStartCageID = nStopCageID
.head 9 +  If sStopCage = sCage
.head 10 -  Set bNeedNext = TRUE
.head 8 +  If sStopCage = sCage
.head 9 -  Set sStopCage = ""
.head 9 -  Set nStopCageID = NUMBER_Null
.head 7 -  !
.head 7 -  ! Return CloseGaps(oPos.sScreen, oPosC.sRack, sCage, dtNow, bMakeAction, bTerminateBySex, sStopCage)
.head 7 -  Return CloseGaps(oPos.nScreenID,  nStartCageID, dtNow, bMakeAction, bTerminateBySex, nStopCageID)
.head 5 +  Function: CloseGaps
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nScrID
.head 7 -  Number: nCageID
.head 7 -  Date/Time: dtDt
.head 7 -  Boolean: bMakeAction
.head 7 -  Boolean: bTerminateBySex
.head 7 -  Number: nStopCageID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! Sql Handle: hSql
.head 7 -  ! Sql Handle: hSqlPlan
.head 7 -  ! Sql Handle: hSqlReal
.head 7 -  String: sFrom[*]
.head 7 -  String: sTo[*]
.head 7 -  Number: nSource[*]
.head 7 -  Number: nTarget[*]
.head 7 -  Number: nNumberOfTargets
.head 7 -  Number: nNumberOfSources
.head 7 -  String: sStrainTarget
.head 7 -  String: sStrainR
.head 7 -  String: sStrainR1
.head 7 -  String: sSexTarget
.head 7 -  String: sSexR
.head 7 -  String: sSexR1
.head 7 -  String: sScreen
.head 7 -  String: sScreen1
.head 7 -  String: sCurrentCageR
.head 7 -  Number: nCurrentCageID
.head 7 -  Number: nCurrentCageIdR
.head 7 -  Number: nYReal
.head 7 -  Date/Time: dtNow
.head 7 -  Number: nFetch
.head 7 -  Number: nFetchPlan
.head 7 -  Number: nFetchReal
.head 7 -  Boolean: bTerminate
.head 7 -  String: sSQL
.head 7 -  String: sTemp
.head 7 -  Number: hStat
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nChild
.head 7 -  Number: i
.head 7 -  !
.head 7 -  ! Number: nCageID
.head 7 -  ! Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  String: sXStart
.head 7 -  Number: nYStart
.head 7 -  String: sXEnd
.head 7 -  Number: nYEnd
.head 7 -  Number: nY
.head 7 -  String: sCurrentCage
.head 7 -  String: sCurrentCageP
.head 7 -  Number: nYPlan
.head 7 -  String: sStrainP
.head 7 -  String: sStrainP1
.head 7 -  FunctionalVar: oCage
.head 8 -  Class: cPositionData
.head 7 -  String: sScreen0
.head 7 -  String: sRack0
.head 7 -  String: sCage0
.head 7 -  Window Handle: hWndProgress
.head 7 -  String: sText
.head 7 -  Number: nI
.head 7 -  Number: nCloseCages[*]
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSourceCard[*]
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nPrint
.head 6 +  Actions
.head 7 -  Set nNumberOfTargets = 0
.head 7 -  Set nNumberOfSources = 0
.head 7 -  Set nPrint = 0
.head 7 -  ! Call SqlPrepareAndExecute(hSqlPopulate,"select scr_id, rack_id from abt_stat
where abt_key=:sScreen0 and stat_key=:sRack0  into :nScrID, :nRackID ")
.head 7 -  Call SqlPrepareAndExecute(hSqlPopulate,"select abt_key  from abteilung
where id=:nScrID  into :sScreen0 ")
.head 7 -  Call SqlFetchNext(hSqlPopulate, nFetch)
.head 7 -  Call SqlPrepareAndExecute(hSqlPopulate,"select @VALUE(y_pos_label), x_pos_label, gruppe_key, stat_key,rack_id from gruppe where id=:nCageID into :nYStart, :sXStart, :sCage0, :sRack0, :nRackID")
.head 7 +  If SqlFetchNext(hSqlPopulate, nFetch)
.head 8 +  If nStopCageID
.head 9 -  Call SqlPrepareAndExecute(hSqlPopulate, "select @VALUE(y_pos_label), x_pos_label from gruppe where id = :nStopCageID into :nYEnd, :sXEnd")
.head 9 -  Call SqlFetchNext(hSqlPopulate, nFetch)
.head 8 +  If SqlPrepareAndExecute(hSqlPopulate, "select
 g.id, b.gruppe_key, @VALUE(y_pos_label)
from
 bett b, gruppe g
where b.einricht_id =:nEinrichtId
 and b.canceled = 'N'
 and b.rack_id = :nRackID
 and b.CAGE_ID = g.ID
 and g.canceled = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, 3,x_pos_label
order by
 3, x_pos_label
into :nCurrentCageID, :sCurrentCage, :nY")
.head 9 +  If SqlPrepareAndExecute(hSqlPopulateC, "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY)
from
 bett_locks b, fall f, gruppe g, STRAIN s
where b.einricht_id =:nEinrichtId
  and b.stat_key = :sRack0
 and :dtDt between b.von and @NULLVALUE(b.bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.fall_key = b.planbew_fall
 and f.einricht_id = b.einricht_id
 and f.ID_STRAIN=s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageP, :nYPlan, :sStrainP, :sStrainP1")
.head 10 -  Set sSQL = "select 
 g.id, g.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY), min(f.LAST_ABT_KEY), max(f.LAST_ABT_KEY), min(f.geschl), max(f.geschl)
from fall f
join gruppe g on (g.id=f.last_cage_id and g.rack_id=:nRackID)
join STRAIN s on (s.ID = f.id_strain )
where 
f.einricht_id=:nEinrichtId
and f.geloescht = 'N'
and f.ee_datum is null and f.culling_id is null
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))"
.head 10 +  If nStopCageID
.head 11 -  Set sSQL = sSQL||"
and (@VALUE(y_pos_label)<:nYEnd or (@VALUE(y_pos_label) = :nYEnd and x_pos_label<=:sXEnd))"
.head 10 -  Set sSQL = sSQL||"
group by
 1,2,3, x_pos_label
order by
 3, x_pos_label
into
 :nCurrentCageIdR, :sCurrentCageR, :nYReal, :sStrainR, :sStrainR1, :sScreen, :sScreen1, :sSexR, :sSexR1"
.head 10 +  If SqlPrepareAndExecute(hSqlPopulateW , sSQL)
.head 11 -  ! detect strain
.head 11 -  Set sStrainP = ""
.head 11 -  Set sStrainP1 = ""
.head 11 -  Set sStrainR = ""
.head 11 -  Set sStrainR1 = ""
.head 11 -  Set sStrainTarget = ""
.head 11 -  Set sSexR = ""
.head 11 -  Set sSexR1 = ""
.head 11 -  Set sSexTarget = ""
.head 11 -  Call SqlFetchNext(hSqlPopulateC, nFetchPlan)
.head 11 -  Call SqlFetchNext(hSqlPopulateW, nFetchReal)
.head 11 +  If nStopCageID and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 12 -  Set bTerminate = FALSE
.head 12 +  If NOT SqlFetchNext(hSqlPopulate , nFetch)
.head 13 -  Set bTerminate = TRUE
.head 12 +  While NOT bTerminate
.head 13 +  If sCurrentCage = sCurrentCageP
.head 14 -  Set bTerminate = TRUE
.head 13 +  Else
.head 14 +  If sCurrentCage = sCurrentCageR
.head 15 +  If not sSexTarget
.head 16 -  Set sSexTarget = sSexR
.head 13 +  If (sScreen0 != sScreen1) or (sScreen0 != sScreen)
.head 14 -  Set bTerminate = TRUE
.head 13 +  If sCurrentCage = sCurrentCageP
.head 14 -  Set bTerminate = TRUE
.head 13 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 14 -  Set bTerminate = TRUE
.head 13 +  If sCurrentCage != sCurrentCageR and not bTerminate
.head 14 -  Set nNumberOfSources = nNumberOfSources+1
.head 14 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 14 -  Set sFrom[nNumberOfSources-1] = sCurrentCageR
.head 14 -  Set nSource[nNumberOfSources-1] = nCurrentCageIdR
.head 14 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 14 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 14 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 14 -  Set nTarget[nNumberOfTargets-1] = nCurrentCageID
.head 13 +  If NOT SqlFetchNext(hSqlPopulateW , nFetchReal)
.head 14 -  Set bTerminate = TRUE
.head 13 +  If NOT SqlFetchNext(hSqlPopulate, nFetch)
.head 14 -  Set bTerminate = TRUE
.head 12 +  If nNumberOfSources and bMakeAction
.head 13 -  Call LT_OpenTransaction(5,dtDt)
.head 13 -  Call LockSysadmAction("Close gaps started...")
.head 13 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nNumberOfSources  )
.head 13 -  Set nI = 0
.head 13 +  While nI < nNumberOfSources
.head 14 +  If hWndProgress
.head 15 -  Set sText = "Move cage " || sScreen0 || "/" || sRack0  ||"/" ||sFrom[nI]
.head 15 -  Set sText = sText || " to  cage" || sScreen0|| "/" || sRack0 ||"/" ||sTo[nI]
.head 15 -  Call dlgProgress.Init( nNumberOfSources, sText)
.head 15 -  Set dlgProgress.nCurrent = nI
.head 15 -  Call dlgProgress.Next(  )
.head 14 -  Call MoveCage(nScrID, nRackID, nSource[nI], nScrID, nRackID, nTarget[nI], dtDt )
.head 14 -  Call cSourceCard[nPrint].Init( sScreen0, sRack0, sTo[nI])
.head 14 -  Set nPrint = nPrint + 1
.head 14 -  Set nI = nI + 1
.head 13 -  Set cDest = cSourceCard[nPrint-1]
.head 13 -  Call PrintCageCards( cSourceCard, cDest )
.head 13 +  If hWndProgress
.head 14 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 14 -  Set hWndProgress = hWndNULL
.head 13 -  Call LockSysadmAction("...close gaps finished")
.head 13 -  Call LT_CloseLastTransaction()
.head 13 -  Set hStat = FindObject(FindObject( nRoot, nScrID ), nRackID )
.head 13 -  Set nI = EnumChildren(hStat,nCloseCages )
.head 13 +  While nI > 0
.head 14 -  Call CloseCageByRow( FindObject( hStat  , nCloseCages[nI-1] ) )
.head 14 -  Set nI = nI - 1
.head 11 +  Else
.head 12 +  If (sStrainR != "")  and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 13 -  Set bTerminate = FALSE
.head 13 +  While (NOT bTerminate) and SqlFetchNext(hSqlPopulate , nFetch)
.head 14 +  If sCurrentCage = sCurrentCageP
.head 15 -  Set bTerminate = TRUE
.head 14 +  Else
.head 15 +  If sCurrentCage = sCurrentCageR
.head 16 +  If (sStrainR1 = sStrainR)
.head 17 -  Set sStrainTarget = sStrainR
.head 17 +  If not sSexTarget
.head 18 -  Set sSexTarget = sSexR
.head 16 +  Else
.head 17 +  If sSexR != sSexR1
.head 18 -  Set sStrainTarget = LitterStrain(  sRack0, sCurrentCage, dtDt  )
.head 17 +  If not sSexTarget
.head 18 -  Set sSexTarget = sSexR1
.head 16 -  Set bTerminate = TRUE
.head 13 +  If sStrainTarget
.head 14 -  Call SqlFetchRow(hSqlPopulate, 0, nFetch)
.head 14 -  Set bTerminate = FALSE
.head 14 +  While NOT bTerminate
.head 15 +  If sCurrentCage = sCurrentCageP
.head 16 -  Set bTerminate = TRUE
.head 15 +  Else
.head 16 +  If sCurrentCage = sCurrentCageR
.head 17 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 18 -  Set bTerminate = TRUE
.head 17 +  Else
.head 18 +  If ((sStrainR = sStrainR1 and sStrainR = sStrainTarget) or (sStrainR != sStrainR1 and LitterStrain(  sRack0, sCurrentCage, dtDt  )= sStrainTarget) ) and (sScreen0 = sScreen1) and (sScreen0 = sScreen)
.head 19 +  If nNumberOfTargets>0
.head 20 -  Set nNumberOfSources = nNumberOfSources+1
.head 20 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 20 -  Set sFrom[nNumberOfSources-1] = sCurrentCage
.head 20 -  Set nSource[nNumberOfSources-1]  = nCurrentCageID
.head 20 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 20 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 20 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 20 -  Set nTarget[nNumberOfTargets-1]  = nCurrentCageID
.head 19 +  If NOT SqlFetchNext(hSqlPopulateW , nFetchReal)
.head 20 -  Set bTerminate = TRUE
.head 18 +  Else
.head 19 -  Set bTerminate = TRUE
.head 16 +  Else
.head 17 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 17 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 17 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 17 -  Set nTarget[nNumberOfTargets-1]  = nCurrentCageID
.head 16 +  If NOT SqlFetchNext(hSqlPopulate , nFetch)
.head 17 -  Set bTerminate = TRUE
.head 14 +  If nNumberOfSources and bMakeAction
.head 15 -  Call LT_OpenTransaction(5,dtDt)
.head 15 -  Call LockSysadmAction("Close gaps started...")
.head 15 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nNumberOfSources  )
.head 15 -  Set nI = 0
.head 15 +  While nI < nNumberOfSources
.head 16 +  If hWndProgress
.head 17 -  Set sText = "Move cage " || sScreen0 || "/" || sRack0  ||"/" ||sFrom[nI]
.head 17 -  Set sText = sText || " to  cage" || sScreen0|| "/" || sRack0 ||"/" ||sTo[nI]
.head 17 -  Call dlgProgress.Init( nNumberOfSources, sText)
.head 17 -  Set dlgProgress.nCurrent = nI
.head 17 -  Call dlgProgress.Next(  )
.head 16 -  Call MoveCage(nScrID, nRackID, nSource[nI], nScrID, nRackID, nTarget[nI], dtDt )
.head 16 -  Call cSourceCard[nPrint].Init( sScreen0, sRack0, sTo[nI])
.head 16 -  Set nPrint = nPrint + 1
.head 16 -  Set nI = nI + 1
.head 15 -  Set cDest = cSourceCard[nPrint-1]
.head 15 -  Call PrintCageCards( cSourceCard, cDest )
.head 15 +  If hWndProgress
.head 16 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 16 -  Set hWndProgress = hWndNULL
.head 15 -  Call LockSysadmAction("...close gaps finished")
.head 15 -  Call LT_CloseLastTransaction()
.head 15 -  Set hStat = FindObject(FindObject( nRoot, nScrID ), nRackID ) 
.head 15 -  Set nI = EnumChildren(hStat,nCloseCages )
.head 15 +  While nI > 0
.head 16 -  Call CloseCageByRow( FindObject( hStat , nCloseCages[nI-1] ) )
.head 16 -  Set nI = nI - 1
.head 15 -  ! Set nChild = EnumChildren( hStat, hChildren )
.head 15 +  ! If nChild
.head 16 -  Set i = 0
.head 16 +  Loop 
.head 17 +  If i >= nChild
.head 18 -  Break 
.head 17 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 17 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 17 -  Set i = i + 1
.head 7 -  !
.head 7 +  If nNumberOfSources and (NOT bMakeAction)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_CGSetSequence, 0, SalHStringToNumber(sTo[0]||","||sFrom[nNumberOfSources-1]))
.head 7 +  Else
.head 8 +  If NOT bMakeAction
.head 9 -  Call SalSendMsg(hWndStar2000, AM_CGSetSequence, 0, SalHStringToNumber(""))
.head 7 +  If bMakeAction
.head 8 -  Call Rack2DView_RefreshCageContents("")
.head 7 -  Call SalArraySetUpperBound(sFrom, 1, -1)
.head 7 -  Call SalArraySetUpperBound(sTo, 1, -1)
.head 7 -  Call SalArraySetUpperBound(nSource , 1, -1)
.head 7 -  Call SalArraySetUpperBound(nTarget, 1, -1)
.head 7 -  Return nNumberOfSources
.head 5 +  Function: CloseGapsOld
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sScreen0
.head 7 -  String: sRack0
.head 7 -  String: sCage0
.head 7 -  Date/Time: dtDt
.head 7 -  Boolean: bMakeAction
.head 7 -  Boolean: bTerminateBySex
.head 7 -  String: sStopCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! Sql Handle: hSql
.head 7 -  ! Sql Handle: hSqlPlan
.head 7 -  ! Sql Handle: hSqlReal
.head 7 -  String: sFrom[*]
.head 7 -  String: sTo[*]
.head 7 -  Number: nNumberOfTargets
.head 7 -  Number: nNumberOfSources
.head 7 -  String: sStrainTarget
.head 7 -  String: sStrainR
.head 7 -  String: sStrainR1
.head 7 -  String: sSexTarget
.head 7 -  String: sSexR
.head 7 -  String: sSexR1
.head 7 -  String: sScreen
.head 7 -  String: sScreen1
.head 7 -  String: sCurrentCageR
.head 7 -  Number: nYReal
.head 7 -  Date/Time: dtNow
.head 7 -  Number: nFetch
.head 7 -  Number: nFetchPlan
.head 7 -  Number: nFetchReal
.head 7 -  Boolean: bTerminate
.head 7 -  String: sSQL
.head 7 -  String: sTemp
.head 7 -  Number: hStat
.head 7 -  Number: hChildren[*]
.head 7 -  Number: nChild
.head 7 -  Number: i
.head 7 -  !
.head 7 -  Number: nCageID
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  String: sXStart
.head 7 -  Number: nYStart
.head 7 -  String: sXEnd
.head 7 -  Number: nYEnd
.head 7 -  Number: nY
.head 7 -  String: sCurrentCage
.head 7 -  String: sCurrentCageP
.head 7 -  Number: nYPlan
.head 7 -  String: sStrainP
.head 7 -  String: sStrainP1
.head 7 -  FunctionalVar: oCage
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set nNumberOfTargets = 0
.head 7 -  Set nNumberOfSources = 0
.head 7 -  Call SqlPrepareAndExecute(hSqlPopulate,"select scr_id, rack_id from abt_stat
where abt_key=:sScreen0 and stat_key=:sRack0  into :nScrID, :nRackID ")
.head 7 -  Call SqlFetchNext(hSqlPopulate, nFetch)
.head 7 -  Call SqlPrepareAndExecute(hSqlPopulate,"select @VALUE(y_pos_label), x_pos_label, gruppe_key, stat_key from gruppe where gruppe_key=:sCage0 and stat_key=:sRack0 into :nYStart, :sXStart, :sCage0, :sRack0")
.head 7 +  If SqlFetchNext(hSqlPopulate, nFetch)
.head 8 +  If sStopCage
.head 9 -  Call SqlPrepareAndExecute(hSqlPopulate, "select @VALUE(y_pos_label), x_pos_label from gruppe where gruppe_key = :nCageID into :nYEnd, :sXEnd")
.head 9 -  Call SqlFetchNext(hSqlPopulate, nFetch)
.head 8 +  If SqlPrepareAndExecute(hSqlPopulate, "select
 b.gruppe_key, @VALUE(y_pos_label)
from
 bett b, gruppe g
where b.einricht_id =:nEinrichtId
 and b.canceled = 'N'
 and b.stat_key = :sRack0
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into :sCurrentCage, :nY")
.head 9 +  If SqlPrepareAndExecute(hSqlPopulateC, "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY)
from
 bett_locks b, fall f, gruppe g, STRAIN_N s
where b.einricht_id =:nEinrichtId
 and b.stat_key = :sRack0
 and :dtDt between b.von and @NULLVALUE(b.bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.fall_key = b.planbew_fall
 and f.einricht_id = b.einricht_id
 and f.ID_STRAIN=s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageP, :nYPlan, :sStrainP, :sStrainP1")
.head 10 -  Set sSQL = "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY), min(b.abt_key), max(b.abt_key), min(f.geschl), max(f.geschl)
from
 bewegung b, fall f, gruppe g, STRAIN_N s
where b.einricht_id =:nEinrichtId
 and b.stat_key = :sRack0
 and b.geloescht = 'N'
 and b.ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and :dtDt between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.einricht_id = b.einricht_id
 and f.fall_key = b.fall_key
 and f.ID_STRAIN = s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))"
.head 10 +  If sStopCage
.head 11 -  Set sSQL = sSQL||"
and (@VALUE(y_pos_label)<:nYEnd or (@VALUE(y_pos_label) = :nYEnd and x_pos_label<=:sXEnd))"
.head 10 -  Set sSQL = sSQL||"
group by
 1,2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageR, :nYReal, :sStrainR, :sStrainR1, :sScreen, :sScreen1, :sSexR, :sSexR1"
.head 10 +  If SqlPrepareAndExecute(hSqlPopulateW , sSQL)
.head 11 -  ! detect strain
.head 11 -  Set sStrainP = ""
.head 11 -  Set sStrainP1 = ""
.head 11 -  Set sStrainR = ""
.head 11 -  Set sStrainR1 = ""
.head 11 -  Set sStrainTarget = ""
.head 11 -  Set sSexR = ""
.head 11 -  Set sSexR1 = ""
.head 11 -  Set sSexTarget = ""
.head 11 -  Call SqlFetchNext(hSqlPopulateC, nFetchPlan)
.head 11 -  Call SqlFetchNext(hSqlPopulateW, nFetchReal)
.head 11 +  If sStopCage and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 12 -  Set bTerminate = FALSE
.head 12 +  If NOT SqlFetchNext(hSqlPopulate , nFetch)
.head 13 -  Set bTerminate = TRUE
.head 12 +  While NOT bTerminate
.head 13 +  If sCurrentCage = sCurrentCageP
.head 14 -  Set bTerminate = TRUE
.head 13 +  Else
.head 14 +  If sCurrentCage = sCurrentCageR
.head 15 +  If not sSexTarget
.head 16 -  Set sSexTarget = sSexR
.head 13 +  If (sScreen0 != sScreen1) or (sScreen0 != sScreen)
.head 14 -  Set bTerminate = TRUE
.head 13 +  If sCurrentCage = sCurrentCageP
.head 14 -  Set bTerminate = TRUE
.head 13 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 14 -  Set bTerminate = TRUE
.head 13 +  If sCurrentCage != sCurrentCageR and not bTerminate
.head 14 -  Set nNumberOfSources = nNumberOfSources+1
.head 14 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 14 -  Set sFrom[nNumberOfSources-1] = sCurrentCageR
.head 14 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 14 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 14 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 13 +  If NOT SqlFetchNext(hSqlPopulateW , nFetchReal)
.head 14 -  Set bTerminate = TRUE
.head 13 +  If NOT SqlFetchNext(hSqlPopulate, nFetch)
.head 14 -  Set bTerminate = TRUE
.head 12 +  If nNumberOfSources and bMakeAction
.head 13 -  Call LT_OpenTransaction(5,dtDt)
.head 13 -  Call LockSysadmAction("Close gaps started...")
.head 13 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 13 -  Call LockSysadmAction("...close gaps finished")
.head 13 -  Call LT_CloseLastTransaction()
.head 13 -  ! Set hStat =  FindChild( FindChild( hRoot, sScreen0 ), sRack0 )
.head 13 -  ! Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 13 -  Set hStat = FindObject(FindObject( nRoot, nScrID ), nRackID )
.head 13 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 13 -  Set nChild = MTblGetFirstChildRow( hWndForm, hStat )
.head 13 +  Loop
.head 14 +  If nChild = TBL_Error
.head 15 -  Break
.head 14 -  Call _GetPositionID( nChild, oCage )
.head 14 -  Call CloseCage( oCage.nScreenID, oCage.nRackID, oCage.nCageID )
.head 14 -  Set nChild = MTblGetNextChildRow( hWndForm, nChild )
.head 13 -  ! Set nChild = EnumChildren( hStat, hChildren )
.head 13 +  ! If nChild
.head 14 -  Set i = 0
.head 14 +  Loop 
.head 15 +  If i >= nChild
.head 16 -  Break 
.head 15 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 15 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 15 -  Set i = i + 1
.head 11 +  Else
.head 12 +  If (sStrainR != "")  and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 13 -  Set bTerminate = FALSE
.head 13 +  While (NOT bTerminate) and SqlFetchNext(hSqlPopulate , nFetch)
.head 14 +  If sCurrentCage = sCurrentCageP
.head 15 -  Set bTerminate = TRUE
.head 14 +  Else
.head 15 +  If sCurrentCage = sCurrentCageR
.head 16 +  If (sStrainR1 = sStrainR)
.head 17 -  Set sStrainTarget = sStrainR
.head 17 +  If not sSexTarget
.head 18 -  Set sSexTarget = sSexR
.head 16 +  Else
.head 17 +  If sSexR != sSexR1
.head 18 -  Set sStrainTarget = LitterStrain(  sRack0, sCurrentCage, dtDt  )
.head 17 +  If not sSexTarget
.head 18 -  Set sSexTarget = sSexR1
.head 16 -  Set bTerminate = TRUE
.head 13 +  If sStrainTarget
.head 14 -  Call SqlFetchRow(hSqlPopulate, 0, nFetch)
.head 14 -  Set bTerminate = FALSE
.head 14 +  While NOT bTerminate
.head 15 +  If sCurrentCage = sCurrentCageP
.head 16 -  Set bTerminate = TRUE
.head 15 +  Else
.head 16 +  If sCurrentCage = sCurrentCageR
.head 17 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 18 -  Set bTerminate = TRUE
.head 17 +  Else
.head 18 +  If ((sStrainR = sStrainR1 and sStrainR = sStrainTarget) or (sStrainR != sStrainR1 and LitterStrain(  sRack0, sCurrentCage, dtDt  )= sStrainTarget) ) and (sScreen0 = sScreen1) and (sScreen0 = sScreen)
.head 19 +  If nNumberOfTargets>0
.head 20 -  Set nNumberOfSources = nNumberOfSources+1
.head 20 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 20 -  Set sFrom[nNumberOfSources-1] = sCurrentCage
.head 20 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 20 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 20 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 19 +  If NOT SqlFetchNext(hSqlPopulateC , nFetchReal)
.head 20 -  Set bTerminate = TRUE
.head 18 +  Else
.head 19 -  Set bTerminate = TRUE
.head 16 +  Else
.head 17 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 17 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 17 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 16 +  If NOT SqlFetchNext(hSqlPopulate , nFetch)
.head 17 -  Set bTerminate = TRUE
.head 14 +  If nNumberOfSources and bMakeAction
.head 15 -  Call LT_OpenTransaction(5,dtDt)
.head 15 -  Call LockSysadmAction("Close gaps started...")
.head 15 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 15 -  Call LockSysadmAction("...close gaps finished.")
.head 15 -  Call LT_CloseLastTransaction()
.head 15 -  ! Set hStat =  FindChild( FindChild( hRoot, sScreen0 ), sRack0 )
.head 15 -  Set hStat = FindObject(FindObject( nRoot , nScrID ), nRackID )
.head 15 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 15 -  Set nChild = MTblGetFirstChildRow( hWndForm, hStat )
.head 15 +  Loop
.head 16 +  If nChild = TBL_Error
.head 17 -  Break
.head 16 -  Call _GetPositionID( nChild, oCage )
.head 16 -  Call CloseCage( oCage.nScreenID, oCage.nRackID, oCage.nCageID )
.head 16 -  Set nChild = MTblGetNextChildRow( hWndForm, nChild )
.head 15 -  ! Set nChild = EnumChildren( hStat, hChildren )
.head 15 +  ! If nChild
.head 16 -  Set i = 0
.head 16 +  Loop 
.head 17 +  If i >= nChild
.head 18 -  Break 
.head 17 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 17 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 17 -  Set i = i + 1
.head 7 -  !
.head 7 +  ! If GalConnect(hSql) and GalConnect(hSqlPlan) and GalConnect(hSqlReal)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select @VALUE(y_pos_label), x_pos_label from gruppe where gruppe_key = :sCage0 and stat_key = :sRack0 into :nYStart, :sXStart")
.head 8 +  If SqlFetchNext(hSql, nFetch)
.head 9 +  If sStopCage
.head 10 -  Call SqlPrepareAndExecute(hSql, "select @VALUE(y_pos_label), x_pos_label from gruppe where gruppe_key = :sStopCage and stat_key = :sRack0 into :nYEnd, :sXEnd")
.head 10 -  Call SqlFetchNext(hSql, nFetch)
.head 9 +  If SqlPrepareAndExecute(hSql, "select
 b.gruppe_key, @VALUE(y_pos_label)
from
 bett b, gruppe g
where b.einricht_id =:nEinrichtId
 and b.canceled = 'N'
 and b.stat_key = :sRack0
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into :sCurrentCage, :nY")
.head 10 +  If SqlPrepareAndExecute(hSqlPlan, "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY)
from
 bett_locks b, fall f, gruppe g, STRAIN_N s
where b.einricht_id =:nEinrichtId
 and b.stat_key = :sRack0
 and :dtDt between b.von and @NULLVALUE(b.bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.fall_key = b.planbew_fall
 and f.einricht_id = b.einricht_id
 and f.ID_STRAIN=s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))
group by 1, 2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageP, :nYPlan, :sStrainP, :sStrainP1")
.head 11 -  Set sSQL = "select
 b.gruppe_key, @VALUE(y_pos_label), min(s.STRAIN_KEY), max(s.STRAIN_KEY), min(b.abt_key), max(b.abt_key), min(f.geschl), max(f.geschl)
from
 bewegung b, fall f, gruppe g, STRAIN_N s
where b.einricht_id =:nEinrichtId
 and b.stat_key = :sRack0
 and b.geloescht = 'N'
 and b.ba_key in ( 'AE', 'VE', 'UE', 'RE')
 and :dtDt between b.bew_zeit and @NULLVALUE(b.bew_zeit_bis, 12-31-2199)
 and b.einricht_id = g.einricht_id
 and b.stat_key = g.stat_key
 and b.gruppe_key = g.gruppe_key
 and g.canceled = 'N'
 and f.einricht_id = b.einricht_id
 and f.fall_key = b.fall_key
 and f.ID_STRAIN = s.ID
 and f.geloescht = 'N'
 and (@VALUE(y_pos_label)>:nYStart or (@VALUE(y_pos_label) = :nYStart and x_pos_label>=:sXStart))"
.head 11 +  If sStopCage
.head 12 -  Set sSQL = sSQL||"
and (@VALUE(y_pos_label)<:nYEnd or (@VALUE(y_pos_label) = :nYEnd and x_pos_label<=:sXEnd))"
.head 11 -  Set sSQL = sSQL||"
group by
 1,2, x_pos_label
order by
 2, x_pos_label
into
 :sCurrentCageR, :nYReal, :sStrainR, :sStrainR1, :sScreen, :sScreen1, :sSexR, :sSexR1"
.head 11 +  If SqlPrepareAndExecute(hSqlReal, sSQL)
.head 12 -  ! detect strain
.head 12 -  Set sStrainP = ""
.head 12 -  Set sStrainP1 = ""
.head 12 -  Set sStrainR = ""
.head 12 -  Set sStrainR1 = ""
.head 12 -  Set sStrainTarget = ""
.head 12 -  Set sSexR = ""
.head 12 -  Set sSexR1 = ""
.head 12 -  Set sSexTarget = ""
.head 12 -  Call SqlFetchNext(hSqlPlan, nFetchPlan)
.head 12 -  Call SqlFetchNext(hSqlReal, nFetchReal)
.head 12 +  If sStopCage and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 13 -  Set bTerminate = FALSE
.head 13 +  If NOT SqlFetchNext(hSql, nFetch)
.head 14 -  Set bTerminate = TRUE
.head 13 +  While NOT bTerminate
.head 14 +  If sCurrentCage = sCurrentCageP
.head 15 -  Set bTerminate = TRUE
.head 14 +  Else 
.head 15 +  If sCurrentCage = sCurrentCageR
.head 16 +  If not sSexTarget
.head 17 -  Set sSexTarget = sSexR
.head 16 -  ! If sSexR != sSexR1
.head 16 +  ! Else
.head 17 -  Set sSexTarget = sSexR1
.head 16 -  ! Set bTerminate = TRUE
.head 14 +  If (sScreen0 != sScreen1) or (sScreen0 != sScreen)
.head 15 -  Set bTerminate = TRUE
.head 14 +  If sCurrentCage = sCurrentCageP
.head 15 -  Set bTerminate = TRUE
.head 14 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 15 -  Set bTerminate = TRUE
.head 14 +  If sCurrentCage != sCurrentCageR and not bTerminate
.head 15 -  Set nNumberOfSources = nNumberOfSources+1
.head 15 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 15 -  Set sFrom[nNumberOfSources-1] = sCurrentCageR
.head 15 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 15 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 15 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 14 +  If NOT SqlFetchNext(hSqlReal, nFetchReal)
.head 15 -  Set bTerminate = TRUE
.head 14 +  If NOT SqlFetchNext(hSql, nFetch)
.head 15 -  Set bTerminate = TRUE
.head 13 +  If nNumberOfSources and bMakeAction
.head 14 -  Call LT_OpenTransaction(5,dtDt)
.head 14 -  Call LockSysadmAction("Close gaps started...")
.head 14 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 14 -  Call LockSysadmAction("...close gaps finished")
.head 14 -  Call LT_CloseLastTransaction()
.head 14 -  Set hStat =  FindChild( FindChild( hRoot, sScreen0 ), sRack0 )
.head 14 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 14 -  Set nChild = EnumChildren( hStat, hChildren )
.head 14 +  If nChild
.head 15 -  Set i = 0
.head 15 +  Loop 
.head 16 +  If i >= nChild
.head 17 -  Break 
.head 16 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 16 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 16 -  Set i = i + 1
.head 12 +  Else 
.head 13 +  If (sStrainR != "")  and (sScreen0 = sScreen1) and (sScreen0 = sScreen) and ((sSexR = sSexR1) or (NOT bTerminateBySex))
.head 14 -  Set bTerminate = FALSE
.head 14 +  While (NOT bTerminate) and SqlFetchNext(hSql, nFetch)
.head 15 +  ! If (sScreen0 != sScreen1) or (sScreen0 != sScreen)
.head 16 -  Set bTerminate = TRUE
.head 15 +  If sCurrentCage = sCurrentCageP
.head 16 -  Set bTerminate = TRUE
.head 15 +  Else 
.head 16 +  If sCurrentCage = sCurrentCageR
.head 17 +  If (sStrainR1 = sStrainR)
.head 18 -  Set sStrainTarget = sStrainR
.head 18 +  If not sSexTarget
.head 19 -  Set sSexTarget = sSexR
.head 17 +  Else 
.head 18 +  If sSexR != sSexR1
.head 19 -  Set sStrainTarget = LitterStrain(  sRack0, sCurrentCage, dtDt  )
.head 18 +  If not sSexTarget
.head 19 -  Set sSexTarget = sSexR1
.head 17 -  Set bTerminate = TRUE
.head 14 +  If sStrainTarget
.head 15 -  Call SqlFetchRow(hSql, 0, nFetch)
.head 15 -  Set bTerminate = FALSE
.head 15 +  While NOT bTerminate
.head 16 +  If sCurrentCage = sCurrentCageP
.head 17 -  Set bTerminate = TRUE
.head 16 +  Else 
.head 17 +  If sCurrentCage = sCurrentCageR
.head 18 +  ! If (sStrainR != sStrainTarget) or (sStrainR != sStrainR1)  or (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 19 -  Set bTerminate = TRUE
.head 18 +  If (bTerminateBySex and ((sSexR != sSexTarget) or (sSexR != sSexR1)))
.head 19 -  Set bTerminate = TRUE
.head 18 +  Else 
.head 19 +  If ((sStrainR = sStrainR1 and sStrainR = sStrainTarget) or (sStrainR != sStrainR1 and LitterStrain(  sRack0, sCurrentCage, dtDt  )= sStrainTarget) ) and (sScreen0 = sScreen1) and (sScreen0 = sScreen)
.head 20 +  If nNumberOfTargets>0
.head 21 -  Set nNumberOfSources = nNumberOfSources+1
.head 21 -  Call SalArraySetUpperBound(sFrom, 1, nNumberOfSources)
.head 21 -  Set sFrom[nNumberOfSources-1] = sCurrentCage
.head 21 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 21 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 21 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 20 +  If NOT SqlFetchNext(hSqlReal, nFetchReal)
.head 21 -  Set bTerminate = TRUE
.head 19 +  Else 
.head 20 -  Set bTerminate = TRUE
.head 17 +  Else 
.head 18 -  Set nNumberOfTargets = nNumberOfTargets+1
.head 18 -  Call SalArraySetUpperBound(sTo, 1, nNumberOfTargets)
.head 18 -  Set sTo[nNumberOfTargets-1] = sCurrentCage
.head 17 +  If NOT SqlFetchNext(hSql, nFetch)
.head 18 -  Set bTerminate = TRUE
.head 15 +  If nNumberOfSources and bMakeAction
.head 16 -  ! Call TransferCages(sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 16 -  Call LT_OpenTransaction(5,dtDt)
.head 16 -  Call LockSysadmAction("Close gaps started...")
.head 16 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScreen0, sRack0, nNumberOfSources, sFrom, sTo, dtDt)
.head 16 -  Call LockSysadmAction("...close gaps finished.")
.head 16 -  Call LT_CloseLastTransaction()
.head 16 -  Set hStat =  FindChild( FindChild( hRoot, sScreen0 ), sRack0 )
.head 16 -  Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 16 -  Set nChild = EnumChildren( hStat, hChildren )
.head 16 +  If nChild
.head 17 -  Set i = 0
.head 17 +  Loop 
.head 18 +  If i >= nChild
.head 19 -  Break 
.head 18 -  Call GetPosition( hChildren[ i ], sTemp, sTemp, sCurrentCage, sTemp )
.head 18 -  Call CloseGruppe( sScreen0, sRack0, sCurrentCage )
.head 18 -  Set i = i + 1
.head 16 -  ! Set nFetch = 0
.head 16 -  ! Set sIn = ""
.head 16 -  ! Set nCurrentRes = nSelectedHandle
.head 16 +  ! While nFetch<nNumberOfSources
.head 17 -  ! Set nSelectedHandle = SearchFrom(hCurrentHandle, s[nCount])
.head 17 -  Call MoveCage(sRack, sFrom[nFetch], sScr, sRack, sTo[nFetch], GetTime4Refresh() )
.head 17 -  Set sIn = sIn||sFrom[nFetch]||","||sTo[nFetch]||","
.head 17 -  ! Call SalSendMsg( hWndItem, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 17 -  ! Call CloseGruppe(sScr, sRack, sSources[nCount])
.head 17 -  ! Call OpenGruppe(sScr, sRack, sTargets[nCount],  FALSE, -1)
.head 17 -  Call cSrc[nFetch].Init( sScr, sRack, sTo[nFetch] )
.head 17 -  Set nFetch = nFetch+1
.head 16 -  ! Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 16 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 17 -  Call SalDateToStr( GetTime4Refresh( ), sTmp )
.head 17 -  Call SalSendMsg( hWndRack2DView, AM_KHE_SetRefreshTime, 0,
					SalHStringToNumber( sTmp ) )
.head 17 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sIn ))
.head 16 -  ! Set cDest = cSrc[nNumberOfSources-1]
.head 16 -  ! Call SalArraySetUpperBound(cSrc, 1, nNumberOfSources-1)
.head 16 -  ! Call Move_PrintCageCards( cSrc, cDest)
.head 16 -  ! Call frmAtlantaMain.ReArrangeButtons(FALSE)
.head 7 -  ! Call SqlDisconnect(hSql)
.head 7 -  ! Call SqlDisconnect(hSqlPlan)
.head 7 -  ! Call SqlDisconnect(hSqlReal)
.head 7 +  If nNumberOfSources and (NOT bMakeAction)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_CGSetSequence, 0, SalHStringToNumber(sTo[0]||","||sFrom[nNumberOfSources-1]))
.head 7 +  Else
.head 8 +  If NOT bMakeAction
.head 9 -  Call SalSendMsg(hWndStar2000, AM_CGSetSequence, 0, SalHStringToNumber(""))
.head 7 -  Call SalArraySetUpperBound(sFrom, 1, -1)
.head 7 -  Call SalArraySetUpperBound(sTo, 1, -1)
.head 7 -  ! Call SalArraySetUpperBound( hChildren, 1, -1 )
.head 7 -  Return nNumberOfSources
.head 5 +  Function: Mate
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  Number: nValueLoc
.head 7 -  Number: nValueLoc1
.head 7 -  Number: nValueLoc2
.head 7 -  Number: nFlags
.head 7 -  Number: nFlags1
.head 7 -  Number: nFlags2
.head 7 -  Number: hStat[*]
.head 7 -  Number: hGrp[*]
.head 7 -  Number: hBet[*]
.head 7 -  Number: hBetFem
.head 7 -  Number: hBetFem1
.head 7 -  Number: hBetMale
.head 7 -  Number: nStat
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrM
.head 7 -  Number: nGrp
.head 7 -  Number: nBet
.head 7 -  Number: nFemale
.head 7 -  Number: nFemale2
.head 7 -  Number: nMale
.head 7 -  Number: i
.head 7 -  Number: k
.head 7 -  Number: l
.head 7 -  Number: a
.head 7 -  Number: nBound
.head 7 -  Number: hCurrent
.head 7 -  Number: hAbt
.head 7 -  Number: hSta
.head 7 -  Number: hSourceFem
.head 7 -  Number: hSourceMale
.head 7 -  Number: hTarget
.head 7 -  Number: nCounter
.head 7 -  Number: nCount
.head 7 -  String: sBetKey 
.head 7 -  String: sBettKeyTmp
.head 7 -  String: sGrpKey
.head 7 -  String: sStatKey
.head 7 -  String: sAbtKey
.head 7 -  String: sBA_Key 
.head 7 -  String: sMetingSt
.head 7 -  String: sMetingGr
.head 7 -  String: sText
.head 7 -  String: sText1
.head 7 -  String: sText2
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  String: sRoomCage
.head 7 -  String: asRoomCage[*]
.head 7 -  Number: nQBed
.head 7 -  Number: nCountEmptyCage
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Boolean: bE
.head 7 -  Number: hFT
.head 7 -  Number: hFT1
.head 7 -  Number: hMT
.head 7 -  Sql Handle: hSql
.head 7 -  Window Handle: ahTargetCage[*]
.head 7 -  !
.head 7 -  FunctionalVar: cSourceF
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSourceM
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  !
.head 7 -  FunctionalVar: cCages[3]
.head 8 -  Class: clsLocation
.head 7 -  String: sCagesList
.head 6 +  Actions
.head 7 +  If bMatingActive 
.head 8 -  Return FALSE
.head 7 -  Set bMatingActive=TRUE
.head 7 -  Call MassMating(nFem,bMassMating)
.head 7 -  Set bMatingActive=FALSE
.head 5 +  Function: MassMating
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 7 -  Boolean: bMass
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oEmptyCages[*]
.head 8 -  Class: cPositionData
.head 7 -  String: sBA_Key
.head 7 -  Date/Time: dtBewZeit_New
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  ! Sql Handle: hSqlSelect
.head 7 -  Number: nBound
.head 7 -  Number: nMales[*,2]
.head 7 -  Number: nFeMales[*,2]
.head 7 -  Number: nIndMale
.head 7 -  Number: nIndFeMale
.head 7 -  Number: nCountMale
.head 7 -  Number: nCountFeMale
.head 7 -  Number: nCountEmptyCage
.head 7 -  Number: nIndEmptyCage
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrF1
.head 7 -  Number: nBewNrM
.head 7 -  ! clsLocation: cCages[*]
.winattr class FunctionalVar:
.head 8 -  Class: clsLocation
.end
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nIndCage
.head 7 -  Number: nPrintCages[*]
.head 7 -  Number: nPrevCage
.head 7 -  Number: nCageID
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  Number: hAbt
.head 7 -  Number: nFetch
.head 7 -  Boolean: bCancelBewegung
.head 7 -  Number: nCageRef[*]
.head 7 -  Number: nI
.head 7 -  FunctionalVar: oFallData
.head 8 -  Class: cFERow
.head 7 -  Number: nRackID
.head 7 -  Number: nRow
.head 7 -  Number: nRowCages[*]
.head 6 +  Actions
.head 7 -  Set bOk = CanMate( nFem )
.head 7 -  Set bCancelBewegung = FALSE
.head 7 -  Set bOk = bOk and _GetPositionID( nSelectedRow , oPos )
.head 7 -  ! Set bOk = bOk and GalConnect( hSqlSelect )
.head 7 -  ! Clear vars
.head 7 +  If bOk
.head 8 -  Set nIndMale = -1
.head 8 -  Set nIndFeMale = -1
.head 8 -  Call SalArraySetUpperBound( nMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nFeMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( oEmptyCages, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( cSourceCage, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nPrintCages, 1, -1 )
.head 8 -  Set sGrund1=''
.head 8 -  Set sGrund2=''
.head 8 -  Set sBA_Key = 'UE'
.head 8 -  Set nIndCage = 0
.head 7 -  ! Prepare falls and empty cages
.head 7 +  If bOk
.head 8 +  If oHandleSelect.nIndex>0
.head 9 -  ! Call SalArrayGetUpperBound( HandleToPlace, 1, nBound )
.head 9 -  Set bOk = bOk and SqlPrepare(hSqlPopulate, "select last_cage_id from fall where einricht_id=:nEinrichtId and fall_key=:oFallData.nID_Obj into :nCageID ")
.head 9 -  Set nI =0
.head 9 +  While nI < oHandleSelect.nIndex and bOk 
.head 10 -  Set oFallData = FE_GetInfo( GetRowID(oHandleSelect.nRow[nI]) )
.head 10 -  Set bOk = bOk and SqlExecute(hSqlPopulate) and SqlFetchNext(hSqlPopulate, nFetch)
.head 10 +  If oFallData.GetSValue( "Sex" ) = "M"
.head 11 -  Set nIndMale = nIndMale + 1
.head 11 -  Set nMales[nIndMale,0] = oFallData.nID_Obj
.head 11 -  Set nMales[nIndMale,1] = nCageID
.head 10 +  Else
.head 11 -  Set nIndFeMale = nIndFeMale + 1
.head 11 -  Set nFeMales[nIndFeMale,0] = oFallData.nID_Obj
.head 11 -  Set nFeMales[nIndFeMale,1] = nCageID
.head 10 -  Set nI = nI + 1
.head 9 -  Set nCountMale = nIndMale + 1
.head 9 -  Set nCountFeMale = nIndFeMale + 1
.head 8 +  Else
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulate , "select f.fall_key, t.id, g.gruppe_key,g.stat_key, g.rack_id
   from " || sUserName || ".t_cage t
   join fall f on(f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null and f.ee_datum is null)
   join gruppe g on (g.id = t.id )
where f.geschl='M'
order by t.id
into :nMales[nIndMale,0],:nMales[nIndMale,1]
" )
.head 9 -  Set nIndMale =0
.head 9 +  While bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 10 -  Set nIndMale = nIndMale + 1 
.head 9 -  Set nCountMale = nIndMale
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulate, "select f.fall_key, t.id, g.gruppe_key,g.stat_key, g.rack_id
   from " || sUserName || ".t_cage t
   join fall f on(f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null and f.ee_datum is null )
   join gruppe g on (g.id = t.id )
where f.geschl!='M'
order by t.id
into :nFeMales[nIndFeMale,0],:nFeMales[nIndFeMale,1]
" )
.head 9 -  Set nIndFeMale =0
.head 9 +  While bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 10 -  Set nIndFeMale = nIndFeMale + 1 
.head 9 -  Set nCountFeMale = nIndFeMale
.head 8 -  ! Prepare array empty cages
.head 8 +  If bMass
.head 9 -  ! Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select t.id , g.gruppe_key, g.stat_key, g.rack_id, @if(t.id-:oPos.nCageID,t.id,0)
  from "|| sUserName ||".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.culling_id is null and f.ee_datum is null )
  join gruppe g on(g.id=t.id)
  left join cadavers c on (c.rack=g.stat_key and c.cage=g.gruppe_key)
where f.geschl is null and c.id is null
group by 1,2,3,4
having  count(f.fall_key)-count(f.culling_id)=0
order by 5
into :oEmptyCages[nIndEmptyCage].nCageID, :oEmptyCages[nIndEmptyCage].sCage, :oEmptyCages[nIndEmptyCage].sRack, :oEmptyCages[nIndEmptyCage].nRackID
")
.head 9 -  ! Set nIndEmptyCage = 0
.head 9 +  ! While bOk and SqlFetchNext( hSqlPopulate, nFetch )
.head 10 -  Set nIndEmptyCage = nIndEmptyCage + 1
.head 9 -  Set nIndEmptyCage = GetOpenCages( nRoot, CageIsEmpty  , nRowCages )
.head 9 -  Set nI = 0
.head 9 +  While nI < nIndEmptyCage
.head 10 -  Call _GetPositionID( nRowCages[nI], oEmptyCages[nI] )
.head 10 -  Set nI = nI + 1
.head 8 +  Else
.head 9 -  Set oEmptyCages[0].nActHandel = oPos.nActHandel
.head 9 -  Set oEmptyCages[0].nCageID = oPos.nCageID
.head 9 -  Set oEmptyCages[0].nPosID= oPos.nPosID
.head 9 -  Set oEmptyCages[0].nRackID = oPos.nRackID
.head 9 -  Set oEmptyCages[0].nScreenID = oPos.nScreenID
.head 9 -  Set oEmptyCages[0].sBett = oPos.sBett
.head 9 -  Set oEmptyCages[0].sCage = oPos.sCage
.head 9 -  Set oEmptyCages[0].sRack = oPos.sRack
.head 9 -  Set oEmptyCages[0].sScreen = oPos.sScreen
.head 9 -  Set nIndEmptyCage = 1
.head 8 -  Set nCountEmptyCage = nIndEmptyCage
.head 7 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtBewZeit_New, sGrund1, sGrund2 )
.head 8 -  Set bOk = FALSE
.head 7 -  If FALSE ! not bPlanningMode
.head 7 -  Call LT_OpenTransaction( 1, dtBewZeit_New )
.head 7 -  ! Move animals
.head 7 -  Set nIndMale = 0
.head 7 -  Set nIndFeMale = 0
.head 7 -  Set nIndEmptyCage = 0
.head 7 +  While bOk and nIndMale < nCountMale and nIndFeMale + nFem < nCountFeMale and nIndEmptyCage < nCountEmptyCage
.head 8 -  Set nBewNrF = InsertBewegung(nFeMales[nIndFeMale,0], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2, oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, AddWonBettX( oPos.sScreen, 
oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage,dtBewZeit_New ),"", "", "", "" )
.head 8 +  If nBewNrF <=0
.head 9 -  Call DoCloseTransaction( FALSE )
.head 9 -  Set bOk = FALSE
.head 8 +  If nFem=1 and bOk
.head 9 -  Set nIndFeMale = nIndFeMale + 1
.head 9 -  Set nBewNrF1 = InsertBewegung(nFeMales[nIndFeMale,0], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2,  oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, AddWonBettX( oPos.sScreen, 
oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage,dtBewZeit_New ),"", "", "", "" )
.head 9 +  If nBewNrF1 <=0
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bOk = FALSE
.head 8 -  Set nIndFeMale = nIndFeMale + 1
.head 8 +  If bOk
.head 9 -  Set nBewNrM = InsertBewegung(nMales[nIndMale,0], 0, dtBewZeit_New, sBA_Key,sGrund1, sGrund2,  oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage, AddWonBettX( oPos.sScreen, 
oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage,dtBewZeit_New ),"", "", "", "" )
.head 9 +  If nBewNrM<=0
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bOk = FALSE
.head 9 -  Set nIndMale = nIndMale + 1
.head 9 +  If not bOk
.head 10 -  Set nCageRef[0]=0
.head 10 +  If nFem=1
.head 11 -  Call DeleteMovement(hWndNULL,  nFeMales[nIndFeMale - 1 ,0],nBewNrF1,nCageRef )
.head 11 -  Call DeleteMovement(hWndNULL,  nFeMales[nIndFeMale - 2,0],nBewNrF,nCageRef )
.head 10 +  Else
.head 11 -  Call DeleteMovement(hWndNULL,  nFeMales[nIndFeMale - 1,0],nBewNrF,nCageRef )
.head 10 -  If nFem=1
.head 10 -  Set bCancelBewegung = TRUE
.head 8 +  If bOk
.head 9 -  Call DoCloseTransaction( TRUE )
.head 9 -  Call Transfer_AppendToAll( sBA_Key, nMales[nIndMale-1,0], nBewNrM )
.head 9 +  If nFem=1
.head 10 -  Call Transfer_AppendToAll( sBA_Key, nFeMales[nIndFeMale-2,0], nBewNrF )
.head 10 -  Call Transfer_AppendToAll( sBA_Key,  nFeMales[nIndFeMale-1,0], nBewNrF1 )
.head 9 +  Else
.head 10 -  Call Transfer_AppendToAll( sBA_Key,  nFeMales[nIndFeMale-1,0], nBewNrF )
.head 9 -  Call cSourceCage[nIndCage].Init( oPos.sScreen, oEmptyCages[nIndEmptyCage].sRack, oEmptyCages[nIndEmptyCage].sCage )
.head 9 -  Set nIndCage = nIndCage + 1
.head 8 -  Set nIndEmptyCage = nIndEmptyCage + 1
.head 7 -  Set bOk = (bOk or bCancelBewegung) and (nIndCage > 0)
.head 7 +  If bOk
.head 8 -  Set hAbt = GetParent( GetParent(nSelectedRow) )
.head 8 -  Set nCageID = -1
.head 7 +  If bOk 
.head 8 -  Call Refresh( 8, 0 )
.head 7 -  Set bOk = bOk and SqlPrepare(hSqlPopulate , "select g.rack_id
				from gruppe g 
				where g.id=:nCageID
                                            into :nRackID ")
.head 7 -  ! Refresh and prepare print cages with male
.head 7 +  Loop
.head 8 -  Set nIndMale = nIndMale - 1
.head 8 +  If nIndMale < 0 or not bOk
.head 9 -  Break
.head 8 +  If nCageID != nMales[nIndMale,1]
.head 9 -  Set nCageID = nMales[nIndMale,1]
.head 9 -  Set bOk = bOk and SqlExecute(hSqlPopulate) and SqlFetchNext(hSqlPopulate, nFetch)
.head 9 +  If bOk
.head 10 -  Set nRow =  FindObject(FindObject( hAbt, nRackID ) ,nCageID ) 
.head 10 +  If CheckStatusObj( nRow, CageIsEmpty )
.head 11 -  Call CloseCage( oPos.nScreenID , nRackID, nCageID )
.head 10 +  Else
.head 11 -  ! Call KHE_RefreshGruppe(SearchFrom(SearchFrom( hAbt, sRack ), sCage))
.head 11 -  Call _GetPositionID( nRow, oPos )
.head 11 -  Call cSourceCage[nIndCage].Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 11 -  Set nIndCage = nIndCage + 1
.head 7 -  ! Refresh and prepare print cages with female
.head 7 +  Loop
.head 8 -  Set nIndFeMale = nIndFeMale - 1
.head 8 +  If nIndFeMale < 0 or not bOk
.head 9 -  Break
.head 8 +  If nCageID != nFeMales[nIndFeMale,1]
.head 9 -  Set nCageID = nFeMales[nIndFeMale,1]
.head 9 -  Set bOk = bOk and SqlExecute(hSqlPopulate) and SqlFetchNext(hSqlPopulate, nFetch)
.head 9 +  If bOk
.head 10 -  Set nRow =  FindObject(FindObject( hAbt, nRackID ) ,nCageID ) 
.head 10 +  If CheckStatusObj(nRow, CageIsEmpty )
.head 11 -  Call CloseCage( oPos.nScreenID , nRackID, nCageID )
.head 10 +  Else
.head 11 -  ! Call KHE_RefreshGruppe(SearchFrom(SearchFrom( hAbt, sRack ), sCage))
.head 11 -  Call _GetPositionID( nRow, oPos )
.head 11 -  Call cSourceCage[nIndCage].Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 11 -  Set nIndCage = nIndCage + 1
.head 7 +  If bOk
.head 8 -  Set cDest = cSourceCage[nIndCage - 1]
.head 7 -  ! Refresh Source cages
.head 7 +  Loop
.head 8 -  Set nIndEmptyCage = nIndEmptyCage - 1
.head 8 +  If nIndEmptyCage<0 or not bOk
.head 9 -  Break
.head 8 +  If CheckStatusObj( oEmptyCages[nIndEmptyCage].nActHandel, CageIsEmpty  ) 
.head 9 -  Call CloseCage( oEmptyCages[nIndEmptyCage].nScreenID, oEmptyCages[nIndEmptyCage].nRackID, oEmptyCages[nIndEmptyCage].nCageID )
.head 8 +  ! Else
.head 9 -  Call KHE_RefreshGruppe(SearchFrom(SearchFrom( hAbt, oEmptyCages[nIndEmptyCage].sRack ), oEmptyCages[nIndEmptyCage].sCage))
.head 7 +  If TRUE ! not bPlanningMode
.head 8 -  Call LT_CloseLastTransaction(  )
.head 7 +  ! If hSqlSelect
.head 8 -  Call SqlDisconnect( hSqlSelect )
.head 7 -  ! Call Rack2DView_RefreshCageContents("")
.head 7 +  If not SalArrayIsEmpty( cSourceCage )
.head 8 -  Call Move_PrintCageCards(cSourceCage,cDest)
.head 7 -  Call UnSelectAll(  )
.head 7 -  ! Clear arrays
.head 7 +  If TRUE
.head 8 -  Call SalArraySetUpperBound( nMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nFeMales, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( oEmptyCages, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( cSourceCage, 1, -1 )
.head 8 -  Call SalArraySetUpperBound( nPrintCages, 1, -1 )
.head 7 -  !
.head 7 -  Return bOk
.head 5 +  Function: StudMailMate
.head 6 -  Description: if nFem=0- Mate Pair
if nFem=1- Mate Trio
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Sql Handle: hSQLUnreg
.head 7 -  Sql Handle: hSQLCage
.head 7 -  Number: nFetch
.head 7 -  Number: nFallKey[*,2]
.head 7 -  Number: nF
.head 7 -  String: sCage[*,3]
.head 7 -  Number: nCage[*]
.head 7 -  Number: nM
.head 7 -  Number: nCageID
.head 7 -  String: sRack
.head 7 -  String: sGruppe
.head 7 -  String: sPrevRack
.head 7 -  String: sPrevGruppe
.head 7 -  String: sSex
.head 7 -  Number: nCountS
.head 7 -  Number: nPrevCage
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  !
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocation
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Boolean: bStudMailActive
.head 7 -  !
.head 7 -  String: sScr
.head 7 -  String: sStatKeyTmp
.head 7 -  String: sGrpKeyTmp
.head 7 -  String: sBettKeyTmp
.head 7 -  !
.head 7 -  Number: nCountF
.head 7 -  Number: nCountM
.head 7 -  String: sBA_Key
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Date/Time: dtpTime
.head 7 -  !
.head 7 -  Number: nBewNrF
.head 7 -  Number: nBewNrF1
.head 7 -  Boolean: bStudMassMatingFull
.head 7 -  Number: nIndCage
.head 7 -  Number: hScr
.head 7 -  Boolean: bPrint
.head 7 -  Boolean: bOk
.head 7 -  Number: nRefrCage[*]
.head 7 -  FunctionalVar: oSelPos
.head 8 -  Class: cPositionData
.head 7 -  Number: nCageIdClose
.head 7 -  Number: nRackIdClose
.head 6 +  Actions
.head 7 +  If not CanStudMailMate(nFem)
.head 8 -  Return FALSE
.head 7 +  If bStudMailActive
.head 8 -  Return FALSE
.head 7 +  If SqlCreateStatement( hSesionFE, hSqlFind) and SqlCreateStatement( hSesionFE, hSQLUnreg) and SqlCreateStatement( hSesionFE,hSQLCage)
.head 8 -  Set bStudMailActive=TRUE
.head 8 -  Call SalArraySetUpperBound(cSourceCage,1,-1)
.head 8 -  Call SalArraySetUpperBound(cCages,1,-1)
.head 8 -  ! Call GetPosition( nSelectedHandle, sScr, sStatKeyTmp, sGrpKeyTmp, sBettKeyTmp )
.head 8 -  Call _GetPositionID(nSelectedRow, oSelPos)
.head 8 -  Set sScr = oSelPos.sScreen
.head 8 -  Set sStatKeyTmp = oSelPos.sRack
.head 8 -  Set sGrpKeyTmp = oSelPos.sCage
.head 8 -  Set hScr = GetParent( nSelectedRow )
.head 8 -  Set hScr = GetParent( hScr )
.head 8 -  Set bOk = TRUE
.head 8 -  Set bOk = bOk and SqlPrepare(hSQLCage, " select stat_key, gruppe_key,rack_id,id from GRUPPE where id=:nPrevCage 
into :sStatKeyTmp , :sGrpKeyTmp, :nRackIdClose, :nCageIdClose")
.head 8 -  ! Female
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlFind,"select  f.Fall_key, t.ID,t.Port_POC

  from   " || sUserName || ".T_Cage t
 join sysadm.fall f on (f.last_cage_id=t.id and f.geschl='W' and f.geloescht='N' and f.culling_id is null and f.ee_time is null )
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key) 
where  rf.fall_key is null
and t.id not in (select t2.id from  " || sUserName || ".T_Cage t2
    join sysadm.fall f2 on (f2.last_cage_id=t2.id and f2.geschl='M' and f2.geloescht='N' and f2.culling_id is null  and f2.ee_time is null)     where t2.id=t.id )
and t.id not in (select t3.id
  from " || sUserName || ".T_Cage t3
      join sysadm.fall f on (f.last_cage_id=t3.id and f.geschl='W' and f.geloescht='N' and f.culling_id is null  and f.ee_time is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and (rf.fallrolle_key='PARENT' or (rf.fallrolle_key = 'MATE' and @nullvalue(rf.rs_fall_valid,@now+365)>=@now)))
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id)))
order by t.Port_POC, t.ID
into :nFallKey[nF,0], :nFallKey[nF,1] "  )
.head 8 -  Set nF = 0
.head 8 +  While SqlFetchNext(hSqlFind, nFetch)
.head 9 -  Set nF = nF + 1
.head 8 -  ! cage with Male
.head 8 -  Set bOk = SqlPrepareAndExecute(hSqlFind,"select  t.id,  f.last_stat_key, f.last_gruppe_key ,t.Port_POC

  from  " || sUserName || ".T_Cage t
      join sysadm.fall f on (f.last_cage_id=t.id and f.geschl='M' and f.geloescht='N' and f.culling_id is null  and f.ee_time is null )
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key)

where  rf.fall_key is null
and t.id not in (select t2.id from "|| sUserName ||".T_Cage t2
 join sysadm.fall f2 on (f2.last_cage_id=t2.id and f2.geschl='W' and f2.geloescht='N' and f2.culling_id is null  and f2.ee_time is null)  where t2.id=t.id )
group by 1,2,3,4
having count(f.fall_key)=1
order by t.Port_POC, t.ID
into :nCageID, :sCage[nM,0], :sCage[nM,1] " )
.head 8 -  Set nM = 0
.head 8 +  While SqlFetchNext(hSqlFind, nFetch)
.head 9 -  Set nCage[nM] = nCageID
.head 9 -  Set nM = nM + 1
.head 8 +  If nFem = 1
.head 9 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlFind,"select t.id,  f.last_stat_key, f.last_gruppe_key, f.geschl , count(f.geschl) ,t.Port_POC

  from  " || sUserName || ".T_Cage t
join sysadm.fall f on (f.last_cage_id=t.id and f.geloescht='N' and f.ee_datum is null )
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='MATE' and rf.rs_fall_valid is null )
    left join sysadm.roling_fall rl on (rl.status=0 and rl.fall_key=f.fall_key)

where rl.fall_key is null
  and t.id not in (select t.id
  from " || sUserName || ".T_Cage t
   join sysadm.fall f on (f.last_cage_id=t.id and f.geschl='W' and f.geloescht='N' and f.ee_datum is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='PARENT')
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id) ) )

group by 1,2,3,4,6
having count(f.fall_key)=1
order by t.Port_POC, t.ID,4

into :nCageID, :sRack, :sGruppe , :sSex, :nCountS " )
.head 9 +  While SqlFetchNext(hSqlFind, nFetch)
.head 10 +  If nPrevCage != nCageID
.head 11 +  If bM and bF
.head 12 -  Set sCage[nM,0] = sPrevRack
.head 12 -  Set sCage[nM,1] = sPrevGruppe
.head 12 -  Set sCage[nM,2] = 'SMP'
.head 12 -  Set nCage[nM] = nCageID
.head 12 -  Set nM = nM + 1
.head 11 -  Set nPrevCage = nCageID
.head 11 -  Set sPrevRack = ""
.head 11 -  Set sPrevGruppe= ""
.head 11 -  Set bF = FALSE
.head 11 -  Set bM = FALSE
.head 10 -  Set sPrevRack = sRack
.head 10 -  Set sPrevGruppe= sGruppe
.head 10 +  If sSex = 'M'
.head 11 -  Set bM = TRUE
.head 10 +  Else
.head 11 +  If nCountS = 1
.head 12 -  Set bF = TRUE
.head 9 +  If bM and bF
.head 10 -  Set sCage[nM,0] = sPrevRack
.head 10 -  Set sCage[nM,1] = sPrevGruppe
.head 10 -  Set sCage[nM,2] = 'SMP'
.head 10 -  Set nCage[nM] = nPrevCage
.head 10 -  Set nM = nM + 1
.head 8 -  !
.head 8 -  Set nCountF = nF
.head 8 -  Set nCountM = nM
.head 8 -  Set nF=0
.head 8 -  Set nM=0
.head 8 -  Set sBA_Key = 'UE'
.head 8 -  Set nIndCage = 0
.head 8 -  Set nPrevCage = -100
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtpTime, sGrund1, sGrund2 )
.head 9 -  Set bStudMailActive=FALSE
.head 9 -  Return FALSE
.head 8 +  If TRUE ! not bPlanningMode
.head 9 -  Call LT_OpenTransaction( 1, dtpTime )
.head 9 -  Call LockSysadmAction("Perform studmating...")
.head 8 -  Set sEventTypeName = "STUD_MATING"
.head 8 +  While bOk and nM<nCountM and nF<nCountF-nFem
.head 9 +  If nPrevCage = -100
.head 10 -  Set nPrevCage = nFallKey[nF,1] 
.head 10 +  If SqlExecute( hSQLCage )
.head 11 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 -  Set nBewNrF = InsertBewegung(nFallKey[nF,0], 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sCage[nM,0], sCage[nM,1], AddWonBettX( sScr,
sCage[nM,0], sCage[nM,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <=0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Set sEventTypeName = ""
.head 10 -  Set bOk = FALSE
.head 9 +  If bOk
.head 10 -  Call cSourceCage[nIndCage].Init(sScr, sCage[nM,0],sCage[nM,1]  )
.head 10 -  Set cCages[nIndCage] = cSourceCage[nIndCage]
.head 10 +  If nPrevCage != nFallKey[nF,1] 
.head 11 +  If SqlExecute( hSQLCage )
.head 12 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 11 -  Call CloseCage(oSelPos.nScreenID, nRackIdClose, nCageIdClose )
.head 11 -  Set nIndCage=nIndCage+1
.head 11 -  Set cCages[nIndCage] = cDest
.head 11 -  Set nPrevCage = nFallKey[nF,1] 
.head 11 +  If SqlExecute( hSQLCage )
.head 12 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 11 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 10 -  Set nIndCage=nIndCage+1
.head 9 +  If bOk and (nFem=1) and (nCountF - nF)>=1 and sCage[nM,2] != 'SMP'
.head 10 -  Set nF=nF+1
.head 10 -  Set nBewNrF1 = InsertBewegung(nFallKey[nF,0], 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sCage[nM,0], sCage[nM,1], AddWonBettX( sScr,
sCage[nM,0], sCage[nM,1],dtpTime ),"", "", "", "" )
.head 10 +  If nBewNrF1 <=0
.head 11 -  Set sEventTypeName = ""
.head 11 -  Call DoCloseTransaction( FALSE )
.head 11 -  Set bStudMailActive=FALSE
.head 11 -  Set sEventTypeName = ""
.head 11 -  Set bOk = FALSE
.head 10 +  If bOk
.head 11 -  Call cSourceCage[nIndCage].Init(sScr, sCage[nM,0],sCage[nM,1]  )
.head 11 -  Set cCages[nIndCage] = cSourceCage[nIndCage]
.head 11 +  If nPrevCage != nFallKey[nF,1] 
.head 12 +  If SqlExecute( hSQLCage )
.head 13 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 12 -  Call CloseCage(oSelPos.nScreenID, nRackIdClose, nCageIdClose )
.head 12 -  Set nIndCage=nIndCage+1
.head 12 -  Set cCages[nIndCage] = cDest
.head 12 -  Set nPrevCage = nFallKey[nF,1] 
.head 12 +  If SqlExecute( hSQLCage )
.head 13 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 12 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 10 -  Set nIndCage=nIndCage+1
.head 9 +  If bOk
.head 10 +  If nFem=1
.head 11 -  Call Transfer_AppendToAll (sBA_Key, nFallKey[nF,0], nBewNrF )
.head 11 +  If sCage[nM,2] != 'SMP'
.head 12 -  Call Transfer_AppendToAll (sBA_Key, nFallKey[nF-1,0], nBewNrF1 )
.head 10 +  Else
.head 11 -  Call Transfer_AppendToAll (sBA_Key, nFallKey[nF,0], nBewNrF )
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(SearchFrom(hScr,sCage[nM,0] ) , sCage[nM,1] ) )
.head 10 -  ! Call Refresh(2,nCage[nM])
.head 9 -  Set nF=nF+1
.head 9 -  Set nM=nM + 1
.head 8 -  Set bStudMassMatingFull = GalGetProfileBooleanX("KHE", "StudMaleMatingFull", FALSE, sUserINIFileName)
.head 8 +  If bOk and (nCountF-nF+1)=1 and bStudMassMatingFull
.head 9 -  Set nBewNrF = InsertBewegung(nFallKey[nF,0], 0, dtpTime, sBA_Key,sGrund1, sGrund2, sScr, sCage[nM,0], sCage[nM,1], AddWonBettX( sScr,
sCage[nM,0], sCage[nM,1],dtpTime ),"", "", "", "" )
.head 9 +  If nBewNrF <=0
.head 10 -  Set sEventTypeName = ""
.head 10 -  Call DoCloseTransaction( FALSE )
.head 10 -  Set bStudMailActive=FALSE
.head 10 -  Set sEventTypeName = ""
.head 10 -  Set bOk = FALSE
.head 9 +  If bOk 
.head 10 -  Call cSourceCage[nIndCage].Init(sScr, sCage[nM,0],sCage[nM,1]  )
.head 10 -  Set cCages[nIndCage] = cSourceCage[nIndCage]
.head 9 +  If bOk and nPrevCage != nFallKey[nF,1] 
.head 10 +  If SqlExecute( hSQLCage )
.head 11 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 10 -  ! Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call CloseCage(oSelPos.nScreenID, nRackIdClose, nCageIdClose )
.head 10 -  Set nIndCage=nIndCage+1
.head 10 -  Set cCages[nIndCage] = cDest
.head 10 -  Set nPrevCage = nFallKey[nF,1] 
.head 10 +  If SqlExecute( hSQLCage )
.head 11 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 10 -  Call cDest.Init( sScr, sStatKeyTmp, sGrpKeyTmp )
.head 9 +  ! If bOk
.head 10 -  ! Call KHE_RefreshGruppe( SearchFrom(SearchFrom(hScr,sCage[nM,0] ) , sCage[nM,1] ) )
.head 10 -  Call Refresh(2, nCage[nM])
.head 8 -  ! Set nM = nM - 1 
.head 8 -  Set nF = nF - 1
.head 8 +  ! If bOk and SqlExecute( hSQLCage )
.head 9 -  Call SqlFetchNext(hSQLCage,nFetch)
.head 8 +  If bOk
.head 9 -  ! Call KHE_RefreshGruppe(SearchFrom(SearchFrom(hScr,sStatKeyTmp) , sGrpKeyTmp ) )
.head 9 -  Call Refresh(2,nCageIdClose)
.head 9 +  If CheckStatusObj( FindObject(FindObject( hScr, nRackIdClose ), nCageIdClose ) , CageIsEmpty )
.head 10 -  ! Call CloseGruppe( sScr,sStatKeyTmp, sGrpKeyTmp  )
.head 10 -  Call CloseCage(oSelPos.nScreenID, nRackIdClose, nCageIdClose )
.head 8 +  While nM>0
.head 9 -  Set nM = nM - 1 
.head 9 -  Call Refresh( 2, nCage[nM])
.head 8 -  Call ActivateRow( FindObject(FindObject(FindObject( nRoot, oPosition.nScreenID ),oPosition.nRackID), oPosition.nCageID) )
.head 8 -  Call Refresh( 2, oPosition.nCageID )
.head 8 -  Call LockSysadmAction("...studmating performed")
.head 8 -  Call LT_CloseLastTransaction(  )
.head 8 -  ! Call Rack2DView_RefreshCageContents("")
.head 8 -  Call SqlDisconnect(hSqlFind)
.head 8 -  Call SqlDisconnect(hSQLUnreg)
.head 8 -  Call SqlDisconnect(hSQLCage)
.head 8 +  If not SalArrayIsEmpty( cSourceCage )
.head 9 -  Call Move_PrintCageCards(cSourceCage,cDest)
.head 8 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 0,0)
.head 8 -  Set bStudMailActive=FALSE
.head 8 -  Set sEventTypeName = ""
.head 8 -  Return TRUE
.head 5 +  Function: MoveCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nScrIdFrom
.head 7 -  Number: nRackIdFrom
.head 7 -  Number: nCageIdFrom
.head 7 -  Number: nScrIdTo
.head 7 -  Number: nRackIdTo
.head 7 -  Number: nCageIdTo
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sEmpty
.head 7 -  Number: nBewNr
.head 7 -  !
.head 7 -  String: sCageTypeFrom
.head 7 -  Number: nCageID_From
.head 7 -  String: sRFIDFrom
.head 7 -  Number: nUniqNrFrom
.head 7 -  String: sGruppeBarFrom
.head 7 -  !
.head 7 -  String: sCageTypeTo
.head 7 -  Number: nCageID_To
.head 7 -  String: sRFIDTo
.head 7 -  Number: nUniqNrTo
.head 7 -  String: sGruppeBarTo
.head 7 -  !
.head 7 -  Number: nFall
.head 7 -  Number: nBettKey
.head 7 -  !
.head 7 -  Number: nTransferredFalls[*]
.head 7 -  Number: nBetts[*]
.head 7 -  Number: nTransferredCount
.head 7 -  Number: nTransferBack
.head 7 -  !
.head 7 -  String: sBA
.head 7 -  Boolean: bRFIDToAndFrom
.head 7 -  String: sSqlBew
.head 7 -  String: sRfAbtKeyFrom
.head 7 -  String: sRfAbtKeyTo
.head 7 -  Number: nMinUniqNr
.head 7 -  Boolean: bOk
.head 7 -  String: sClear
.head 7 -  String: sRackFrom
.head 7 -  String: sCageFrom
.head 7 -  String: sRackTo
.head 7 -  String: sCageTo
.head 7 -  String: sScrTo
.head 7 -  String: sScrFrom
.head 6 +  Actions
.head 7 -  Set sEmpty = ""
.head 7 -  Set bRFIDToAndFrom = FALSE
.head 7 -  Call SqlCreateStatement( hSesionFE, hSql )
.head 7 +  If SqlPrepare(hSql, "select abt_key from abteilung where id=:nCageID_From into :sCageFrom")
.head 8 -  Set nCageID_From = nScrIdFrom
.head 8 +  If SqlExecute(hSql)
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set sScrFrom = sCageFrom
.head 8 -  Set nCageID_From = nScrIdTo
.head 8 +  If SqlExecute(hSql)
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set sScrTo = sCageFrom
.head 7 +  If SqlPrepareAndExecute(hSql, "select RFID, Uniq_Nr, type, gruppe_bar, rf_abt_key , id, stat_key, gruppe_key from gruppe
	where id=:nCageIdFrom
	into :sRFIDFrom, :nUniqNrFrom, :sCageTypeFrom, :sGruppeBarFrom, :sRfAbtKeyFrom, :nCageID_From, :sRackFrom, :sCageFrom ")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 +  If SqlPrepareAndExecute(hSql, "select RFID, Uniq_Nr, type, gruppe_bar, rf_abt_key, s.stat_key,g.ID, g.stat_key, g.gruppe_key  from gruppe g left join station s on (s.id=g.rack_id and s.clearRFID='J')
	where g.id=:nCageIdTo
	into :sRFIDTo, :nUniqNrTo, :sCageTypeTo, :sGruppeBarTo, :sRfAbtKeyTo, :sClear, :nCageID_To, :sRackTo, :sCageTo  ")
.head 9 -  Call SqlFetchNext(hSql, nFetch)
.head 9 +  If sClear != "" or sClear != STRING_Null
.head 10 -  Set sRFIDFrom = ""
.head 9 -  ! Call SwapCagesStr(sRackFrom, sCageFrom, sRackTo, sCageTo)
.head 9 -  Call SwapCages(nCageIdFrom, nCageIdTo)
.head 9 -  Set sSqlBew = "select f.fall_key, f.last_bett_key from fall f
	where f.einricht_id = :nEinrichtId
	and f.last_cage_id = :nCageIdFrom 
	and f.LAST_BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 9 -  ! If bRealTimeMode
.head 9 +  ! Else
.head 10 -  Set sSqlBew = "select b.fall_key, bett_key from bewegung b, fall f
	where b.einricht_id = :nEinrichtId and gruppe_key = :sCageFrom and stat_key = :sRackFrom
	and b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
	and b.geloescht = 'N'
	and bew_zeit<:dtAction
	and (bew_zeit_bis is null or bew_zeit_bis >= :dtAction)
	and f.fall_key=b.fall_key
	and f.einricht_id=b.einricht_id
	and @nullvalue( f.GELOESCHT, 'N' ) != 'J' into :nFall, :nBettKey"
.head 9 +  If SqlPrepareAndExecute(hSql, sSqlBew)
.head 10 -  Set nTransferredCount = 0
.head 10 +  While SqlFetchNext(hSql, nFetch)
.head 11 -  Set nTransferredCount = nTransferredCount+1
.head 11 -  Call SalArraySetUpperBound(nTransferredFalls, 1, nTransferredCount)
.head 11 -  Set nTransferredFalls[nTransferredCount-1] = nFall
.head 11 -  Set nBetts[nTransferredCount-1]=nBettKey
.head 10 +  If sScrFrom != sScrTo
.head 11 -  Set sBA = "VES"
.head 10 +  Else
.head 11 -  Set sBA="UES"
.head 10 -  Set bOk = TRUE
.head 10 +  While (nTransferredCount>0) and bOk
.head 11 -  Set bOk = bOk and InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction, sBA,"", "", sScrTo, sRackTo, sCageTo, SalNumberToStrX(nBetts[nTransferredCount-1],0),"", "", "", "" )
.head 11 +  If bOk
.head 12 -  Call SqlPrepareAndExecute(hSql, "update fall set last_cage_nr = :nUniqNrFrom where fall_key=:nTransferredFalls[nTransferredCount-1] and einricht_id=:nEinrichtId")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 12 -  Call SqlPrepareAndExecute(hSql, "select max(bew_nr) from bewegung where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] into :nBewNr")
.head 12 -  Call SqlFetchNext(hSql, nFetch)
.head 12 -  Call SqlPrepareAndExecute(hSql, "update bewegung set cage_nr=:nUniqNrFrom
	where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] and bew_nr = :nBewNr")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 12 -  Set nTransferredCount = nTransferredCount-1
.head 11 +  Else
.head 12 -  Call GalMessageBox("Error!", "Error in cage transfer. All mice will be returned to source cage.", MB_Ok)
.head 12 -  Call SalArrayGetUpperBound(nTransferredFalls, 1, nTransferBack)
.head 12 -  Set nTransferredCount = nTransferredCount + 1
.head 12 +  While nTransferredCount <= nTransferBack
.head 13 -  Call InsertBewegung( nTransferredFalls[nTransferredCount-1] , 0, dtAction+0.00000001, sBA,"", "", sScrFrom, sRackFrom, sCageFrom, SalNumberToStrX(nBetts[nTransferredCount-1],0),"", "", "", "" )
.head 13 -  Call SqlPrepareAndExecute(hSql, "update fall set last_cage_nr = :nUniqNrTo where fall_key=:nTransferredFalls[nTransferredCount-1] and einricht_id=:nEinrichtId")
.head 13 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 13 -  Call SqlPrepareAndExecute(hSql, "select max(bew_nr) from bewegung where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] into :nBewNr")
.head 13 -  Call SqlFetchNext(hSql, nFetch)
.head 13 -  Call SqlPrepareAndExecute(hSql, "update bewegung set cage_nr=:nUniqNrTo
	where einricht_id = :nEinrichtId and fall_key = :nTransferredFalls[nTransferredCount-1] and bew_nr = :nBewNr")
.head 13 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 13 -  Set nTransferredCount = nTransferredCount+1
.head 10 +  If bOk 
.head 11 +  If (sBA = 'VES') and bAskForLicense
.head 12 -  Call SetMassLicense( hSesionFE,  nTransferredFalls, sScrTo)
.head 11 -  Call SqlPrepareAndExecute(hSql, "select min(@NULLVALUE(uniq_nr,0) -1) from gruppe into :nMinUniqNr")
.head 11 -  Call SqlFetchNext(hSql, nFetch)
.head 11 +  If SqlPrepareAndExecute(hSql, "update gruppe set Uniq_Nr = :nMinUniqNr, RFID = '---', gruppe_bar = '---'
	where einricht_id = :nEinrichtId and id=:nCageIdFrom ")
.head 12 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 12 +  If SqlPrepareAndExecute(hSql, "update gruppe set Uniq_Nr = :nUniqNrFrom, RFID = :sRFIDFrom, gruppe_bar = :sGruppeBarFrom, rf_abt_key=:sScrTo
	where einricht_id = :nEinrichtId and id=:nCageIdTo ")
.head 13 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 13 +  If SqlPrepareAndExecute(hSql, "update gruppe set Uniq_Nr = :nUniqNrTo, RFID = :sRFIDTo, gruppe_bar=:sGruppeBarTo, rf_abt_key=:sScrFrom
	where einricht_id = :nEinrichtId and id=:nCageIdFrom ")
.head 14 +  If SqlPrepareAndExecute(hSql, "Update lst_erf set  gruppe_key= :sCageTo,  stat_key=:sRackTo where stat_key=:sRackFrom and gruppe_key= :sCageFrom")
.head 15 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 11 +  If nCageID_To != nCageID_From
.head 12 -  Call T_ShiftCage( nCageID_From, nCageID_To )
.head 10 -  Call SqlPrepareAndExecute(hSql, "select min(@NULLVALUE(uniq_nr,0) -1) from gruppe into :nMinUniqNr")
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Call SalArraySetUpperBound(nTransferredFalls, 1, 0)
.head 7 -  Return bOk
.head 5 +  Function: PrepareTransferFalls
.head 6 -  Description: get information from FE
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTransferredCount
.head 7 -  Number: nRowAn
.head 7 -  FunctionalVar: cRowFall
.head 8 -  Class: cFERow
.head 7 -  Number: nLev
.head 6 +  Actions
.head 7 -  Set nLev = MTblGetRowLevel( hWndForm, nRow )
.head 7 +  If SalArrayIsEmpty( oTransferAnimals )
.head 8 -  Set nTransferredCount = 0
.head 7 +  Else
.head 8 -  Call SalArrayGetUpperBound( oTransferAnimals, 1, nTransferredCount )
.head 8 -  Set nTransferredCount = nTransferredCount + 1
.head 7 +  If nLev = KHEL_Gruppe
.head 8 -  Set nRowAn = MTblGetFirstChildRow( hWndForm, nRow )
.head 8 +  Loop
.head 9 +  If nRowAn = TBL_Error
.head 10 -  Break
.head 9 -  Set cRowFall = FE_GetInfo( nRowAn )
.head 9 +  If cRowFall.nID_Obj != -100
.head 10 -  Call _GetPositionID( nRowAn, oTransferAnimals[nTransferredCount] )
.head 10 -  Set oTransferAnimals[nTransferredCount].nAnimalID = cRowFall.nID_Obj
.head 10 -  Set nTransferredCount = nTransferredCount+1
.head 9 -  Set nRowAn = MTblGetNextChildRow( hWndForm, nRowAn )
.head 7 +  Else If nLev = KHEL_Bett
.head 8 -  Set cRowFall = FE_GetInfo( nRow )
.head 8 +  If cRowFall.nID_Obj != -100
.head 9 -  Call _GetPositionID(nRow, oTransferAnimals[nTransferredCount] )
.head 9 -  Set oTransferAnimals[nTransferredCount].nAnimalID = cRowFall.nID_Obj
.head 9 -  Set nTransferredCount = nTransferredCount+1
.head 5 +  Function: PrepareTransferFallsFromDB
.head 6 -  Description: get information from database
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nScrID
.head 7 -  Number: nRackID
.head 7 -  Number: nCageID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTransferredCount
.head 7 -  String: sSqlBew
.head 7 -  Number: nFtch
.head 6 +  Actions
.head 7 -  Set sSqlBew = "select distinct f.fall_key, f.last_abt_key,g.stat_key,f.last_gruppe_key,f.last_scr_id, g.rack_id , g.id
 from fall f left join gruppe g on (g.id=f.last_cage_id)
where f.GELOESCHT='N'
   and f.last_ba_key!='EE'
   and f.last_scr_id=:nScrID 
"

.head 7 +  If nRackID
.head 8 -  Set sSqlBew = sSqlBew || "
and g.rack_id=:nRackID "
.head 7 +  If nCageID
.head 8 -  Set sSqlBew = sSqlBew || "
and g.id=:nCageID "
.head 7 -  Set sSqlBew = sSqlBew || "
order by f.last_gruppe_key
into :oTransferAnimals[nTransferredCount].nAnimalID,
 :oTransferAnimals[nTransferredCount].sScreen,
 :oTransferAnimals[nTransferredCount].sRack,
 :oTransferAnimals[nTransferredCount].sCage,
 :oTransferAnimals[nTransferredCount].nScreenID, 
 :oTransferAnimals[nTransferredCount].nRackID, 
 :oTransferAnimals[nTransferredCount].nCageID "
.head 7 +  If SalArrayIsEmpty( oTransferAnimals )
.head 8 -  Set nTransferredCount = 0
.head 7 +  Else
.head 8 -  Call SalArrayGetUpperBound( oTransferAnimals, 1, nTransferredCount )
.head 8 -  Set nTransferredCount = nTransferredCount + 1
.head 7 +  If SqlPrepareAndExecute(hSqlTransfer,sSqlBew)
.head 8 +  While SqlFetchNext( hSqlTransfer, nFtch )
.head 9 -  Set nTransferredCount = nTransferredCount + 1
.head 7 -  Return TRUE
.head 5 +  Function: MoveToVirt
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nID
.head 7 -  Number: nLevel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sVirtRack
.head 7 -  String: sVirtScr
.head 7 -  String: sVirtCage
.head 7 -  Sql Handle: hSqlV
.head 7 -  FunctionalVar: oSourceCage[*]
.head 8 -  Class: cPositionData
.head 7 -  Boolean: bOk
.head 7 -  Number: nI
.head 7 -  Number: nFetch
.head 7 -  Number: nCountSource
.head 7 -  Number: nVirtCageID
.head 7 -  Number: nVirtRackID
.head 7 -  Number: nVirtScrID
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nPrint
.head 7 -  Number: nRow
.head 7 -  String: strNull
.head 7 -  Number: nRefreshScrID
.head 7 -  Number: nRefreshRackID
.head 7 -  Boolean: bMoveDone
.head 6 +  Actions
.head 7 -  Set nCountSource = -1
.head 7 -  Set bMoveDone = FALSE
.head 7 -  Set bOk = SqlCreateStatement( hSesionFE, hSqlV)
.head 7 +  If bOk
.head 8 +  If nLevel = KHEL_Gruppe
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlV, "select distinct g.id, g.rack_id, f.last_scr_id from gruppe g
left join fall f on (f.last_cage_id=g.id and f.culling_id is null and f.ee_datum is null)
where g.id=:nID
into :oSourceCage[0].nCageID, :oSourceCage[0].nRackID, :oSourceCage[0].nScreenID " )
.head 9 +  If bOk and SqlFetchNext( hSqlV, nFetch )
.head 10 -  Set nCountSource = 1
.head 8 +  Else If nLevel = KHEL_Station
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlV, "select t.scr_id,g.rack_id,t.id from " || sUserName  ||".t_cage t 
join gruppe g on (g.id=t.id and g.rack_id=:nID)
into :oSourceCage[nI].nScreenID , :oSourceCage[nI].nRackID, :oSourceCage[nI].nCageID " )
.head 9 -  Set nI = 0
.head 9 -  Set nCountSource = 0
.head 9 +  While SqlFetchNext( hSqlV, nFetch )
.head 10 -  Set nCountSource = nCountSource + 1
.head 10 -  Set nI = nI + 1
.head 8 +  Else If nLevel = KHEL_Abteilung
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlV, "select t.scr_id,g.rack_id,t.id from " || sUserName  ||".t_cage t 
join gruppe g on (g.id=t.id)
where t.scr_id=:nID
into :oSourceCage[nI].nScreenID, :oSourceCage[nI].nRackID, :oSourceCage[nI].nCageID " )
.head 9 -  Set nI = 0
.head 9 -  Set nCountSource = 0
.head 9 +  While SqlFetchNext( hSqlV, nFetch )
.head 10 -  Set nCountSource = nCountSource + 1
.head 10 -  Set nI = nI + 1
.head 8 +  If nCountSource>0 and bOk
.head 9 -  Set sVirtRack = frmKHE2DViewVirt.cRack2DLayoutManager.sRack
.head 9 -  Set sVirtScr = frmKHE2DViewVirt.cRack2DLayoutManager.sScreen
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlV, "select id from abteilung
where abt_key=:sVirtScr
into :nVirtScrID " )
.head 9 -  Set bOk = bOk and SqlFetchNext(hSqlV, nFetch)
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlV, "select id from station
where stat_key=:sVirtRack
into :nVirtRackID " )
.head 9 -  Set bOk = bOk and SqlFetchNext(hSqlV, nFetch)
.head 9 -  Set strNull = STRING_Null
.head 9 -  Set bOk = bOk and SqlSetParameter( hSqlV, DBP_PRESERVE	, TRUE, strNull )
.head 9 -  Set bOk = bOk and  SqlPrepareAndExecute(hSqlV, "select g.id, g.rack_id, g.gruppe_key from gruppe g
where g.stat_key =:sVirtRack
and not exists (
select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew
where
   bew.stat_key = g.stat_key
   and bew.gruppe_key =  g.gruppe_key
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit <= @NOW
   and       @nullvalue( bew.BEW_ZEIT_BIS, @datevalue('2222-12-31')) >@NOW
   and	bew.EINRICHT_ID = :nEinrichtId )
and not exists
(select	bew.GRUPPE_KEY
from 	 BEWEGUNG bew
where
   bew.STAT_KEY = g.stat_key
   and bew.gruppe_key=g.gruppe_key
   and       bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
   and       bew.bew_zeit > @NOW
   and	bew.EINRICHT_ID = :nEinrichtId)
and not exists
(select bew.GRUPPE_KEY
  from BETT_LOCKS bew, FALL f,FALL_EXPERIMENT f1
  where bew.STAT_KEY= g.stat_key
     and bew.gruppe_key = g.gruppe_key
     and bew.EINRICHT_ID=:nEinrichtId
     and bew.EINRICHT_ID=f.EINRICHT_ID
     and bew.PLANBEW_FALL=f.FALL_KEY
     and f1.FALL_KEY=f.FALL_KEY
     and f1.EINRICHT_ID=f.EINRICHT_ID
     and @NOW < @NULLVALUE(bew.bis, 12-31-2199))
group by 1,2,3
into :nVirtCageID, :nVirtRackID,:sVirtCage ")
.head 9 -  Set nI = 0
.head 9 +  If CheckStatusObj( FindObject(FindObject( nRoot, nVirtScrID ),nVirtRackID), Rack_NotNeedPrint )
.head 10 -  Set bNotNeedPrintCageCard = TRUE
.head 9 +  While bOk and nI < nCountSource  and SqlFetchNext(hSqlV, nFetch)
.head 10 -  Call MoveCage(oSourceCage[nI].nScreenID, oSourceCage[nI].nRackID, oSourceCage[nI].nCageID,nVirtScrID,nVirtRackID, nVirtCageID, GetTime4Refresh() )
.head 10 +  If nRefreshRackID = NUMBER_Null
.head 11 -  Set nRefreshRackID = oSourceCage[nI].nRackID
.head 11 -  Set nRefreshScrID = oSourceCage[nI].nScreenID
.head 10 +  Else If oSourceCage[nI].nScreenID != nRefreshScrID or oSourceCage[nI].nRackID!=nRefreshRackID 
.head 11 -  Call PopulateRack( FindObject(FindObject( nRoot, nRefreshScrID ),nRefreshRackID), FALSE )
.head 11 -  Set nRefreshRackID = oSourceCage[nI].nRackID
.head 11 -  Set nRefreshScrID = oSourceCage[nI].nScreenID
.head 10 -  Call CloseCage( oSourceCage[nI].nScreenID, oSourceCage[nI].nRackID, oSourceCage[nI].nCageID )
.head 10 -  Call OpenCage( nVirtScrID,nVirtRackID, nVirtCageID )
.head 10 -  Call cSourceCage[nI].Init( sVirtScr,sVirtRack, sVirtCage )
.head 10 -  Set bMoveDone = TRUE
.head 10 -  Set nI = nI + 1
.head 9 -  Call PopulateRack( FindObject(FindObject( nRoot, nRefreshScrID ),nRefreshRackID), FALSE )
.head 9 +  If nI > 0
.head 10 -  Call cDest.Init( cSourceCage[nI-1].sScreenKey, cSourceCage[nI-1].sRackKey, cSourceCage[nI-1].sCageKey)
.head 9 -  Call SalPostMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 9 -  Call SalPostMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 9 -  Call Rack2DView_ReflectButtonsState()
.head 9 -  Call PrintCageCards( cSourceCage, cDest )
.head 9 -  Call PopulateRack( FindObject(FindObject( nRoot, nVirtScrID ),nVirtRackID), FALSE )
.head 9 -  ! Call Rack2DView_RefreshCageContents(sCageList)
.head 7 +  If hSqlV
.head 8 -  Call SqlDisconnect( hSqlV )
.head 7 -  Set bNotNeedPrintCageCard = FALSE
.head 7 -  Return bOk and bMoveDone
.head 5 +  Function: MoveFromVirt
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nRowEmpty[*]
.head 7 -  Number: nRowRack
.head 7 -  Number: nCountEmpty
.head 7 -  String: sVirtRack
.head 7 -  String: sVirtScr
.head 7 -  String: strNull
.head 7 -  FunctionalVar: oSource
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oTarget
.head 8 -  Class: cPositionData
.head 7 -  Number: nI
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set nRowRack = nSelectedRow
.head 7 -  Set bOk  = TRUE
.head 7 +  Loop
.head 8 +  If GetLevel( nRowRack) <= KHEL_Station
.head 9 -  Break
.head 8 -  Set nRowRack = GetParent( nRowRack )
.head 7 -  Call oRefreshCages.Init(  )
.head 7 -  Set strNull = STRING_Null
.head 7 -  Set nCountEmpty = GetOpenCages(nRowRack, CageIsEmpty  ,nRowEmpty )
.head 7 -  Set sVirtRack = frmKHE2DViewVirt.cRack2DLayoutManager.sRack
.head 7 -  Set sVirtScr = frmKHE2DViewVirt.cRack2DLayoutManager.sScreen
.head 7 -  Set bOk = bOk and SqlSetParameter( hSqlGetInfo, DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlGetInfo , "select distinct f.last_abt_key, f.last_stat_key, f.last_gruppe_key, f.last_scr_id,g.rack_id,f.last_cage_id from fall f
left join gruppe g on (g.id=f.last_cage_id)
where ee_datum is null and culling_id is null 
and last_abt_key=:sVirtScr
and last_stat_key=:sVirtRack 
into :oSource.sScreen, :oSource.sRack, :oSource.sCage, :oSource.nScreenID, :oSource.nRackID, :oSource.nCageID   " )
.head 7 -  Set nI = 0
.head 7 +  While bOk and nI < nCountEmpty  and SqlFetchNext(hSqlGetInfo, nFetch)
.head 8 -  Call _GetPositionID( nRowEmpty[nI], oTarget )
.head 8 -  Call MoveCage(oSource.nScreenID, oSource.nRackID, oSource.nCageID,oTarget.nScreenID, oTarget.nRackID, oTarget.nCageID, GetTime4Refresh() )
.head 8 -  Call oRefreshCages.AddRow( nRowEmpty[nI] )
.head 8 -  Set nI = nI + 1
.head 7 -  Call RefreshCages(  )
.head 7 -  Call PopulateRack( FindObject(FindObject( nRoot, oSource.nScreenID ),oSource.nRackID), FALSE )
.head 7 -  Return TRUE
.head 5 +  Function: MoveTransferCages
.head 6 -  Description: Shift cages between screens and racks
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oSourceCage[*]
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oTargetCage[*]
.head 8 -  Class: cPositionData
.head 7 -  Number: nTCage
.head 7 -  Number: nSCage
.head 7 -  FunctionalVar: oCurPos
.head 8 -  Class: cPositionData
.head 7 -  Number: hScreen[*]
.head 7 -  Number: hRack[*]
.head 7 -  Number: hCage[*]
.head 7 -  Number: nScreens
.head 7 -  Number: nRacks
.head 7 -  Number: nCages
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nJ
.head 7 -  Boolean: bShowDialog
.head 7 -  ! Window Handle: hWndProgress
.head 7 -  String: sText
.head 7 -  Boolean: bSaveLicence
.head 7 -  FunctionalVar: cSourceCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nIndCage
.head 7 -  Number: nType
.head 7 -  Sql Handle: hSql
.head 7 -  Number: hStat
.head 7 -  Boolean: bNeedShowSR
.head 7 -  String: sListCages
.head 7 -  !
.head 7 -  Number: nEmptyCages
.head 7 -  Number: nFullCages
.head 7 -  Number: nRowEmpty[*]
.head 7 -  Number: nRowFull[*]
.head 7 -  Number: nTransferredFalls[*]
.head 6 +  Actions
.head 7 +  If CanMoveTransferCages(nType)
.head 8 -  ! Clear Arrays
.head 8 -  Set sListCages = ""
.head 8 -  Call SalSetArrayBounds( oTransferAnimals, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oSourceCage, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oTargetCage, 1, -1 )
.head 8 -  Call SalSetArrayBounds( nRowEmpty, 1, -1 )
.head 8 -  Call SalSetArrayBounds( nRowFull, 1, -1 )
.head 8 -  Call SalSetArrayBounds( nTransferredFalls, 1, -1 )
.head 8 -  Call oRefreshCages.Init(  )
.head 8 -  ! Find open cages and save informations 
.head 8 -  Set nEmptyCages = GetOpenCages(nRoot, CageIsEmpty,nRowEmpty )
.head 8 -  Set nFullCages = GetOpenCages(nRoot, CageIsFull  ,nRowFull )
.head 8 -  Set nI = 0
.head 8 -  Set nTCage = 0
.head 8 +  While nI < nEmptyCages
.head 9 -  Call _GetPositionID( nRowEmpty[nI], oCurPos )
.head 9 -  Set oCurPos.nActHandel = nRowEmpty[nI]
.head 9 -  Call oRefreshCages.AddRow( nRowEmpty[nI] )
.head 9 -  Set oTargetCage[nTCage].nActHandel = oCurPos.nActHandel
.head 9 -  Set oTargetCage[nTCage].nCageID = oCurPos.nCageID
.head 9 -  Set oTargetCage[nTCage].nPosID= oCurPos.nPosID
.head 9 -  Set oTargetCage[nTCage].nRackID = oCurPos.nRackID
.head 9 -  Set oTargetCage[nTCage].nScreenID= oCurPos.nScreenID
.head 9 -  Set oTargetCage[nTCage].sBett= oCurPos.sBett
.head 9 -  Set oTargetCage[nTCage].sCage= oCurPos.sCage
.head 9 -  Set oTargetCage[nTCage].sRack= oCurPos.sRack
.head 9 -  Set oTargetCage[nTCage].sScreen= oCurPos.sScreen
.head 9 -  Set nTCage = nTCage + 1
.head 9 -  Set nI = nI + 1
.head 8 -  Set nI = 0
.head 8 -  Set nSCage = 0
.head 8 +  While nI < nFullCages
.head 9 -  Call _GetPositionID( nRowFull[nI], oCurPos )
.head 9 -  Set oCurPos.nActHandel = nRowFull[nI]
.head 9 -  Call oRefreshCages.AddRow( nRowFull[nI] )
.head 9 -  Set oSourceCage[nSCage].nActHandel = oCurPos.nActHandel
.head 9 -  Set oSourceCage[nSCage].nCageID = oCurPos.nCageID
.head 9 -  Set oSourceCage[nSCage].nPosID= oCurPos.nPosID
.head 9 -  Set oSourceCage[nSCage].nRackID = oCurPos.nRackID
.head 9 -  Set oSourceCage[nSCage].nScreenID= oCurPos.nScreenID
.head 9 -  Set oSourceCage[nSCage].sBett= oCurPos.sBett
.head 9 -  Set oSourceCage[nSCage].sCage= oCurPos.sCage
.head 9 -  Set oSourceCage[nSCage].sRack= oCurPos.sRack
.head 9 -  Set oSourceCage[nSCage].sScreen= oCurPos.sScreen
.head 9 -  Set nSCage = nSCage + 1
.head 9 -  Set sListCages = sListCages || oCurPos.sCage || ","
.head 9 +  If bAskForLicense
.head 10 -  Call PrepareTransferFalls( nRowFull[nI] )
.head 9 -  Set nI = nI + 1
.head 8 -  Set nI = 0
.head 8 -  Call SalArrayGetUpperBound( oTransferAnimals, 1, nK )
.head 8 +  While nI <= nK
.head 9 -  Set nTransferredFalls[nI] = oTransferAnimals[nI].nAnimalID
.head 9 -  Set nI = nI + 1
.head 8 -  !
.head 8 -  Set bShowDialog = bShowTransferDialog
.head 8 +  If sListCages != ""
.head 9 -  Call SalStrLeft( sListCages, SalStrLength( sListCages ) - 1 , sListCages )
.head 8 +  If not bShowDialog or SalModalDialog( dlgTransferCages, hWndForm, oSourceCage, oTargetCage, nType ) = IDOK ! not bPlanningMode 
.head 9 -  Call LockSysadmAction( "Start transfer cages")
.head 9 -  Set bNeedShowSR = FALSE
.head 9 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 10 -  Call VisWinShow (hWndRack2DView, SHOW_Minimized)
.head 10 -  Set bNeedShowSR = TRUE
.head 9 -  Set bSaveLicence = bAskForLicense
.head 9 -  Set bAskForLicense = FALSE
.head 9 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nSCage  )
.head 9 -  Set nI = 0
.head 9 -  Set nIndCage = 0
.head 9 -  Call LT_OpenTransaction(6,SalDateCurrent(  ))
.head 9 +  While nI < nSCage
.head 10 +  If hWndProgress
.head 11 -  Set sText = "Move cage " ||oSourceCage[nI].sScreen|| "/" ||oSourceCage[nI].sRack ||"/" ||oSourceCage[nI].sCage 
.head 11 -  Set sText = sText || " to  cage" || oTargetCage[nI].sScreen|| "/" || oTargetCage[nI].sRack ||"/" ||oTargetCage[nI].sCage
.head 11 -  Call dlgProgress.Init( nSCage, sText)
.head 11 -  Set dlgProgress.nCurrent = nI
.head 11 -  Call dlgProgress.Next(  )
.head 10 -  Call MoveCage(oSourceCage[nI].nScreenID, oSourceCage[nI].nRackID, oSourceCage[nI].nCageID, oTargetCage[nI].nScreenID, oTargetCage[nI].nRackID, oTargetCage[nI].nCageID, SalDateCurrent(  ) )
.head 10 -  Set nIndCage = nIndCage + 1
.head 10 -  Set nI = nI + 1
.head 9 -  Set cDest = cSourceCage[nIndCage - 1]
.head 9 -  Set bAskForLicense = bSaveLicence
.head 9 -  If SqlCreateStatement( hSesionFE , hSql)
.head 9 -  Call GetTime4Refresh()
.head 9 +  If bAskForLicense and oSourceCage[0].sScreen != oTargetCage[0].sScreen
.head 10 -  Call SetMassLicense( hSesionFE,  nTransferredFalls, oTargetCage[0].sScreen)
.head 9 -  !
.head 9 +  If hSql
.head 10 -  Call SqlCommit( hSql )
.head 10 -  Call SqlDisconnect(hSql)
.head 9 -  Call LT_CloseLastTransaction()
.head 9 -  Call RefreshCages(  )
.head 9 +  ! If SalIsWindowVisible( hWndRack2DView ) 
.head 10 -  ! Call VisWinShow (hWndRack2DView, SHOW_Normal)
.head 10 -  ! Call SalPostMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 10 +  If bAskForLicense and oSourceCage[0].sScreen != oTargetCage[0].sScreen
.head 11 -  Call SalPostMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, 0 )
.head 9 +  If hWndProgress
.head 10 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 10 -  Set hWndProgress = hWndNULL
.head 9 -  Call LockSysadmAction( "Finish transfer cages")
.head 8 -  Call SalSetArrayBounds( oTransferAnimals, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oSourceCage, 1, -1 )
.head 8 -  Call SalSetArrayBounds( oTargetCage, 1, -1 )
.head 8 -  Call SalSetArrayBounds( nRowEmpty, 1, -1 )
.head 8 -  Call SalSetArrayBounds( nRowFull, 1, -1 )
.head 8 -  Call SalSetArrayBounds( nTransferredFalls, 1, -1 )
.head 8 -  Call ActivateRow( FindObject(FindObject( nRoot, oTargetCage[nI-1].nScreenID ),oTargetCage[nI-1].nRackID) )
.head 5 +  Function: PrintCageCard
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oPosCage
.head 8 -  Class: cPositionData
.head 7 -  Date/Time: dtKHE
.head 7 -  !
.head 7 -  Boolean: bPrint
.head 7 -  FunctionalVar: cPrintCages[*]
.head 8 -  Class: clsLocation
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocationCage
.head 7 -  Number: nOpenCages
.head 7 -  Number: nOpenCagesRow[*]
.head 7 -  Number: nI
.head 7 -  Number: nFtc
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Call LockSysadmAction("Print cage card start")
.head 7 +  If nSelectedLevel  = KHEL_Gruppe
.head 8 -  Set dtKHE = GetTime4Refresh(  )
.head 8 +  If not CheckStatusObj( nSelectedRow, CageIsOccupied  )
.head 9 -  Call _GetPositionID( nSelectedRow, oPosCage )
.head 9 +  If CageFormularWithLitter( "", "" )
.head 10 +  If CheckStatusObj( nSelectedRow, Rack_IsIntensiv  )
.head 11 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtKHE, '4', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 10 +  Else
.head 11 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtKHE, '2', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 9 +  Else
.head 10 +  If CheckStatusObj( nSelectedRow, Rack_IsIntensiv  )
.head 11 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtKHE, '3', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 10 +  Else
.head 11 -  Call Formular_CageCardX(oPosCage.sRack, oPosCage.sCage, dtKHE, '1', Not SHOW_EXTERNAL, AUTO_PRINT )
.head 7 +  Else If nSelectedLevel  = KHEL_Station
.head 8 -  Set nOpenCages = GetOpenCages(nSelectedRow,CageIsFull ,nOpenCagesRow)
.head 8 +  If nOpenCages > 0
.head 9 -  Set nI = 0
.head 9 +  While nI < nOpenCages
.head 10 -  Call _GetPositionID( nOpenCagesRow[nI], oPos )
.head 10 -  Call cCages[nI].Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 10 -  Set cPrintCages[nI] = cCages[nI]
.head 10 -  Set nI = nI + 1
.head 8 +  Else
.head 9 -  Set nI = 0
.head 9 +  If SqlPrepareAndExecute( hSqlGetInfo, "select distinct f.last_abt_key, g.stat_key,f.last_gruppe_key from fall f
join gruppe g on (g.id=f.last_cage_id and g.rack_id=:oPosition.nRackID)
  where f.geloescht='N' 
and f.ee_datum is null
and f.last_scr_id=:oPosition.nScreenID
into :oPos.sScreen, :oPos.sRack, :oPos.sCage " )
.head 10 +  While SqlFetchNext(hSqlGetInfo,nFtc)
.head 11 -  Call cCages[nI].Init( oPos.sScreen, oPos.sRack, oPos.sCage )
.head 11 -  Set cPrintCages[nI] = cCages[nI]
.head 11 -  Set nI = nI + 1
.head 8 -  !
.head 8 +  If Not Requst_ListForCageCard( cPrintCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 9 -  ! user canceled the action
.head 9 -  Set bOk = TRUE
.head 8 +  If bOk
.head 9 +  If bPrint
.head 10 -  Call Formular_CageCard_Print( '', '', GetTime4Refresh( ) )
.head 5 +  Function: PrintBarcodeCageCard
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sParam
.head 7 -  Date/Time: dtTime
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  If nSelectedLevel  = KHEL_Gruppe
.head 8 -  Set bOk = CageCard_Multi_ClearArr(  )
.head 8 -  Set bOk = bOk And CageCard_Multi_Add2Arr( oPosition.sRack , oPosition.sCage )
.head 8 -  Set dtTime = SalDateCurrent(  )
.head 8 -  Set sParam = oPosition.sRack || "," || oPosition.sCage || "," || SalFmtFormatDateTime( dtTime, 'yyyy-MM-dd hhhh:mm:ss' )
.head 8 -  Set bOk = bOk And Formular_Print( "BC_ALLC", sParam )
.head 8 -  ! Set bOk = bOk and Formular_Show( "BC_ALLC", sParam, FALSE )
.head 5 +  Function: ViewBarcodeCageCard
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sParam
.head 7 -  Date/Time: dtTime
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  If nSelectedLevel  = KHEL_Gruppe
.head 8 -  Set bOk = CageCard_Multi_ClearArr(  )
.head 8 -  Set bOk = bOk And CageCard_Multi_Add2Arr( oPosition.sRack , oPosition.sCage )
.head 8 -  Set dtTime = SalDateCurrent(  )
.head 8 -  Set sParam = oPosition.sRack || "," || oPosition.sCage || "," || SalFmtFormatDateTime( dtTime, 'yyyy-MM-dd hhhh:mm:ss' )
.head 8 -  ! Set bOk = bOk And Formular_Print( "BC_ALLC", sParam )
.head 8 -  Set bOk = bOk and Formular_Show( "BC_ALLC", sParam, FALSE )
.head 5 +  Function: MoveCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nDirection
.head 7 -  Number: nDistance
.head 7 -  Number: nTwoDirection
.head 7 -  Number: nTwoDistance
.head 7 -  Boolean: bOnlyCheck
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sScr
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sBett
.head 7 -  Number: hResHandle
.head 7 -  Number: hCurrentHandle
.head 7 -  String: sSources[*]
.head 7 -  String: sTargets[*]
.head 7 -  Number: hChilds[*]
.head 7 -  Number: nChilds
.head 7 -  Number: nNumberOfMovingCages
.head 7 -  Number: nCount
.head 7 -  Boolean: bErrorDetected
.head 7 -  String: sIn
.head 7 -  String: sSrc
.head 7 -  String: sRequest
.head 7 -  Sql Handle: hSql
.head 7 -  String: sFrom
.head 7 -  String: sTo
.head 7 -  Number: nFetch
.head 7 -  Date/Time: dtTime
.head 7 -  Date/Time: dtTimeShift
.head 7 -  FunctionalVar: cSrc[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  String: sRFID
.head 7 -  String: sOrder
.head 7 -  Number: i
.head 7 -  Number: nTemp
.head 7 -  !
.head 7 -  FunctionalVar: oPosSelect
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  ! ! Get active rack and screen; set up root handle
.head 7 +  If (nDistance <= 0) or (NOT nDirection) or ((nTwoDistance > 0) and (NOT nTwoDirection))
.head 8 -  Return FALSE
.head 7 -  Set hCurrentHandle = nSelectedRow
.head 7 -  ! Call GetPosition(nSelectedHandle, sScr, sRack, sCage, sBett)
.head 7 -  Call _GetPositionID(nSelectedRow , oPosSelect)
.head 7 -  Set dtTime = GetTime4Refresh()
.head 7 +  If CheckStatusObj( nSelectedRow, CageIsOccupied )
.head 8 -  Return FALSE
.head 7 +  ! If KHE_IsOccupied( sScr, sRack, sCage, sBett, dtTime)
.head 8 -  Return FALSE
.head 7 +  If (oPosSelect.sScreen != "") and (oPosSelect.sRack !="")
.head 8 +  If oPosSelect.sBett != ""
.head 9 -  Set hCurrentHandle = GetParent(hCurrentHandle)
.head 8 +  If oPosSelect.sCage  != ""
.head 9 -  Set hCurrentHandle = GetParent(hCurrentHandle)
.head 8 -  ! Set nChilds = EnumChildren(hCurrentHandle, hChilds)
.head 8 -  Set nChilds = 1
.head 8 +  If nChilds>0
.head 9 -  ! fill hSources array
.head 9 -  Set nCount = 0
.head 9 -  Set nNumberOfMovingCages = 0
.head 9 -  Set sIn = ""
.head 9 +  If SqlCreateStatement( hSesionFE , hSql )
.head 10 +  If not  SqlPrepareAndExecute( hSql, "select g.stat_key, g.gruppe_key 
from "||sUserName  ||".t_cage t
 left join gruppe g on (g.id=t.id)
where scr_id=:oPosSelect.nScreenID
and g.rack_id=:oPosSelect.nRackID 
into :sRack , :sCage" )
.head 11 -  Set bErrorDetected = TRUE
.head 10 +  While SqlFetchNext( hSql, nFetch )
.head 11 -  Set sIn = sIn||"'"||sCage||"',"
.head 11 -  Set nNumberOfMovingCages = nNumberOfMovingCages+1
.head 9 +  ! While (nCount<nChilds) and (NOT bErrorDetected)
.head 10 +  If KHE_IsExpanded(hChilds[nCount])
.head 11 +  If KHEGetHasFall(hChilds[nCount])
.head 12 -  Call GetPosition(hChilds[nCount], sScr, sRack, sCage, sBett)
.head 12 -  Set sIn = sIn||"'"||sCage||"',"
.head 12 -  Set nNumberOfMovingCages = nNumberOfMovingCages+1
.head 11 +  Else 
.head 12 -  Set bErrorDetected = TRUE
.head 10 -  Set nCount = nCount+1
.head 9 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 9 +  If (NOT bErrorDetected) and (sIn != "")
.head 10 +  If TRUE ! SqlCreateStatement( hSesionFE , hSql )
.head 11 -  ! sort src array
.head 11 +  Select Case nDirection
.head 12 +  Case DIR_Up
.head 13 +  If nTwoDirection = DIR_Right
.head 14 -  Set sOrder = "a.y_pos_label, a.x_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.y_pos_label, a.x_pos_label"
.head 13 -  Break
.head 12 +  Case DIR_Down
.head 13 +  If nTwoDirection = DIR_Right
.head 14 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label"
.head 13 -  Break
.head 12 +  Case DIR_Left
.head 13 +  If nTwoDirection = DIR_Down
.head 14 -  Set sOrder = "a.x_pos_label, a.y_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.x_pos_label, a.y_pos_label"
.head 13 -  Break
.head 12 +  Case DIR_Right
.head 13 +  If nTwoDirection = DIR_Down
.head 14 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label desc"
.head 13 +  Else
.head 14 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label"
.head 13 -  Break
.head 11 -  Call SqlPrepareAndExecute(hSql, "select a.gruppe_key from gruppe a where gruppe_key in("||sIn||") and STAT_KEY=:sRack  order by "||sOrder||" into :sFrom")
.head 11 -  Call SalArraySetUpperBound(sSources, 1, nNumberOfMovingCages)
.head 11 -  Call SalArraySetUpperBound(sTargets, 1, nNumberOfMovingCages)
.head 11 -  Set nCount = 0
.head 11 -  Set sIn = ""
.head 11 +  While SqlFetchNext(hSql, nFetch)
.head 12 -  Set sSources[nCount] = sFrom
.head 12 -  Set sIn = sIn||"'"||sFrom||"',"
.head 12 -  Set nCount = nCount+1
.head 11 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 11 -  Set sSrc = sIn
.head 10 +  Else
.head 11 -  Set bErrorDetected = TRUE
.head 9 +  If nCount = nNumberOfMovingCages
.head 10 +  Select Case nDirection
.head 11 +  Case DIR_Up
.head 12 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 12 -  Set sTo = "b.y_pos_label = (select max(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)<@value(a.y_pos_label))"
.head 12 -  Break
.head 11 +  Case DIR_Down
.head 12 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 12 -  Set sTo = "b.y_pos_label = (select min(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)>@value(a.y_pos_label))"
.head 12 -  Break
.head 11 +  Case DIR_Left
.head 12 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 12 -  Set sTo = "b.x_pos_label = (select max(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label<a.x_pos_label)"
.head 12 -  Break
.head 11 +  Case DIR_Right
.head 12 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 12 -  Set sTo = "b.x_pos_label = (select min(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label>a.x_pos_label)"
.head 12 -  Break
.head 10 -  Set sRequest = sFrom||" and "||sTo
.head 10 +  While (nDistance >0) and (NOT bErrorDetected)
.head 11 -  Set nCount = 0
.head 11 -  Call SqlPrepareAndExecute(hSql, "select
 b.gruppe_key
from
 gruppe a, gruppe b
where
 a.gruppe_key in ("||sIn||")
 and a.stat_key=:sRack
 and b.stat_key = a.stat_key
 and "||sRequest||" order by "||sOrder||" into :sTo")
.head 11 -  Set nCount = 0
.head 11 -  Set sIn = ""
.head 11 +  While SqlFetchNext(hSql, nFetch)
.head 12 -  Set sTargets[nCount] = sTo
.head 12 -  Set sIn = sIn||"'"||sTo||"',"
.head 12 -  Set nCount = nCount+1
.head 11 +  If nCount != nNumberOfMovingCages
.head 12 -  Set bErrorDetected = TRUE
.head 11 +  Else
.head 12 -  Set nDistance = nDistance -1
.head 12 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 9 -  ! fill hSources array
.head 9 +  If nTwoDistance
.head 10 -  Set i = 0
.head 10 -  Set sIn = ""
.head 10 +  While (i<nCount) and (NOT bErrorDetected)
.head 11 -  Set sIn = sIn||"'"||sTargets[i]||"',"
.head 11 -  Set i = i + 1
.head 10 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 10 +  If (NOT bErrorDetected) and (sIn != "")
.head 11 +  If GalConnect(hSql)
.head 12 -  ! sort src array
.head 12 +  Select Case nDirection
.head 13 +  Case DIR_Up
.head 14 +  If nTwoDirection = DIR_Right
.head 15 -  Set sOrder = "a.y_pos_label, a.x_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.y_pos_label, a.x_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Down
.head 14 +  If nTwoDirection = DIR_Right
.head 15 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.y_pos_label desc, a.x_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Left
.head 14 +  If nTwoDirection = DIR_Down
.head 15 -  Set sOrder = "a.x_pos_label, a.y_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.x_pos_label, a.y_pos_label"
.head 14 -  Break
.head 13 +  Case DIR_Right
.head 14 +  If nTwoDirection = DIR_Down
.head 15 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label desc"
.head 14 +  Else
.head 15 -  Set sOrder = "a.x_pos_label desc, a.y_pos_label"
.head 14 -  Break
.head 12 -  Call SqlPrepareAndExecute(hSql, "select a.gruppe_key from gruppe a where gruppe_key in("||sIn||") and STAT_KEY=:sRack  order by "||sOrder||" into :sFrom")
.head 12 -  Call SalArraySetUpperBound(sSources, 1, nNumberOfMovingCages)
.head 12 -  Call SalArraySetUpperBound(sTargets, 1, nNumberOfMovingCages)
.head 12 -  Set nCount = 0
.head 12 -  Set sIn = ""
.head 12 +  While SqlFetchNext(hSql, nFetch)
.head 13 -  ! Set sSources[nCount] = sFrom
.head 13 -  Set sIn = sIn||"'"||sFrom||"',"
.head 13 -  Set nCount = nCount+1
.head 12 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 12 -  ! Set sSrc = sIn
.head 11 +  Else
.head 12 -  Set bErrorDetected = TRUE
.head 10 +  If nCount = nNumberOfMovingCages
.head 11 +  Select Case nTwoDirection
.head 12 +  Case DIR_Up
.head 13 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 13 -  Set sTo = "b.y_pos_label = (select max(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)<@value(a.y_pos_label))"
.head 13 -  Break
.head 12 +  Case DIR_Down
.head 13 -  Set sFrom = "b.x_pos_label = a.x_pos_label"
.head 13 -  Set sTo = "b.y_pos_label = (select min(@value(y_pos_label)) from gruppe where stat_key = a.stat_key and @value(y_pos_label)>@value(a.y_pos_label))"
.head 13 -  Break
.head 12 +  Case DIR_Left
.head 13 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 13 -  Set sTo = "b.x_pos_label = (select max(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label<a.x_pos_label)"
.head 13 -  Break
.head 12 +  Case DIR_Right
.head 13 -  Set sFrom = "b.y_pos_label = a.y_pos_label"
.head 13 -  Set sTo = "b.x_pos_label = (select min(x_pos_label) from gruppe where stat_key = a.stat_key and x_pos_label>a.x_pos_label)"
.head 13 -  Break
.head 11 -  Set sRequest = sFrom||" and "||sTo
.head 11 +  While (nTwoDistance >0) and (NOT bErrorDetected)
.head 12 -  Set nCount = 0
.head 12 -  Call SqlPrepareAndExecute(hSql, "select
 b.gruppe_key
from
 gruppe a, gruppe b
where
 a.gruppe_key in ("||sIn||")
 and a.stat_key=:sRack
 and b.stat_key = a.stat_key
 and "||sRequest||" order by "||sOrder||" into :sTo")
.head 12 -  Set nCount = 0
.head 12 -  Set sIn = ""
.head 12 +  While SqlFetchNext(hSql, nFetch)
.head 13 -  Set sTargets[nCount] = sTo
.head 13 -  Set sIn = sIn||"'"||sTo||"',"
.head 13 -  Set nCount = nCount+1
.head 12 +  If nCount != nNumberOfMovingCages
.head 13 -  Set bErrorDetected = TRUE
.head 12 +  Else
.head 13 -  Set nTwoDistance = nTwoDistance -1
.head 13 -  Set sIn = SalStrLeftX(sIn, SalStrLength(sIn)-1)
.head 9 +  If NOT bErrorDetected
.head 10 -  Call SqlExists("select b.fall_key
from bewegung b, fall f
	where gruppe_key in ("||sIn||") and gruppe_key not in ("||sSrc||")
 and @nullvalue( b.GELOESCHT, 'N' ) != 'J'
 and	b.BA_KEY in ( 'AE', 'UE', 'VE', 'RE' )
 and	:dtTime >= b.BEW_ZEIT
 and	( :dtTime <= b.BEW_ZEIT_BIS or ( b.BEW_ZEIT_BIS is NULL) )
 and	f.EINRICHT_ID = b.EINRICHT_ID
 and	f.FALL_KEY = b.FALL_KEY
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
union
select f.fall_key
from BETT_LOCKS b, FALL f
where gruppe_key in ("||sIn||") and gruppe_key not in ("||sSrc||")
and b.EINRICHT_ID=1
and b.EINRICHT_ID=f.EINRICHT_ID
and b.PLANBEW_FALL=f.FALL_KEY
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and (b.bis is null or b.bis>:dtTime)
union
select b.fall_key
from BEWEGUNG b, Fall f
where b.BEW_ZEIT> :dtTime
and gruppe_key in ("||sIn||") and gruppe_key not in ("||sSrc||")
 and @nullvalue( b.GELOESCHT, 'N' ) != 'J'
and b.EINRICHT_ID=1
and b.EINRICHT_ID=f.EINRICHT_ID
 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and b.FALL_KEY=f.FALL_KEY", bErrorDetected)
.head 10 +  If (NOT bErrorDetected) and (NOT bOnlyCheck)
.head 11 -  ! Movecages ;)
.head 11 -  Set dtTimeShift=GetTime4Refresh()
.head 11 -  Call LT_OpenTransaction(5,dtTimeShift)
.head 11 -  Call LockSysadmAction("Shift cages started...")
.head 11 -  Call SalModalDialog(dlgShiftProcess, hWndForm, sScr, sRack, nNumberOfMovingCages, sSources, sTargets, dtTimeShift)
.head 11 -  Call LockSysadmAction("...Shift cages finished")
.head 11 -  Call LT_CloseLastTransaction()
.head 8 +  Else
.head 9 -  Set bErrorDetected = TRUE
.head 7 +  Else
.head 8 -  Set bErrorDetected = TRUE
.head 7 +  If hSql
.head 8 -  Call SqlDisconnect(hSql)
.head 7 -  Call SalArraySetUpperBound(sSources, 1, 0)
.head 7 -  Call SalArraySetUpperBound(sTargets, 1, 0)
.head 7 -  Call SalArraySetUpperBound(cSrc, 1, 0)
.head 7 -  Return NOT bErrorDetected
.head 5 +  Function: PasteRolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlRol
.head 7 -  Number: nFallMale
.head 7 -  Number: nCountOpenCage
.head 7 -  Number: nRowOpenCages[*]
.head 7 -  FunctionalVar: oFECage
.head 8 -  Class: cFERowCage
.head 7 -  Number: nSourceCage
.head 7 -  Number: nFalls[*]
.head 7 -  Number: nCountFalls
.head 7 -  Number: nI
.head 7 -  Number: nFtch
.head 7 -  Number: nRowMale
.head 6 +  Actions
.head 7 +  If SqlCreateStatement( hSesionFE , hSqlRol )
.head 8 -  !
.head 8 -  Set nCountOpenCage = GetOpenCages( nRoot, CageIsFull , nRowOpenCages )
.head 8 +  If oHandleSelect.bAnySelects
.head 9 -  Set nFallMale = GetIdObject( GetRowID(oHandleSelect.nRow[0]) )
.head 9 -  Set nRowMale = GetRowID(oHandleSelect.nRow[0])
.head 8 +  Else
.head 9 +  If nSelectedLevel = KHEL_Bett
.head 10 -  Set nFallMale = GetIdObject( nSelectedRow )
.head 10 -  Call SwitchSelectRow( nSelectedRow )
.head 10 -  Set nRowMale = nSelectedRow
.head 8 -  !
.head 8 -  Set oFECage = FE_GetInfo( nRowOpenCages[0] )
.head 8 +  If oFECage.GetNValue( "SEX" ) = 1 ! only female
.head 9 -  Set nSourceCage = nRowOpenCages[0]
.head 9 +  If not nFallMale
.head 10 -  Set nCountFalls = EnumChildren(nRowOpenCages[1], nFalls)
.head 10 +  If nCountFalls = 1
.head 11 -  Set nFallMale = nFalls[0]
.head 10 +  Else
.head 11 -  Set nI = 0
.head 11 +  While nI < nCountFalls
.head 12 -  Call SqlPrepareAndExecute( hSqlRol, "select rf.fall_key from roling_fall rf
 join fall f on (f.fall_key=rf.fall_key and f.geschl = 'M' ) where rf.fall_key=:nFalls[nI] and rf.status=0 into :nFallMale " )
.head 12 +  If SqlFetchNext( hSqlRol, nFtch )
.head 13 -  Break
.head 12 -  Set nI = nI + 1
.head 10 -  Set nRowMale = FindObject( nRowOpenCages[1], nFallMale )
.head 8 +  Else
.head 9 +  If not nFallMale
.head 10 -  Set nCountFalls = EnumChildren(nRowOpenCages[0], nFalls)
.head 10 +  If nCountFalls = 1
.head 11 -  Set nFallMale = nFalls[0]
.head 10 +  Else
.head 11 -  Set nI = 0
.head 11 +  While nI < nCountFalls
.head 12 -  Call SqlPrepareAndExecute( hSqlRol, "select rf.fall_key from roling_fall rf
 join fall f on (f.fall_key=rf.fall_key and f.geschl = 'M' ) where rf.fall_key=:nFalls[nI] and rf.status=0 into :nFallMale " )
.head 12 +  If SqlFetchNext( hSqlRol, nFtch )
.head 13 -  Break
.head 12 -  Set nI = nI + 1
.head 10 -  Set nRowMale = FindObject( nRowOpenCages[0], nFallMale )
.head 9 -  Set oFECage = FE_GetInfo( nRowOpenCages[1] )
.head 9 +  If oFECage.GetNValue( "SEX" ) = 1
.head 10 -  Set nSourceCage = nRowOpenCages[1]
.head 8 -  !
.head 8 +  If nFallMale and nSourceCage and nRowMale
.head 9 -  Call LockSysadmAction("Rolling ...")
.head 9 +  If not oHandleSelect.RowIsSelected( GetUniqRowID(nRowMale) )
.head 10 -  Call SwitchSelectRow( nRowMale )
.head 9 -  Call SqlPrepareAndExecute(hSqlRol,"select fall_key from roling_fall where fall_key=:nFallMale and status=0" )
.head 9 +  If not SqlFetchNext( hSqlRol, nFtch )
.head 10 -  Call SqlPrepareAndExecute(hSqlRol,"Insert into roling_fall(fall_key,status) values(:nFallMale,0)" )
.head 9 -  Call SqlCommit(hSqlRol)
.head 9 -  Call SalTblSetFocusRow( hWndForm, nSourceCage )
.head 9 -  Call SalTblSetContext( hWndForm, nSourceCage )
.head 9 -  Call PasteToCurrent(  )
.head 8 +  If hSqlRol
.head 9 -  Call SqlDisconnect( hSqlRol )
.head 8 -  !
.head 8 -  !
.head 5 +  Function: PasteToCurrent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  Date/Time: dtTime
.head 7 -  FunctionalVar: oTarget
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oSource
.head 8 -  Class: cPositionData
.head 7 -  Boolean: bOk
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nInd
.head 7 -  Number: nMax
.head 7 -  Number: nTransferredFalls[*]
.head 7 -  FunctionalVar: oRefreshCage[*]
.head 8 -  Class: cPositionData
.head 7 -  String: sBA_Key
.head 7 -  String: sBA_KeyPrev
.head 7 -  String: sBettKey
.head 7 -  Number: nBewNr
.head 7 -  FunctionalVar: oRowSource
.head 8 -  Class: cFERow
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Boolean: bCadaver
.head 7 -  Boolean: bLicence
.head 7 -  Number: nRowRefresh
.head 6 +  Actions
.head 7 -  Call SalSetArrayBounds( oTransferAnimals, 1, -1 )
.head 7 -  Call SalSetArrayBounds( nTransferredFalls, 1, -1 )
.head 7 -  Call oRefreshCages.Init(  )
.head 7 -  Set bCadaver = FALSE
.head 7 -  Set bLicence = FALSE
.head 7 -  Call _GetPositionID( nSelectedRow, oTarget )
.head 7 -  Call oRefreshCages.AddRow( nSelectedRow )
.head 7 -  Set oRowSource = FE_GetInfo( nSelectedRow )
.head 7 -  Set nMax = 0
.head 7 -  Set nInd = 0
.head 7 -  Set nI = 0
.head 7 +  While nI < oHandleSelect.nIndex
.head 8 -  Call PrepareTransferFalls( GetRowID(oHandleSelect.nRow[nI]) )
.head 8 -  Call oRefreshCages.AddRow( GetParent(GetRowID(oHandleSelect.nRow[nI])) )
.head 8 -  Set nI = nI + 1
.head 7 -  !
.head 7 -  Set nI = 0
.head 7 -  Call SalArrayGetUpperBound( oTransferAnimals, 1, nK )
.head 7 +  While nI <= nK
.head 8 -  Set nTransferredFalls[nI] = oTransferAnimals[nI].nAnimalID
.head 8 -  Set nI = nI + 1
.head 7 -  !
.head 7 -  Call LT_OpenTransaction(7,SalDateCurrent(  ))
.head 7 -  Call LockSysadmAction("Move animals started...")
.head 7 -  Set dtTime = GetTime4Refresh()
.head 7 -  Set nI = 0
.head 7 -  Set bOk = TRUE
.head 7 +  While bOk And nI <= nK
.head 8 +  If oTransferAnimals[nI].sScreen != oTarget.sScreen
.head 9 -  Set sBA_Key = "VE"
.head 8 +  Else
.head 9 -  Set sBA_Key = "UE"
.head 9 -  ! If oRowSource.GetState(CageIsCadaver )
.head 8 -  Set bLicence = bLicence or (sBA_Key = 'VE' and bAskForLicense)
.head 8 +  If sBA_KeyPrev != sBA_Key
.head 9 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, sBA_Key, dtTime, sGrund1, sGrund2 )
.head 10 -  Set bOk = FALSE
.head 9 -  Set sBA_KeyPrev = sBA_Key
.head 8 -  Set sBettKey = AddWonBettX( oTarget.sScreen, oTarget.sRack, oTarget.sCage,dtTime )
.head 8 +  If sBettKey=''
.head 9 -  Return FALSE
.head 8 -  !
.head 8 -  Set nBewNr = InsertBewegung(nTransferredFalls[nI], 0, dtTime, sBA_Key,sGrund1, sGrund2, oTarget.sScreen, oTarget.sRack, oTarget.sCage, sBettKey,"", "", "", "" )
.head 8 +  If nBewNr< 0
.head 9 -  ! Return FALSE
.head 9 -  Set bOk = FALSE
.head 8 +  Else
.head 9 +  If nMax = 0
.head 10 -  Set oRefreshCage[0].sScreen =oTransferAnimals[nI].sScreen 
.head 10 -  Set oRefreshCage[0].sRack =oTransferAnimals[nI].sRack
.head 10 -  Set oRefreshCage[0].sCage =oTransferAnimals[nI].sCage
.head 10 -  Set oRefreshCage[0].nScreenID =oTransferAnimals[nI].nScreenID
.head 10 -  Set oRefreshCage[0].nRackID =oTransferAnimals[nI].nRackID
.head 10 -  Set oRefreshCage[0].nCageID =oTransferAnimals[nI].nCageID
.head 10 -  Call oRefreshCages.AddRow( FindObject(FindObject(FindObject( nRoot, oRefreshCage[nMax].nScreenID ), oRefreshCage[nMax].nRackID ) ,oRefreshCage[nMax].nCageID) )
.head 10 -  Set nMax = nMax + 1
.head 9 +  Else
.head 10 -  Set nInd = 0
.head 10 +  While nInd < nMax
.head 11 +  If oRefreshCage[nInd].nCageID = oTransferAnimals[nI].nCageID
.head 12 -  Break
.head 11 -  Set nInd = nInd + 1
.head 10 +  If nInd = nMax
.head 11 -  Set oRefreshCage[nInd].sScreen =oTransferAnimals[nI].sScreen 
.head 11 -  Set oRefreshCage[nInd].sRack =oTransferAnimals[nI].sRack
.head 11 -  Set oRefreshCage[nInd].sCage =oTransferAnimals[nI].sCage
.head 11 -  Set oRefreshCage[nInd].nScreenID =oTransferAnimals[nI].nScreenID
.head 11 -  Set oRefreshCage[nInd].nRackID =oTransferAnimals[nI].nRackID
.head 11 -  Set oRefreshCage[nInd].nCageID =oTransferAnimals[nI].nCageID
.head 11 -  Call oRefreshCages.AddRow( FindObject(FindObject(FindObject( nRoot, oRefreshCage[nInd].nScreenID ), oRefreshCage[nInd].nRackID ) ,oRefreshCage[nInd].nCageID) )
.head 11 -  Set nMax = nMax + 1
.head 8 -  Set dtTime = GetTime4Refresh()
.head 8 -  !
.head 8 +  ! If not bDestinationBed 
.head 9 -  Set bOk = FALSE
.head 9 -  Break 
.head 8 +  ! If bShowPlacesWithContent and bOk
.head 9 -  !
.head 9 -  Set hGrp=GetParent(hBeds2Operate[ nInd ])
.head 9 -  Set i = 0
.head 9 -  Set bGrpT=FALSE
.head 9 +  While i<=nIndGrpRefresh
.head 10 +  If hGruppe[i] = hGrp
.head 11 -  Set bGrpT=TRUE
.head 11 -  Break 
.head 10 -  Set i=i+1
.head 9 +  If bGrpT = FALSE
.head 10 -  Set hGruppe[nIndGrpRefresh] = hGrp
.head 10 -  Set nIndGrpRefresh =nIndGrpRefresh + 1
.head 8 -  Set nI = nI + 1
.head 7 +  If bOk
.head 8 -  Set oRefreshCage[nMax].sScreen =oTarget.sScreen 
.head 8 -  Set oRefreshCage[nMax].sRack =oTarget.sRack
.head 8 -  Set oRefreshCage[nMax].sCage =oTarget.sCage
.head 8 -  Set oRefreshCage[nMax].nScreenID =oTarget.nScreenID
.head 8 -  Set oRefreshCage[nMax].nRackID =oTarget.nRackID
.head 8 -  Set oRefreshCage[nMax].nCageID =oTarget.nCageID
.head 8 -  Call oRefreshCages.AddRow( FindObject(FindObject(FindObject( nRoot, oRefreshCage[nMax].nScreenID ), oRefreshCage[nMax].nRackID ) ,oRefreshCage[nMax].nCageID) )
.head 8 -  Set nMax = nMax + 1
.head 7 -  Call LockSysadmAction("...move animals finished")
.head 7 -  Call LT_CloseLastTransaction()
.head 7 +  If bLicence and not bCadaver and bOk
.head 8 -  Call SetMassLicense( hSesionFE, nTransferredFalls, oTarget.sScreen )
.head 7 -  Call UnSelectAll(  )
.head 7 -  ! Refresh cages and print cage cards
.head 7 -  Call RefreshCages(  )
.head 7 -  !
.head 7 -  !
.head 7 -  Call SalSetArrayBounds( oTransferAnimals, 1, -1 )
.head 7 -  Call SalSetArrayBounds( nTransferredFalls, 1, -1 )
.head 7 -  Return bOk
.head 5 +  Function: Paste 		
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bWithInternalRequest
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Date/Time: dtDate
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 7 -  String: sIn
.head 7 -  Number: nI
.head 7 -  !
.head 7 -  FunctionalVar: oRowSel
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oSource
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oTarget
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  !
.head 7 -  Set oRowSel = FE_GetInfo( nSelectedRow  )
.head 7 -  Call _GetPositionID( nSelectedRow , oTarget )
.head 7 +  If nSelectedLevel = KHEL_Gruppe and IsAllCageSelected()
.head 8 -  Call _GetPositionID( GetParent(GetRowID(oHandleSelect.nRow[0]) ), oSource )
.head 8 -  Set dtDate= GetTime4Refresh(  )
.head 8 -  Call SqlExists("
select	1
from	fall f
where	f.last_cage_id=" || SalNumberToStrX(oTarget.nCageID,0) || "
	and       F.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   	and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
   						
	", bOk)
.head 8 +  If not bOk
.head 9 -  Call SqlExists("
select	 bett.planbew_fall
from bett_locks bett
where		bett.Stat_key = '" || oTarget.sRack || "'
		and bett.Gruppe_key= '"|| oTarget.sCage ||"'
   						
	", bOk)
.head 8 +  If not bOk
.head 9 -  ! Call cDestination.Init( oTarget.sScreen, oTarget.sRack, oTarget.sCage )
.head 9 -  Set bOk = PasteToCurrent( )
.head 9 -  ! Call LT_OpenTransaction(5,SalDateCurrent(  ))
.head 9 -  ! Call LockSysadmAction("Move cage started...")
.head 9 -  ! Call oRefreshCages.Init(  )
.head 9 -  ! Call oRefreshCages.AddRow( GetParent(GetRowID(oHandleSelect.nRow[0]) ) )
.head 9 -  ! Call oRefreshCages.AddRow( nSelectedRow )
.head 9 -  ! Set nI = 0 
.head 9 -  ! Set dtTime = GetTime4Refresh()
.head 9 +  ! While nI < oHandleSelect.nIndex and bOk
.head 10 -  Set bOk = bOk and 
.head 9 -  ! Set bOk = MoveCage(oSource.nScreenID, oSource.nRackID, oSource.nCageID, oTarget.nScreenID, oTarget.nRackID, oTarget.nCageID, dtDate)
.head 9 -  ! Call LockSysadmAction("...move cage finished")
.head 9 -  ! Call LT_CloseLastTransaction()
.head 9 -  ! Call UnSelectAll(  )
.head 9 +  ! If oSource.sScreen != oTarget.sScreen
.head 10 -  Set sIn = sIn||oTarget.sCage
.head 9 +  ! Else
.head 10 -  Set sIn = sIn||oSource.sCage||","||oTarget.sCage
.head 9 +  If hWnd_POC
.head 10 -  Call frmPOC.MoveHandle(GetUniqRowID(  GetParent(GetRowID(oHandleSelect.nRow[0]) ) ), GetUniqRowID( nSelectedRow ) )
.head 10 -  ! Call frmPOC.MoveHandle(GetUniqRowID( FindObject( FindObject(FindObject( nRoot, oSource.nScreenID ) , oSource.nRackID ), oSource.nCageID ) ), GetUniqRowID( nSelectedRow ) )
.head 9 -  ! Call RefreshCages(  )
.head 8 +  Else
.head 9 -  Set bOk = PasteToCurrent( )
.head 7 +  Else
.head 8 +  If CanRolingMatings(  )
.head 9 -  Call PasteRolingMatings(  )
.head 8 +  Else
.head 9 -  Set bOk = PasteToCurrent( )
.head 7 -  Return bOk
.head 5 +  Function: IsAllCageSelected
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bRet
.head 7 -  FunctionalVar: oCageIsSelect
.head 8 -  Class: cFERow
.head 7 -  Number: nI
.head 7 -  Number: nParentC
.head 6 +  Actions
.head 7 -  Set bRet = TRUE
.head 7 +  If oHandleSelect.nIndex> 0
.head 8 -  Set nParentC = GetParent(GetRowID(oHandleSelect.nRow[0]) )
.head 8 -  Set oCageIsSelect = FE_GetInfo(nParentC )
.head 8 -  Set nI = 0
.head 8 -  Set bRet = (oHandleSelect.nIndex = oCageIsSelect.GetNValue( "Count" ))
.head 8 +  While nI < oHandleSelect.nIndex and bRet
.head 9 +  If GetParent( GetRowID(oHandleSelect.nRow[nI]) ) != nParentC
.head 10 -  Set bRet = FALSE
.head 9 -  Set nI = nI + 1
.head 7 +  Else
.head 8 -  Set bRet = FALSE
.head 7 -  Return bRet
.head 5 +  Function: CageCard
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oPosCage
.head 8 -  Class: cPositionData
.head 7 -  Date/Time: dtFE
.head 6 +  Actions
.head 7 -  Call LockSysadmAction("View cage card start")
.head 7 -  Call _GetPositionID( nSelectedRow, oPosCage )
.head 7 -  Set dtFE = GetTime4Refresh(  )
.head 7 +  !
.head 8 -  ! Set sFormularKey = GetFormular4Gruppe( sStatKey, sGruppeKey, KHE_DefaultCageCard )
.head 8 -  ! Call ShowReport( REPORT_View, sFormularKey, sStatKey || "," || sGruppeKey || "," || SalFmtFormatDateTime( dtKHK_RefreshTime, 'yyyy-MM-dd hhhh:mm:ss' ))
.head 7 +  If CageFormularWithLitter ( '', '' )
.head 8 +  If CheckStatusObj( nSelectedRow, Rack_IsIntensiv )
.head 9 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtFE, '4', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 8 +  Else
.head 9 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtFE, '2', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 7 +  Else
.head 8 +  If CheckStatusObj( nSelectedRow, Rack_IsIntensiv )
.head 9 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtFE, '3', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 8 +  Else
.head 9 -  Call Formular_CageCardX( oPosCage.sRack, oPosCage.sCage, dtFE, '1', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 5 +  Function: CageFormularWithLitter
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sStatParam
.head 7 -  String: sGrpParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bShowLitterFormular
.head 7 -  Boolean: bExist
.head 7 -  Sql Handle: hSql
.head 7 -  String: sAbt
.head 7 -  String: sStat
.head 7 -  String: sGrp
.head 7 -  String: sBett
.head 7 -  String: sPurpose
.head 7 -  String: sFallKeyWithOpenMR
.head 7 -  String: sSingleFemale
.head 7 -  Number: nFetch
.head 7 -  Number: nFemaleCount
.head 7 -  Number: nMaleCount
.head 7 -  Number: nSingleFemaleFallKey
.head 7 -  Boolean: bOpenMR
.head 7 -  Date/Time: dtGetTime
.head 7 -  FunctionalVar: oPosSelect
.head 8 -  Class: cPositionData
.head 7 -  Boolean: bRealTimeMode
.head 6 +  Actions
.head 7 -  Set bShowLitterFormular = FALSE
.head 7 -  Set bOpenMR = FALSE
.head 7 -  Set bRealTimeMode = TRUE
.head 7 +  If (Not sStatParam) Or (Not sGrpParam)
.head 8 -  ! Call GetCurrentPosition( sAbt, sStat, sGrp, sBett )
.head 8 -  Call _GetPositionID( nSelectedRow, oPosSelect )
.head 8 -  Set sAbt = oPosSelect.sScreen
.head 8 -  Set sStat = oPosSelect.sRack
.head 8 -  Set sGrp = oPosSelect.sCage
.head 8 -  Set sBett = oPosSelect.sBett
.head 7 +  Else
.head 8 -  Set sStat = sStatParam
.head 8 -  Set sGrp = sGrpParam
.head 7 +  If not SqlCreateStatement( hSesionFE, hSql )
.head 8 -  Return FALSE
.head 7 -  ! Female count in a cage
.head 7 -  Set dtGetTime = GetTime4Refresh(  )
.head 7 +  If TRUE
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	 FALL f
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
into	:nFemaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  Else
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
into	:nFemaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  ! Checking Open Mating relationship and Female count in it
.head 7 +  If TRUE
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY
from	 FALL f,  RELSHIP_FALL fr
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'W'
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	fr.FALL_KEY = f.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
group by	f.FALL_KEY
into	 :nSingleFemaleFallKey
" )
.head 10 +  If SqlFetchNext( hSql, nFetch )
.head 11 +  If nFemaleCount > 0
.head 12 -  Set bOpenMR = TRUE
.head 12 -  Set sPurpose = 'MTT'
.head 11 +  Else
.head 12 -  Set sPurpose = ''
.head 11 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurpose  || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 12 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 8 +  Else
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY
from	BEWEGUNG b, FALL f, LE l, RELSHIP_FALL fr
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'W'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
and	fr.FALL_KEY = b.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
group by	f.FALL_KEY
into	 :nSingleFemaleFallKey
" )
.head 10 +  If SqlFetchNext( hSql, nFetch )
.head 11 +  If nFemaleCount > 0
.head 12 -  Set bOpenMR = TRUE
.head 12 -  Set sPurpose = 'MTT'
.head 11 +  Else
.head 12 -  Set sPurpose = ''
.head 11 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = '" || sPurpose  || "'
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 12 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 7 -  ! Male count in Open Mating relationship
.head 7 +  If TRUE
.head 8 +  ! If bOpenMR
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l, GESCHLECHT gs, ADRESSE a, RELSHIP_FALL fr
where
b.GRUPPE_KEY =   :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'M'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= @now
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > @now
and	b.BEW_ZEIT <= @now
and	l.LE_ID = f.LE_ID
and	a.ADRESSE_ID = l.ADRESSE_ID
and          gs.GESCHL_KEY = l.GESCHL
and	fr.FALL_KEY = b.FALL_KEY
and	fr.FALLROLLE_KEY= 'MATE'
and          fr.RS_FALL_END  is null
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  If bRealTimeMode
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	 FALL f
where
f.LAST_GRUPPE_KEY =  :sGrp
and	f.LAST_STAT_KEY = :sStat
and	f.EINRICHT_ID = :nEinrichtId
and  	f.GESCHL = 'M'
and	not (f.GELOESCHT = 'J')
and	f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  Else
.head 9 +  If SqlPrepareAndExecute( hSql, "
select	count(f.FALL_KEY)
from	BEWEGUNG b, FALL f, LE l
where
b.GRUPPE_KEY =  :sGrp
and	b.STAT_KEY = :sStat
and	b.EINRICHT_ID = :nEinrichtId
and	b.FALL_KEY=f.FALL_KEY
and  	l.GESCHL = 'M'
and	f.EINRICHT_ID = :nEinrichtId
and	not (f.GELOESCHT = 'J')
and 	not (b.GELOESCHT = 'J')
and	b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	b.BEW_ZEIT <= :dtGetTime
and	@nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31') ) > :dtGetTime
and	l.LE_ID = f.LE_ID
into	:nMaleCount
" )
.head 10 -  Call SqlFetchNext( hSql, nFetch )
.head 7 -  ! Case 1 & Case 2
.head 7 +  If bOpenMR And nFemaleCount = 1
.head 8 +  If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 -  ! Case 2 (open relationship between a Female and a Male, Litters)
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set bShowLitterFormular = TRUE
.head 9 -  ! Case 1 (open relationship between a Female and a Male, without Litters)
.head 9 +  Else
.head 10 -  Set bShowLitterFormular = FALSE
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return bShowLitterFormular
.head 7 -  ! Case 3 (open relationship between several Females and one Male)
.head 7 +  If bOpenMR And nFemaleCount > 1 And nMaleCount = 1
.head 8 -  Set bShowLitterFormular = FALSE
.head 8 +  If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = ''
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 9 -  ! Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 8 -  Call SqlDisconnect( hSql )
.head 8 -  Return bShowLitterFormular
.head 7 -  ! Case 4 (open or closed Mate relationship; Female is alone)
.head 7 +  If nFemaleCount = 1 And nMaleCount = 0
.head 8 +  ! If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr, GESCHLECHT g
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 -  Call SqlFetchNext( hSql, nFetch )
.head 8 +  If SqlPrepareAndExecute( hSql, "
select	l.LITTER_ID
from	LITTER l, RELATIONSHIP r, RELSHIP_TYPE rt, RELSHIP_FALL fr, RELSHIP_ROLLE rr
where	fr.EINRICHT_ID = :nEinrichtId
   and	rr.FALLROLLE_KEY = fr.FALLROLLE_KEY
   and	rr.IS_PARENT = 'J'
   and	r.RELSHIP_ID = fr.RELSHIP_ID
   and	rt.RELTYPE_KEY = r.RELTYPE_KEY
   and	rt.FAMILY = 'J'
   and	l.FAMILY_RELSHIP_ID = r.RELSHIP_ID
   and	fr.FALL_KEY= :nSingleFemaleFallKey
" )
.head 9 +  If SqlFetchNext( hSql, nFetch )
.head 10 -  Set bShowLitterFormular = TRUE
.head 9 +  Else
.head 10 -  Set bShowLitterFormular = FALSE
.head 9 +  ! If DoImmediate("
update	GRUPPE
set	PURPOSE_KEY = ''
where  	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	STAT_KEY     = '" || sStat  || "'
   and	GRUPPE_KEY = '" || sGrp  || "'
;
commit")
.head 10 -  Call RefreshSingleGruppeLabel( nSelectedHandle, sGrp, sStat )
.head 9 -  Call SqlDisconnect( hSql )
.head 9 -  Return bShowLitterFormular
.head 7 -  ! Call SqlDisconnect( hSql )
.head 7 -  ! Return bShowLitterFormular
.head 5 +  Function: MoveFemaleAfterPL
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npFall
.head 7 -  Boolean: bStop
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRet
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bPaste
.head 7 -  Boolean: bNeedPrintForSmartLabel
.head 7 -  Number: hAbt
.head 7 -  Number: hFall
.head 7 -  Number: hCage
.head 7 -  FunctionalVar: oPosInfo
.head 8 -  Class: cPositionData
.head 7 -  Sql Handle: hSqlFall
.head 7 -  Number: nFetch
.head 7 -  Number: nNewCageID
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sState
.head 7 -  Date/Time: dtTime
.head 7 -  Number: nCountFemale
.head 7 -  Number: nIndex
.head 7 -  String: sSex
.head 7 -  Number: hNowCage
.head 7 -  Boolean: bPrintAfterMove_Save
.head 7 -  Boolean: bAutoPrint_Save
.head 7 -  Number: nCageIDPaste
.head 7 -  Number: nRackIDPaste
.head 7 -  Number: nScrIDPaste
.head 7 -  ! !
.head 7 -  FunctionalVar: cCage[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDistinct
.head 8 -  Class: clsLocationCage
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set nRet = 1
.head 7 +  ! If FALSE
.head 8 -  Set hRakc = GetParent( hCage )
.head 8 -  Set nChildR = EnumChildren (hAbt, hChildrenR)
.head 7 +  If SqlCreateStatement( hSesionFE ,hSqlFall )
.head 8 +  If SqlPrepareAndExecute( hSqlFall, "select f.last_scr_id , g.rack_id, f.last_cage_id
from fall f 
left join gruppe g on (g.id=f.last_cage_id)
where fall_key=:npFall
into :oPosInfo.nScreenID, :oPosInfo.nRackID, :oPosInfo.nCageID  " )
.head 9 +  If SqlFetchNext( hSqlFall, nFetch )
.head 10 -  Set hFall = FindObject( nRoot, oPosInfo.nScreenID )
.head 10 +  If hFall != -1
.head 11 -  Set hFall = FindObject( hFall, oPosInfo.nRackID )
.head 11 +  If hFall != -1
.head 12 -  Set hFall = FindObject( hFall, oPosInfo.nCageID)
.head 12 +  If hFall != -1
.head 13 -  Set hCage = hFall
.head 13 -  Set hFall = FindObject( hFall, npFall)
.head 7 -  Set bPaste = FALSE
.head 7 -  ! Set hFall = SearchFrom( hRoot,  SalNumberToStrX( npFall, 0 ) )
.head 7 -  ! Set hFall = 
.head 7 +  ! If hFall = NUMBER_Null or hFall= 0
.head 8 -  Call OpenBettByFallKey( npFall, bAutoScan)
.head 8 -  Set hFall = SearchFrom( hRoot,  SalNumberToStrX( npFall, 0 ) )
.head 7 -  ! Set hCage = GetParent( hFall )
.head 7 -  ! Set hAbt = GetParent( GetParent( hCage ) )
.head 7 -  Call _GetPositionID( hCage, oPosInfo )
.head 7 -  Set bNeedPrintForSmartLabel = GalGetProfileBooleanX("SmartLabels","PrintForCollectionCages",TRUE,ATLANTA_INI) and GetBuildParameterB("IncludingSmartLables")  and bUseSmartLabels
.head 7 -  Set dtTime = GetTime4Refresh(  )
.head 7 -  ! Check count open cages
.head 7 +  If SqlCreateStatement( hSesionFE ,hSqlFall )
.head 8 -  Set bOk = SqlPrepareAndExecute(hSqlFall,"select t.id, g.stat_key, g.gruppe_key, @if(@nullvalue(f.fall_key,0),'F','E'), t.id, t.scr_id, g.rack_id, @if(g.rack_id-:oPosInfo.nRackID,1,0)
 from t_cage t left join gruppe g on (g.id=t.id)
 join station s on (s.id=g.rack_id)
 join abt_stat a on (a.rack_id=s.id and a.scr_id=:oPosInfo.nScreenID)
 left join fall f on(f.last_cage_id=t.id and f.geloescht='N' and ee_datum is null )
where t.id != :oPosInfo.nCageID
 
order by 4 	desc,5,2,3,6,7,8
into :nNewCageID ,:sRack, :sCage, :sState, :nCageIDPaste, :nScrIDPaste , :nRackIDPaste ")
.head 8 -  Set nNewCageID = -100
.head 8 +  While bOk and SqlFetchNext(hSqlFall, nFetch )
.head 9 +  If sState = "F"
.head 10 +  If not bStop
.head 11 +  If CheckCageIsCollector(nNewCageID,dtTime  )
.head 12 -  Set bPaste = TRUE
.head 12 -  Break
.head 10 +  Else
.head 11 +  If CheckCageIsStock( nNewCageID,dtTime , sSex )
.head 12 +  If sSex = 'W'
.head 13 -  Set bPaste = TRUE
.head 13 -  Break
.head 9 +  Else If sState='E'
.head 10 -  Set bPaste = TRUE
.head 10 -  Break
.head 9 -  Set nNewCageID = -100
.head 8 +  If nNewCageID = -100
.head 9 -  Set bOk = bOk and  SqlPrepareAndExecute(hSqlFall, "select count(b.fall_key)
 from sysadm.bewegung b
, sysadm.Fall f 
 where       b.cage_id=:oPosInfo.nCageID and b.geloescht='N'
    and       b.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
    and       b.bew_zeit <= :dtTime
    and       @nullvalue( b.BEW_ZEIT_BIS, @datevalue('2222-12-31')) > :dtTime
    and	f.EINRICHT_ID = b.EINRICHT_ID 
    and	f.FALL_KEY = b.FALL_KEY
    and	f.GESCHL = 'W'
into :nCountFemale ")
.head 9 -  Set bOk = bOk and  SqlFetchNext( hSqlFall, nFetch)
.head 9 +  If nCountFemale > 1
.head 10 -  Set bPaste = FALSE
.head 10 -  Call GalMessageBox( "Warning", "Please don't mix plugged and unplugged females!", MB_Ok )
.head 10 -  Set nRet = 2
.head 8 +  Else
.head 9 -  Set hNowCage = FindObject(FindObject(FindObject( nRoot, nScrIDPaste ), nRackIDPaste ) , nCageIDPaste )
.head 8 -  Call SqlDisconnect(hSqlFall)
.head 7 +  If not bOk 
.head 8 -  Set nRet = 0
.head 7 +  If not bStop and bOk
.head 8 -  Call RS_SetFemalePlugged(npFall,dtTime )
.head 7 +  If bOk and bPaste
.head 8 -  Call UnSelectAll(  )
.head 8 -  Call SwitchSelectRow( hFall )
.head 8 -  Call ActivateRow( FindObject(FindObject(FindObject( nRoot, nScrIDPaste ), nRackIDPaste ) , nCageIDPaste) )
.head 8 +  If Paste( FALSE )
.head 9 -  Call T_SetPrintOnCage( nNewCageID, 1 )
.head 9 -  Set nRet = 1
.head 8 +  Else
.head 9 -  Call GalMessageBox("Warning", "Movement was not performed but service is confirmed. 
Probably manual correction will be required!",  0)
.head 9 -  Set nRet = 2
.head 8 +  If bNeedPrintForSmartLabel
.head 9 -  Set bPrintAfterMove_Save = GalGetProfileBooleanX( "Settings", "PrintCageCardsOnMovement", TRUE, sUserINIFileName )
.head 9 -  Set bAutoPrint_Save=GalGetProfileBooleanX( "KHE", "CageCardAutoPrint", FALSE, sUserINIFileName )
.head 9 -  Call GalSetProfileBoolean( "Settings", "PrintCageCardsOnMovement" , TRUE, sUserINIFileName )
.head 9 -  Call GalSetProfileBoolean(  "KHE", "CageCardAutoPrint", TRUE, sUserINIFileName )
.head 9 -  Call cDistinct.Init( oPosInfo.sScreen, sRack, sCage )
.head 9 -  Set cCage[0] = cDistinct
.head 9 -  Call Move_PrintCageCards( cCage, cDistinct )
.head 9 -  Call GalSetProfileBoolean( "Settings", "PrintCageCardsOnMovement" , bPrintAfterMove_Save, sUserINIFileName )
.head 9 -  Call GalSetProfileBoolean(  "KHE", "CageCardAutoPrint", bAutoPrint_Save, sUserINIFileName )
.head 7 -  Return nRet 
.head 5 +  Function: ChangingEarTags
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 +  Static Variables
.head 7 -  String: sAbt_Key
.head 7 -  String: sStat_Key
.head 7 -  String: sGruppe_Key
.head 7 -  String: sBett_Key
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible( hWnd_EarTags )
.head 8 -  Call SalSendMsg(hWnd_EarTags,SAM_Close,0,0)
.head 7 -  Set hWnd_EarTags = SalCreateWindow( tblEarTags, hWndStar2000 , oPosition.sScreen, oPosition.sRack, oPosition.sCage)
.head 5 +  Function: TransferCagesBetweenWorkGroup
.head 6 -  Description: Transfer all racks from source workgroup to target workgroup
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nScrIDSource
.head 7 -  Number: nScrIDTarget
.head 7 -  Date/Time: dtAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bAskForLicenseSave
.head 7 -  Sql Handle: hSqlCages
.head 7 -  Sql Handle: hSqlInsert
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOK
.head 7 -  Number: nRackID
.head 7 -  Number: nI
.head 7 -  String: sBA
.head 7 -  Number: nTransferredCount
.head 7 -  String: sScrTo
.head 7 -  String: sRackPrev
.head 7 -  String: sCagePrev
.head 7 -  Number: nFalls[*]
.head 7 -  Number: nCount
.head 7 -  Window Handle: hWndProgress
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSourceCard[*]
.head 8 -  Class: clsLocationCage
.head 7 -  !
.head 7 -  ! String: sCage
.head 7 -  ! String: sRack
.head 7 -  ! Boolean: bExists
.head 7 -  ! Number: nCageID
.head 7 -  ! Number: nScrToID
.head 7 -  ! Number: nScrFromID
.head 6 +  Actions
.head 7 -  Set bAskForLicenseSave = bAskForLicense
.head 7 -  Call SalArraySetUpperBound(oTransferAnimals, 1, -1)
.head 7 -  Call SalArraySetUpperBound(nFalls, 1, -1)
.head 7 -  Set bOK= SqlCreateStatement( hSesionFE, hSqlCages ) and SqlCreateStatement( hSesionFE, hSqlInsert )
.head 7 +  If bOK
.head 8 -  Call CloseAllCagesOnCollapse( FindObject( nRoot, nScrIDSource ) )
.head 8 -  Call CloseAllCagesOnCollapse( FindObject( nRoot, nScrIDTarget ) )
.head 7 +  If bOK
.head 8 -  Set bOK= bOK and  SqlPrepareAndExecute( hSqlCages, "select distinct g.rack_id , @nullvalue(sr.rack_id,-100)
 from fall f 
 left join gruppe g on (g.id=f.last_cage_id)
 left join screen_rack sr on (sr.scr_id=:nScrIDTarget and sr.rack_id=g.rack_id )
where f.GELOESCHT='N'
   and f.last_ba_key!='EE'
   and f.last_scr_id=:nScrIDSource
order by f.last_stat_key   
into  :nRackID, :nI " )
.head 8 -  Set bOK= bOK and  SqlPrepare( hSqlInsert, "Insert into screen_rack(scr_id,rack_id,kst_key) values(:nScrIDTarget,:nRackID,1)" )
.head 8 +  While bOK and SqlFetchNext(hSqlCages, nFetch)
.head 9 +  If nI = -100
.head 10 -  Set bOK= bOK and SqlExecute( hSqlInsert )
.head 9 -  Call PrepareTransferFallsFromDB(nScrIDSource,nRackID,0)
.head 8 -  Set bOK= bOK and  SqlPrepareAndExecute( hSqlCages, "select count(distinct g.id)
 from fall f 
 left join gruppe g on (g.id=f.last_cage_id)
where f.GELOESCHT='N'
   and f.last_ba_key!='EE'
   and f.last_scr_id=:nScrIDSource
order by f.last_stat_key   
into  :nCount " )
.head 8 -  Set bOK = bOK and SqlFetchNext(hSqlCages, nFetch)
.head 8 -  Set bOK = bOK and SqlPrepareAndExecute( hSqlCages, "select abt_key from abteilung where id=:nScrIDTarget into :sScrTo" )
.head 8 -  Set bOK = bOK and SqlFetchNext(hSqlCages, nFetch)
.head 8 -  Call SqlCommit( hSqlInsert )
.head 8 +  If hSqlCages
.head 9 -  Call SqlDisconnect( hSqlCages )
.head 8 +  If hSqlInsert
.head 9 -  Call SqlDisconnect( hSqlInsert )
.head 8 -  !
.head 8 -  Set sBA="VES"
.head 8 +  If nCount > 0 
.head 9 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,nCount  )
.head 8 -  Set nI = 1
.head 8 -  Set sRackPrev = ""
.head 8 -  Set sCagePrev = ""
.head 8 -  Call SalArrayGetUpperBound( oTransferAnimals, 1, nTransferredCount )
.head 8 +  While nTransferredCount >=0
.head 9 +  If sCagePrev != oTransferAnimals[nTransferredCount].sCage and hWndProgress
.head 10 -  Set sCagePrev = oTransferAnimals[nTransferredCount].sCage
.head 10 -  Call dlgProgress.Init( nCount, "Transfer cage " || sCagePrev || " from " || oTransferAnimals[nTransferredCount].sScreen || " to " || sScrTo || " screen")
.head 10 -  Set dlgProgress.nCurrent = nI - 1
.head 10 -  Call dlgProgress.Next(  )
.head 10 -  Call cSourceCard[nI - 1].Init(sScrTo,oTransferAnimals[nTransferredCount].sRack ,sCagePrev)
.head 10 -  Set nI = nI + 1
.head 9 -  Set nFalls[nTransferredCount] =  oTransferAnimals[nTransferredCount].nAnimalID
.head 9 -  Call InsertBewegung( oTransferAnimals[nTransferredCount].nAnimalID , 0, dtAction, sBA,"", "", sScrTo, oTransferAnimals[nTransferredCount].sRack , oTransferAnimals[nTransferredCount].sCage, oTransferAnimals
[nTransferredCount].sBett,"", "", "", "" )
.head 9 -  Set nTransferredCount = nTransferredCount-1
.head 8 -  Call SalSendMsg( hWndStar2000 , AM_TransferBeetwenScreens, nScrIDSource, nScrIDTarget )
.head 8 +  If bAskForLicense
.head 9 -  Call SetMassLicense( hSesionFE,  nFalls, sScrTo)
.head 8 +  If nI>1
.head 9 -  Call cDest.Init( cSourceCard[nI-2].sScreenKey, cSourceCard[nI-2].sRackKey, cSourceCard[nI-2].sCageKey)
.head 9 -  Call PrintCageCards( cSourceCard, cDest )
.head 8 +  If hWndProgress
.head 9 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 9 -  Set hWndProgress = hWndNULL
.head 8 -  Call SalArraySetUpperBound(oTransferAnimals, 1, -1)
.head 8 -  Call SalArraySetUpperBound(nFalls, 1, -1)
.head 8 -  !
.head 7 -  !
.head 7 -  !
.head 7 +  If hSqlCages
.head 8 -  Call SqlDisconnect( hSqlCages )
.head 7 +  If hSqlInsert
.head 8 -  Call SqlDisconnect( hSqlInsert )
.head 7 +  If bOK
.head 8 -  Call PopulateWorkGroup( FindObject( nRoot, nScrIDSource ), TRUE )
.head 8 -  Call PopulateWorkGroup( FindObject( nRoot, nScrIDTarget ), TRUE )
.head 7 -  Return bOK
.head 5 +  Function: CageCardForWorkgroup
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 -  Actions
.head 5 +  Function: CageInsteadVirtual
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  String: sBettKey
.head 7 -  Boolean: bClosePlan2Real_Bew
.head 7 -  FunctionalVar: oAdmServ
.head 8 -  Class: cLstAdmin
.head 7 -  Number: nFallK
.head 7 -  Number: nSrvNr
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bClosePlan2Real_Bew = FALSE
.head 7 -  Set bOk = TRUE
.head 7 -  Set nFallK = SalSendMsg (hWL_Plan2Real_Bew,AM_GetObjValue,1,0)
.head 7 -  Set nSrvNr = SalSendMsg (hWL_Plan2Real_Bew,AM_GetObjValue,2,0)
.head 7 -  Call oRefreshCages.Init(  )
.head 7 -  Call oRefreshCages.AddRow( nSelectedRow )
.head 7 -  Call oAdmServ.Init( nFallK, nSrvNr )
.head 7 -  Set bOk = bOk and oAdmServ.SetPlace( oPosition.nScreenID , oPosition.nCageID)
.head 7 -  Set bOk = bOk and oAdmServ.ToRealCage(  )
.head 7 +  If bOk
.head 8 -  Set bOk = not oAdmServ.InVirtualCage(  )
.head 8 +  If not bOk
.head 9 -  Call SalMessageBox ('This list contains virtual Cages', '',0)
.head 8 -  Set bOk = bOk and oAdmServ.Do_All_Items(  )
.head 8 -  Set bClosePlan2Real_Bew = bOk
.head 7 -  !
.head 7 +  ! If cSrvAdmin.SetPlace( oPosition.nScreenID , oPosition.nCageID)
.head 8 +  If cSrvAdmin.UpdateToRealCage( tblWL_Plan2Real_Bew.colStat_Key_2, tblWL_Plan2Real_Bew.colGruppe_Key_2 )
.head 9 +  If cSrvAdmin.InVirtualCage(  )
.head 10 -  Call SalMessageBox ('This list contains virtual Cages', '',0)
.head 10 -  Return FALSE
.head 9 +  If cSrvAdmin.Do_All_Items(  )
.head 10 -  Set bClosePlan2Real_Bew = TRUE
.head 8 +  Else 
.head 9 -  Return FALSE
.head 7 +  ! If SalSendMsg (hWL_Plan2Real_Bew, AM_KHE_Plan2Real_Bew, oPosition.nScreenID , oPosition.nCageID )
.head 8 -  Set bClosePlan2Real_Bew = TRUE
.head 7 -  ! Call LockSysadmAction( "CageInsteadVirtual(): Refresh cages start" )
.head 7 +  If bOk
.head 8 -  Call RefreshCages(  )
.head 8 -  Call RefreshVirtualRacks()
.head 8 +  If hWL_Edit and SalIsWindowVisible(hWL_Edit)
.head 9 -  Call SalSendMsg (frmWL_Edit, AM_Refresh, 0, 0)
.head 8 +  If hWnd_OrderList
.head 9 -  Call SalSendMsg (hWnd_OrderList, AM_Refresh, 0, 0)
.head 8 +  If hWndWorklistOpened
.head 9 -  Call SalSendMsg (hWndWorklistOpened, AM_Refresh, 0, 0)
.head 7 +  Else
.head 8 -  Call SalSendMsg (hWL_Plan2Real_Bew, AM_Refresh, 0, 0)
.head 7 -  ! Call LockSysadmAction( "CageInsteadVirtual(): Refresh cages finished" )
.head 7 +  If bClosePlan2Real_Bew
.head 8 -  Call SalSendMsg( hWL_Plan2Real_Bew, SAM_Close, 0, 0 )
.head 7 -  ! Call SalSendMsg(hWndStar2000, AM_Timer,1,0)
.head 7 -  ! Call LockSysadmAction( "CageInsteadVirtual(): AM_Timer=1" )
.head 5 -  ! checking functions
.head 5 +  Function: CanChangeOrder
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nAction
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn 
.head 7 -  Number: nCountChild
.head 7 -  Number: nDelta
.head 6 +  Actions
.head 7 -  Set bReturn = (nSelectedLevel = KHEL_Abteilung) or (nSelectedLevel = KHEL_Station)
.head 7 +  If nSelectedLevel = KHEL_Station
.head 8 -  Set nDelta = -1
.head 7 +  Select Case nAction
.head 8 +  Case SCREEN_TOP
.head 9 -  Set bReturn = bReturn and (colOrder>1)
.head 9 -  Break
.head 8 +  Case SCREEN_UP
.head 9 -  Set bReturn = bReturn and (colOrder>1)
.head 9 -  Break
.head 8 +  Case SCREEN_DOWN
.head 9 -  Set nCountChild = MTblGetChildRowCount( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext( hWndForm ) ) )
.head 9 -  Set bReturn = bReturn and (colOrder< nCountChild + nDelta)
.head 9 -  Break
.head 8 +  Case SCREEN_BUTTOM
.head 9 -  Set nCountChild = MTblGetChildRowCount( hWndForm, MTblGetParentRow( hWndForm, SalTblQueryContext( hWndForm ) ) )
.head 9 -  Set bReturn = bReturn and (colOrder<nCountChild + nDelta)
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return bReturn
.head 5 +  Function: CanCloseCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 7 -  Boolean: bFindAnyCage
.head 7 -  Number: nRowCage
.head 6 +  Actions
.head 7 -  Set bReturn = (nSelectedLevel=KHEL_Station)
.head 7 -  Set bFindAnyCage = FALSE
.head 7 +  If bReturn
.head 8 -  Set nRowCage = MTblGetFirstChildRow( hWndForm, nSelectedRow )
.head 8 +  Loop
.head 9 +  If nRowCage = TBL_Error or bFindAnyCage
.head 10 -  Break
.head 9 +  If MTblQueryRowFlags( hWndForm, nRowCage, MTBL_ROW_ISEXPANDED )
.head 10 -  Set bFindAnyCage = TRUE
.head 9 -  Set nRowCage = MTblGetNextChildRow( hWndForm, nRowCage )
.head 8 -  Set bReturn = bReturn and bFindAnyCage
.head 7 -  Return bReturn
.head 5 +  Function: CanExistsServicesOrAlert
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 7 -  FunctionalVar: oCheckRow
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set bReturn = FALSE
.head 7 -  Set oCheckRow = FE_GetInfo( nSelectedRow  )
.head 7 +  If nSelectedLevel = FEL_Pos
.head 8 -  ! Set bReturn = colFlags&8 or colFlags&16
.head 8 -  Set bReturn = oCheckRow.GetState( IsAlert ) or oCheckRow.GetState( IsServise)
.head 8 -  Set bReturn = bReturn and not oCheckRow.GetState( CageIsOccupied  )
.head 7 +  Else If nSelectedLevel = FEL_Cage
.head 8 -  ! Set bReturn = colFlags&8 or colFlags&4
.head 8 -  Set bReturn = oCheckRow.GetState( IsAlert ) or oCheckRow.GetState( IsServise)
.head 8 -  Set bReturn = bReturn and not oCheckRow.GetState( CageIsOccupied  )
.head 8 -  ! Set bReturn = bReturn and not colFlags&16
.head 7 +  Else If nSelectedLevel = FEL_Rack
.head 8 -  ! Set bReturn = colFlags&8 or colFlags&4
.head 8 -  Set bReturn = oCheckRow.GetState( IsAlert ) or oCheckRow.GetState( IsServise)
.head 8 -  ! Set bReturn = bReturn and not colFlags&16
.head 7 -  Return bReturn
.head 5 +  Function: CanCut
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTypeOfBAR
.head 7 -  !
.head 7 -  Number: nHandles[*]
.head 7 -  Number: nHandleCount
.head 7 -  Number: nFallKeys[*]
.head 6 +  Actions
.head 7 +  If not CheckStatusObj(nSelectedRow, CageIsOccupied)
.head 8 +  Select Case nSelectedLevel
.head 9 +  Case FEL_Cage
.head 10 -  ! Call GetFallsInGruppe( nSelectedHandle, nFallKeys )
.head 10 +  If not EnumChildren( nSelectedRow, nFallKeys ) 
.head 11 -  Return FALSE
.head 10 -  Return TRUE
.head 9 +  Case FEL_Pos
.head 10 +  ! If bCurrentBettHasFall and bCurrentBettLegalAbteilung
.head 11 +  If bPlanningMode and not HasHandlePlanExpFall( nSelectedHandle )
.head 12 -  Return FALSE
.head 11 +  If bPlanningMode and bMatingMode
.head 12 +  If SalStrScan( GetItemText( nSelectedHandle ), ", M," ) >= 0 and bMaleIsExist  
.head 13 -  Return FALSE
.head 11 -  Set nTypeOfBAR = GetTypeOfMove_ByHandle( nSelectedHandle )
.head 11 +  If ( nTypeOfBAR = nTYPE_PLAN) And Not bPlanningMode
.head 12 -  Return FALSE
.head 11 +  If nTypeOfBAR = nTYPE_LOCK
.head 12 -  Return FALSE
.head 11 -  Return TRUE
.head 10 +  If colIDObject != -100
.head 11 -  Return TRUE
.head 10 -  Break
.head 9 +  Case FEL_Rack
.head 10 +  If not EnumChildren( nSelectedRow, nFallKeys ) 
.head 11 -  Return FALSE
.head 10 -  Return TRUE
.head 9 +  Default
.head 10 -  Break
.head 7 -  Return FALSE
.head 5 +  Function: CanCageRelease
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKeys[*]
.head 6 +  Actions
.head 7 +  If not CheckStatusObj(nSelectedRow, CageIsOccupied )
.head 8 +  Select Case nSelectedLevel
.head 9 +  Case FEL_Cage
.head 10 +  If not EnumChildren( nSelectedRow, nFallKeys )
.head 11 -  Return FALSE
.head 10 -  Return TRUE
.head 9 +  Case FEL_Pos
.head 10 +  ! If bCurrentBettHasFall and bCurrentBettLegalAbteilung
.head 11 +  If bPlanningMode and not HasHandlePlanExpFall( nSelectedHandle )
.head 12 -  Return FALSE
.head 11 +  If bPlanningMode and bMatingMode
.head 12 +  If SalStrScan( GetItemText( nSelectedHandle ), ", M," ) >= 0 and bMaleIsExist  
.head 13 -  Return FALSE
.head 11 -  Set nTypeOfBAR = GetTypeOfMove_ByHandle( nSelectedHandle )
.head 11 +  If ( nTypeOfBAR = nTYPE_PLAN) And Not bPlanningMode
.head 12 -  Return FALSE
.head 11 +  If nTypeOfBAR = nTYPE_LOCK
.head 12 -  Return FALSE
.head 11 -  Return TRUE
.head 10 +  If colIDObject!=-100
.head 11 -  Return TRUE
.head 10 -  Break
.head 9 +  Case FEL_Rack
.head 10 +  If EnumChildren( nSelectedRow, nFallKeys ) and oHandleSelect.bAnySelects
.head 11 -  Return TRUE
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 7 -  Return FALSE
.head 5 +  Function: Check_Fall_Litter
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Date/Time: dtKHEDate
.head 7 -  Boolean: bExists
.head 7 -  FunctionalVar: oC_Pos
.head 8 -  Class: cPositionData
.head 7 -  !
.head 6 +  Actions
.head 7 -  Set dtKHEDate = GetTime4Refresh(  )
.head 7 -  Set bExists = FALSE
.head 7 +  If CheckStatusObj( nSelectedRow, CageIsFull )
.head 8 +  If not CheckStatusObj( nSelectedRow, CageIsOccupied )
.head 9 -  Call _GetPositionID( nSelectedRow, oC_Pos )
.head 9 +  If nSelectedLevel = KHEL_Bett
.head 10 -  Call SqlExists( "select rf.RELSHIP_ID
 from fall f, relship_fall rf
  where
   f.pos_id=:oC_Pos.nPosID
  and f.ee_datum is null
 and f.geloescht ='N'
  and f.geschl !='M'
   and rf.EINRICHT_ID = f.EINRICHT_ID
   and rf.fall_key= f.fall_key
and  rf.fallrolle_key = 'MATE'
   and (@nullvalue(rf.RS_FALL_VALID,@datevalue(:dtKHEDate) + 1 ) >= :dtKHEDate
or exists(select lc.litter_id from litter_child lc, litter l where l.place_relship_id=rf.relship_id and @nullvalue(l.miss,0)=0 and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id and @nullvalue(kk.miss,0)=0
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id ))
)
  
", bExists )
.head 9 +  Else If nSelectedLevel = KHEL_Gruppe
.head 10 -  Call SqlExists( "select rf.RELSHIP_ID
 from fall f, relship_fall rf
  where
   f.last_cage_id=:oC_Pos.nCageID
  and f.ee_datum is null
 and f.geloescht ='N'
and f.geschl!='M'
   and rf.EINRICHT_ID = f.EINRICHT_ID
   and rf.fall_key= f.fall_key
  and  rf.fallrolle_key = 'MATE'
and ( @nullvalue(rf.RS_FALL_VALID,@datevalue(:dtKHEDate) + 1 ) >= :dtKHEDate
or exists(select lc.litter_id from litter_child lc, litter l where l.place_relship_id=rf.relship_id and @nullvalue(l.miss,0)=0 and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0 )
     or exists(select kk.place_relship_id from litter kk where kk.place_relship_id=rf.relship_id and @nullvalue(kk.miss,0)=0
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id ))
) ", bExists )
.head 7 -  Return bExists
.head 5 +  Function: CanDistributionAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCountAnimal
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oRowInfo
.head 8 -  Class: cFERow
.head 7 -  Number: nM
.head 7 -  Number: nF
.head 7 -  Number: nAnimal
.head 7 -  Number: nCheck
.head 7 -  Number: nFetch
.head 7 -  Number: nRowR
.head 7 -  Number: nRowC
.head 7 -  Boolean: bEmpty
.head 7 -  Boolean: bNeedAssignSlots
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set bEmpty = FALSE
.head 7 +  If nSelectedLevel != FEL_Cage
.head 8 -  Set bOk = FALSE
.head 7 -  Set bOk = bOk and not (oHandleSelect.nIndex>0)
.head 7 +  If bOk
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate , "select count(count(scr_id)) from "|| sUserName  || ".t_cage
group by scr_id into :nCheck "  )
.head 8 +  If bOk
.head 9 -  Call SqlFetchNext( hSqlPopulate, nFetch )
.head 8 -  Set bOk = bOk and nCheck=1
.head 7 +  If bOk 
.head 8 -  Set nRowR = GetFirstChildRow( GetParent(GetParent(nSelectedRow)) )
.head 8 +  Loop
.head 9 +  If nRowR = TBL_Error or not bOk
.head 10 -  Break
.head 9 -  Set bNeedAssignSlots = CheckStatusObj( nRowR, Rack_SlotNeedAssign )
.head 9 -  Set nRowC = GetFirstChildRow( nRowR )
.head 9 +  Loop
.head 10 +  If nRowC = TBL_Error or not bOk
.head 11 -  Break
.head 10 -  Set oRowInfo = FE_GetInfo( nRowC )
.head 10 +  If oRowInfo.nID_Obj != -100
.head 11 +  If oRowInfo.GetState( CageIsEmpty  )
.head 12 -  Set bEmpty = TRUE
.head 11 +  Else
.head 12 -  Set nM = nM + oRowInfo.GetNValue( "Male" )
.head 12 -  Set nF = nF +oRowInfo.GetNValue( "Female" )
.head 10 +  If bNeedAssignSlots
.head 11 -  Set bOk = bOk and oRowInfo.GetState(Cage_LOCKCurrScreen)
.head 10 -  Set nRowC = GetNextChildRow( nRowC )
.head 9 -  Set nRowR = GetNextChildRow( nRowR )
.head 8 -  Set oRowInfo = FE_GetInfo( nSelectedRow )
.head 8 -  Set bOk = bOk and oRowInfo.GetState( CageIsFull )
.head 8 -  Set nAnimal = nM + nF
.head 8 -  Set bOk = bOk and nAnimal>1 and bEmpty and ((nM>0 and nF=0) or (nM=0 and nF>0))
.head 7 -  Set bOk = bOk and (nAnimal >= nCountAnimal) 
.head 7 -  Return bOk
.head 5 +  Function: CanMate
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  ! Sql Handle: hSqlRoling
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Number: nFetch
.head 7 -  Number: nBound
.head 7 -  Number: nFallKey
.head 7 -  Number: i
.head 7 -  String: sFalls
.head 7 -  String: sSex
.head 7 -  Number: nCount
.head 7 -  Number: nCountW
.head 7 -  Number: nCountM
.head 7 -  Number: nCountAnimal
.head 7 -  Number: nCageId
.head 7 -  Number: nPrevCageId
.head 7 -  Boolean: bStockMale
.head 7 -  Boolean: bStockFeMale
.head 7 -  String: sPrevSex
.head 7 -  Number: nCountEmptyCage
.head 7 -  FunctionalVar: oFallRow
.head 8 -  Class: cFERow
.head 7 -  Number: nrEmpty[*]
.head 7 -  Number: nEmptyCages
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set bOk = bOk and nSelectedLevel = KHEL_Gruppe and CheckStatusObj( nSelectedRow , CageIsEmpty)
.head 7 -  Set bOk = bOk and _GetPositionID(nSelectedRow, oPos)
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate ,"select * from cadavers where rack=:oPos.sRack  and cage=:oPos.sCage  " )
.head 7 +  If bOk and SqlFetchNext( hSqlPopulate, nFetch )
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 +  If oHandleSelect.nIndex>0
.head 9 -  ! Call SalArrayGetUpperBound ( oHandleSelect, 1, nBound )
.head 9 -  Call SqlPrepare( hSqlPopulate,  "select rf.fall_key
  from roling_fall rf
where rf.status = 0  and rf.fall_key=:nFallKey

union

select b.fall_key
 from sysadm.bewegung b
      join sysadm.fall f on (     f.einricht_id = b.einricht_id
			     and f.fall_key=b.fall_key
			     and @nullvalue(f.GELOESCHT,'N') ='N'	)
      join relship_fall rf on (rf.einricht_id=b.einricht_id and rf.fall_key=b.fall_key)
      join  roling_fall rl on (rl.relship_id=rf.relship_id and rl.status=0)
  where  b.einricht_id = :nEinrichtId
	    and b.fall_key = :nFallKey
	    and @nullvalue(b.GELOESCHT,'N') ='N'
 	     and b.ba_key in ('AE','VE','UE','RE')
 	     and 	b.bew_zeit_bis is null " )
.head 9 -  Set i = 0
.head 9 -  Set sFalls = ""
.head 9 +  Loop
.head 10 +  If i >= oHandleSelect.nIndex or not bOk
.head 11 -  Break
.head 10 -  Set oFallRow = FE_GetInfo( GetRowID(oHandleSelect.nRow[i]) )
.head 10 -  Set nFallKey = oFallRow.nID_Obj
.head 10 -  Set sFalls = sFalls || SalNumberToStrX(nFallKey, 0) || ", "
.head 10 +  If SqlExecute( hSqlPopulate )
.head 11 +  If SqlFetchNext( hSqlPopulate, nFetch )
.head 12 -  Set bOk =  FALSE
.head 10 -  Set i = i + 1
.head 9 +  If bOk
.head 10 -  Call SalStrLeft( sFalls, SalStrLength( sFalls ) - 2, sFalls )
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select f.fall_key
  from fall f
  , fall f2   where f.einricht_id=1
    and f.fall_key in (" || sFalls || ")
and f.culling_id is null and f.geloescht = 'N'
and f.geschl='M'
and f2.fall_key in (" || sFalls || ")  and f2.geschl='W'
and f.LAST_CAGE_ID=f2.LAST_CAGE_ID" )
.head 9 +  If SqlFetchNext( hSqlPopulate, nFetch )
.head 10 -  Set bOk =  FALSE
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute (hSqlPopulate, "select geschl, count(geschl)
  from fall
  where einricht_id=:nEinrichtId
    and fall_key in (" || sFalls || ")
and culling_id is null and geloescht = 'N'
group by 1
into :sSex , :nCount ")
.head 9 +  While bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 10 +  If sSex = 'M'
.head 11 -  Set nCountM = nCount
.head 10 +  Else
.head 11 -  Set nCountW = nCount
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select count(t.id) 
  from "|| sUserName ||".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null )
where f.geschl is null
having  count(f.fall_key)-count(f.culling_id)=0
into :nCountEmptyCage ")
.head 9 -  Set bOk = bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 9 -  Set bOk = bOk and ( (bMassMating and nCountM <= nCountEmptyCage ) or (not bMassMating and (nBound-nFem)=1) ) and ((nFem=1 and nCountW=2*nCountM ) or (nFem=0 and nCountW=nCountM) ) and (oHandleSelect.nIndex = nCountM + 
nCountW)
.head 9 +  ! If bMassMating
.head 10 -  Set bOk = bOk and nCountM =1 and ((nFem=1 and nBound =2 and nCountW=2 ) or (nFem=0 and nBound =1 and nCountW=1) )
.head 9 +  ! Else
.head 10 -  Set bOk = bOk and nCountM =1 and ((nFem=1 and nBound =2 and nCountW=2 ) or (nFem=0 and nBound =1 and nCountW=1) )
.head 8 +  Else
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate , "select *
  from " || sUserName || ".t_cage t
       join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null and f.culling_id is null),
   relship_fall rf
where
       rf.einricht_id=f.einricht_id
and rf.fall_key=f.fall_KEY
and rf.FALLROLLE_KEY='MATE'
and ( (@Nullvalue(rf.RS_FALL_VALID, 01.01.2500)>@Now)
      or rf.plugged is not null
      or exists (select lc.litter_id from litter_child lc, litter l
                                         where l.place_relship_id=rf.relship_id
                                             and l.FAMILY_RELSHIP_ID in (select r2.relship_id from relship_fall r2
                                                                                                         where r2.einricht_id = f.einricht_id and r2.fall_key = f.fall_key and r2.fallrolle_key = 'PARENT')
                                             and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0
                                             and (lc.LITTER_REASON !='MISS' or lc.LITTER_REASON is null)
                                             and @NULLVALUE(l.miss, 0) = 0 )
     or exists(select kk.place_relship_id from litter kk , relship_fall rf2
                                          where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id )
		                              and rf2.relship_id = kk.FAMILY_RELSHIP_ID
                                              and rf2.einricht_id=f.einricht_id and rf2.fall_key=f.fall_key)
      
)")
.head 9 -  Set bOk = bOk and not SqlFetchNext( hSqlPopulate , nFetch )
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate , "select t.id, f.geschl,  count(f.fall_key) - count(f.culling_id) 
  from " || sUserName || ".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null and f.culling_id is null )
group by 1,2
having  count(f.fall_key)-count(f.culling_id)>0
order by 1, 3 desc,  2
into :nCageId, :sSex, :nCountAnimal  ")
.head 9 -  Set nPrevCageId= 0
.head 9 -  Set sPrevSex = ""
.head 9 -  Set nCountW = 0
.head 9 -  Set nCountM = 0
.head 9 -  Set nBound = 0
.head 9 +  While bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 10 +  If nPrevCageId!=nCageId
.head 11 -  Set nPrevCageId=nCageId
.head 11 -  Set sPrevSex = sSex
.head 11 -  Set bStockMale = (nCountM> 0 and nCountW=0) or bStockMale
.head 11 -  Set bStockFeMale =(nCountW> 0 and nCountM=0) or bStockFeMale
.head 11 -  Set bOk = bOk and not(nCountW> 0 and nCountM>0)
.head 11 +  If bOk
.head 12 -  Set nBound = nBound + nCountW
.head 11 -  Set nCountW = 0
.head 11 -  Set nCountM = nCountW
.head 10 +  If sSex = 'M' 
.head 11 -  Set nCountM = nCountAnimal
.head 10 +  Else
.head 11 -  Set nCountW = nCountAnimal
.head 9 -  Set bStockMale = (nCountM> 0 and nCountW=0) or bStockMale
.head 9 -  Set bStockFeMale =(nCountW> 0 and nCountM=0) or bStockFeMale
.head 9 -  Set bOk = bOk and not(nCountW> 0 and nCountM>0)
.head 9 +  If bOk
.head 10 -  Set nBound = nBound + nCountW
.head 9 -  Set bOk = bOk and bStockMale and bStockFeMale and (nBound - nFem ) > 0
.head 7 -  Return bOk
.head 7 -  !
.head 5 +  Function: CanStudMailMate
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Number: nFtch
.head 7 -  Number: nCageID
.head 7 -  String: sRack
.head 7 -  String: sCage
.head 7 -  String: sStatus
.head 7 -  String: sSex
.head 7 -  Number: nCountS
.head 7 -  Boolean: bStockM
.head 7 -  Boolean: bStockF
.head 7 -  Boolean: bEmptyCages
.head 7 -  Boolean: bMPP
.head 7 -  Number: nPrevCage
.head 7 -  String: sStatusCage
.head 7 -  Boolean: bCheck
.head 7 -  Number: nRow
.head 7 -  Boolean: bF
.head 7 -  Boolean: bM
.head 7 -  Number: nCountAnim
.head 7 -  Number: nCountF
.head 7 -  Number: nCount
.head 6 +  Actions
.head 7 -  ! If GalConnect(hSqlPopulate )
.head 7 -  Set bEmptyCages = FALSE
.head 7 -  Set bOk =SqlPrepareAndExecute(hSqlPopulate,"select count(t.id)
into :nCount
 from "|| sUserName ||".t_cage t
where  not exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null   and f.geloescht='N' )
")
.head 7 +  If bOk 
.head 8 +  If SqlFetchNext(hSqlPopulate,nFtch )
.head 9 +  If nCount > 0
.head 10 -  Set bEmptyCages = TRUE
.head 7 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate,"select  t.id,  f.last_stat_key, f.last_gruppe_key 

  from  " || sUserName || ".T_Cage t
    join sysadm.fall f on (f.geschl='M' and f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null  and ee_time is null)
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key)
where  rf.fall_key is null
and t.id not in (select t2.id from "|| sUserName ||".T_Cage t2
    join sysadm.fall f2 on (f2.geschl='W' and f2.last_cage_id=t2.id and f2.geloescht='N' and f2.culling_id is null) where t2.id=t.id)
group by 1,2,3
having count(f.fall_key)=1
into :nCageID, :sRack, :sCage" )
.head 7 +  If SqlFetchNext(hSqlPopulate,nFtch )
.head 8 -  Set bStockM = TRUE
.head 7 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlPopulate,"select  t.id,  f.last_stat_key, f.last_gruppe_key,count(f.fall_key)

  from   " || sUserName || ".T_Cage t
    join sysadm.fall f on (f.geschl='W' and f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null)
   left join sysadm.roling_fall rf on (rf.status=0 and rf.fall_key=f.fall_key)
where  rf.fall_key is null
and t.id not in (select t2.id from  " || sUserName || ".T_Cage t2
    join sysadm.fall f2 on (f2.last_cage_id=t2.id and f2.geschl='M' and f2.geloescht='N' and f2.culling_id is null) where t2.id=t.id)
and t.id not in (select t3.id
  from " || sUserName || ".T_Cage t3
   join sysadm.fall f on (f.last_cage_id=t3.id and f.geschl='W' and f.geloescht='N' and f.culling_id is null  and ee_time is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and (rf.fallrolle_key='PARENT' or (rf.fallrolle_key = 'MATE' and @nullvalue(rf.rs_fall_valid,@now+365)>=@now)))
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id
	 and fall_key is null
	and dead = 0) or not exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id)))
group by 1,2,3

into :nCageID, :sRack, :sCage,:nCountAnim  " )
.head 7 -  Set nCountF = 0
.head 7 +  While SqlFetchNext(hSqlPopulate,nFtch )
.head 8 -  Set nCountF = nCountF + nCountAnim
.head 7 +  If nCountF >= 1+nFem
.head 8 -  Set bStockF = TRUE
.head 7 +  If nFem = 1
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlPopulate,"select  t.id,  f.last_stat_key, f.last_gruppe_key, f.geschl , count(f.geschl)  

  from  " || sUserName || ".T_Cage t
join sysadm.fall f on (f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='MATE' and rf.rs_fall_valid is null )
    left join sysadm.roling_fall rl on (rl.status=0 and rl.fall_key=f.fall_key)

where rl.fall_key is null
  and t.id not in (select t.id
  from " || sUserName || ".T_Cage t
   join sysadm.fall f on (f.geschl='W' and f.last_cage_id=t.id and f.geloescht='N' and f.culling_id is null)
   join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key = f.fall_key and rf.fallrolle_key='PARENT')
   join sysadm.litter l on (l.family_relship_id = rf.relship_id and @nullvalue(miss,0)=0)

where  (exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id
	 and fall_key is null 
	and dead = 0) or not exists(select child_nr 
	from sysadm.litter_child 
	where litter_id = l.litter_id)))

group by 1,2,3,4
having count(f.fall_key)=1
order by 1,4
into :nCageID, :sRack, :sCage , :sSex, :nCountS " )
.head 8 +  While SqlFetchNext(hSqlPopulate,nFtch )
.head 9 +  If nPrevCage != nCageID
.head 10 +  If not bMPP
.head 11 -  Set bMPP = bF and bM
.head 10 -  Set nPrevCage = nCageID
.head 10 -  Set bM = FALSE
.head 10 -  Set bF = FALSE
.head 9 +  If sSex='M' 
.head 10 -  Set bM = TRUE
.head 9 +  Else
.head 10 -  Set bF = TRUE
.head 8 +  If not bMPP
.head 9 -  Set bMPP = bF and bM
.head 7 -  ! Call SqlDisconnect(hSqlFind)
.head 7 +  ! Else
.head 8 -  Set bOk = FALSE
.head 7 -  Set bOk = bOk and ((bStockM and bStockF) or (bStockF and bMPP)) and not bEmptyCages
.head 7 -  Return bOk
.head 5 +  Function: CanMoveTransferCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Receive Number: nType ! 1 - Move cages ; 2 - Transfer cages
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlCheck
.head 7 -  Number: nFetch
.head 7 -  Number: nScreenTarget
.head 7 -  Number: nScreenSource
.head 7 -  Number: nScreenPrev
.head 7 -  Number: nCount
.head 7 -  Number: nCountTargetCages
.head 7 -  Number: nCountSourceCages
.head 7 -  Boolean: bOk
.head 7 -  !
.head 7 -  Number: nOpenCages[*]
.head 7 -  Number: nI
.head 7 -  Boolean: bNeedRegSlot
.head 6 +  Actions
.head 7 -  Set bOk = FALSE
.head 7 -  Set nType = 2
.head 7 +  If nSelectedLevel ! = FEL_Institute and nSelectedLevel ! = FEL_Pos
.head 8 -  Set bOk = TRUE
.head 7 +  If oHandleSelect.nIndex > 0
.head 8 -  Set bOk = FALSE
.head 7 -  !
.head 7 +  If bOk
.head 8 -  Set nCount = GetOpenCages( nRoot, 0, nOpenCages )
.head 8 -  Set nI = 0
.head 8 -  Set bOk = bOk and nCount>1 and SalNumberMod ( nCount , 2 ) = 0
.head 8 +  While nI < nCount and bOk
.head 9 +  If GetIdObject( nOpenCages[nI] ) !=-100
.head 10 -  Set bNeedRegSlot = CheckStatusObj( GetParent( nOpenCages[nI] ), Rack_SlotNeedAssign )
.head 10 +  If bNeedRegSlot
.head 11 -  Set bOk = bOk and CheckStatusObj(nOpenCages[nI], Cage_LOCKCurrScreen)
.head 10 +  If bOk
.head 11 +  If CheckStatusObj(nOpenCages[nI], CageIsFull)
.head 12 +  If nScreenSource = 0 or nScreenSource = NUMBER_Null
.head 13 -  Set nScreenSource = GetParent(GetParent( nOpenCages[nI] ))
.head 12 +  Else
.head 13 +  If nScreenSource != GetParent(GetParent( nOpenCages[nI] ))
.head 14 -  Set bOk = FALSE
.head 11 +  Else
.head 12 +  If nScreenTarget = 0 or nScreenTarget = NUMBER_Null
.head 13 -  Set nScreenTarget = GetParent(GetParent( nOpenCages[nI] ))
.head 12 +  Else
.head 13 +  If nScreenTarget != GetParent(GetParent( nOpenCages[nI] ))
.head 14 -  Set bOk = FALSE
.head 9 -  Set nI = nI + 1
.head 7 -  !
.head 7 -  Set bOk = bOk and nScreenSource>0 and nScreenTarget>0
.head 7 +  If nScreenSource = nScreenTarget
.head 8 -  Set nType = 1
.head 7 +  ! If bOk and  SqlCreateStatement( hSesionFE ,hSqlCheck)
.head 8 -  Set bOk = TRUE
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlCheck, "select t.scr_id,count(t.id)
into :nScreenTarget, :nCount
 from "|| sUserName ||".t_cage t
where  not exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null   and f.geloescht='N' )
group by 1
")
.head 8 -  Set nScreenPrev = -1000
.head 8 +  While SqlFetchNext(hSqlCheck,nFetch ) and bOk
.head 9 +  If nScreenPrev = -1000
.head 10 -  Set nScreenPrev = nScreenTarget
.head 9 +  Else 
.head 10 +  If nScreenPrev != nScreenTarget
.head 11 -  Set bOk = FALSE
.head 9 -  Set nCountTargetCages = nCount
.head 8 -  Set nScreenPrev = -1000
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute(hSqlCheck, "select t.scr_id,count(t.id)
into :nScreenSource, :nCount
 from "|| sUserName ||".t_cage t
where  exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null and f.geloescht='N' )
group by 1
")
.head 8 +  While SqlFetchNext(hSqlCheck,nFetch ) and bOk
.head 9 +  If nScreenPrev = -1000
.head 10 -  Set nScreenPrev = nScreenSource
.head 9 +  Else 
.head 10 +  If nScreenPrev != nScreenSource
.head 11 -  Set bOk = FALSE
.head 9 -  Set nCountSourceCages = nCount
.head 8 -  Set bOk = bOk and (nCountTargetCages=nCountSourceCages) and nCountTargetCages > 0
.head 8 +  If nScreenSource = nScreenTarget
.head 9 -  Set nType = 1
.head 8 -  Call SqlDisconnect( hSqlCheck )
.head 7 -  Return bOk
.head 5 +  Function: CanUnregisterCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bRet
.head 7 -  FunctionalVar: nRowCheck
.head 8 -  Class: cFERow
.head 7 -  Number: nAnimals
.head 6 +  Actions
.head 7 -  Set bRet = (nSelectedLevel = KHEL_Gruppe)
.head 7 +  If bRet
.head 8 -  Set nRowCheck = FE_GetInfo( nSelectedRow )
.head 8 -  Set bRet = bRet and nRowCheck.GetState( CageWithRFID )
.head 8 +  If bRet
.head 9 -  Set nAnimals = 0
.head 9 -  Set nAnimals =nRowCheck.GetNValue( "Male" ) 
.head 9 -  Set nAnimals =nAnimals + nRowCheck.GetNValue( "FeMale" ) 
.head 9 -  Set bRet = bRet and not nAnimals
.head 7 -  Return bRet
.head 5 +  Function: CanShift
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oPos
.head 8 -  Class: cPositionData
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Number: nEmpty
.head 7 -  Number: nFtch
.head 6 +  Actions
.head 7 -  Call _GetPositionID( nSelectedRow , oPos )
.head 7 -  Set bOk = (nSelectedLevel = KHEL_Gruppe)
.head 7 -  Set bOk = bOk and CheckStatusObj( nSelectedRow , CageIsFull )
.head 7 -  ! Set bOk = bOk and CageIsEmpty(oPos.sRack, oPos.sCage, SalDateCurrent(  ), TRUE )
.head 7 +  If bOk 
.head 8 -  Set bOk =  SqlCreateStatement( hSesionFE, hSqlFind )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlFind,"select count(t.id)
into :nEmpty
 from "|| sUserName ||".t_cage t
where  not exists (select * from fall f where f.last_cage_id=t.id and f.ee_datum is null   and f.geloescht='N' )
")
.head 8 +  If bOk 
.head 9 +  If SqlFetchNext(hSqlFind,nFtch )
.head 10 +  If nEmpty > 0
.head 11 -  Set bOk = FALSE
.head 8 +  If hSqlFind
.head 9 -  Call SqlDisconnect(hSqlFind)
.head 7 -  Return bOk
.head 5 +  Function: CanPaste
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oRowCheck
.head 8 -  Class: cFERow
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set bOk = FALSE
.head 7 -  ! Set bBettIsSummary = BettIsSummary()
.head 7 +  If CheckStatusObj(nSelectedRow, CageIsOccupied)
.head 8 -  Return bOk
.head 7 -  ! Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  ! If HandleToPlace[0,1] <=  0 and nBound > 0
.head 8 -  Call DelNul()
.head 8 -  Call SalArrayGetUpperBound ( HandleToPlace, 1, nBound ) 
.head 7 +  ! If HandleToPlace[0,1] <=  0 and nBound = 0
.head 8 -  Return FALSE
.head 7 -  ! Set nBound = nBound + 1
.head 7 +  If TRUE ! Not CheckStatusObj(nSelectedRow, RackIsVirtual) !   or bPlanningMode)
.head 8 +  If oHandleSelect.nIndex > 0
.head 9 -  Set oRowCheck = FE_GetInfo( nSelectedRow )
.head 9 +  If (nSelectedLevel = KHEL_Gruppe and  oHandleSelect.nIndex<=oRowCheck.GetNValue( "Empty" ))
.head 10 -  ! Set bOk = (EnumChildren(hMove_Source, hBetts)>0) or bMove_SingleBett or (Not SalArrayIsEmpty(HandleToPlace))
.head 10 -  Set bOk = TRUE
.head 10 -  Set nI=0
.head 10 +  While nI < oHandleSelect.nIndex and bOk
.head 11 -  Set bOk = not (nSelectedRow = GetParent( GetRowID(oHandleSelect.nRow[nI] ) ))
.head 11 -  Set nI=nI +1
.head 9 +  Else If (nSelectedLevel = KHEL_Bett) and oHandleSelect.nIndex=1
.head 10 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 +  Function: CanRolingMatings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oRowCheck
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oRowAnimal
.head 8 -  Class: cFERow
.head 7 -  Number: nOpenCages[*]
.head 7 -  Number: nCount
.head 7 -  Boolean: bFemales
.head 7 -  Boolean: bMales
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Set bOk = bOk and (nSelectedLevel = KHEL_Gruppe or nSelectedLevel = KHEL_Bett)
.head 7 +  If bOk
.head 8 -  Set nCount = GetOpenCages( nRoot, 0, nOpenCages )
.head 8 -  Set bOk = bOk and (nCount=2)
.head 7 +  If bOk 
.head 8 -  Set oRowCheck = FE_GetInfo( nOpenCages[0] )
.head 8 -  Set bOk = bOk and oRowCheck.GetState( CageIsFull )
.head 8 +  Select Case oRowCheck.GetNValue( "SEX" )
.head 9 +  Case 0
.head 10 -  Set bOk = FALSE
.head 10 -  Break
.head 9 +  Case 1
.head 10 -  Set bFemales = TRUE
.head 10 -  Break
.head 9 +  Case 2
.head 10 -  Set bMales = TRUE
.head 10 +  If oHandleSelect.bAnySelects
.head 11 -  Set bOk = bOk and oHandleSelect.nCountMales=1 and oHandleSelect.nCountFemales = 0
.head 10 +  Else
.head 11 +  If nSelectedLevel = KHEL_Bett
.head 12 -  Set oRowAnimal = FE_GetInfo( nSelectedRow )
.head 12 -  Set bOk = bOk and oRowAnimal.GetSValue( "SEX" ) = 'M'
.head 11 +  Else
.head 12 -  Set bOk = bOk and oRowCheck.GetNValue( "MALE" ) = 1 or oRowCheck.GetState( CageIsRoling  )
.head 10 -  Break
.head 9 +  Case 3
.head 10 +  If oHandleSelect.bAnySelects
.head 11 -  Set bOk = bOk and oHandleSelect.nCountMales=1 and oHandleSelect.nCountFemales = 0
.head 10 +  Else
.head 11 -  Set bOk = bOk and oRowCheck.GetState( CageIsRoling )
.head 10 -  Set bMales = TRUE
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 8 +  If bOk
.head 9 -  Set oRowCheck = FE_GetInfo( nOpenCages[1] )
.head 9 -  Set bOk = bOk and oRowCheck.GetState( CageIsFull )
.head 9 +  Select Case oRowCheck.GetNValue( "SEX" )
.head 10 +  Case 0
.head 11 -  Set bOk = FALSE
.head 11 -  Break
.head 10 +  Case 1
.head 11 -  Set bFemales = TRUE
.head 11 -  Set bOk = bOk and bMales
.head 11 -  Break
.head 10 +  Case 2
.head 11 -  Set bMales = TRUE
.head 11 -  Set bOk = bOk and bFemales
.head 11 +  If bOk
.head 12 +  If oHandleSelect.bAnySelects
.head 13 -  Set bOk = bOk and oHandleSelect.nCountMales=1 and oHandleSelect.nCountFemales = 0
.head 12 +  Else
.head 13 +  If nSelectedLevel = KHEL_Bett
.head 14 -  Set oRowAnimal = FE_GetInfo( nSelectedRow )
.head 14 -  Set bOk = bOk and oRowAnimal.GetSValue( "SEX" ) = 'M'
.head 13 +  Else
.head 14 -  Set bOk = bOk and oRowCheck.GetNValue( "MALE" ) = 1 or oRowCheck.GetState( CageIsRoling  )
.head 11 -  Break
.head 10 +  Case 3
.head 11 +  If oHandleSelect.bAnySelects
.head 12 -  Set bOk = bOk and oHandleSelect.nCountMales=1 and oHandleSelect.nCountFemales = 0
.head 11 +  Else
.head 12 -  Set bOk = bOk and oRowCheck.GetState( CageIsRoling )
.head 11 -  Break
.head 10 +  Default
.head 11 -  Break
.head 7 -  Return bOk
.head 5 +  Function: CanPrintCageCard
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If nSelectedLevel = KHEL_Gruppe
.head 8 -  Set bOk = bOk and not CheckStatusObj( nSelectedRow, CageIsOccupied )
.head 8 -  Set bOk = bOk and CheckStatusObj( nSelectedRow, CageIsFull )
.head 7 +  Else If nSelectedLevel  = KHEL_Station
.head 8 -  Set bOk = bOk and CheckStatusObj( nSelectedRow, RackIsFull )
.head 7 +  Else
.head 8 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 +  Function: CanCollect
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: oEmptyCage
.head 8 -  Class: cFERowCage
.head 7 -  FunctionalVar: oCageStock
.head 8 -  Class: cFERowCage
.head 7 -  FunctionalVar: cAnimal
.head 8 -  Class: cFERow
.head 7 -  Number: nOpenCagesFull[*]
.head 7 -  Number: nCountFullCages
.head 7 -  Number: nOpenCagesEmpty[*]
.head 7 -  Number: nCountEmptyCages
.head 7 -  Number: nFtch
.head 7 -  Number: nCS
.head 7 -  Number: nRowScreen
.head 7 -  Number: nI
.head 7 -  Number: nRowA
.head 7 -  Number: nCountAnimals
.head 7 -  Boolean: bMaleExists
.head 7 -  Boolean: bFeMaleExists
.head 7 -  String: sStrain
.head 6 +  Actions
.head 7 -  Set bOk = (nSelectedLevel = FEL_Cage )
.head 7 +  ! If bOk
.head 8 -  Set oEmptyCage = FE_GetInfo( nSelectedRow )
.head 8 -  Set bOk = bOk and oEmptyCage.GetState( CageIsEmpty )
.head 7 +  If bOk ! Check open cages in same screen
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select count(distinct scr_id) from " || sUserName || ".t_cage into :nCS  ")
.head 8 -  Set bOk = bOk and SqlFetchNext(hSqlPopulate, nFtch)
.head 8 -  Set bOk = bOk and (nCS=1)
.head 7 +  If bOk ! Check only one open empty cage
.head 8 -  Set nRowScreen = GetParent(GetParent( nSelectedRow ))
.head 8 -  Set nCountEmptyCages = GetOpenCages( nRowScreen, CageIsEmpty, nOpenCagesEmpty )
.head 8 -  Set bOk = bOk and (nCountEmptyCages<=1)
.head 7 +  If bOk
.head 8 -  Set oEmptyCage = FE_GetInfo( nSelectedRow )
.head 7 +  If bOk and nCountEmptyCages=1
.head 8 -  Set bOk = bOk and oEmptyCage.GetState( CageIsEmpty )
.head 7 +  If bOk 
.head 8 -  Set nCountFullCages = GetOpenCages( nRowScreen, CageIsFull , nOpenCagesFull )
.head 8 -  Set bOk = bOk and (nCountFullCages>0)
.head 8 -  Set nI = 0
.head 8 -  Set nCountAnimals = 0
.head 8 -  Set sStrain = ""
.head 8 +  While nI < nCountFullCages and bOk
.head 9 +  If nOpenCagesFull[nI] != nSelectedRow
.head 10 -  Set oCageStock = FE_GetInfo( nOpenCagesFull[nI] )
.head 10 +  If oCageStock.nMales
.head 11 -  Set bMaleExists = TRUE
.head 10 +  If oCageStock.nFemales
.head 11 -  Set bFeMaleExists  = TRUE
.head 10 -  Set nRowA = MTblGetFirstChildRow( hWndForm, nOpenCagesFull[nI] )
.head 10 +  Loop
.head 11 +  If nRowA = TBL_Error or not bOk
.head 12 -  Break
.head 11 -  Set cAnimal = FE_GetInfo( nRowA )
.head 11 +  If cAnimal.nID_Obj!=-100
.head 12 +  If sStrain = ""
.head 13 -  Set sStrain = cAnimal.GetSValue( "strain" )
.head 12 +  Else
.head 13 +  If sStrain != cAnimal.GetSValue( "strain" )
.head 14 -  Set bOk = FALSE
.head 11 -  Set nRowA = MTblGetNextChildRow( hWndForm, nRowA )
.head 10 -  Set nCountAnimals = nCountAnimals + oCageStock.GetNValue("COUNT")
.head 10 -  Set bOk = bOk and nCountAnimals<=oEmptyCage.nEmptyPlace
.head 10 -  Set bOk = bOk and ( (bMaleExists and not bFeMaleExists) or (not bMaleExists and bFeMaleExists) )
.head 9 -  Set nI = nI + 1
.head 7 -  Return bOk
.head 5 +  Function: CanMoveWorkGroup
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTmp
.head 7 -  String: sSqlCheck
.head 7 -  Number: nFetch
.head 7 -  Sql Handle: hSql
.head 6 +  Actions
.head 7 +  If Not SqlCreateStatement( hSesionFE , hSql )
.head 8 -  Return FALSE
.head 7 -  Set nTmp = 0
.head 7 +  If oPosition.nRackID > 0
.head 8 -  Set sSqlCheck = "
select count(*) from user_screen u
join screen_rack s on (s.scr_id=u.scr_id and s.rack_id=:oPosition.nRackID )
where u.user_id=:nUserId and u.scr_id<>:oPosition.nScreenID
into :nTmp"
.head 7 +  Else If oPosition.nScreenID > 0
.head 8 -  Set sSqlCheck = "
select count(count(u.scr_id))
   from user_screen u
join screen_rack s on (s.scr_id=u.scr_id)
where u.user_id=:nUserId
and u.scr_id<>:oPosition.nScreenID
group by u.scr_id
into :nTmp"
.head 7 +  If sSqlCheck != STRING_Null and sSqlCheck != ""
.head 8 +  If SqlPrepareAndExecute(hSql, sSqlCheck)
.head 9 -  Call SqlFetchNext(hSql, nFetch)
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Return nTmp>0
.head 5 +  Function: CanMoveToVirt
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowParent
.head 7 -  Number: nRowEmpty[*]
.head 7 -  Number: nRowFull[*]
.head 7 -  Number: nI
.head 7 -  Boolean: bOk
.head 7 -  Number: nCountFull
.head 6 +  Actions
.head 7 -  Set nRowParent = nSelectedRow
.head 7 +  Loop
.head 8 +  If GetLevel( nRowParent) <= KHEL_Station
.head 9 -  Break
.head 8 -  Set nRowParent = GetParent( nRowParent )
.head 7 -  Set bOk = GetOpenCages(nRowParent, CageIsEmpty,nRowEmpty ) = 0
.head 7 +  If bOk
.head 8 -  Set nCountFull = GetOpenCages(nRowParent, CageIsFull  ,nRowFull )
.head 8 -  Set bOk = bOk and nCountFull >0
.head 8 -  Set nI = 0
.head 8 +  While bOk and nI<nCountFull
.head 9 -  Set bOk = bOk and not CheckStatusObj(nRowFull[nI], RackIsVirtual)
.head 9 -  Set nI = nI + 1
.head 7 -  Return bOk
.head 5 +  Function: CanGetRealCages
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nRowEmpty[*]
.head 7 -  Number: nRowFull[*]
.head 7 -  Number: nRowWorkGroup
.head 7 -  Number: nI
.head 7 -  Number: nCountFull
.head 6 +  Actions
.head 7 -  Set nRowWorkGroup = nSelectedRow
.head 7 +  Loop
.head 8 +  If GetLevel( nRowWorkGroup) <= KHEL_Abteilung
.head 9 -  Break
.head 8 -  Set nRowWorkGroup = GetParent( nRowWorkGroup )
.head 7 -  Set bOk = GetOpenCages(nRowWorkGroup, CageIsEmpty,nRowEmpty ) = 0
.head 7 +  If bOk
.head 8 -  Set nCountFull = GetOpenCages(nRowWorkGroup, CageIsFull  ,nRowFull )
.head 8 -  Set bOk = bOk and nCountFull >0
.head 8 -  Set nI = 0
.head 8 +  While bOk and nI<nCountFull
.head 9 -  Set bOk = bOk and not CheckStatusObj(nRowFull[nI], RackIsVirtual)
.head 9 -  Set nI = nI + 1
.head 7 -  Call SalSendMsg( hWndRack2DViewVirt , AM_VirtR2D, bOk, 0 )
.head 7 -  Return bOk
.head 5 +  Function: CanMoveFromVirtual
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowRack
.head 7 -  Number: nCountEmpty
.head 7 -  Number: nCountFull
.head 7 -  Number: nRowEmpty[*]
.head 7 -  Number: nRowFull[*]
.head 7 -  String: sVirtRack
.head 7 -  String: sVirtScr
.head 7 -  Boolean: bOk
.head 7 -  Number: nFullCageInVirt
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If GetLevel( nSelectedRow ) != KHEL_Station or hWndRack2DViewVirt = hWndNULL
.head 8 -  Return FALSE
.head 7 -  Set nRowRack = nSelectedRow
.head 7 +  Loop
.head 8 +  If GetLevel( nRowRack) <= KHEL_Station
.head 9 -  Break
.head 8 -  Set nRowRack = GetParent( nRowRack )
.head 7 -  Set nCountEmpty = GetOpenCages(nRowRack, CageIsEmpty  ,nRowEmpty )
.head 7 -  Set nCountFull = GetOpenCages(GetParent(nRowRack), CageIsFull  ,nRowFull )
.head 7 +  If nCountEmpty = 0
.head 8 -  Set nCountEmpty = -1
.head 7 -  Set sVirtRack = frmKHE2DViewVirt.cRack2DLayoutManager.sRack
.head 7 -  Set sVirtScr = frmKHE2DViewVirt.cRack2DLayoutManager.sScreen
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlGetInfo , "select count(distinct last_gruppe_key) from fall
where ee_datum is null and culling_id is null 
and last_abt_key=:sVirtScr
and last_stat_key=:sVirtRack 
into :nFullCageInVirt " )
.head 7 -  Set bOk = bOk and SqlFetchNext(hSqlGetInfo, nFetch)
.head 7 -  Return nFullCageInVirt=nCountEmpty and nCountFull = 0
.head 5 +  Function: CanCageUsingEnable
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  ! If SalIsWindowVisible (hWL_Plan2Real_Bew)
.head 8 -  Return TRUE
.head 7 -  ! Set bOk = SalIsWindowVisible (hWL_Plan2Real_Bew) and CheckStatusObj(nSelectedRow, CageIsEmpty ) and nSelectedLevel = KHEL_Gruppe
.head 7 -  Set bOk = hWL_Plan2Real_Bew != hWndNULL  and CheckStatusObj(nSelectedRow, CageIsEmpty ) and nSelectedLevel = KHEL_Gruppe
.head 7 -  Return bOk
.head 5 +  Function: CanExpandCollapseRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 7 -  Number: nChild[*]
.head 6 +  Actions
.head 7 -  Set bReturn = nSelectedLevel < FEL_Pos
.head 7 +  If nSelectedLevel = FEL_Workgroup or nSelectedLevel = FEL_Rack
.head 8 -  Set bReturn = bReturn and EnumChildren(nSelectedRow, nChild) > 0
.head 7 -  Return bReturn
.head 5 +  Function: CanImport
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Boolean: bActRFID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nParent
.head 7 -  Number: nChild
.head 7 -  Number: nIDChild
.head 6 +  Actions
.head 7 -  Set bOk = nSelectedLevel = FEL_Cage and ( NOT bActRFID or CheckStatusObj( nSelectedRow, CageWithRFID ))
.head 7 -  Set bOk = bOk  and not CheckStatusObj( nSelectedRow, CageIsOccupied  )
.head 7 +  If CheckStatusObj( nSelectedRow, Rack_SlotNeedAssign  )
.head 8 -  Set nParent = GetParent( nSelectedRow )
.head 8 -  Set nChild = GetFirstChildRow( nParent )
.head 8 +  Loop
.head 9 +  If nChild = TBL_Error or not bOk
.head 10 -  Break
.head 9 +  If GetIdObject(nChild) != -100
.head 10 -  Set bOk = bOk and CheckStatusObj( nChild, Cage_LOCKCurrScreen  )
.head 9 -  Set nChild = GetNextChildRow( nChild )
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: RefreshCages
.head 6 -  Description: Refresh prepare cages and Print cage card
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nPrintCages
.head 7 -  FunctionalVar: cDest
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cSourceCard[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: oData
.head 8 -  Class: cPositionData
.head 7 -  Number: nRowRack
.head 7 -  Number: nRowRackNext
.head 7 -  Number: nRowID
.head 7 -  Number: nUniqSelectedRow
.head 7 -  Number: nUniqParentSelectedRow
.head 7 -  Boolean: bPrintCages
.head 7 -  String: sListCages
.head 7 -  FunctionalVar: cRowCheck
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  ! 1 Refresh
.head 7 -  ! Call LockSysadmAction("Refresh FE Start ")
.head 7 +  If bFreezeRefresh
.head 8 -  Return FALSE
.head 7 -  Set sListCages = ""
.head 7 -  Set bFreezeRefreshToolbars = TRUE
.head 7 -  Set nUniqSelectedRow = GetUniqRowID( nSelectedRow )
.head 7 -  Set nUniqParentSelectedRow = GetUniqRowID( GetParent(nSelectedRow) )
.head 7 -  Call oRefreshCages.PrepareRefresh(  )
.head 7 -  Call SalArraySetUpperBound( cSourceCard, 1, -1 )
.head 7 -  Set bPrintCages = FALSE
.head 7 -  Set nI = 0
.head 7 -  Set nRowRack = 0
.head 7 -  Set nPrintCages = 0
.head 7 +  While nI < oRefreshCages.nInd
.head 8 -  Set nRowID = GetRowID( oRefreshCages.nRow[nI] )
.head 8 +  If nRowID != TBL_Error
.head 9 -  Set nSelectedRow = nRowID
.head 9 -  Set nRowRackNext = GetParent( nSelectedRow )
.head 9 +  If nRowRack = 0
.head 10 -  Set nRowRack = nRowRackNext
.head 9 +  Else If nRowRack != nRowRackNext
.head 10 -  Set nSelectedRow = nRowRack
.head 10 -  Set nSelectedLevel = MTblGetRowLevel( hWndForm, nSelectedRow )
.head 10 -  Call Refresh( 10, 0 )
.head 10 -  Set nRowRack = nRowRackNext
.head 10 -  Set nSelectedRow = GetRowID(oRefreshCages.nRow[nI])
.head 9 -  Set nSelectedLevel = MTblGetRowLevel( hWndForm, nSelectedRow )
.head 9 -  Set cRowCheck = FE_GetInfo( nSelectedRow )
.head 9 -  Set sListCages = sListCages || cRowCheck.GetSValue( "Cage" ) || ";"
.head 9 -  Call Refresh( 10, 0 )
.head 9 -  Call _GetPositionID( nSelectedRow , oData )
.head 9 +  If CheckStatusObj( nSelectedRow, CageIsFull )
.head 10 +  If not bPrintCages and not CheckStatusObj(nSelectedRow , Rack_NotNeedPrint )
.head 11 -  Set bPrintCages = TRUE
.head 10 +  If not CheckStatusObj(nSelectedRow , Rack_NotNeedPrint )
.head 11 -  Call cSourceCard[nPrintCages].Init( oData.sScreen, oData.sRack, oData.sCage )
.head 11 -  Set nPrintCages = nPrintCages + 1
.head 9 +  Else
.head 10 -  Call POC_Unreg(oData.nCageID,TRUE)
.head 10 +  If not bNotNeedCloseCage
.head 11 -  Call CloseCage( oData.nScreenID, oData.nRackID, oData.nCageID )
.head 8 -  Set nI = nI + 1
.head 7 -  ! Call LockSysadmAction("Refresh FE 2 ")
.head 7 -  ! 2 Refresh
.head 7 +  If nRowRack
.head 8 -  Set nSelectedRow = nRowRack
.head 8 -  Set nSelectedLevel = MTblGetRowLevel( hWndForm, nSelectedRow )
.head 8 -  Call Refresh( 10, 0 )
.head 7 -  ! 3 Refresh
.head 7 +  If hWndRack2DViewVirt and SalIsWindowVisible( hWndRack2DViewVirt ) 
.head 8 -  Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshContent,0 )
.head 7 -  Set sListCages = SalStrLeftX( sListCages, SalStrLength( sListCages ) - 1 )
.head 7 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 1, SalHStringToNumber( sListCages) )
.head 7 -  ! Call LockSysadmAction("Refresh FE 3 ")
.head 7 -  !
.head 7 -  Set nRowRack = GetRowID( nUniqSelectedRow )
.head 7 +  If nRowRack = TBL_Error 
.head 8 -  Set nRowRack = GetRowID( nUniqParentSelectedRow )
.head 7 -  Set bFreezeRefreshToolbars = FALSE
.head 7 +  If nRowRack = TBL_Error 
.head 8 -  Call ActivateRow( nRoot )
.head 7 +  Else
.head 8 -  Call ActivateRow( nRowRack )
.head 7 -  ! Call LockSysadmAction("Refresh FE 4 ")
.head 7 +  If hWndProgress
.head 8 -  Call SalSendMsg( hWndProgress, SAM_Close, 0, 0 )
.head 8 -  Set hWndProgress = hWndNULL
.head 7 -  Call Rack2DView_RefreshCageContents("")
.head 7 -  ! Call LockSysadmAction("Refresh FE 5 ")
.head 7 -  !
.head 7 +  If not SalArrayIsEmpty( cSourceCard )
.head 8 -  Call cDest.Init( cSourceCard[nPrintCages-1].sScreenKey, cSourceCard[nPrintCages-1].sRackKey, cSourceCard[nPrintCages-1].sCageKey)
.head 8 +  If not bPrintCages
.head 9 -  Set bNotNeedPrintCageCard = TRUE
.head 8 -  Call Move_PrintCageCards( cSourceCard, cDest )
.head 8 -  Set bNotNeedPrintCageCard = FALSE
.head 7 -  Call oRefreshCages.Init(  )
.head 7 -  Call MTblAutoSizeRows( hWndForm, MTASR_ALLROWS | MTASR_HIDDENROWS )
.head 7 -  Call SalArraySetUpperBound( cSourceCard, 1, -1 )
.head 7 -  Call LockSysadmAction("Refresh FE End ")
.head 7 -  Return TRUE
.head 5 +  Function: RefreshVirtualRacks
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowW
.head 7 -  Number: nRowR
.head 6 +  Actions
.head 7 -  Set nRowW = GetFirstChildRow( nRoot )
.head 7 +  Loop
.head 8 +  If nRowW = TBL_Error
.head 9 -  Break
.head 8 +  If RowIsExpand( nRowW )
.head 9 -  Set nRowR = GetFirstChildRow( nRowW )
.head 9 +  Loop
.head 10 +  If nRowR = TBL_Error
.head 11 -  Break
.head 10 +  If CheckStatusObj(nRowR, RackIsVirtual )
.head 11 -  Call PopulateRack( nRowR, FALSE )
.head 10 -  Set nRowR = GetNextChildRow( nRowR )
.head 8 -  Set nRowW = GetNextChildRow( nRowW )
.head 5 +  Function: Move_PrintCageCards
.head 6 -  Description: Prints page cards for each source and destination cages after a movement
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocation
.head 7 -  Number: nCount
.head 7 -  Number: i
.head 7 -  FunctionalVar: cCage
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call PrintCageCards(cSource,cDestination)
.head 7 +  If GalGetProfileBooleanX( 'Settings', 'AutoCloseCageAfterMovement', FALSE, sUserINIFileName ) and not bNotNeedCloseCage
.head 8 -  Call SalArrayGetUpperBound( cSource, 1, nCount )
.head 8 -  Set i=0
.head 8 +  While i<= nCount
.head 9 -  Set cCage = GetPlaceFormString(cSource[i].sScreenKey || ";" || cSource[i].sRackKey || ";" || cSource[i].sCageKey)
.head 9 -  Call CloseCage( cCage.nScreenID, cCage.nRackID, cCage.nCageID )
.head 9 -  Set i=i+1
.head 8 -  Set cCage = GetPlaceFormString(cDestination.sScreenKey || ";" || cDestination.sRackKey || ";" || cDestination.sCageKey)
.head 8 -  ! Call CloseCage( cCage.nScreenID, cCage.nRackID, cCage.nCageID )
.head 7 -  Return bOk
.head 5 +  Function: PrintCageCards
.head 6 -  Description: Prints page cards for each source and destination cages 
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  FunctionalVar: cSource[*]
.head 8 -  Class: clsLocationCage
.head 7 -  FunctionalVar: cDestination
.head 8 -  Class: clsLocationCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: i
.head 7 -  Number: nCount
.head 7 -  FunctionalVar: cCages[*]
.head 8 -  Class: clsLocation
.head 7 -  Boolean: bPrint
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  If GalGetProfileBooleanX( 'Settings', 'PrintCageCardsOnMovement', TRUE, sUserINIFileName ) and not bNotNeedPrintCageCard
.head 8 -  Call SalArrayGetUpperBound( cSource, 1, nCount )
.head 8 -  Set i=0
.head 8 +  While i<= nCount
.head 9 -  Set cCages[i] = cSource[i]
.head 9 -  Set i=i+1
.head 8 -  Set cCages[i] = cDestination
.head 8 +  If Not Requst_ListForCageCard( cCages, "Cage Cards For Source And Destination Cages", bPrint )
.head 9 -  ! user canceled the action
.head 9 -  Set bOk = TRUE
.head 8 +  If bOk
.head 9 +  If bPrint
.head 10 -  Call Formular_CageCard_Print( '', '', GetTime4Refresh( ) )
.head 7 -  Return bOk
.head 5 -  !
.head 5 +  Function: ShowWorkLists
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If SalIsWindowVisible (hWorkLstOpened) 
.head 8 -  Call SalSendMsg( tblWorklistsOpened, SAM_Close, 0, 0 )
.head 8 -  Set hWorkLstOpened = SalCreateWindow( tblWorklistsOpened, hWndStar2000 , SalDateCurrent (), oPosition.sScreen)
.head 7 +  Else
.head 8 -  Set hWorkLstOpened = SalCreateWindow( tblWorklistsOpened, hWndStar2000 , SalDateCurrent (), oPosition.sScreen)
.head 7 -  Return TRUE
.head 5 +  Function: CallBulkImport
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sParam
.head 6 +  Actions
.head 7 -  Set sParam = ""
.head 7 +  If oPosition.sScreen
.head 8 -  Set sParam ="/screen=" || oPosition.sScreen
.head 8 +  If oPosition.sRack
.head 9 -  Set sParam =sParam || "/rack=" || oPosition.sRack
.head 9 +  If oPosition.sCage
.head 10 -  Set sParam =sParam || "/cage=" || oPosition.sCage
.head 7 -  Return SalSendMsg( hWndStar2000, AM_Start_Bulkimport, SalHStringToNumber( sParam ), 0 )
.head 5 -  ! POC functions
.head 5 +  Function: POC_FocusGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGrp
.head 7 -  Number: hStat
.head 7 -  Number: nIndex
.head 7 -  Window Handle: hWnd
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 6 +  Actions
.head 7 -  ! ! SS 15.12.2007 add sRoomCage for transfer Room and Cage to Mice_imp
.head 7 -  ! AS 11.11.2004: use bAutoScan instead of FALSE
.head 7 -  ! Set hGrp = FindH_4Gruppe( FindH_4Station( FindH_4Abteilung( sAbtKey ), sStatKey, bForceScan ), sGrpKey, bForceScan )
.head 7 -  ! Set hGrp = FindChild( FindChild( FindChild( hRoot, sAbtKey ), sStatKey ), sGrpKey )
.head 7 -  ! Set nIndex = GetItemIndex( hGrp )
.head 7 +  ! If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  ! Call ActivateSelectedItem(  )     
.head 7 +  ! If bBreedingIsON
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 7 -  Return TRUE
.head 5 +  Function: POC_FocusStation
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGrpKey
.head 7 -  Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: hGrp
.head 7 -  Number: hStat
.head 7 -  Number: nIndex
.head 7 -  Window Handle: hWnd
.head 7 -  Number: nTop
.head 7 -  Number: nLeft
.head 7 -  Number: nBottom
.head 7 -  Number: nRight
.head 7 -  Number: nFocusIndex
.head 7 -  Number: nX
.head 7 -  Number: nY
.head 7 -  Number: nW
.head 7 -  Number: nH
.head 6 +  Actions
.head 7 -  ! Set hGrp =  FindChild( FindChild( hRoot, sAbtKey ), sStatKey )
.head 7 -  ! Set nIndex = GetItemIndex( hGrp )
.head 7 +  ! If Not SalListSetSelect( hWndItem, nIndex )
.head 8 -  Return FALSE
.head 7 -  ! Call ActivateSelectedItem(  )     
.head 7 +  ! If bBreedingIsON
.head 8 -  Call SalSendMsg(hWndItem,SAM_Click,wParam,lParam)
.head 7 -  Return TRUE
.head 5 +  Function: ChangeCage
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nFetch
.head 7 -  String: sNull
.head 7 -  String: sBG1
.head 7 -  String: sBG2
.head 7 -  String: sBedLabel
.head 7 -  String: sAbtKeySrc
.head 7 -  String: sBettKey
.head 7 -  String: sGrpKeySrc
.head 7 -  String: sStatKeySrc
.head 7 -  String: sLaKey
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  Number: nInd
.head 7 -  Number: nBedAmount
.head 7 -  Number: nFallR
.head 7 -  Number: nLstNrPP
.head 7 -  Number: nLstNrP
.head 7 -  Date/Time: dtBuh
.head 7 -  Number: hBeds[*]
.head 7 -  String: sCom
.head 7 -  Number: nDone
.head 7 -  !
.head 7 -  Number: nCage
.head 7 -  Number: nScr
.head 6 +  Actions
.head 7 -  ! Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey )
.head 7 -  ! Set nInd = 0
.head 7 +  ! If GalConnect(hSql)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select id from sysadm.gruppe where gruppe_key = :sGrpKeySrc and stat_key = :sStatKeySrc and einricht_id = :nEinrichtId into :nCage")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlPrepareAndExecute(hSql, "select id from sysadm.abteilung where abt_key = :sAbtKeySrc and einricht_id = :nEinrichtId into :nScr")
.head 8 -  Call SqlFetchNext(hSql, nFetch)
.head 8 -  Call SqlDisconnect(hSql)
.head 8 -  Set nFallR = GetLicenseFall()
.head 8 +  If nFallR and nCCSrv and nScr and nCage
.head 9 -  Call InsertServiceINT(nCCSrv, nFallR, SalDateCurrent(), sGrpKeySrc||" changed with POC", nScr, nCage, FALSE, TRUE)
.head 5 +  Function: POC_OpenGruppe
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sPosition
.head 7 -  Number: nPort
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oData
.head 8 -  Class: cPositionData
.head 7 -  Number: nRowCage
.head 6 +  Actions
.head 7 -  Set oData = GetPlaceFormString(sPosition)
.head 7 -  Set nRowCage = OpenCage(oData.nScreenID, oData.nRackID , oData.nCageID)
.head 7 -  Call POC_ShowPort(nRowCage,nPort)
.head 7 -  Return nRowCage
.head 5 +  Function: POC_ShowPort
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: hGruppe ! it's uniq row id
.head 7 -  Number: nPort
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oGruppe
.head 8 -  Class: cPositionData
.head 7 -  String: sTextGrp
.head 7 -  FunctionalVar: oCage
.head 8 -  Class: cFERowCage
.head 7 -  Window Handle: hCol[*]
.head 7 -  Number: nColSort[*]
.head 7 -  Number: nFinishRow
.head 7 -  Number: nStartRow
.head 7 -  Number: nParentR
.head 7 -  Number: nChildRow
.head 6 +  Actions
.head 7 -  Set hGruppe = GetRowID( hGruppe )
.head 7 +  If hGruppe != TBL_Error
.head 8 +  If GetLevel(hGruppe) = KHEL_Gruppe
.head 9 -  Call _GetPositionID( hGruppe, oGruppe )
.head 9 -  Set sTextGrp=oGruppe.sScreen ||","||oGruppe.sRack||","||oGruppe.sCage
.head 9 -  Set oCage = FE_GetInfo( hGruppe )
.head 9 -  Set oCage.nPortPOS = nPort
.head 9 -  Set oCage.nOrder = nPort
.head 9 -  Call oCage.SetState( CageWithRFID )
.head 9 -  Set oCage.nLabelFlags = oSettingsCage.nFlags
.head 9 -  Call FE_SetInfo(hGruppe,oCage )
.head 9 -  ! Sorting level 
.head 9 -  Set hCol[0] = colOrder
.head 9 -  Set nColSort[0] = MTS_ASC | MTS_DT_DEFAULT
.head 9 -  Set nParentR = GetParent( hGruppe )
.head 9 -  Set nStartRow = MTblGetFirstChildRow( hWndForm,  nParentR )
.head 9 -  Set nChildRow = nStartRow
.head 9 +  Loop
.head 10 +  If nChildRow=TBL_Error
.head 11 -  Break
.head 10 -  Set nFinishRow = nChildRow
.head 10 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 9 -  Call MTblSortRange( hWndForm, hCol, nColSort, nStartRow, nFinishRow )
.head 9 -  Set hGruppe = FindObject( nParentR, oCage.nID_Obj )
.head 9 -  Call SetPOCPos(hGruppe, nPort)
.head 9 +  If hGruppe != nSelectedRow
.head 10 -  Call ActivateRow( hGruppe )
.head 9 -  Call SalPostMsg( hWndStar2000, AM_AttachPOC, nPort, SalHStringToNumber ( sTextGrp ) )
.head 5 +  Function: SetPOCPos
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowCage
.head 7 -  Number: nPort
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCageID
.head 6 +  Actions
.head 7 -  ! Call SetOutlineRedraw(FALSE)
.head 7 -  ! Call GetPositionID(hCage,nScr,nRack,nCage,nPos )
.head 7 -  Set nCageID = GetIdObject(nRowCage)
.head 7 -  Call T_SetPortPOC(nCageID, nPort )
.head 7 +  ! If NOT nPort
.head 8 +  Loop 
.head 9 -  Set hPrevious = GetNextSibling(hCage)
.head 9 +  If hPrevious = NUMBER_Null
.head 10 -  Break 
.head 9 +  If NOT GetItemData(hPrevious, sPortSubstring, nVal, nFlags)
.head 10 -  Break 
.head 9 -  Set nVal = SalStrScan(sPortSubstring, "<")
.head 9 -  Set nFlags = SalStrScan(sPortSubstring, " Pos>")
.head 9 +  If (nVal = 0) and (nFlags > nVal)
.head 10 -  Set nFlags = GetItemIndex(hCage)
.head 10 +  If nFlags = LB_Err
.head 11 -  Break 
.head 10 -  Call MoveDown(nFlags)
.head 9 +  Else 
.head 10 -  Break 
.head 7 +  ! Else
.head 8 +  Loop 
.head 9 -  Set hPrevious = GetPrevSibling(hCage)
.head 9 +  If hPrevious = NUMBER_Null
.head 10 -  Break 
.head 9 +  If NOT GetItemData(hPrevious, sPortSubstring, nVal, nFlags)
.head 10 -  Break 
.head 9 -  Set nVal = SalStrScan(sPortSubstring, "<")
.head 9 -  Set nFlags = SalStrScan(sPortSubstring, " Pos>")
.head 9 +  If (nVal = 0) and (nFlags > nVal)
.head 10 -  Set sPortSubstring = SalStrMidX(sPortSubstring, 1, nFlags -1)
.head 10 -  Set nPos = GetPOCPointNr(sPortSubstring)
.head 10 +  If nPos and (nPos < nPort)
.head 11 -  Break 
.head 9 -  Set nFlags = GetItemIndex(hCage)
.head 9 +  If nFlags = LB_Err
.head 10 -  Break 
.head 9 -  Call MoveUp(nFlags)
.head 7 -  ! Call SetOutlineRedraw(TRUE)
.head 5 +  Function: POC_CheckAndCloseFall
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: i
.head 7 -  Number: nBet
.head 7 -  Number: nFalls[*]
.head 6 +  Actions
.head 7 +  If Not VisWinIsWindow( hWndFall )
.head 8 -  Return TRUE
.head 7 +  If MTblGetRowLevel( hWndForm, nSelectedRow ) = KHEL_Gruppe
.head 8 -  Set nBet= EnumChildren( nSelectedRow, nFalls )
.head 7 +  Else If MTblGetRowLevel( hWndForm, nSelectedRow ) = KHEL_Bett
.head 8 -  Set nBet= EnumChildren(GetParent( nSelectedRow), nFalls )
.head 7 +  If nBet
.head 8 -  Set i=0
.head 8 +  Loop
.head 9 +  If i >=nBet
.head 10 -  Break
.head 9 +  If nFalls[i]= Fall.dfFall_Key
.head 10 -  Call SalSendMsg(hWndFall, SAM_Close,0,0)
.head 10 -  Return TRUE
.head 9 -  Set i=i+1
.head 5 +  Function: POC_FindCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nCage
.head 7 -  Receive String: sAbtKey
.head 7 -  Receive String: sStatKey
.head 7 -  Receive String: sGrpKey
.head 7 -  Receive Number: hGrp
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  !
.head 7 -  Number: nI
.head 7 -  Number: nCount
.head 7 -  Number: nCageOpen[*]
.head 7 -  FunctionalVar: _oCage
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set nCount = GetOpenCages( nRoot, 0, nCageOpen )
.head 7 -  Set nI = 0
.head 7 +  Loop
.head 8 +  If nI >= nCount
.head 9 -  Break
.head 8 +  If not CheckStatusObj( nCageOpen[nI], CageWithRFID )
.head 9 -  Call _GetPositionID( nCageOpen[nI], _oCage )
.head 9 -  Set sAbtKey = _oCage.sScreen
.head 9 -  Set sStatKey = _oCage.sRack
.head 9 -  Set sGrpKey = _oCage.sCage
.head 9 -  Set hGrp = nCageOpen[nI]
.head 9 -  Set hGrp = GetUniqRowID( hGrp )
.head 9 -  Set nI = nCount
.head 8 -  Set nI = nI + 1
.head 7 -  Return hGrp!=NUMBER_Null
.head 5 +  Function: POC_Open
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Boolean: bOpen
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If hWnd_POC and not SalIsWindowVisible( hWnd_POC )
.head 8 -  Call SalSendMsg( hWnd_POC, 30000, 0, WM_LButtonDblClk )
.head 7 +  If bOpen
.head 8 +  If not SalIsWindowVisible( hWnd_POC )
.head 9 -  Set hWnd_POC = SalCreateWindow( frmPOC, hWndStar2000 )
.head 8 -  Call VisWinShow( hWnd_POC, SHOW_Normal )
.head 7 +  Else
.head 8 -  Call SalSendMsg(hWnd_POC, SAM_Close, 0,0)
.head 8 -  Set hWnd_POC = hWndNULL
.head 5 +  Function: POC_ReaderStatus
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Boolean: bStart
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If not hWnd_POC
.head 8 -  Set hWnd_POC =  SalCreateWindow( frmPOC, hWndStar2000 )
.head 7 +  If bStart
.head 8 -  Call SalSendMsg( hWnd_POC, AM_Start, 0, 0 )
.head 7 +  Else
.head 8 -  Call SalSendMsg( hWnd_POC, AM_Stop, 0, 0 )
.head 5 +  Function: POC_Discharge
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bPOC=TRUE
.head 7 +  If CullingAndDischarge(TRUE)
.head 8 -  Set bPOC=FALSE
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Set bPOC=FALSE
.head 8 -  Return FALSE
.head 5 +  Function: POC_Unregister
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: hCage
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sAbt
.head 7 -  ! String: sStat
.head 7 -  ! String: sGrp
.head 7 -  ! String: sBett
.head 7 -  ! Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: cData
.head 8 -  Class: cPositionData
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call _GetPositionID(hCage,cData)
.head 7 +  If cData = OBJ_Null
.head 8 -  Set bOk = FALSE
.head 7 +  If bOk
.head 8 -  Set bOk = POC_Unreg(cData.nCageID,TRUE)
.head 8 +  If bOk
.head 9 -  Call Refresh(2,cData.nCageID)
.head 9 -  Call SalSendMsg( hWndStar2000, AM_Refresh, 0, 0 )	! Refresh tollbar puchbuttons
.head 9 +  If hWnd_POC
.head 10 +  If VisWinIsWindow ( hWnd_POC )
.head 11 -  ! Call frmPOC.CloseCageFromKHE( cData.sScreen, cData.sRack, cData.sCage )
.head 11 -  Call CloseCage( cData.nScreenID, cData.nRackID, cData.nCageID )
.head 7 -  Return bOk
.head 5 +  Function: POC_FocusObj
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sPlace
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oObj
.head 8 -  Class: cPositionData
.head 7 -  Number: nFocusRow
.head 6 +  Actions
.head 7 -  Set oObj = GetPlaceFormString( sPlace )
.head 7 +  If oObj.nScreenID
.head 8 -  Set nFocusRow = FindObject( nRoot, oObj.nScreenID )
.head 8 +  If nFocusRow!=-1 and oObj.nRackID
.head 9 -  Set nFocusRow = FindObject( nFocusRow, oObj.nRackID )
.head 9 +  If nFocusRow!=-1 and oObj.nCageID
.head 10 -  Set nFocusRow = FindObject( nFocusRow, oObj.nCageID )
.head 7 +  If nFocusRow !=-1
.head 8 -  Call ActivateRow( nFocusRow )
.head 7 -  Return nFocusRow
.head 5 +  Function: POC_ChangePorts
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowOpenCages[*]
.head 7 -  Number: nCountCages
.head 7 -  Number: nI
.head 7 -  Number: nPort
.head 7 -  FunctionalVar: cFECage
.head 8 -  Class: cFERowCage
.head 6 +  Actions
.head 7 -  Set nCountCages = GetOpenCages( nRoot, 0, nRowOpenCages )
.head 7 -  Set nI = 0
.head 7 +  While nI < nCountCages
.head 8 -  Set cFECage = FE_GetInfo( nRowOpenCages[nI] )
.head 8 +  If cFECage.sRFID
.head 9 -  Set nPort = frmPOC.IsCageOpen( cFECage.sRFID )
.head 9 +  If nPort
.head 10 -  Call POC_ShowPort( nRowOpenCages[nI], nPort )
.head 8 -  Set nI = nI + 1
.head 5 -  ! Find  functions
.head 5 +  Function: FindRack
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFtch
.head 6 +  Actions
.head 7 -  Set oGetInfo.sScreen = oPosition.sScreen
.head 7 -  Set oGetInfo.nScreenID = oPosition.nScreenID
.head 7 +  If Not oGetInfo.sScreen
.head 8 -  Call SalMessageBox ('Please, choose Workgroup', 'Searching Rack...', MB_Ok)
.head 8 -  Return FALSE
.head 7 +  If SalModalDialog( dlgKHEItemSearch, hWndForm, 'Rack', oGetInfo.sRack )
.head 8 +  If SqlPrepareAndExecute(hSqlGetInfo, "Select id from station where stat_key=:oGetInfo.sRack into :oGetInfo.nRackID ")
.head 9 -  Call SqlFetchNext( hSqlGetInfo, nFtch )
.head 9 -  Call OpenRack( oGetInfo.nScreenID, oGetInfo.nRackID )
.head 9 -  Return TRUE
.head 5 +  Function: FindCage
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sGrpKey
.head 7 -  ! Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sGrp
.head 7 -  String: sCagePrefix
.head 7 -  Number: nFtch
.head 6 +  Actions
.head 7 -  Set oGetInfo.sScreen = oPosition.sScreen
.head 7 -  Set oGetInfo.sRack = oPosition.sRack
.head 7 -  Set oGetInfo.nScreenID = oPosition.nScreenID
.head 7 -  Set oGetInfo.nRackID = oPosition.nRackID
.head 7 +  If Not oGetInfo.sRack
.head 8 -  Call SalMessageBox ('Please, choose Rack', 'Searching Cage...', MB_Ok)
.head 8 -  Return FALSE
.head 7 -  Set sCagePrefix = SalStrRightX ( oGetInfo.sRack, 4 )
.head 7 +  If SalModalDialog( dlgKHEItemSearch, hWndForm, 'Cage (Prefix: ' || sCagePrefix || ')', oGetInfo.sCage )
.head 8 +  If SqlPrepareAndExecute(hSqlGetInfo, "Select id from gruppe where gruppe_key=:oGetInfo.sCage and rack_id=:oGetInfo.nRackID into :oGetInfo.nCageID ")
.head 9 -  Call SqlFetchNext( hSqlGetInfo, nFtch )
.head 9 -  Call OpenCage( oGetInfo.nScreenID, oGetInfo.nRackID, oGetInfo.nCageID )
.head 9 -  Return TRUE
.head 5 +  Function: FindAnimal
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  ! String: sAbtKey
.head 7 -  ! String: sStatKey
.head 7 -  ! String: sGrpKey
.head 7 -  ! Boolean: bForceScan
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sFallKey
.head 6 +  Actions
.head 7 +  If SalModalDialog( dlgKHEItemSearch, hWndForm, 'Animal ID', sFallKey )
.head 8 -  Return SalSendMsg( frmAtlantaMain, AM_KHE_GotoBedByFall, 0, GalSetAsWinMsgLParam_Number( SalStrToNumber( sFallKey ) ) )
.head 5 -  ! Cut&Paste 
.head 5 +  Function: CanCutRack
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nScrCheck
.head 7 -  Sql Handle: hSqlCages
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 +  If nSelectedLevel = KHEL_Station
.head 8 +  If SqlCreateStatement( hSesionFE , hSqlCages ) 
.head 9 +  If SqlPrepareAndExecute( hSqlCages, "select distinct f.LAST_SCR_ID
from 	 fall f 
 join gruppe g on (f.last_cage_id=g.id)
where
   g.rack_id=:oPosition.nRackID
   and      f.LAST_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
   and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
into :nScrCheck
 " )
.head 10 -  Set bOk = FALSE
.head 10 +  While not bOk and SqlFetchNext( hSqlCages, nFetch )
.head 11 -  Set bOk = (nScrCheck = oPosition.nScreenID)
.head 9 -  Call SqlDisconnect( hSqlCages )
.head 8 +  Else
.head 9 -  Set bOk = FALSE
.head 7 +  Else
.head 8 -  Set bOk = FALSE
.head 7 -  Return bOk
.head 5 -  ! plan bewegung
.head 5 +  Function: FE_Plan2Real_Bew
.head 6 -  Description: Does InsertBewegung4Plan()
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey_Parm
.head 7 -  Number: nBewPlanNr_Parm
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nBewNr_Real
.head 7 -  !
.head 7 -  Number: nI
.head 7 -  Number: nRowA
.head 7 -  Number: nRowInFocus
.head 6 +  Actions
.head 7 +  ! If GalConnect(hSqlSelFall)
.head 8 +  If SqlPrepareAndExecute( hSqlSelFall, "select LAST_CAGE_ID from fall where fall_key=:nFallKey_Parm into :nFindCage " )
.head 9 -  If SqlFetchNext( hSqlSelFall, nFetch )
.head 8 -  Call SqlDisconnect( hSqlSelFall )
.head 7 -  Set nI = 0
.head 7 -  Set nRowInFocus = GetUniqRowID( nSelectedRow )
.head 7 -  Set nRowA = 0
.head 7 +  While nI < oHandleSelect.nIndex and not nRowA
.head 8 +  If nFallKey_Parm = GetIdObject(GetRowID(oHandleSelect.nRow[nI]))
.head 9 -  Set nRowA = GetParent( GetRowID(oHandleSelect.nRow[nI]) )
.head 9 +  If nRowA > -1
.head 10 -  Call oRefreshCages.AddRow( nRowA )
.head 8 -  Set nI = nI + 1
.head 7 -  Call oRefreshCages.AddRow( nSelectedRow )
.head 7 -  Set nBewNr_Real = InsertBewegung4Plan( nFallKey_Parm,  nBewPlanNr_Parm )
.head 7 +  ! If nBewNr_Real > 0 and nRowA
.head 8 -  ! Call Refresh( 8, 0 )
.head 8 -  ! Call Refresh( 2, nFindCage )
.head 8 +  If MTblIsParentRow( hWndForm, nRowA )
.head 9 -  Call PopulateCage( nRowA, TRUE )
.head 9 -  Call MTblExpandRow( hWndForm, nRowA, MTCR_BY_USER )
.head 8 +  Else 
.head 9 -  Call PopulateCage( nRowA, FALSE )
.head 7 -  Return nBewNr_Real
.head 5 +  Function: FE_PlanMove
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 -  Actions
.head 5 +  Function: Can_FE_PlanMove
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bOk = (nSelectedLevel = FEL_Rack)
.head 7 -  Set bOk = bOk and CheckStatusObj(nSelectedRow, RackIsVirtual)
.head 7 -  Return bOk
.head 5 +  Function: FE_PlanMating
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nI
.head 7 -  Number: nJ
.head 7 -  Number: nA
.head 7 -  String: sExp
.head 7 -  String: sExpRec
.head 7 -  String: sExpTemp
.head 7 -  FunctionalVar: oCageEmpty[*]
.head 8 -  Class: cPositionData
.head 7 -  FunctionalVar: oAnimal
.head 8 -  Class: cPositionData
.head 7 -  Number: nFtch
.head 7 -  Number: nVirtFallKey
.head 7 -  Number: nAEBewNr
.head 7 -  Number: nNewLstErfNr
.head 7 -  Number: nBEwNr
.head 7 -  String: sTarif
.head 7 -  Boolean: bExists
.head 7 -  Boolean: bNotInLicence
.head 7 -  Boolean: bSeveralLicence
.head 7 -  Number: nRetMsg
.head 7 -  Number: nRowSel
.head 7 -  String: sVal[1]
.head 7 -  Number: nRowFullCages[*]
.head 7 -  Boolean: bClearSelectAnimals
.head 7 -  Number: nMale[*]
.head 7 -  Number: nFemale[*]
.head 7 -  Number: nAnimals[*]
.head 7 -  Number: nCountF
.head 7 -  Number: nCountM
.head 7 -  Number: nCountCages
.head 7 -  Number: nCountEmptyCages
.head 7 -  FunctionalVar: oCageOpen
.head 8 -  Class: cFERow
.head 7 -  String: sStrNull
.head 7 -  Date/Time: dtPlanMating
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Sql Handle: hSql_LT
.head 7 -  Number: nLT
.head 7 -  String: sStorn
.head 7 -  Number: nNR_Detail
.head 6 +  Actions
.head 7 -  Set bOk = Can_FE_PlanMating(nFem)
.head 7 -  Set bClearSelectAnimals = FALSE
.head 7 -  Set bNotInLicence = FALSE
.head 7 -  Set bSeveralLicence = FALSE
.head 7 -  ! Check experiment
.head 7 +  If bOk
.head 8 -  Set nI = 0
.head 8 -  Set nJ = 0
.head 8 +  If oHandleSelect.nIndex > 0
.head 9 +  While nI < oHandleSelect.nIndex and not bSeveralLicence
.head 10 +  If sExp = STRING_Null
.head 11 -  Set nRowSel = GetRowID(oHandleSelect.nRow[nI])
.head 11 -  Set sExp = GetSValue(nRowSel , "EXP")
.head 11 +  If sExp = STRING_Null
.head 12 -  Set bOk = FALSE
.head 12 -  Set bNotInLicence = TRUE
.head 11 +  Else
.head 12 -  Set sExpTemp = sExp
.head 10 +  Else
.head 11 -  Set nRowSel = GetRowID(oHandleSelect.nRow[nI])
.head 11 -  Set sExp = GetSValue(nRowSel , "EXP")
.head 11 +  If sExpTemp != STRING_Null and sExpTemp != sExp and sExp != STRING_Null
.head 12 -  Set bOk = FALSE
.head 12 -  Set bNotInLicence = FALSE
.head 12 -  Set bSeveralLicence = TRUE
.head 11 +  Else If sExp = STRING_Null
.head 12 -  Set bOk = FALSE
.head 12 -  Set bNotInLicence = TRUE
.head 10 -  Set nI = nI + 1
.head 8 +  Else
.head 9 -  Call oHandleSelect.ReInit(  )
.head 9 -  Set nCountCages = GetOpenCages(GetParent(nSelectedRow), CageIsFull,nRowFullCages )
.head 9 +  While nJ < nCountCages and not bSeveralLicence
.head 10 -  ! Set nA = nRowFullCages[nI]
.head 10 -  Set nA = GetFirstChildRow(nRowFullCages[nJ])
.head 10 +  Loop
.head 11 +  If nA = TBL_Error
.head 12 -  Break
.head 11 +  If GetIdObject(nA) != -100
.head 12 -  Set nRowSel = nA
.head 12 +  If sExp = STRING_Null
.head 13 -  Set sExp = GetSValue(nRowSel , "EXP")
.head 13 +  If sExp = STRING_Null
.head 14 -  Set bOk = FALSE
.head 14 -  Set bNotInLicence = TRUE
.head 14 -  Call oHandleSelect.SelectRow( GetUniqRowID(nRowSel), GetSValue(nRowSel , "SEX") )
.head 13 +  Else
.head 14 -  Set sExpTemp = sExp
.head 12 +  Else
.head 13 -  Set sExp = GetSValue(nRowSel , "EXP")
.head 13 +  If sExpTemp != STRING_Null and sExpTemp != sExp and sExp != STRING_Null
.head 14 -  Set bOk = FALSE
.head 14 -  Set bNotInLicence = FALSE
.head 14 -  Set bSeveralLicence = TRUE
.head 13 +  Else If sExp = STRING_Null
.head 14 -  Set bOk = FALSE
.head 14 -  Set bNotInLicence = TRUE
.head 14 -  Call oHandleSelect.SelectRow( GetUniqRowID(nRowSel), GetSValue(nRowSel , "SEX") )
.head 11 -  Set nA = GetNextChildRow(nA)
.head 10 -  Set nJ = nJ + 1
.head 9 -  Set bClearSelectAnimals = TRUE
.head 9 +  If not bOk and not bNotInLicence
.head 10 -  Call oHandleSelect.ReInit(  )
.head 10 -  Set bClearSelectAnimals = FALSE
.head 8 +  If not bOk
.head 9 +  If bNotInLicence
.head 10 -  Set bFreezeRefresh = TRUE
.head 10 +  If sExpTemp = STRING_Null
.head 11 -  Set nMsgBtn1 = 5014
.head 11 -  Set nMsgBtn2 = 5015
.head 11 -  Set nMsgBtn3 = 10003
.head 11 -  Set nRetMsg = GalMessageBox(D_GetMessageStatic( 11075 ), D_GetMessageStatic_w_Nr( 11078,1 ), MB_UserButtons3)
.head 11 +  If nRetMsg = IDYES
.head 12 +  If SqlPrepareAndExecute( hSqlPopulate , "select EXPERIMENT_KEY from experiment where EXP_SIGNED_P2=3
into :sExp " )
.head 13 -  If SqlFetchNext( hSqlPopulate, nJ )
.head 13 +  Else
.head 14 -  Set nRetMsg = IDCANCEL
.head 12 +  Else
.head 13 -  Set nRetMsg = IDCANCEL
.head 10 +  Else
.head 11 -  Set nMsgBtn1 = 10004
.head 11 -  Set nMsgBtn2 = 10003
.head 11 -  Set sVal[0] = sExpTemp
.head 11 -  Set nRetMsg = GalMessageBox(D_GetMessageStatic( 11075 ), D_GetMessageFull(11078,2,sVal  ) , MB_UserButtons2)
.head 11 -  Set sExp = sExpTemp
.head 10 +  If nRetMsg = IDYES or nRetMsg = IDOK
.head 11 +  If SqlPrepareAndExecute(hSqlPopulate, " select	ORD_CODE, ORD_DESC||'('||SPECIES||')'
into :sExpRec
from	EXP_SPECIES e
where	EXPERIMENT_KEY = :sExp and STATUS='1'
and NOT exists (select e1.ORD_CODE
	from EXP_SPECIES e1 
	where e.EXPERIMENT_KEY=e1.EXPERIMENT_KEY and e.ORD_CODE||'.1' = e1.ORD_CODE and e1.STATUS='1')")
.head 12 +  If SqlFetchNext( hSqlPopulate, nJ )
.head 13 -  Set bOk = Cage2Experiment(sExp, sExpRec )
.head 12 +  Else
.head 13 -  Set nRetMsg = IDCANCEL
.head 11 +  Else
.head 12 -  Set nRetMsg = IDCANCEL
.head 10 +  Else If nRetMsg = IDNO
.head 11 -  Set bOk = Cage2Experiment("","" )
.head 11 -  Set nRowSel = GetRowID(oHandleSelect.nRow[0])
.head 11 -  Set nVirtFallKey = GetIdObject( nRowSel )
.head 11 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select experiment_key from fall_experiment where fall_key=:nVirtFallKey and end_date is null into :sExp")
.head 11 -  Set bOk = bOk and SqlFetchNext( hSqlPopulate, nJ )
.head 10 +  Else If nRetMsg = IDCANCEL
.head 11 -  Set bOk = FALSE
.head 10 -  Set bFreezeRefresh = FALSE
.head 10 +  If bClearSelectAnimals
.head 11 -  Call oHandleSelect.ReInit(  )
.head 10 -  ! Set bOk = FALSE
.head 9 +  Else
.head 10 -  Call T_MessageBox_Static(10015,5012,MB_Ok) 
.head 7 +  If bOk
.head 8 -  Set bPlanDate = TRUE
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, 'UE', dtPlanMating, sGrund1, sGrund2 )
.head 9 -  Set bOk = FALSE
.head 8 -  Set bPlanDate = FALSE
.head 7 +  If bOk
.head 8 -  Call GetVirtFallKey4Experiment( sExp, nVirtFallKey, nAEBewNr )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulate, "select TARIF_KEY from leistung
where LA_KEY = 'AL'
and LST_KEY = 'MATING'
into :sTarif")
.head 8 -  Set bOk = bOk and SqlFetchNext( hSqlPopulate, nFtch )
.head 8 -  Call oRefreshCages.Init(  )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateP , "select g.id, g.stat_key, g.gruppe_key
from  abt_stat a, gruppe g, STATION s
where  a.scr_id = :oPosition.nScreenID
and	a.rack_ID = s.ID
and 	s.ID = g.RACK_ID
and	s.VIRTUAL = 'J'

and not EXISTS(select	 f.LAST_CAGE_ID
from  fall f
where	     	f.last_CAGE_ID = g.ID
	 and       f.last_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
) 
 and	g.gruppe_KEY not in (select	 bl.gruppe_KEY
				from  BETT_LOCKS bl
   				where	      g.gruppe_KEY=bl.gruppe_KEY
   					 and       (bl.bis>@NOW or bl.bis is null  )
)
into :oCageEmpty[nA].nCageID, :oCageEmpty[nA].sRack, :oCageEmpty[nA].sCage
" )
.head 8 -  ! Set sStrNull = STRING_Null
.head 8 -  ! Set bOk = bOk and SqlSetParameter ( hSqlPopulateP, DBP_PRESERVE, TRUE, sStrNull )
.head 8 +  If oHandleSelect.bAnySelects
.head 9 -  Set nA = 0
.head 9 +  If SqlFetchNext( hSqlPopulateP, nFtch )
.head 10 -  Set oCageEmpty[nA].nScreenID = oPosition.nScreenID
.head 10 -  Set oCageEmpty[nA].sScreen= oPosition.sScreen
.head 10 -  Set nI = 0
.head 10 -  Call LockSysadmAction("Plan service(MATING)...")
.head 10 -  ! ! Start Logical Transaction here/ Get new LT number.
.head 10 -  Set nLT = LT_GetNumOfNewTransaction()
.head 10 -  Call SqlConnect(hSql_LT)
.head 10 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT ,"Insert into LT ( NR, USER_ID, TYPE, STATUS, START, END) values (:nLT, :nUserId, 10, 1, @NOW, @NOW) ")
.head 10 -  ! Set nNewLstErfNr = InsertAdminLstErf( nVirtFallKey, nAEBewNr, sTarif, "MATING", 'AL', dtPlanMating )
.head 10 -  Set nNewLstErfNr = InsertAdminLstErfX( nVirtFallKey, nAEBewNr, sTarif, "MATING", 'AL', dtPlanMating, hSql_LT, nLT)
.head 10 +  If nNewLstErfNr = 0
.head 11 -  Set bOk = FALSE
.head 10 -  Set oCageEmpty[nA].nPosID =  1
.head 10 +  While nI < oHandleSelect.nIndex and bOk
.head 11 -  Call _GetPositionID( GetRowID(oHandleSelect.nRow[nI]), oAnimal )
.head 11 -  Call oRefreshCages.AddRow( GetParent( GetRowID(oHandleSelect.nRow[nI])) )
.head 11 -  ! Set nBEwNr = Bewegung_DoInsertPlan("SYSADM", nEinrichtId, oAnimal.nAnimalID,0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1)
.head 11 -  Set nBEwNr = Bewegung_DoInsertPlanX2("SYSADM", nEinrichtId, oAnimal.nAnimalID,0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1, hSql_LT, nLT)
.head 11 -  ! Call PlanedMovement_InsAdmAction(nVirtFallKey,nNewLstErfNr,oAnimal.nAnimalID, nBEwNr, 'Plan2Real_Bew')
.head 11 -  Set bOk = bOk And PlanedMovement_InsAdmActionX(nVirtFallKey,nNewLstErfNr,oAnimal.nAnimalID, nBEwNr, 'Plan2Real_Bew', hSql_LT, nLT)
.head 11 -  Set oCageEmpty[nA].nPosID =  oCageEmpty[nA].nPosID+1
.head 11 -  Set nI = nI + 1
.head 10 +  If SqlExists ("Select * from LST_ADM_TODO_ITEMS where LST_ERF_NR = :nNewLstErfNr  ", bExists)
.head 11 +  If not bExists
.head 12 -  ! ! ! ! Logging "Update LST_ERF" - save values before update into LT journal - 1 record will be updated
.head 12 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
select  	STORNIERT
from 	LST_ERF
where 	LST_ERF_NR = :nNewLstErfNr
and 	EINRICHT_ID = :nEinrichtId
and 	FALL_KEY = :nVirtFallKey
into 	:sStorn
" )
.head 12 +  If SqlFetchNext( hSql_LT, nFtch )
.head 13 -  Set bOk =bOk And  SqlPrepareAndExecute( hSql_LT, "
select 	@nullvalue(max(NR)+1,1)
from 	LT_DETAIL
where 	LT_NR=:nLT into :nNR " )
.head 13 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql_LT, nLT, 'LST_ERF', 'U')
.head 13 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
insert	into LT_VALUES (ID, NAME, VALS, KEY1,KEY2,KEY3 )
values	(:nNR_Detail, 'STORNIERT LST_ERF', :sStorn,  :nEinrichtId,  :nVirtFallKey, :nNewLstErfNr )" )
.head 13 -  ! end of log
.head 12 -  Set bOk = bOk and SqlPrepareAndExecute( hSql_LT ,"
	Update 	LST_ERF
	set 	STORNIERT = 'J'
	where 	LST_ERF_NR = :nNewLstErfNr
	and 	EINRICHT_ID = :nEinrichtId
	and 	FALL_KEY = :nVirtFallKey ")
.head 10 +  If bOk
.head 11 -  Call SqlCommit( hSqlPopulateP )
.head 11 -  Call SqlCommit( hSql_LT )
.head 10 +  Else
.head 11 -  Call SqlPrepareAndExecute( hSqlPopulateP, "rollback" )
.head 11 -  Call SqlPrepareAndExecute( hSql_LT, "rollback" )
.head 10 -  Call SqlDisconnect(hSql_LT)
.head 10 +  If bOk
.head 11 -  Set bNotNeedPrintCageCard = TRUE
.head 11 -  Call RefreshCages(  )
.head 11 -  Call UnSelectAll(  )
.head 11 -  Set bNotNeedPrintCageCard = FALSE
.head 11 -  Call Refresh(10,0)
.head 11 -  Call Rack2DView_RefreshCageContents("")
.head 8 +  Else
.head 9 -  Call LockSysadmAction("Plan service(MATING)...")
.head 9 -  Set nA = 0
.head 9 +  While bOk and SqlFetchNext( hSqlPopulateP, nFtch )
.head 10 -  Set nA = nA + 1
.head 9 -  Set nCountEmptyCages = nA
.head 9 -  Set nA = 0
.head 9 -  Set nJ = 0
.head 9 -  Set nCountF = 0
.head 9 -  Set nCountM = 0
.head 9 +  While nJ < nCountCages
.head 10 -  Call oRefreshCages.AddRow( nRowFullCages[nJ] )
.head 10 -  Set oCageOpen = FE_GetInfo( nRowFullCages[nJ] )
.head 10 +  If oCageOpen.GetNValue( "SEX" ) = 1
.head 11 -  Set nA = EnumChildren(nRowFullCages[nJ], nAnimals)
.head 11 -  Set nI = 0
.head 11 +  While nI < nA
.head 12 -  Set nFemale[nCountF] = nAnimals[nI]
.head 12 -  Set nCountF = nCountF + 1
.head 12 -  Set nI = nI + 1
.head 10 +  Else If oCageOpen.GetNValue( "SEX" ) = 2
.head 11 -  Set nA = EnumChildren(nRowFullCages[nJ], nAnimals)
.head 11 -  Set nI = 0
.head 11 +  While nI < nA
.head 12 -  Set nMale[nCountM] = nAnimals[nI]
.head 12 -  Set nCountM = nCountM + 1
.head 12 -  Set nI = nI + 1
.head 10 -  Set nJ = nJ+ 1
.head 9 -  Set nI = 0
.head 9 -  Set nJ = 0
.head 9 -  Set nA = 0
.head 9 -  Set nLT = LT_GetNumOfNewTransaction()
.head 9 -  Call SqlConnect(hSql_LT)
.head 9 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT ,"Insert into LT ( NR, USER_ID, TYPE, STATUS, START, END) values (:nLT, :nUserId, 10, 1, @NOW, @NOW) ")
.head 9 +  While bOk and nA < nCountEmptyCages and nI < nCountF and nJ < nCountM
.head 10 -  ! Set nNewLstErfNr = InsertAdminLstErf( nVirtFallKey, nAEBewNr, sTarif, "MATING", 'AL', dtPlanMating )
.head 10 -  Set nNewLstErfNr = InsertAdminLstErfX( nVirtFallKey, nAEBewNr, sTarif, "MATING", 'AL', dtPlanMating, hSql_LT, nLT )
.head 10 +  If nNewLstErfNr = 0
.head 11 -  Set bOk = FALSE
.head 10 -  Set oCageEmpty[nA].nPosID =  1
.head 10 -  Set oCageEmpty[nA].nScreenID = oPosition.nScreenID
.head 10 -  Set oCageEmpty[nA].sScreen= oPosition.sScreen
.head 10 +  If nI < nCountF and nJ < nCountM and bOk
.head 11 -  ! Set nBEwNr = Bewegung_DoInsertPlan("SYSADM", nEinrichtId, nMale[nJ],0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1)
.head 11 -  Set nBEwNr = Bewegung_DoInsertPlanX2("SYSADM", nEinrichtId, nMale[nJ],0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1, hSql_LT, nLT)
.head 11 +  If nBEwNr = 0
.head 12 -  Set bOk = FALSE
.head 11 -  ! Call PlanedMovement_InsAdmAction(nVirtFallKey,nNewLstErfNr,nMale[nJ], nBEwNr, 'Plan2Real_Bew')
.head 11 -  Set bOk = bOk And  PlanedMovement_InsAdmActionX(nVirtFallKey,nNewLstErfNr,nMale[nJ], nBEwNr, 'Plan2Real_Bew', hSql_LT, nLT)
.head 11 -  Set oCageEmpty[nA].nPosID =  oCageEmpty[nA].nPosID+1
.head 11 -  Set nJ= nJ + 1
.head 11 -  ! Set nBEwNr = Bewegung_DoInsertPlan("SYSADM", nEinrichtId, nFemale[nI],0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1)
.head 11 -  Set nBEwNr = Bewegung_DoInsertPlanX2("SYSADM", nEinrichtId, nFemale[nI],0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1, hSql_LT, nLT)
.head 11 -  ! Call PlanedMovement_InsAdmAction(nVirtFallKey,nNewLstErfNr,nFemale[nI], nBEwNr, 'Plan2Real_Bew')
.head 11 -  Set bOk = bOk And  PlanedMovement_InsAdmActionX(nVirtFallKey,nNewLstErfNr,nFemale[nI], nBEwNr, 'Plan2Real_Bew', hSql_LT, nLT)
.head 11 -  Set oCageEmpty[nA].nPosID =  oCageEmpty[nA].nPosID+1
.head 11 -  Set nI= nI + 1
.head 11 +  If nFem =1
.head 12 -  ! Set nBEwNr = Bewegung_DoInsertPlan("SYSADM", nEinrichtId, nFemale[nI],0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1)
.head 12 -  Set nBEwNr = Bewegung_DoInsertPlanX2("SYSADM", nEinrichtId, nFemale[nI],0, dtPlanMating, "UE", sGrund1,sGrund2,
			oCageEmpty[nA].sScreen,oCageEmpty[nA].sRack, oCageEmpty[nA].sCage, SalNumberToStrX(oCageEmpty[nA].nPosID, 0), 1,  hSql_LT, nLT)
.head 12 -  ! Call PlanedMovement_InsAdmAction(nVirtFallKey,nNewLstErfNr,nFemale[nI], nBEwNr, 'Plan2Real_Bew')
.head 12 -  Set bOk = bOk And PlanedMovement_InsAdmActionX(nVirtFallKey,nNewLstErfNr,nFemale[nI], nBEwNr, 'Plan2Real_Bew', hSql_LT, nLT)
.head 12 -  Set oCageEmpty[nA].nPosID =  oCageEmpty[nA].nPosID+1
.head 12 -  Set nI= nI + 1
.head 10 +  If SqlExists ("Select * from LST_ADM_TODO_ITEMS where LST_ERF_NR = :nNewLstErfNr  ", bExists)
.head 11 +  If not bExists
.head 12 -  ! ! ! ! Logging "Update LST_ERF" - save values before update into LT journal - 1 record will be updated
.head 12 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
select  	STORNIERT
from 	LST_ERF
where 	LST_ERF_NR = :nNewLstErfNr
and 	EINRICHT_ID = :nEinrichtId
and 	FALL_KEY = :nVirtFallKey
into 	:sStorn
" )
.head 12 +  If SqlFetchNext( hSql_LT, nFtch )
.head 13 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql_LT, nLT, 'LST_ERF', 'U')
.head 13 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
insert	into LT_VALUES (ID, NAME, VALS, KEY1,KEY2,KEY3 )
values	(:nNR_Detail, 'STORNIERT LST_ERF', :sStorn,  :nEinrichtId,  :nVirtFallKey, :nNewLstErfNr )" )
.head 13 -  ! end of log
.head 12 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulateC ,"Update LST_ERF
		set STORNIERT = 'J'
		where LST_ERF_NR = :nNewLstErfNr
		and EINRICHT_ID = :nEinrichtId
		and FALL_KEY = :nVirtFallKey ")
.head 10 -  Set nA = nA + 1
.head 9 -  ! Call SqlPrepareAndExecute( hSql_LT, "Rollback" )
.head 9 +  If bOk
.head 10 -  Call SqlCommit( hSqlPopulateP )
.head 10 -  Call SqlCommit( hSql_LT )
.head 9 +  Else
.head 10 -  Call SqlPrepareAndExecute( hSqlPopulateP, "rollback" )
.head 10 -  Call SqlPrepareAndExecute( hSql_LT, "rollback" )
.head 9 -  Call SqlDisconnect(hSql_LT)
.head 9 +  If bOk
.head 10 -  Call oHandleSelect.ReInit(  )
.head 10 -  Set bNotNeedPrintCageCard = TRUE
.head 10 -  Call RefreshCages(  )
.head 10 -  Set bNotNeedPrintCageCard = FALSE
.head 10 -  Call Refresh(10,0)
.head 10 -  Call Rack2DView_RefreshCageContents("")
.head 8 -  Call LockSysadmAction("...service planned")
.head 5 +  Function: Can_FE_PlanMating
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nI
.head 7 -  String: sSex
.head 7 -  Number: nCountAnimal
.head 7 -  Number: nCageId
.head 7 -  Number: nFetch
.head 7 -  Number: nCountW
.head 7 -  Number: nCountM
.head 7 -  Number: nPrevCageId
.head 7 -  String: sPrevSex
.head 7 -  Number: nBound
.head 7 -  Boolean: bStockMale
.head 7 -  Boolean: bStockFeMale
.head 7 -  FunctionalVar: cRowCheck
.head 8 -  Class: cFERowRack
.head 6 +  Actions
.head 7 -  Set bOk = (nSelectedLevel = FEL_Rack)
.head 7 +  If bOk
.head 8 -  Set cRowCheck = FE_GetInfo( nSelectedRow )
.head 8 -  Set bOk = bOk and cRowCheck.GetState( RackIsVirtual ) and cRowCheck.GetNValue( "EMPTY" ) > 0
.head 7 -  ! Set bOk = bOk and CheckStatusObj(nSelectedRow, RackIsVirtual)
.head 7 +  If bOk 
.head 8 +  If oHandleSelect.nIndex>0
.head 9 -  Set bOk = bOk and (oHandleSelect.nCountFemales = nFem + 1 and oHandleSelect.nCountMales = 1)
.head 9 -  Set nI = 0
.head 9 +  While nI < oHandleSelect.nIndex and bOk
.head 10 +  If CheckStatusObj(GetRowID(oHandleSelect.nRow[nI]), AnimalInPlanBew)
.head 11 -  Set bOk = FALSE
.head 10 -  Set nI = nI + 1
.head 8 +  Else
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate,"select bp.*
 from " || sUserName || ".t_cage t
join fall f on (f.last_cage_id=t.id and f.last_scr_id=t.scr_id)
join bewegung_plan bp on (bp.einricht_id=f.einricht_id and bp.fall_key=f.fall_key)
where f.geloescht='N'")
.head 9 +  If SqlFetchNext( hSqlPopulate, nFetch )
.head 10 -  Set bOk = FALSE
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate , "select *
  from " || sUserName || ".t_cage t
       join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null and f.culling_id is null),
   relship_fall rf
where
       rf.einricht_id=f.einricht_id
and rf.fall_key=f.fall_KEY
and rf.FALLROLLE_KEY='MATE'
and ( (@Nullvalue(rf.RS_FALL_VALID, 01.01.2500)>@Now)
      or rf.plugged is not null
      or exists (select lc.litter_id from litter_child lc, litter l
                                         where l.place_relship_id=rf.relship_id
                                             and l.FAMILY_RELSHIP_ID in (select r2.relship_id from relship_fall r2
                                                                                                         where r2.einricht_id = f.einricht_id and r2.fall_key = f.fall_key and r2.fallrolle_key = 'PARENT')
                                             and lc.litter_id=l.litter_id and lc.fall_key is null and lc.dead=0
                                             and (lc.LITTER_REASON !='MISS' or lc.LITTER_REASON is null)
                                             and @NULLVALUE(l.miss, 0) = 0 )
     or exists(select kk.place_relship_id from litter kk , relship_fall rf2
                                          where kk.place_relship_id=rf.relship_id
                                              and not exists(select  lc.litter_id from litter_child lc where lc.litter_id=kk.litter_id )
		                              and rf2.relship_id = kk.FAMILY_RELSHIP_ID
                                              and rf2.einricht_id=f.einricht_id and rf2.fall_key=f.fall_key)
      
)")
.head 9 -  Set bOk = bOk and not SqlFetchNext( hSqlPopulate , nFetch )
.head 9 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate , "select t.id, f.geschl,  count(f.fall_key) - count(f.culling_id) 
  from " || sUserName || ".t_cage t
     left  join fall f on ( f.last_cage_id = t.id  and f.geloescht = 'N' and f.ee_datum is null and f.culling_id is null )
group by 1,2
having  count(f.fall_key)-count(f.culling_id)>0
order by 1, 3 desc,  2
into :nCageId, :sSex, :nCountAnimal  ")
.head 9 -  Set nPrevCageId= 0
.head 9 -  Set sPrevSex = ""
.head 9 -  Set nCountW = 0
.head 9 -  Set nCountM = 0
.head 9 -  Set nBound = 0
.head 9 +  While bOk and SqlFetchNext(hSqlPopulate, nFetch)
.head 10 +  If nPrevCageId!=nCageId
.head 11 -  Set nPrevCageId=nCageId
.head 11 -  Set sPrevSex = sSex
.head 11 -  Set bStockMale = (nCountM> 0 and nCountW=0) or bStockMale
.head 11 -  Set bStockFeMale =(nCountW> 0 and nCountM=0) or bStockFeMale
.head 11 -  Set bOk = bOk and not(nCountW> 0 and nCountM>0)
.head 11 +  If bOk
.head 12 -  Set nBound = nBound + nCountW
.head 11 -  Set nCountW = 0
.head 11 -  Set nCountM = nCountW
.head 10 +  If sSex = 'M' 
.head 11 -  Set nCountM = nCountAnimal
.head 10 +  Else
.head 11 -  Set nCountW = nCountAnimal
.head 9 -  Set bStockMale = (nCountM> 0 and nCountW=0) or bStockMale
.head 9 -  Set bStockFeMale =(nCountW> 0 and nCountM=0) or bStockFeMale
.head 9 -  Set bOk = bOk and not(nCountW> 0 and nCountM>0)
.head 9 +  If bOk
.head 10 -  Set nBound = nBound + nCountW
.head 9 -  Set bOk = bOk and bStockMale and bStockFeMale and (nBound - nFem ) > 0
.head 7 -  Return bOk
.head 5 +  Function: GetVirtFallKey4Experiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spExperiment
.head 7 -  Receive Number: nrpVirtFallKey
.head 7 -  Receive Number: nrpBewNr
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If Not spExperiment
.head 8 -  Return FALSE
.head 7 -  Set nrpVirtFallKey = Experiment_VirtualCaseX( spExperiment )
.head 7 +  If nrpVirtFallKey = 0
.head 8 -  Return FALSE
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlPopulateC , "
select bew_nr
 from bewegung b
where	b.EINRICHT_ID = :nEinrichtId
   and	b.FALL_KEY = :nrpVirtFallKey
into	:nrpBewNr
" )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSqlPopulateC, nFetch )
.head 7 +  If Not bOk
.head 8 -  Set nrpVirtFallKey = 0
.head 8 -  Set nrpBewNr = 0
.head 7 -  Return bOk
.head 5 +  Function: InsertAdminLstErf
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Number: nBewNr_AE
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  String: sLAKey
.head 7 -  Date/Time: dtLstErfVon
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewLstErf
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlPopulateC, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY = :nFallKey
into	:nNewLstErf " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSqlPopulateC, nFetch )
.head 7 +  If Not bOk And nFetch = FETCH_EOF
.head 8 -  Set nNewLstErf = 1
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk And Not nNewLstErf
.head 8 -  Set nNewLstErf = 1
.head 7 -  !
.head 7 +  If nNewLstErf
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSqlPopulateC, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR,
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY,
	Lst_Erf_VON,
	MENGE, STATISTIK, PRZ,
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID,
	FKT, BEW_NR, DONE )
 values (	:nEinrichtId, :nFallKey , :nNewLstErf , SYSDATETIME,
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', :nUserId, 1, :nBewNr_AE , 0 ) " )
.head 8 -  Set bOk = bOk And SqlCommit( hSqlPopulateC )
.head 8 +  If Not bOk
.head 9 -  Call SqlPrepareAndExecute( hSql, 'rollback' )
.head 9 -  Set nNewLstErf = 0
.head 7 -  Return nNewLstErf
.head 5 +  Function: InsertAdminLstErfX
.head 6 -  Description: performs InsertAdminLstErf with logging into LT tables and without Commit, as part of indivisible set of actions within one transaction
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Number: nBewNr_AE
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  String: sLAKey
.head 7 -  Date/Time: dtLstErfVon
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nLT
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewLstErf
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nNR
.head 7 -  Number: nNR_Detail
.head 6 +  Actions
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY = :nFallKey
into	:nNewLstErf " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 7 +  If Not bOk And nFetch = FETCH_EOF
.head 8 -  Set nNewLstErf = 1
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk And Not nNewLstErf
.head 8 -  Set nNewLstErf = 1
.head 7 -  !
.head 7 +  If nNewLstErf
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR,
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY,
	Lst_Erf_VON,
	MENGE, STATISTIK, PRZ,
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID,
	FKT, BEW_NR, DONE )
 values (	:nEinrichtId, :nFallKey , :nNewLstErf , SYSDATETIME,
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', :nUserId, 1, :nBewNr_AE , 0 ) " )
.head 8 -  ! Logging
.head 8 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql, nLT, 'LST_ERF', 'I')
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert	into LT_VALUES (ID, NAME, KEY1, KEY2, KEY3 )
values	(:nNR_Detail, 'insert into LS_ERF', :nEinrichtId, :nFallKey , :nNewLstErf )" )
.head 8 -  ! end of log
.head 8 +  If Not bOk
.head 9 -  Set nNewLstErf = 0
.head 7 -  Return nNewLstErf
.head 5 +  Function: Experiment_VirtualCaseX
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number: nFallKey
.head 6 +  Parameters
.head 7 -  String: sExperimentKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFetch
.head 7 -  !
.head 7 -  Number: nFallKey
.head 6 +  Actions
.head 7 +  If SqlPrepareAndExecute( hSqlPopulateP , "
select max( e.FALL_KEY )
from FALL_EXPERIMENT e, FALL f, VIS_KAT v
where e.EINRICHT_ID = 1
 and e.EXPERIMENT_KEY = :sExperimentKey
 and f.EINRICHT_ID = e.EINRICHT_ID
 and f.FALL_KEY = e.FALL_KEY
 and v.VIS_KAT_KEY = f.VIS_KAT_KEY
 and v.PATIENT = 'N'
into :nFallKey
" )
.head 8 -  Call SqlFetchNext( hSqlPopulateP, nFetch )
.head 7 -  Return nFallKey
.head 5 +  Function: PlanedMovement_InsAdmAction
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npVirtFallKey
.head 7 -  Number: npNewLstErfNr
.head 7 -  Number: npFallKey
.head 7 -  Number: npBewPlanNr
.head 7 -  String: spAdminItemKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nIdminItemNr
.head 6 +  Actions
.head 7 -  !
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlPopulateP, "
select	max( ADMIN_ITEM_NR ) + 1
from	LST_ADM_TODO_ITEMS
where	EINRICHT_ID = 1
   and	FALL_KEY = :npVirtFallKey
   and	LST_ERF_NR =  :npNewLstErfNr
into	:nIdminItemNr " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSqlPopulateP, nFetch )
.head 7 +  If Not bOk
.head 8 +  If nFetch = FETCH_EOF
.head 9 -  Set bOk = TRUE
.head 8 +  Else
.head 9 -  Return 0
.head 7 +  If Not nIdminItemNr
.head 8 -  Set nIdminItemNr = 1
.head 7 -  !
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSqlPopulateP, "
insert
into	LST_ADM_TODO_ITEMS (
	EINRICHT_ID, FALL_KEY, LST_ERF_NR,
	ADMIN_ITEM_NR, 	ADMIN_ITEM_KEY,
	ITEM_EINRICHT_ID, ITEM_FALL_KEY, ITEM_BEW_NR )
values (	1, :npVirtFallKey , :npNewLstErfNr, :nIdminItemNr ,
	'" || spAdminItemKey || "', 1, :npFallKey , :npBewPlanNr  )" )
.head 7 +  If bOk
.head 8 -  Set bOk = SqlCommit( hSqlPopulateP )
.head 7 +  If Not bOk
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulateP, 'rollback' )
.head 8 -  Set nIdminItemNr = 0
.head 7 -  Return nIdminItemNr
.head 5 +  Function: PlanedMovement_InsAdmActionX
.head 6 -  Description: performs PlanedMovement_InsAdmAction using given SQL handle and without "commit", to be used as part of set of actions within one transaction. Also post logs in gs in  LT tables
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npVirtFallKey
.head 7 -  Number: npNewLstErfNr
.head 7 -  Number: npFallKey
.head 7 -  Number: npBewPlanNr
.head 7 -  String: spAdminItemKey
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nLT
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nIdminItemNr
.head 7 -  Number: nNR
.head 7 -  Number: nNR_Detail
.head 6 +  Actions
.head 7 -  !
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( ADMIN_ITEM_NR ) + 1
from	LST_ADM_TODO_ITEMS
where	EINRICHT_ID = 1
   and	FALL_KEY = :npVirtFallKey
   and	LST_ERF_NR =  :npNewLstErfNr
into	:nIdminItemNr " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 7 +  If Not bOk
.head 8 +  If nFetch = FETCH_EOF
.head 9 -  Set bOk = TRUE
.head 8 +  Else
.head 9 -  Return 0
.head 7 +  If Not nIdminItemNr
.head 8 -  Set nIdminItemNr = 1
.head 7 -  !
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert
into	LST_ADM_TODO_ITEMS (
	EINRICHT_ID, FALL_KEY, LST_ERF_NR,
	ADMIN_ITEM_NR, 	ADMIN_ITEM_KEY,
	ITEM_EINRICHT_ID, ITEM_FALL_KEY, ITEM_BEW_NR )
values (	1, :npVirtFallKey , :npNewLstErfNr, :nIdminItemNr ,
	'" || spAdminItemKey || "', 1, :npFallKey , :npBewPlanNr  )" )
.head 7 -  ! Logging
.head 7 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql, nLT, 'LST_ADM_TODO_ITEMS', 'I')
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert	into LT_VALUES (ID, NAME, KEY1, KEY2, KEY3, KEY4 ) 
values	(:nNR_Detail, 'insert into LST_ADM_TODO_ITEMS', 1, :npVirtFallKey , :npNewLstErfNr, :nIdminItemNr  )" ) 
.head 7 -  ! end of log
.head 7 +  If Not bOk
.head 8 -  Set nIdminItemNr = 0
.head 7 -  Return nIdminItemNr
.head 5 -  !
.head 5 +  Function: KeyDown
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: _wPar
.head 7 -  Number: _lPar
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 +  Select Case _wPar
.head 8 +  Case VK_ADD
.head 9 +  If not MTblQueryRowFlags( hWndForm, nSelectedRow , MTBL_ROW_ISEXPANDED )
.head 10 -  Call PopulateRow(nSelectedRow)
.head 9 -  Break
.head 8 +  Case VK_Plus
.head 9 +  If not MTblQueryRowFlags( hWndForm, nSelectedRow , MTBL_ROW_ISEXPANDED )
.head 10 -  Call PopulateRow(nSelectedRow)
.head 9 -  Break
.head 8 +  Case VK_Minus
.head 9 +  If MTblQueryRowFlags( hWndForm, nSelectedRow , MTBL_ROW_ISEXPANDED )
.head 10 -  Call PopulateRow(nSelectedRow)
.head 9 -  Break
.head 8 +  Case VK_SUBTRACT
.head 9 +  If MTblQueryRowFlags( hWndForm, nSelectedRow , MTBL_ROW_ISEXPANDED )
.head 10 -  Call PopulateRow(nSelectedRow)
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set bOk = FALSE
.head 9 -  Break
.head 7 -  Return bOk
.head 5 +  Function: CheckSelectedRows
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call oHandleSelect.CheckRows(  )
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call SqlCreateSession( hSesionFE, "" )
.head 6 -  Call SqlCreateSession( hSesionFEPopulate, "" )
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlPopulate )
.head 6 -  Call SqlSetIsolationLevel(hSqlPopulate, "RL")
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlPopulateW )
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlPopulateR )
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlPopulateC )
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlPopulateP )
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlGetInfo )
.head 6 -  Call SqlCreateStatement( hSesionFE, hSqlTransfer )
.head 6 -  ! Call oSqlL1.SetSession( hSesionFEPopulate )
.head 6 -  ! Call oSqlL1.InitSqls( 5 )
.head 6 -  ! Call oSqlL2.SetSession( hSesionFEPopulate )
.head 6 -  ! Call oSqlL2.InitSqls( 5 )
.head 6 -  ! Call oSqlL3.SetSession( hSesionFEPopulate )
.head 6 -  ! Call oSqlL3.InitSqls( 6 )
.head 6 -  ! Call oSqlL4.SetSession( hSesionFEPopulate )
.head 6 -  ! Call oSqlL4.InitSqls( 6 )
.head 6 -  ! Call oSqlL5.SetSession( hSesionFEPopulate )
.head 6 -  ! Call oSqlL5.InitSqls( 6 )
.head 6 -  Set bNeedActivateRow = TRUE
.head 6 -  Set bFreezeRefresh = FALSE
.head 6 -  Call T_CageCreate()
.head 5 +  On SAM_CreateComplete
.head 6 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,10  )
.head 6 -  Call dlgProgress.SetText( "Populate facility explorer. Please wait...")
.head 6 -  Set bAutoSize = TRUE
.head 6 -  Call Start()
.head 6 -  Set bAutoSize = FALSE
.head 6 -  Set bNotNeedCloseCage = FALSE
.head 6 -  Set bNotNeedPrintCageCard = FALSE
.head 6 -  Call oRefreshCages.SetParentTbl(hWndForm)
.head 6 -  Call SalPostMsg(hWndForm, WM_Size,0,0)
.head 5 +  On SAM_Destroy
.head 6 -  ! Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 6 -  Call oSqlL1.AllDisconnect(  )
.head 6 -  Call oSqlL2.AllDisconnect(  )
.head 6 -  Call oSqlL3.AllDisconnect(  )
.head 6 -  Call oSqlL4.AllDisconnect(  )
.head 6 -  Call oSqlL5.AllDisconnect(  )
.head 6 +  If hSqlPopulate
.head 7 -  Call SqlDisconnect( hSqlPopulate )
.head 6 +  If hSqlPopulateW
.head 7 -  Call SqlDisconnect( hSqlPopulateW )
.head 6 +  If hSqlPopulateR
.head 7 -  Call SqlDisconnect( hSqlPopulateR )
.head 6 +  If hSqlPopulateC
.head 7 -  Call SqlDisconnect( hSqlPopulateC )
.head 6 +  If hSqlPopulateP
.head 7 -  Call SqlDisconnect( hSqlPopulateP )
.head 6 +  If hSqlGetInfo
.head 7 -  Call SqlDisconnect( hSqlGetInfo )
.head 6 +  If hSqlTransfer
.head 7 -  Call SqlDisconnect( hSqlTransfer )
.head 6 +  If hSesionFE
.head 7 -  Call SqlFreeSession( hSesionFE )
.head 6 +  If hSesionFEPopulate
.head 7 -  Call SqlFreeSession( hSesionFEPopulate )
.head 5 +  On SAM_DoubleClick
.head 6 -  Call PopulateRow(lParam)
.head 6 +  If nSelectedLevel = FEL_Rack 
.head 7 -  Call Rack2DView_CheckState(TRUE)
.head 7 +  ! If CheckStatusObj(nSelectedRow, RackIsVirtual )
.head 8 -  ! If not SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call Rack2DView_CheckState(TRUE)
.head 7 +  ! Else
.head 8 -  If not SalIsWindowVisible( hWndRack2DViewVirt )
.head 6 +  If nSelectedLevel = FEL_Pos and not bFreezeMark
.head 7 -  Call SwitchSelectRow(lParam)
.head 5 +  ! On MTM_ExpandRow
.head 6 -  ! Call SalTblSetRowFlags ( hWndForm, FindObject(lParam, -100), ROW_Hidden, TRUE )
.head 6 -  Call PopulateRow(lParam)
.head 5 +  On MTM_ExpandRowDone
.head 6 -  Call SalTblSetRowFlags ( hWndForm, FindObject(lParam, -100), ROW_Hidden, TRUE )
.head 5 +  On SAM_RowSetContext
.head 6 +  ! If bNeedActivateRow
.head 7 -  Call SalTblQueryFocus( hWndForm, nSelectedRow, hWndCol )
.head 7 -  ! Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  ! Call ActivateSelectedItem()
.head 7 -  Call ActivateRow(nSelectedRow)
.head 6 -  Call SalPostMsg(hWndForm, AM_SetFocus , 10, 0)
.head 6 -  Return TRUE
.head 5 +  On AM_SetFocus
.head 6 +  If wParam = 10
.head 7 +  If bNeedActivateRow
.head 8 -  Call SalTblQueryFocus( hWndForm, nSelectedRow, hWndCol )
.head 8 -  Call ActivateRow(nSelectedRow)
.head 6 +  Else If wParam = 2
.head 7 -  Set oData = GetPlaceFormString(SalNumberToHString( lParam ) )
.head 7 -  Call OpenRack( oData.nScreenID, oData.nRackID )
.head 6 -  Return TRUE
.head 5 +  ! On MTM_RowSelChanged
.head 6 +  If bNeedActivateRow
.head 7 -  Call ActivateSelectedItem()
.head 6 -  Return TRUE
.head 5 +  On AM_Refresh
.head 6 +  If bNeedActivateRow
.head 7 -  Return Refresh( wParam, lParam )
.head 5 +  On AM_KHE_GotoGrp
.head 6 -  ! Return GotoGruppeByString( GalGetAsWinMsgWParam_String( wParam ), bAutoScan )
.head 6 +  If lParam = 1
.head 7 +  If bMoveToVirt
.head 8 -  Set bMoveToVirt = FALSE
.head 8 -  Call OpenCageByString(GalGetAsWinMsgWParam_String( wParam ))
.head 8 -  Set bMoveToVirt = TRUE
.head 7 +  Else
.head 8 -  Call OpenCageByString(GalGetAsWinMsgWParam_String( wParam ))
.head 6 +  Else
.head 7 -  Call OpenCageByString(GalGetAsWinMsgWParam_String( wParam ))
.head 6 -  ! Return OpenCageByString(GalGetAsWinMsgWParam_String( wParam ))
.head 5 +  On AM_KHE_CloseGrp
.head 6 -  ! Return CloseGruppeByString( GalGetAsWinMsgWParam_String( wParam ) )
.head 6 -  Return CloseCageByString(GalGetAsWinMsgWParam_String( wParam ))
.head 5 +  On AM_ReloadSettings
.head 6 -  Call LoadSettings()
.head 6 +  If wParam = 2
.head 7 +  If lParam = 1
.head 8 -  Call oSettingsHouse.cPicture.Reload(  )
.head 8 -  Call oSettingsWorkGroup.cPicture.Reload(  )
.head 8 -  Call oSettingsRack.cPicture.Reload(  )
.head 8 -  Call oSettingsCage.cPicture.Reload(  )
.head 8 -  Call oSettingsBett.cPicture.Reload(  )
.head 7 -  Call Refresh(9,0)
.head 6 +  ! If wParam=0
.head 7 -  Call Refresh(1,0)
.head 5 +  On AM_OpenFall
.head 6 -  ! Opens Fall for Selected Item
.head 6 +  If (nSelectedLevel = KHEL_Bett) And colIDObject != -100
.head 7 -  Call SalPostMsg( hWndStar2000, AM_OpenFall, 0, GalSetAsWinMsgLParam_Number( colIDObject ) )
.head 5 +  On AM_KHE_ForcedPopulateCurrent
.head 6 -  Return SalSendMsg( hWndForm, AM_Refresh, 10, 0 )
.head 5 +  On AM_KHE_RefreshItems
.head 6 -  Return Refresh( 8,0 )
.head 5 +  On AM_KHE_RefreshGruppe
.head 6 -  ! Set sTemp = SalNumberToHString( wParam )
.head 6 -  ! Set nTemp = SalStrTokenize ( sTemp, "", ";", asTemp )
.head 6 +  ! If nTemp > 2
.head 7 -  Set nTemp = SearchFrom(hRoot, asTemp[3])
.head 6 +  ! Else
.head 7 -  Set nTemp = 0
.head 6 -  ! Return KHE_RefreshGruppe()
.head 6 +  ! If bShowPlacesWithContent
.head 7 +  If nTemp > 0
.head 8 -  Return KHE_RefreshGruppe(nTemp)
.head 7 +  Else 
.head 8 -  Return KHE_RefreshGruppe(nSelectedHandle)
.head 6 +  ! Else
.head 7 -  ! Call PopulateAndExpand(nSelectedHandle, TRUE )
.head 7 +  If GetLevel( nSelectedHandle ) = KHEL_Bett
.head 8 -  Set nSelectedHandle=GetParent(nSelectedHandle)
.head 8 -  Set nSelectedLevel  = KHEL_Gruppe
.head 8 -  Call PopulateAndExpand(nSelectedHandle, TRUE )
.head 7 +  Else 
.head 8 -  !
.head 8 -  Call PopulateAndExpand(nSelectedHandle, TRUE )
.head 7 -  Return PopulateSelectedItem( FALSE )
.head 6 +  If wParam > 0
.head 7 -  Call Refresh(2, wParam )
.head 6 +  Else
.head 7 -  Call Refresh(10, 0 )
.head 5 +  On AM_KHE_Cut
.head 6 +  ! If wParam = 1
.head 7 -  Set bMenuCutFallNrX = TRUE
.head 6 +  ! Else
.head 7 -  Set bMenuCutFallNrX = FALSE
.head 6 -  Return CutCurrent(  )
.head 5 +  On AM_KHE_Paste
.head 6 -  Return Paste( wParam )
.head 5 +  On AM_KHE_GroupCulling
.head 6 -  Return CullingAndDischarge(FALSE  )
.head 5 +  On AM_KHE_GroupRelease
.head 6 -  Return CullingAndDischarge( TRUE )
.head 5 +  On SAM_ContextMenu
.head 6 +  Select Case nSelectedLevel
.head 7 +  Case KHEL_Einrichtung
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_FE_L1', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case KHEL_Abteilung
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_FE_L2', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case KHEL_Station
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_FE_L3', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case KHEL_Gruppe
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_FE_L4', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case KHEL_Bett
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_FE_L5', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Default
.head 8 -  Break
.head 5 +  On AM_KHE_MoveFemaleAfterPL
.head 6 -  Return MoveFemaleAfterPL( GalGetAsWinMsgLParam_Number( lParam ),wParam )
.head 5 +  On AM_KHE_GoToCageNR
.head 6 -  Return GoToCageNR( wParam )
.head 5 +  On AM_KHE_GotoBedByFall
.head 6 +  ! If GotoBettByFallKey( GalGetAsWinMsgLParam_Number( lParam ), bAutoScan )
.head 7 -  Call Rack2DView_CheckState(FALSE)
.head 7 -  Call MultiSelect()
.head 7 -  Return TRUE
.head 6 +  If wParam = 3
.head 7 -  Call ActivatePosFallKey(GalGetAsWinMsgLParam_Number( lParam ))
.head 6 +  Else
.head 7 +  If OpenPosByFallKey(GalGetAsWinMsgLParam_Number( lParam ))
.head 8 -  Call Rack2DView_CheckState(FALSE)
.head 8 +  If wParam = 2
.head 9 -  Call UnSelectAll(  )
.head 8 -  Return TRUE
.head 5 +  On AM_KHE_GotoGrpByFall
.head 6 -  Return GotoCageByFallKey( GalGetAsWinMsgLParam_Number( lParam ) )
.head 5 +  On AM_KHE_MoveCages
.head 6 -  Set bMoveFlag = TRUE
.head 6 +  If lParam = KHEL_Station
.head 7 +  ! If (SalModalDialog(dlgAskForMoveScreen, hWndForm, sAbtKeySrc, sStatKeyTmp)) and (sMoveScreen != "") and (sMoveScreen!=sStatKeyTmp)
.head 8 -  Call TransferCageInScreens(sAbtKeySrc,sMoveScreen,sStatKeyTmp, GetTime4Refresh(  ))
.head 8 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
					SalHStringToNumber( sAbtKeySrc || ";" || sStatKeyTmp ) )
.head 6 +  Else If lParam = KHEL_Abteilung
.head 7 +  If (SalModalDialog(dlgAskForMoveInScreen, hWndForm, oPosition.sScreen, oPosition.sRack, sMoveScreen, nMoveScrID )) 
.head 8 +  If nMoveScrID and nMoveScrID != oPosition.nScreenID
.head 9 -  Call TransferCagesBetweenWorkGroup( oPosition.nScreenID,nMoveScrID, GetTime4Refresh(  ))
.head 9 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged,
					SalHStringToNumber( oPosition.sScreen || ";" || oPosition.sRack ) )
.head 9 -  ! Call TurnLevel(  )
.head 6 -  Set bMoveFlag = FALSE
.head 6 -  Set sMoveScreen = ""
.head 6 -  Set nMoveScrID = NUMBER_Null
.head 5 +  On AM_GM_RENEW_BY_ID
.head 6 +  If lParam = TYPE_SCREEN
.head 7 -  Call RepopulateWorkgroup(wParam)
.head 5 +  On AM_GM_RENEW_LIGHT_BY_ID
.head 6 +  If lParam = TYPE_RACK
.head 7 -  Call RepopulateRack(wParam)
.head 5 +  On AM_MoveToVirt
.head 6 +  If wParam = 1
.head 7 -  Call MoveToVirt(GetIdObject(nSelectedRow), nSelectedLevel  )
.head 5 +  On AM_KHE_OpenTempCage
.head 6 +  If wParam = 1
.head 7 +  If nSelectedLevel = KHEL_Station
.head 8 -  Call MoveToVirt(GetIdObject(GetParent( nSelectedRow)), KHEL_Abteilung  )
.head 6 +  Else If wParam = 2
.head 7 -  Call MoveFromVirt(  )
.head 5 +  On AM_KHE_Plan2Real_Bew
.head 6 -  ! lParam - FallKey
.head 6 -  ! wParam - BewPlanNr
.head 6 -  Return FE_Plan2Real_Bew( GalGetAsWinMsgLParam_Number( lParam ), GalGetAsWinMsgWParam_Number( wParam ) )
.head 5 +  On WM_KEYDOWN
.head 6 +  If KeyDown(wParam, lParam)
.head 7 -  Return FALSE
.head 6 +  Else
.head 7 -  Call SalSendMsg(hWndStar2000 , WM_KEYDOWN, wParam, lParam )
.head 5 +  On AM_SetStatus
.head 6 +  If wParam = 1
.head 7 +  If lParam
.head 8 -  Set bFreezeMark = TRUE
.head 7 +  Else
.head 8 -  Set bFreezeMark = FALSE
.head 3 +  Functional Class: cSelectRowFE
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Number: nRow[*]
.head 5 -  Number: nIndex
.head 5 -  Number: nCountFemales
.head 5 -  Number: nCountMales
.head 5 -  Boolean: bAnySelects
.head 5 -  Boolean: bInit
.head 5 -  String: sTotalObjects
.head 4 +  Functions
.head 5 +  Function: Init
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If not bInit
.head 8 -  Call SalArraySetUpperBound( nRow, 1, -1 )
.head 8 -  Set nCountFemales = 0
.head 8 -  Set nCountMales = 0
.head 8 -  Set nIndex = 0
.head 8 -  Set bAnySelects = FALSE
.head 8 -  Set bInit = TRUE
.head 7 -  Return TRUE
.head 5 +  Function: ReInit
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set bInit = FALSE
.head 7 -  Return Init()
.head 5 +  Function: SelectRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowSel
.head 7 -  String: sSex
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If not RowIsSelected(nRowSel )
.head 8 -  Set nRow[nIndex] = nRowSel
.head 8 -  Set nIndex = nIndex + 1
.head 8 +  If sSex = "M"
.head 9 -  Set nCountMales = nCountMales + 1
.head 8 +  Else
.head 9 -  Set nCountFemales = nCountFemales + 1
.head 8 -  Set bAnySelects = nCountMales>0 or nCountFemales>0
.head 8 +  If not bAnySelects
.head 9 -  Set nCountFemales = 0
.head 9 -  Set nCountMales = 0
.head 5 +  Function: UnselectRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowUnSel
.head 7 -  String: sSex
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 +  Loop
.head 8 +  If nI >= nIndex
.head 9 -  Break
.head 8 +  If nRow[nI] = nRowUnSel
.head 9 -  Break
.head 8 -  Set nI = nI + 1
.head 7 +  While nI  < (nIndex - 1)
.head 8 -  Set nRow[nI] = nRow[nI+1]
.head 8 -  Set nI = nI + 1
.head 7 +  If nI =  (nIndex - 1)
.head 8 -  Call SalArraySetUpperBound( nRow, 1, nI-1 )
.head 8 -  Set nIndex = (nIndex - 1)
.head 7 +  If sSex = "M"
.head 8 -  Set nCountMales = nCountMales - 1
.head 7 +  Else
.head 8 -  Set nCountFemales = nCountFemales - 1
.head 7 -  Set bAnySelects = nCountMales>0 or nCountFemales>0
.head 7 +  If not bAnySelects
.head 8 -  Set nCountFemales = 0
.head 8 -  Set nCountMales = 0
.head 7 +  If nIndex = 0
.head 8 -  Call ReInit()
.head 7 -  Return TRUE
.head 5 +  Function: RowIsSelected
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nInd
.head 7 -  Boolean: bExists
.head 6 +  Actions
.head 7 -  Set nInd = 0
.head 7 -  Set bExists = FALSE
.head 7 +  While nInd < nIndex
.head 8 +  If nRow[nInd] = _nRow
.head 9 -  Set bExists = TRUE
.head 8 -  Set nInd = nInd + 1
.head 7 -  Return bExists
.head 5 +  Function: CheckRows
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nInd
.head 7 -  Number: nJ
.head 7 -  Boolean: bChange
.head 6 +  Actions
.head 7 -  Set nInd = 0
.head 7 -  Set bChange = FALSE
.head 7 +  While nInd < nIndex
.head 8 +  If MTblGetRowFromID( hWndKHE , nRow[nInd] ) = TBL_Error
.head 9 -  Set bChange = TRUE
.head 9 -  Set nJ = nInd
.head 9 +  While nJ < nIndex - 1
.head 10 -  Set nRow[nJ] =  nRow[nJ + 1]
.head 10 -  Set nJ = nJ + 1
.head 9 -  Set nIndex = nIndex - 1
.head 8 -  Set nInd = nInd + 1
.head 7 +  If bChange
.head 8 -  Call SalArraySetUpperBound( nRow, 1, nIndex - 1)
.head 8 -  Set nCountFemales = 0
.head 8 -  Set nCountMales = 0
.head 8 -  Set bAnySelects = FALSE
.head 8 -  Set nInd = 0
.head 8 +  While nInd < nIndex
.head 9 +  If hWndKHE.clsNewFE.GetSValue(MTblGetRowFromID( hWndKHE , nRow[nInd] ), "SEX") = 'M'
.head 10 -  Set nCountMales = nCountMales + 1
.head 9 +  Else
.head 10 -  Set nCountFemales = nCountFemales + 1
.head 9 -  Set nInd = nInd + 1
.head 8 -  Set bAnySelects = (nCountFemales + nCountMales) > 0
.head 3 +  Functional Class: cRefreshRow
.head 4 -  Description: Refresh row in FE
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Number: nRow[*]
.head 5 -  Number: nInd
.head 5 -  Window Handle: hWndParentTbl
.head 4 +  Functions
.head 5 +  Function: Init
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set nInd = 0
.head 7 -  Call SalArraySetUpperBound( nRow, 1, -1 )
.head 5 +  Function: AddRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set nRow[nInd] = _nRow
.head 7 -  Set nInd =nInd + 1
.head 5 +  Function: PrepareRefresh
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nJ
.head 7 -  Number: nTmp
.head 7 -  Number: nUniqRow
.head 7 -  Number: nPrev
.head 6 +  Actions
.head 7 -  ! Delete duplicate data
.head 7 -  Set nI = 0
.head 7 +  While nI < nInd
.head 8 -  Set nJ = nI + 1
.head 8 +  While nJ < nInd
.head 9 +  If nRow[nJ] = nRow[nI]
.head 10 -  Set nRow[nJ] = nRow[nInd - 1]
.head 10 -  Set nRow[nInd - 1] = -1
.head 10 -  Set nInd = nInd - 1
.head 10 -  Set nJ = nJ - 1
.head 9 -  Set nJ = nJ + 1
.head 8 -  Set nI = nI + 1
.head 7 -  Call SalArraySetUpperBound( nRow, 1, nInd-1 )
.head 7 -  ! Prepare Uniq RowID
.head 7 -  Set nI = 0
.head 7 +  While nI < nInd
.head 8 -  ! Set nUniqRow = hWndKHE.clsNewFE.GetUniqRowID( nRow[nI] )
.head 8 -  Set nUniqRow = MTblGetRowID( hWndParentTbl, nRow[nI] )
.head 8 -  Set nRow[nI] = nUniqRow
.head 8 -  Set nI = nI + 1
.head 7 -  !
.head 7 +  If FALSE
.head 8 -  Set nI = 0
.head 8 +  While nI < nInd-1
.head 9 -  Set nJ = nI + 1
.head 9 +  While nJ < nInd
.head 10 +  If nRow[nI] < nRow[nJ]
.head 11 -  Set nTmp =  nRow[nI]
.head 11 -  Set nRow[nI] =  nRow[nJ]
.head 11 -  Set nRow[nJ] =  nTmp
.head 10 -  Set nJ = nJ + 1
.head 9 -  Set nI = nI + 1
.head 8 -  ! Delay duplicate data
.head 8 -  Set nI = 1
.head 8 -  Set nPrev = nRow[0]
.head 8 +  While nI < nInd
.head 9 +  If nPrev = nRow[nI]
.head 10 -  Set nJ = nI + 1
.head 10 +  While nJ < nInd
.head 11 -  Set nRow[nJ-1] =  nRow[nJ]
.head 11 -  Set nJ = nJ + 1
.head 10 -  Set nInd = nInd - 1
.head 10 -  Set nPrev = nRow[nI]
.head 9 +  Else
.head 10 -  Set nPrev = nRow[nI]
.head 9 -  Set nI = nI + 1
.head 8 -  Call SalArraySetUpperBound( nRow, 1, nInd-1 )
.head 7 -  Return TRUE
.head 5 +  Function: SetParentTbl
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Window Handle: _hWndTbl
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set hWndParentTbl = _hWndTbl
.head 3 +  Functional Class: cFE_Sqls
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Session Handle: hSession
.head 5 -  Sql Handle: hSql[*]
.head 5 -  Number: nCount
.head 5 -  Boolean: bInit
.head 5 -  Boolean: bPrepare
.head 4 +  Functions
.head 5 +  Function: SetSession
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Session Handle: _hSes
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set hSession = _hSes
.head 5 +  Function: InitSqls
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: _nCountSql
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 +  If not bInit
.head 8 -  Set nI = 0
.head 8 +  While nI < _nCountSql 
.head 9 -  Call SqlCreateStatement(hSession, hSql[nI]  )
.head 9 -  Set nI = nI + 1
.head 8 -  Set nCount = _nCountSql
.head 8 +  If nI > 0
.head 9 -  Call SqlSetIsolationLevel( hSql[0], "RL" )
.head 8 -  Set bInit = TRUE
.head 5 +  Function: AllDisconnect
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 +  While nI < nCount
.head 8 +  If hSql[nI]
.head 9 -  Call SqlDisconnect( hSql[nI] )
.head 8 -  Set nI = nI + 1
.head 7 -  Call SalArraySetUpperBound( hSql, 1, -1 )
.head 7 -  Set nCount = NUMBER_Null
.head 7 -  Set bInit = FALSE
.head 7 -  Set bPrepare = bInit
.head 5 +  Function: ObjectDestructor
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call AllDisconnect()
.head 3 +  Functional Class: cClipsParameters
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  Number: nRowCages[*]
.head 5 -  Number: nFinCage[*]
.head 5 -  Number: nMinCage[*]
.head 5 -  Number: nCageID[*]
.head 5 -  Number: nRackID
.head 5 -  String: sCagePosition[*]
.head 5 -  Number: nMax
.head 5 -  Number: nN
.head 5 -  String: sOutput
.head 5 -  String: sResult
.head 5 -  Number: nE
.head 5 -  Number: nSelected
.head 5 -  String: sOutputSelectedCage
.head 5 -  String: sMedRec
.head 5 -  Boolean: bIsAnimalSelected
.head 5 -  String: sStrain
.head 5 -  String: aAnimalsInSelectedCage[*]
.head 5 -  String: sSex
.head 5 -  String: sSelectedAnimal
.head 5 -  Date/Time: dtGebDatum
.head 5 -  ! String: sGebDatum
.head 5 -  String: sGenoType
.head 5 -  String: sPhenoType
.head 5 -  Boolean: bHasLitter
.head 5 -  FunctionalVar: oLevelSettings
.head 6 -  Class: oSettingsFE
.head 5 -  FunctionalVar: oLevelSettingsCage
.head 6 -  Class: oSettingsFE
.head 5 -  FunctionalVar: oLevelSettingsRack
.head 6 -  Class: oSettingsFE
.head 5 -  String: sCageInfo
.head 5 -  String: aOpenedCages[*]
.head 5 -  String: sActiveServices
.head 5 -  String: sServicesList
.head 5 -  String: aAnimalsSelected[*]
.head 5 -  String: aFirstAnimalInCage[*]
.head 5 -  String: aOpenedRacks[*]
.head 5 -  String: sRackInfo
.head 5 -  String: aWorkgroups[*]
.head 5 -  String: sWorkgroup
.head 5 -  String: sSelAnimalNoMR
.head 5 -  Number: nSelectedCageID
.head 5 -  Number: nSelectedRackID
.head 5 -  Number: nSelectedWorkgroupID
.head 5 -  Number: anFallKey[*]
.head 4 -  Functions
.head 3 +  Functional Class: cAnimalsInCageClips
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: aAnimalsInCage[*]
.head 4 -  Functions
.head 3 -  ! structures that represent location
.head 3 +  Child Table Class: clsGeneralExplorer
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left:
.head 6 -  Top:
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: 50000
.head 5 -  Discardable? Class Default
.head 4 -  Next Class Child Key: 30
.head 4 -  List in Tool Palette? Yes
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Description:
.head 4 -  Derived From
.head 4 +  Contents
.head 5 +  Column: colTree
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 1
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: TREE
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: 600
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colIDObject
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 2
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: ID
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colOrder
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 3
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: order
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCheck
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 4
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Check Box
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colFlags
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 5
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: order
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 6
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 7
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal3
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 8
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal4
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 9
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal5
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 10
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal6
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 11
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal7
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 12
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal8
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 13
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal9
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 14
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal10
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 15
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal11
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 16
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal12
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 17
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 18
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 19
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal3
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 20
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal4
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 21
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal5
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 22
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal6
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 23
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal7
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 24
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal8
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 25
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal9
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 26
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal10
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 27
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 28
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Date/Time
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 29
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Date/Time
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value: 1
.head 8 -  Uncheck Value: 0
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDetailInfo
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 30
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: 32000
.head 6 -  Data Type: String
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  !
.head 5 -  Window Handle: hWndSCol[*]
.head 5 -  Window Handle: hWndNCol[*]
.head 5 -  Window Handle: hWndDtCol[*]
.head 5 -  !
.head 5 -  Boolean: bAutoSize
.head 5 -  Number: nRoot
.head 5 -  Number: nSelectedLevel
.head 5 -  Number: nSelectedRow
.head 5 -  Window Handle: hWndCol
.head 5 -  ! Select rows
.head 5 -  FunctionalVar: oHandleSelect
.head 6 -  Class: cSelectRowFE
.head 5 -  !
.head 4 +  Functions
.head 5 +  Function: InitTable
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Window Handle: hWndCol
.head 7 -  String: sNameCol
.head 7 -  Number: nI
.head 7 -  Number: nK
.head 7 -  Number: nD
.head 7 -  Number: nPos
.head 6 +  Actions
.head 7 -  Call ..LoadSettings()
.head 7 -  Call MTblDefineTree( hWndItem , colTree,8, 16 )
.head 7 -  Call MTblSetTreeFlags( hWndItem, MTBL_TREE_FLAG_NO_ROWLINES, TRUE )
.head 7 -  Call MTblSetFlags( hWndItem, MTBL_FLAG_VARIABLE_ROW_HEIGHT, TRUE )
.head 7 -  Call MTblSetFlags( hWndItem, MTBL_FLAG_NO_FREE_COL_AREA_LINES, TRUE )
.head 7 -  Call MTblSetFlags( hWndItem, MTBL_FLAG_NO_FREE_ROW_AREA_LINES | MTBL_FLAG_SORT_RESTORE_TREE, TRUE )
.head 7 -  Call MTblSetColumnFlags( colTree , MTBL_COL_FLAG_NO_COLLINE, TRUE )
.head 7 -  Call MTblSetColumnHdrFlags( colTree, MTBL_COLHDR_FLAG_TXTALIGN_LEFT, TRUE )
.head 7 -  Call SalTblSetTableFlags ( hWndItem, TBL_Flag_SingleSelection, TRUE )
.head 7 -  Call MTblSetTreeFlags( hWndItem, MTBL_TREE_FLAG_AUTO_NORM_HIER , TRUE )
.head 7 -  Call MTblEnableMWheelScroll( hWndItem, TRUE )
.head 7 -  Call SalTblDefineRowHeader (hWndItem , "", 0 ,TBL_RowHdr_Visible , hWndNULL)
.head 7 -  Call MTblSetSelectionColors( hWndItem, COLOR_White, COLOR_Black )
.head 7 -  Call oHandleSelect.Init(  )
.head 7 -  Call SalArraySetUpperBound( hWndSCol, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hWndNCol, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( hWndDtCol , 1, -1 )
.head 7 -  Set nPos = 1
.head 7 -  Set nI = 0
.head 7 -  Set nK = nI
.head 7 -  Set nD = nI
.head 7 -  Set hWndCol = SalTblGetColumnWindow( hWndForm, nPos, COL_GetPos )
.head 7 +  Loop
.head 8 +  If hWndCol = hWndNULL
.head 9 -  Break
.head 8 -  Call SalGetItemName ( hWndCol, sNameCol )
.head 8 +  If SalStrScan( sNameCol, "colSVal" )!=-1
.head 9 -  Set hWndSCol[nI] = hWndCol
.head 9 -  Set nI = nI + 1
.head 8 +  Else If SalStrScan( sNameCol, "colNVal" )!=-1
.head 9 -  Set hWndNCol[nK] = hWndCol
.head 9 -  Set nK = nK + 1
.head 8 +  Else If SalStrScan( sNameCol, "colDtVal" )!=-1
.head 9 -  Set hWndDtCol[nD] = hWndCol
.head 9 -  Set nD = nD + 1
.head 8 -  Set nPos = nPos + 1
.head 8 -  Set hWndCol = SalTblGetColumnWindow( hWndForm, nPos, COL_GetPos )
.head 5 +  Function: LoadSettings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return TRUE
.head 5 -  !
.head 5 +  Function: GetNameRowLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nRowNr
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return "cFERow"
.head 5 +  Function: GetLevelSettings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  FunctionalVar:
.head 8 -  Class: oSettingsFE
.head 6 +  Parameters
.head 7 -  Number: nRowNr
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return OBJ_Null
.head 5 +  Function: GetLevelFlag
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRowNr
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return 524287
.head 5 +  Function: ReAssignPic
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nCurrentRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  ! If SalObjGetType(this) != "clsGeneralExplorer"
.head 8 -  Return ..ReAssignPic(nCurrentRow)
.head 5 -  !
.head 5 +  Function: GetWidthTree
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nTreeWidth
.head 7 -  Number: nTreeWidthUnits
.head 7 -  Number: nX1
.head 7 -  Number: nY1
.head 7 -  Number: nX2
.head 7 -  Number: nY2
.head 7 -  Number: nWidth
.head 7 -  Number: nWidthVScroll
.head 7 -  Number: nKoef
.head 7 -  Number: nKoefNew
.head 7 -  Number: nTrunc
.head 7 -  Number: nW_Form
.head 7 -  Number: nH_Form
.head 7 -  Number: nDelta
.head 6 +  Actions
.head 7 -  Call SalTblQueryColumnWidth( colTree, nTreeWidthUnits )
.head 7 -  Call GetClientRect(hWndForm, nX1, nY1, nX2, nY2)
.head 7 -  Set nWidth = nX2 - nX1
.head 7 -  Call GetWindowRect(hWndForm,nX1,nY1,nX2,nY2)
.head 7 -  Set nWidthVScroll = nX2 - nX1 - nWidth
.head 7 -  Set nWidthVScroll = SalPixelsToFormUnits( hWndForm, nWidthVScroll , FALSE )
.head 7 -  Call SalGetWindowSize( hWndForm, nW_Form, nH_Form )
.head 7 -  Set nWidth = nW_Form - nWidthVScroll
.head 7 -  Set nDelta = nWidth
.head 7 +  Loop
.head 8 +  If nWidth > nTreeWidthUnits
.head 9 -  Break
.head 8 -  Set nWidth = nWidth + nDelta - nWidthVScroll
.head 7 -  Return nWidth
.head 5 +  Function: SetSizeTree
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If not bAutoSize
.head 8 -  Set bAutoSize = TRUE
.head 8 -  Call SalTimerSet( hWndForm, 10, 1100 )
.head 8 -  Call MTblAutoSizeColumn( hWndForm, colTree, MTASC_ALLROWS )
.head 8 -  Call SalTblSetColumnWidth( colTree, GetWidthTree() )
.head 5 +  Function: FindObject
.head 6 -  Description: Find RowNr with objectID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nID_Object
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRow
.head 7 -  Number: nChildRow
.head 6 +  Actions
.head 7 -  Set nRow = -1
.head 7 +  If nParent != TBL_MinRow
.head 8 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, nParent )
.head 7 +  Else
.head 8 -  Set nChildRow = 0
.head 7 +  While nChildRow != TBL_Error
.head 8 -  Call SalTblSetContext ( hWndForm, nChildRow )
.head 8 +  If colIDObject = nID_Object
.head 9 -  Set nRow = nChildRow
.head 9 -  Break
.head 8 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 7 -  Return nRow
.head 5 +  Function: FE_NewRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewRow
.head 6 +  Actions
.head 7 +  If nParent = -1
.head 8 -  Set nNewRow = SalTblInsertRow ( hWndForm, TBL_MaxRow )
.head 7 +  Else
.head 8 -  Set nNewRow = MTblInsertChildRow( hWndForm, nParent, MTICR_REDRAW )
.head 7 -  Call SalTblSetRowFlags ( hWndForm, nNewRow, ROW_New	, FALSE )
.head 7 -  Call MTblSetRowFlags( hWndItem, nNewRow, MTBL_ROW_NOSELINV_IMAGE | MTBL_ROW_NOSELINV_TEXT, TRUE, MTSRF_REDRAW )
.head 7 -  Return nNewRow
.head 5 +  Function: FE_DelRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nObjDel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowDel
.head 6 +  Actions
.head 7 -  Set nRowDel = FindObject( nParent, nObjDel )
.head 7 +  If nRowDel != -1
.head 8 -  Call MTblDeleteDescRows( hWndForm, nRowDel, TBL_Adjust )
.head 8 -  Call SalTblDeleteRow( hWndForm, nRowDel, TBL_Adjust )
.head 5 +  Function: FE_SetInfo
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  FunctionalVar: _cInfo 
.head 8 -  Class: cFERow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nMax
.head 7 -  Number: nI
.head 7 -  String: sText
.head 6 +  Actions
.head 7 -  Call SalTblSetContext ( hWndForm, nRow )
.head 7 -  Set _cInfo.oLevelSetting = ..GetLevelSettings(nRow)
.head 7 -  ! It's old code
.head 7 +  ! Select Case GetLevel( nRow )
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set _cInfo.oLevelSetting = oSettingsHouse
.head 9 -  Break 
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set _cInfo.oLevelSetting = oSettingsWorkGroup
.head 9 -  Break 
.head 8 +  Case KHEL_Station
.head 9 -  Set _cInfo.oLevelSetting = oSettingsRack
.head 9 -  Break 
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set _cInfo.oLevelSetting = oSettingsCage
.head 9 -  Break 
.head 8 +  Case KHEL_Bett
.head 9 -  Set _cInfo.oLevelSetting = oSettingsBett
.head 9 -  Break 
.head 8 +  Default 
.head 9 -  Break 
.head 7 -  Call _cInfo.Save(  )
.head 7 -  Set colTree = _cInfo.sLabel
.head 7 -  Set colIDObject = _cInfo.nID_Obj
.head 7 -  Set colOrder =_cInfo.nOrder
.head 7 -  Set colFlags = _cInfo.nStatusFlags
.head 7 -  Set colCheck = _cInfo.nCheckRow
.head 7 -  Set colDetailInfo = _cInfo.sInfo
.head 7 +  If not SalArrayIsEmpty (  _cInfo.sVal )
.head 8 -  Call SalArrayGetUpperBound ( _cInfo.sVal , 1, nMax )
.head 8 -  Set nI = 0
.head 8 +  While nI <= nMax
.head 9 -  Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndSCol[nI] ), _cInfo.sVal[nI] )
.head 9 -  Set nI = nI + 1
.head 7 +  If not SalArrayIsEmpty (  _cInfo.nVal )
.head 8 -  Call SalArrayGetUpperBound ( _cInfo.nVal , 1, nMax )
.head 8 -  Set nI = 0
.head 8 +  While nI <= nMax
.head 9 -  Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndNCol[nI] ),SalNumberToStrX(  _cInfo.nVal[nI],2) )
.head 9 -  Set nI = nI + 1
.head 7 +  If not SalArrayIsEmpty (  _cInfo.dtVal )
.head 8 -  Call SalArrayGetUpperBound ( _cInfo.dtVal , 1, nMax )
.head 8 -  Set nI = 0
.head 8 +  While nI <= nMax
.head 9 -  Call SalDateToStr( _cInfo.dtVal[0], sText ) 
.head 9 -  Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndDtCol[nI] ), sText )
.head 9 -  Set nI = nI + 1
.head 7 +  If _cInfo.nID_Obj != -100
.head 8 -  Call ..ReAssignPic(nRow)
.head 7 +  Else
.head 8 -  Call MTblSetRowFlags( hWndForm, nRow, MTBL_ROW_HIDDEN, TRUE, MTSRF_REDRAW )
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 5 +  Function: FE_GetInfo
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  FunctionalVar:
.head 8 -  Class: cFERow
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: _cInfo 
.head 8 -  Class: cFERow
.head 7 -  Number: nInd
.head 7 -  Number: nMax
.head 7 -  String: sVal
.head 6 +  Actions
.head 7 -  Call SalTblSetContext ( hWndForm, nRow )
.head 7 -  Set _cInfo =  SalObjCreateFromString( ..GetNameRowLevel(nRow) )
.head 7 -  ! It's old code
.head 7 +  ! Select Case MTblGetRowLevel( hWndForm, nRow )
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowIns" )
.head 9 -  Break 
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowScr" )
.head 9 -  Break 
.head 8 +  Case KHEL_Station
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowRack" )
.head 9 -  Break 
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowCage" )
.head 9 -  Break 
.head 8 +  Case KHEL_Bett
.head 9 -  Set _cInfo =  SalObjCreateFromString( "cFERowBett" )
.head 9 -  Break 
.head 8 +  Default 
.head 9 -  Break 
.head 7 -  Call _cInfo.Init(  )
.head 7 -  Set _cInfo.sLabel = colTree
.head 7 -  Set _cInfo.nID_Obj = colIDObject
.head 7 -  Set _cInfo.nOrder = colOrder
.head 7 -  Set _cInfo.nStatusFlags = colFlags
.head 7 -  Set _cInfo.nCheckRow = colCheck
.head 7 -  ! Set _cInfo.sCagePosition = colSVal1
.head 7 -  ! Set _cInfo.sStrain = colSVal3
.head 7 -  Set _cInfo.sInfo = colDetailInfo
.head 7 -  Set nInd = 0
.head 7 -  Call SalArrayGetUpperBound( hWndSCol, 1, nMax )
.head 7 +  While nInd <= nMax
.head 8 -  Call SalTblGetColumnText ( hWndForm, SalTblQueryColumnID ( hWndSCol[nInd] ), sVal )
.head 8 -  Call _cInfo.AddString( sVal )
.head 8 -  Set nInd = nInd + 1
.head 7 -  Set nInd = 0
.head 7 -  Call SalArrayGetUpperBound( hWndNCol, 1, nMax )
.head 7 +  While nInd <= nMax
.head 8 -  Call SalTblGetColumnText ( hWndForm, SalTblQueryColumnID ( hWndNCol[nInd] ), sVal )
.head 8 -  Call _cInfo.AddNumber( SalStrToNumber( sVal ) )
.head 8 -  Set nInd = nInd + 1
.head 7 -  Set nInd = 0
.head 7 -  Call SalArrayGetUpperBound( hWndDtCol , 1, nMax )
.head 7 +  While nInd <= nMax
.head 8 -  Call SalTblGetColumnText ( hWndForm, SalTblQueryColumnID ( hWndDtCol[nInd] ), sVal )
.head 8 -  Call _cInfo.AddDate( SalStrToDate ( sVal ) )
.head 8 -  Set nInd = nInd + 1
.head 7 -  Call _cInfo.Associate(  )
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 7 -  Return _cInfo
.head 5 +  Function: FE_ReloadHint
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowReload
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: cInfo 
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set cInfo = FE_GetInfo(nRowReload)
.head 7 -  Set cInfo.nLabelFlags = ..GetLevelFlag(nRowReload)
.head 7 -  ! It's old code
.head 7 +  ! Select Case GetLevel(nRowReload)
.head 8 +  Case KHEL_Einrichtung
.head 9 -  Set cInfo.nLabelFlags = oSettingsHouse.nFlags
.head 9 -  Break 
.head 8 +  Case KHEL_Abteilung
.head 9 -  Set cInfo.nLabelFlags = oSettingsWorkGroup.nFlags
.head 9 -  Break 
.head 8 +  Case KHEL_Station
.head 9 -  Set cInfo.nLabelFlags = oSettingsRack.nFlags
.head 9 -  Break 
.head 8 +  Case KHEL_Gruppe
.head 9 -  Set cInfo.nLabelFlags = oSettingsCage.nFlags
.head 9 -  Break 
.head 8 +  Case KHEL_Bett
.head 9 -  Set cInfo.nLabelFlags = oSettingsBett.nFlags
.head 9 -  Break 
.head 8 +  Default 
.head 9 -  Break 
.head 7 -  Call cInfo.BuildLabels()
.head 7 -  Call FE_SetInfo(nRowReload, cInfo)
.head 5 -  ! General functions
.head 5 +  Function: GetIdObject
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nID
.head 6 +  Actions
.head 7 +  If nRow = nSelectedRow
.head 8 -  Return colIDObject
.head 7 +  Else
.head 8 -  Call SalTblSetContext( hWndForm, nRow )
.head 8 -  Set nID = colIDObject
.head 8 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return nID
.head 5 +  Function: GetStrKey
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sKey
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 -  Set sKey = colSVal1
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return sKey
.head 5 +  Function: EnumChildren
.head 6 -  Description: Return array object's ID (screens, racks, cages, animals) 
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nParentRow
.head 7 -  Receive Number: nChild[*]
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildRow
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 +  If MTblIsParentRow( hWndForm, _nParentRow )
.head 8 -  Set nChildRow = MTblGetFirstChildRow( hWndForm, _nParentRow )
.head 8 +  Loop
.head 9 +  If nChildRow = TBL_Error
.head 10 -  Break
.head 9 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 9 +  If colIDObject != -100
.head 10 -  Set nChild[nI] = colIDObject
.head 10 -  Set nI = nI + 1
.head 9 -  Set nChildRow = MTblGetNextChildRow( hWndForm, nChildRow )
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return nI
.head 5 +  Function: GetParent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nChildRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetParentRow( hWndForm, nChildRow )
.head 5 +  Function: GetNextChildRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetNextChildRow( hWndForm, _nRow )
.head 5 +  Function: GetFirstChildRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetFirstChildRow( hWndForm, _nRow )
.head 5 +  Function: GetUniqRowID
.head 6 -  Description: Gets a row's unique ID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRowID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nURowID
.head 6 +  Actions
.head 7 -  Set nURowID = MTblGetRowID( hWndForm , nRowID )
.head 7 -  Return nURowID
.head 5 +  Function: GetRowID
.head 6 -  Description: Gets a row's number on the basis of it's ID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nURowID
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowID
.head 6 +  Actions
.head 7 -  Set nRowID = MTblGetRowFromID( hWndForm , nURowID )
.head 7 -  Return nRowID
.head 5 +  Function: GetLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblGetRowLevel(hWndForm, _nRow)
.head 5 +  Function: GetSValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 7 -  String: _sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oRowData
.head 8 -  Class: cFERow
.head 7 -  String: sValue
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, _nRow )
.head 7 -  Set oRowData = FE_GetInfo( _nRow )
.head 7 -  Set sValue = oRowData.GetSValue( _sParam )
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return sValue
.head 5 +  Function: GetNValue
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 7 -  String: _sParam
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oRowData
.head 8 -  Class: cFERow
.head 7 -  Number: nValue
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, _nRow )
.head 7 -  Set oRowData = FE_GetInfo( _nRow )
.head 7 -  Set nValue = oRowData.GetNValue( _sParam )
.head 7 -  Call SalTblSetContext( hWndForm, nSelectedRow )
.head 7 -  Return nValue
.head 5 +  Function: RowIsChild
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nRowIsChild
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRow
.head 7 -  Boolean: bIsChild
.head 6 +  Actions
.head 7 -  Set bIsChild = FALSE
.head 7 -  Set nRow = MTblGetFirstChildRow( hWndForm, nParent )
.head 7 +  Loop
.head 8 +  If nRow = TBL_Error or bIsChild
.head 9 -  Break
.head 8 +  If nRow = nRowIsChild
.head 9 -  Set bIsChild = TRUE
.head 8 -  Set nRow = MTblGetNextChildRow( hWndForm, nRow )
.head 7 -  Return bIsChild
.head 5 +  Function: RowIsExpand
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowCheck
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblQueryRowFlags( hWndForm, nRowCheck, MTBL_ROW_ISEXPANDED )
.head 5 +  Function: RowIsParent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRowCheck
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return MTblIsParentRow( hWndForm, nRowCheck ) 
.head 5 +  Function: ExpandRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: _nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If RowIsParent( _nRow )
.head 8 +  If not RowIsExpand( _nRow )
.head 9 -  Call MTblExpandRow( hWndForm, _nRow, MTM_ExpandRow )
.head 5 -  !
.head 5 +  Function: SwitchSelectRow
.head 6 -  Description: Select/Unselect row
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 +  If colIDObject != -100
.head 8 +  If colCheck=1
.head 9 -  Set colCheck = 0
.head 9 -  Call oHandleSelect.UnselectRow( GetUniqRowID(nRow), GetSValue( nRow, "SEX" ) )
.head 8 +  Else
.head 9 -  Set colCheck = 1
.head 9 -  Call oHandleSelect.SelectRow( GetUniqRowID(nRow), GetSValue( nRow, "SEX" ) )
.head 8 -  Call ..ReAssignPic(nRow)
.head 7 -  Call SalTblSetContext ( hWndForm, nSelectedRow )
.head 5 +  Function: UnSelectAll
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  Set nI = 0
.head 7 +  While nI < oHandleSelect.nIndex
.head 8 -  Call SalTblSetContext( hWndForm, GetRowID(oHandleSelect.nRow[nI]) )
.head 8 -  Set colCheck = 0
.head 8 -  Call ..ReAssignPic(GetRowID(oHandleSelect.nRow[nI]))
.head 8 -  Set nI = nI + 1
.head 7 -  Call oHandleSelect.ReInit(  )
.head 5 +  Function: UnselectChild
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: _nParentRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowChild
.head 7 -  FunctionalVar: oRowData
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set nRowChild = MTblGetFirstChildRow( hWndForm, _nParentRow )
.head 7 +  Loop
.head 8 +  If nRowChild = TBL_Error
.head 9 -  Break
.head 8 -  Set oRowData = FE_GetInfo( nRowChild )
.head 8 -  Call oHandleSelect.UnselectRow( GetUniqRowID(nRowChild), oRowData.GetSValue( "Sex" ) )
.head 8 -  Set nRowChild = MTblGetNextChildRow( hWndForm, nRowChild )
.head 7 -  Return TRUE
.head 5 -  !
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call MTblSubClass( hWndItem )
.head 6 -  Call InitTable(  )
.head 5 +  On WM_Size
.head 6 -  Call SetSizeTree()
.head 5 +  On SAM_Timer
.head 6 +  If wParam = 10
.head 7 -  Call SalTimerKill ( hWndForm, 10 )
.head 7 -  Set bAutoSize = FALSE
.head 3 +  Child Table Class: cFallExplorer
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left:
.head 6 -  Top:
.head 6 -  Width:  1.2"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.833"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Class Default
.head 5 -  Discardable? Class Default
.head 4 -  Next Class Child Key: 30
.head 4 -  List in Tool Palette? Yes
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Description:
.head 4 +  Derived From
.head 5 -  Class: clsGeneralExplorer
.head 4 +  Contents
.head 5 +  Column: colTree
.head 6 -  Class Child Ref Key: 1
.head 6 -  Class ChildKey: 1
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: New animal list
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colIDObject
.head 6 -  Class Child Ref Key: 2
.head 6 -  Class ChildKey: 2
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colOrder
.head 6 -  Class Child Ref Key: 3
.head 6 -  Class ChildKey: 3
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCheck
.head 6 -  Class Child Ref Key: 4
.head 6 -  Class ChildKey: 4
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colFlags
.head 6 -  Class Child Ref Key: 5
.head 6 -  Class ChildKey: 5
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal1
.head 6 -  Class Child Ref Key: 6
.head 6 -  Class ChildKey: 6
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal2
.head 6 -  Class Child Ref Key: 7
.head 6 -  Class ChildKey: 7
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal3
.head 6 -  Class Child Ref Key: 8
.head 6 -  Class ChildKey: 8
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal4
.head 6 -  Class Child Ref Key: 9
.head 6 -  Class ChildKey: 9
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal5
.head 6 -  Class Child Ref Key: 10
.head 6 -  Class ChildKey: 10
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal6
.head 6 -  Class Child Ref Key: 11
.head 6 -  Class ChildKey: 11
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal7
.head 6 -  Class Child Ref Key: 12
.head 6 -  Class ChildKey: 12
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal8
.head 6 -  Class Child Ref Key: 13
.head 6 -  Class ChildKey: 13
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal9
.head 6 -  Class Child Ref Key: 14
.head 6 -  Class ChildKey: 14
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal10
.head 6 -  Class Child Ref Key: 15
.head 6 -  Class ChildKey: 15
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal11
.head 6 -  Class Child Ref Key: 16
.head 6 -  Class ChildKey: 16
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSVal12
.head 6 -  Class Child Ref Key: 17
.head 6 -  Class ChildKey: 17
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal1
.head 6 -  Class Child Ref Key: 18
.head 6 -  Class ChildKey: 18
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal2
.head 6 -  Class Child Ref Key: 19
.head 6 -  Class ChildKey: 19
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal3
.head 6 -  Class Child Ref Key: 20
.head 6 -  Class ChildKey: 20
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal4
.head 6 -  Class Child Ref Key: 21
.head 6 -  Class ChildKey: 21
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal5
.head 6 -  Class Child Ref Key: 22
.head 6 -  Class ChildKey: 22
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal6
.head 6 -  Class Child Ref Key: 23
.head 6 -  Class ChildKey: 23
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal7
.head 6 -  Class Child Ref Key: 24
.head 6 -  Class ChildKey: 24
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal8
.head 6 -  Class Child Ref Key: 25
.head 6 -  Class ChildKey: 25
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal9
.head 6 -  Class Child Ref Key: 26
.head 6 -  Class ChildKey: 26
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNVal10
.head 6 -  Class Child Ref Key: 27
.head 6 -  Class ChildKey: 27
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal1
.head 6 -  Class Child Ref Key: 28
.head 6 -  Class ChildKey: 28
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDtVal2
.head 6 -  Class Child Ref Key: 29
.head 6 -  Class ChildKey: 29
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDetailInfo
.head 6 -  Class Child Ref Key: 30
.head 6 -  Class ChildKey: 30
.head 6 -  Class: clsGeneralExplorer
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  FunctionalVar: oSettingsRoot
.head 6 -  Class: oSettingsAE
.head 5 -  FunctionalVar: oSettingsWorkGroup
.head 6 -  Class: oSettingsAE
.head 5 -  FunctionalVar: oSettingsAnimal
.head 6 -  Class: oSettingsAE
.head 5 -  FunctionalVar: oSettingsStrain
.head 6 -  Class: oSettingsAE
.head 5 -  FunctionalVar: oSettingsService
.head 6 -  Class: oSettingsAE
.head 5 -  !
.head 5 -  Session Handle: hSessionGE
.head 5 -  Sql Handle: hSqlPopulate
.head 5 -  Sql Handle: hSqlPopulate1
.head 5 -  FunctionalVar: oSqlL1
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL2
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL3
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlL4
.head 6 -  Class: cFE_Sqls
.head 5 -  FunctionalVar: oSqlUTable
.head 6 -  Class: cFE_Sqls
.head 5 -  !
.head 5 -  ! cFilterFE: cScreenFilter
.head 5 -  ! cFilterFE: cAnimalFilter
.head 5 -  ! cFilterFE: cStrainFilter
.head 5 -  FunctionalVar: cFullFilter
.head 6 -  Class: cFilterAnimalList
.head 5 -  String: sFullFilter
.head 5 -  ! cFilterAnimalList: cFullFilter
.head 5 -  FunctionalVar: cScreenSort
.head 6 -  Class: cSortFE
.head 5 -  FunctionalVar: cAnimalSort
.head 6 -  Class: cSortFE
.head 5 -  FunctionalVar: cStrainSort
.head 6 -  Class: cSortFE
.head 5 -  !
.head 5 -  Boolean: bPopulateOnFirstShow
.head 5 -  Boolean: bProgressBarOnPopulate
.head 5 -  ! Variables for user table
.head 5 -  Number: nUniqRow
.head 5 -  Number: nObjID
.head 5 -  Number: nLevel
.head 5 -  Number: nStatus
.head 5 -  Number: nObjIDParent
.head 5 -  !
.head 5 -  Number: nBGColor
.head 5 -  ! Temporary variables
.head 5 -  Boolean: bSelectF
.head 5 -  Boolean: bSelectM
.head 5 -  Number: naSelectFE[1]
.head 5 -  Number: nActiveLevel
.head 5 -  Boolean: bServisMove
.head 5 -  Boolean: bServisDischarg
.head 5 -  String: sActiveKey
.head 5 -  !
.head 5 -  Number: nRowSetCont
.head 5 -  Boolean: bShowDischargeAnimal
.head 5 -  Boolean: bShowAnimalPlanMove
.head 5 -  Boolean: bShowAnimalMate
.head 5 -  Boolean: bShowService
.head 5 -  Boolean: bFillterOn
.head 5 -  Boolean: bSortOn
.head 5 -  Boolean: bShowCullingAnimal
.head 5 -  Boolean: bNeedPrefix
.head 5 -  !
.head 5 -  Number: nFlags
.head 5 -  Number: nRowFlags
.head 5 -  ! Long String: lsInfoDetail
.head 5 -  Boolean: bNeedRefreshOnShow
.head 5 -  !
.head 5 -  String: sCurrentScreen
.head 4 +  Functions
.head 5 +  Function: LoadSettings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sSection
.head 6 +  Actions
.head 7 -  Set nRoot = -1
.head 7 -  Set sSection = "AE"
.head 7 -  Call oSettingsRoot.Init( "Root" )
.head 7 -  Call oSettingsWorkGroup.Init("Screen")
.head 7 -  Call oSettingsAnimal.Init("Animals")
.head 7 -  Call oSettingsStrain.Init("Strain")
.head 7 -  ! Call oSettingsService.Init("Service")
.head 7 -  Set bShowDischargeAnimal = GetOptionBoolean(sSection, "ShowDischargeAnimal", FALSE  )
.head 7 -  Set bShowCullingAnimal = GetOptionBoolean(sSection, "ShowDeathAnimal", FALSE  )
.head 7 -  Set bShowAnimalPlanMove = GetOptionBoolean(sSection, "ShowInPlan", FALSE  )
.head 7 -  Set bShowAnimalMate = GetOptionBoolean(sSection, "ShowInMate", FALSE  )
.head 7 -  Set bShowService = GetOptionBoolean(sSection, "ShowServices", FALSE  )
.head 7 -  Set bFillterOn = GetOptionBoolean(sSection, "FilterOn", FALSE  )
.head 7 -  Set bSortOn = GetOptionBoolean(sSection, "SortOn", FALSE  )
.head 7 -  Set bNeedPrefix = GetOptionBoolean(sSection, "NeedPrefix", TRUE  )
.head 7 -  Set nBGColor = COLOR_White
.head 7 -  !
.head 7 -  Call cScreenSort.Init( "AE_SortScreen", "Screen" )
.head 7 -  Call cAnimalSort.Init( "AE_SortAnimal", "Fall,Sex,Birth date,Batch,Rack,Cage,Experiment,Genotype,MatingID" )
.head 7 -  Call cStrainSort.Init( "AE_SortService", "Strain" )
.head 7 -  ! Call cScreenFilter.Init( "AE_FiterScreen", "Screen,  a.ABT_KEY" )
.head 7 -  ! Call cAnimalFilter.Init( "AE_FiterAnimal", "Fall,  f.FALL_KEY;
		    Sex,  f.SEX;
		    Birth date,  f.BIRTHDATE;
		    Batch,  f.BATCH;
		    Rack,  f.RACK;
		    Cage, f.CAGE;
		    Experiment, f.EXPERIMENT;
		    Genotype, f.genotype;
		    MateID, f.MateID;
		    Plan, f.inPlan;
		    Age, f.Age
		     " )
.head 7 -  ! Call cStrainFilter.Init( "AE_FiterService", "Strain,  s.strain_key
				 " )
.head 7 -  Call cFullFilter.Init( "AE_Filter" )
.head 7 -  !
.head 7 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 7 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 5 +  Function: CreateTmpTable
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bExists
.head 7 -  String: strNull
.head 6 +  Actions
.head 7 -  Set bOk = SqlExists( "select * from sysadm.systables where name='ANIMALLISTTREE' and creator=:sUserName ", bExists )
.head 7 -  Set strNull = STRING_Null
.head 7 +  If bExists
.head 8 -  Set bOk =bOk and SqlPrepareAndExecute( oSqlUTable.hSql[0], "drop table " || sUserName || ".ANIMALLISTTREE" )	
.head 7 -  Set bOk =bOk and SqlPrepareAndExecute( oSqlUTable.hSql[0], "create table " || sUserName || ".AnimalListTree (UniqRow integer not null, id_obj integer not null, level smallint not null , status smallint ,ID_parent integer not null with default 
,primary key (UniqRow))" )	
.head 7 -  Set bOk =bOk and SqlPrepareAndExecute( oSqlUTable.hSql[0], "create unique index " || sUserName || ".PKX_tree1 on " || sUserName || ".AnimalListTree(uniqrow)" )	
.head 7 -  Set bOk =bOk and SqlPrepareAndExecute( oSqlUTable.hSql[0], "create unique index " || sUserName || ".PKX_tree2 on " || sUserName || ".AnimalListTree(id_obj,level,ID_parent)" )	
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[0], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[0], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[1], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[1], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[2], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[2], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[3], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[3], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[4], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[4], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[5], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[5], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[6], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[6], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[7], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[7], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[8], DBP_AUTOCOMMIT, TRUE, strNull )
.head 7 -  Set bOk = bOk and SqlSetParameter( oSqlUTable.hSql[8], DBP_PRESERVE, TRUE, strNull )
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[0], "insert into " || sUserName || ".AnimalListTree (uniqrow,id_obj,level, status, ID_parent ) values (:nUniqRow, :nObjID, :nLevel, :nStatus , :nObjIDParent)" )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[1], "delete from " || sUserName || ".AnimalListTree where uniqrow=:nUniqRow " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[2], "select uniqrow from " || sUserName || ".AnimalListTree where id_obj=:nObjID and  level = :nLevel and ID_parent=:nObjIDParent into :nUniqRow " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[3], "update " || sUserName || ".AnimalListTree set status=:nStatus where level = :nLevel " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[4], "select uniqrow from " || sUserName || ".AnimalListTree where   level = :nLevel and status =:nStatus and ID_parent=:nObjIDParent into :nUniqRow " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[5], "update " || sUserName || ".AnimalListTree set status=:nStatus where uniqrow=:nUniqRow " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[6], "select uniqrow from " || sUserName || ".AnimalListTree where   level = :nLevel  into :nUniqRow " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[7], "select uniqrow from " || sUserName || ".AnimalListTree where   level = :nLevel and status =:nStatus  into :nUniqRow " )	
.head 7 -  Set bOk =bOk and SqlPrepare( oSqlUTable.hSql[8], "update " || sUserName || ".AnimalListTree set status=:nStatus where level = :nLevel and ID_parent=:nObjIDParent " )	
.head 7 -  Return bOk
.head 5 +  Function: FirstPopulate
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 +  If hWndStartInfoDlg And VisWinIsWindow( hWndStartInfoDlg )
.head 8 -  Call SalDestroyWindow( hWndStartInfoDlg )
.head 8 -  Set hWndStartInfoDlg = hWndNULL
.head 7 +  If not bPopulateOnFirstShow
.head 8 +  If hWndProgress = hWndNULL
.head 9 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,10  )
.head 8 -  ! Call dlgProgress.SetText( "Populate animal list. Please wait...")
.head 8 -  Set sFullFilter =cFullFilter.GetSQLString()
.head 8 -  Call PopulateRoot()
.head 8 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 8 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 8 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 8 -  Call SortTree()
.head 8 -  Set bPopulateOnFirstShow = TRUE
.head 8 +  If hWndProgress
.head 9 -  Call SalDestroyWindow( hWndProgress )
.head 9 -  Set hWndProgress = hWndNULL
.head 5 +  Function: PopulateRoot
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  String: sSQL1
.head 7 -  Number: nID
.head 7 -  Number: nTreeURowID
.head 7 -  Number: nFetch
.head 7 -  Number: nWRow
.head 7 -  Number: nRow
.head 7 -  String: strNull
.head 7 -  Number: nCountRow
.head 7 -  String: sFilter
.head 7 -  FunctionalVar: cRoot
.head 8 -  Class: cAERowRoot
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  ! Prepare SQL statements
.head 7 +  If not oSqlL1.bPrepare
.head 8 -  Set sSQL1 = "
select	 a.id,@nullvalue(t.uniqrow,-1),@nullvalue(u.TOP,9999)
into	 :nID, :nTreeURowID
from 	ABTEILUNG a
left join " || sUserName || ".AnimalListTree t on (t.id_obj=a.id and t.level=2) , user_screen u
where	a.EINRICHT_ID = :nEinrichtId
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	u.user_ID= :nUserId
   and 	u.scr_id = a.id and @nullvalue(u.hide,0) = 0
 "
.head 8 -  ! Set sFilter =cScreenFilter.GetFilterS(  )
.head 8 -  ! Set sFullFilter =cFullFilter.GetSQLString()
.head 8 +  If sFullFilter and sFullFilter != " " and cFullFilter.bFilterScreen
.head 9 -  Set bFillterOn = TRUE
.head 9 -  ! Set sSQL1 = sSQL1 || sFilter
.head 9 -  Set sSQL1 = sSQL1 || "
and a.id in (select f.scr_id from animallist f where " || sFullFilter || " )"
.head 8 -  Set sSQL1 = sSQL1 || "
group by	a.id,u.TOP, t.uniqrow
order by	3 "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL1.hSql[0], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL1.hSql[0],sSQL1) 
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL1.hSql[1], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL1.hSql[1], "select	 A.NAME1, A.NAME2, e.EINRICHT_ID,@nullvalue(t.uniqrow,-1)
from 	EINRICHTUNG E
left join " || sUserName || ".AnimalListTree t on (t.id_obj=E.EINRICHT_ID and t.level=1), ADRESSE a
where	E.ADRESSE_ID = A.ADRESSE_ID
   and	E.EINRICHT_ID = " || StrX( nEinrichtId ) || "
into	:s[0], :s[1], :nID, :nTreeURowID ") 
.head 8 +  If bOk
.head 9 -  Set oSqlL1.bPrepare = TRUE
.head 8 -  !
.head 7 +  If TRUE ! insert info 
.head 8 -  Call cRoot.Init(  )
.head 8 -  Set bOk  =  bOk and SqlExecute( oSqlL1.hSql[1] ) and SqlFetchNext( oSqlL1.hSql[1], nFetch )
.head 8 +  If bOk
.head 9 -  Set cRoot.sName = strEinrichtKey
.head 9 -  Set cRoot.sDescr = s[0] || ' ' || s[1]
.head 9 -  Set cRoot.nLabelFlags = oSettingsRoot.nFlags
.head 9 -  Set cRoot.nID_Obj = nID
.head 9 -  Set cRoot.nOrder = 1
.head 9 +  If nTreeURowID != -1
.head 10 -  Set nWRow = GetRowID( nTreeURowID )
.head 10 -  Set nUniqRow = nTreeURowID
.head 10 -  Set nStatus = 1
.head 10 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[5] )
.head 9 +  Else
.head 10 -  Set nWRow = FE_NewRow(-1)
.head 10 -  Set nUniqRow = GetUniqRowID( nWRow )
.head 10 -  Set nObjID = nID
.head 10 -  Set nLevel = AEL_Root + 1
.head 10 -  Set nStatus = 1
.head 10 -  Set nObjIDParent = -1
.head 10 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[0] )
.head 9 -  Call FE_SetInfo(nWRow,cRoot )
.head 9 -  ! Set nRow = FindObject(TBL_MinRow, nID )
.head 9 +  ! If nRow = -1
.head 10 -  Set nRow = FE_NewRow(-1)
.head 9 -  ! Call FE_SetInfo(nRow,cInfo )
.head 9 -  Set nRoot = nRow
.head 7 -  Set bOk  =  bOk and SqlExecute( oSqlL1.hSql[0] )
.head 7 -  Set bOk  =  bOk and SqlGetResultSetCount(  oSqlL1.hSql[0] , nCountRow )
.head 7 +  If hWndProgress
.head 8 +  If nCountRow = 0
.head 9 -  Set nCountRow = 1
.head 8 -  Call dlgProgress.Init( nCountRow, "Populate animal list. Please wait... " )
.head 7 +  While bOk and SqlFetchNext( oSqlL1.hSql[0], nFetch )
.head 8 +  If nTreeURowID != -1
.head 9 -  Set nWRow = GetRowID( nTreeURowID )
.head 9 -  Set nUniqRow = nTreeURowID
.head 9 -  Set nStatus = 1
.head 9 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[5] )
.head 8 +  Else
.head 9 -  Set nWRow = FE_NewRow(nRoot)
.head 9 -  Set nUniqRow = GetUniqRowID( nWRow )
.head 9 -  Set nObjID = nID
.head 9 -  Set nLevel = AEL_Workgroup + 1
.head 9 -  Set nStatus = 1
.head 9 -  Set nObjIDParent = cRoot.nID_Obj 
.head 9 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[0] )
.head 8 -  Call SalTblSetContext( hWndForm, nWRow )
.head 8 -  Set colIDObject =  nID
.head 8 -  Call PopulateWorkgroup( nWRow, TRUE )
.head 8 +  If hWndProgress
.head 9 -  Call dlgProgress.Next(  )
.head 7 -  Call SalStatusSetText( hWndForm, '' )
.head 5 +  Function: PopulateWorkgroup
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  Boolean: bPopulateChildren
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nID
.head 7 -  Number: nTreeURowID
.head 7 -  Number: nTop
.head 7 -  FunctionalVar: cWG_Row
.head 8 -  Class: cAERowScr
.head 7 -  Number: nRowA
.head 7 -  String: sSQL
.head 7 -  Number: nFetch
.head 7 -  String: strNull
.head 7 -  Number: nStrainID
.head 7 -  Number: nColony
.head 7 -  String: sFilter
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 -  Set nID = colIDObject
.head 7 -  ! Prepare SQL statements
.head 7 +  If not oSqlL2.bPrepare
.head 8 -  Set sSQL = "
select	a.ABT_KEY,a.ABT_BEZ, @NULLVALUE (u.TOP, 0), a.color, a.TEXTCOLOR, a.email
into :cWG_Row.sScreen, :cWG_Row.sDescr, :nTop, :cWG_Row.nBG_Color, :cWG_Row.nTX_Color, :cWG_Row.sEmail 
from 	ABTEILUNG a, user_screen u
where	a.ID = :nID
   and	a.CANCELED = 'N'
   and	a.WITH_BEDS = 'J'
   and	u.USER_ID= :nUserId 
   and 	u.scr_id = a.ID and @nullvalue(u.hide,0) = 0
 "
.head 8 -  Set sSQL = sSQL || "
group by	a.ABT_BEZ, a.ABT_KEY, u.TOP, a.color, a.TEXTCOLOR, a.email
"
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL2.hSql[0], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL2.hSql[0], sSQL)
.head 8 -  Set sSQL = "select distinct f.strainid, f.colony, @nullvalue(t.uniqrow,-1)
into :nStrainID , :nColony, :nTreeURowID
from sysadm.animallist f 
join strain s on (s.id=f.strainid )
left join " || sUserName || ".AnimalListTree t on (t.id_obj=(f.strainid + 65536*f.colony ) and t.level=3 and ID_parent=:nID  ) 
where f.scr_id=:nID 
" 
.head 8 +  If not bShowCullingAnimal
.head 9 -  Set sSQL = sSQL || " and @nullvalue(f.CULLINGID,0) = 0 
"
.head 8 +  If not bShowAnimalMate
.head 9 -  Set sSQL = sSQL || " and @nullvalue(f.MATEID,0) = 0 
"
.head 8 -  ! Set sFilter =cStrainFilter.GetFilterS(  )
.head 8 +  If sFullFilter and sFullFilter != " "
.head 9 -  Set bFillterOn = TRUE
.head 9 -  ! Set sSQL = sSQL || sFilter
.head 9 -  Set sSQL = sSQL || "
and " || sFullFilter
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL2.hSql[1], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL2.hSql[1], sSQL)
.head 8 -  Set sSQL = "select * from screen_rack sr
join station s on (s.id=sr.rack_id and virtual='J')
where sr.scr_id=:nID  "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL2.hSql[2], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL2.hSql[2], sSQL)
.head 8 +  If bOk
.head 9 -  Set oSqlL2.bPrepare = TRUE
.head 8 -  !
.head 7 +  If TRUE ! Execute
.head 8 -  Call cWG_Row.Init()
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL2.hSql[0])
.head 8 -  Set bOk = bOk and SqlFetchNext(oSqlL2.hSql[0], nFetch )
.head 7 +  If TRUE
.head 8 -  Call SalStatusSetText( hWndForm, 'Populate: ' || cWG_Row.sScreen )
.head 8 +  If hWndProgress
.head 9 -  Call dlgProgress.SetText( "Populate animal list. Workgroup:  " || cWG_Row.sScreen )
.head 8 +  If bOk ! insert info screen 
.head 9 -  Set cWG_Row.nID_Obj = nID
.head 9 -  Set cWG_Row.nOrder = colOrder
.head 9 -  ! Set cWG_Row.sScreen = sKey
.head 9 -  ! Set cWG_Row.sDescr = sDescr
.head 9 -  Set cWG_Row.nLabelFlags = oSettingsWorkGroup.nFlags
.head 9 -  Set cWG_Row.sInfo = D_GetMessageStatic_w_Nr(5020,1) || cWG_Row.sScreen || "
" || D_GetMessageStatic_w_Nr(5020,4) || cWG_Row.sDescr || "
" || D_GetMessageStatic_w_Nr(5020,5) ||  cWG_Row.sEmail
.head 9 +  If bOk and SqlExecute( oSqlL2.hSql[2]) and SqlFetchNext( oSqlL2.hSql[2], nFetch )
.head 10 -  Call cWG_Row.SetState( RackIsVirtual  )
.head 9 -  Call FE_SetInfo(nRow,cWG_Row )
.head 9 +  If (cWG_Row.nBG_Color or cWG_Row.nTX_Color) and cWG_Row.nBG_Color!= cWG_Row.nTX_Color
.head 10 -  Call MTblSetRowTextColor( hWndItem, nRow, cWG_Row.nTX_Color, MTSC_REDRAW )
.head 10 -  Call MTblSetRowBackColor( hWndItem, nRow, cWG_Row.nBG_Color, MTSC_REDRAW )
.head 9 +  Else
.head 10 -  Call MTblSetRowTextColor( hWndItem, nRow, COLOR_Black, MTSC_REDRAW )
.head 10 -  Call MTblSetRowBackColor( hWndItem, nRow, nBGColor, MTSC_REDRAW )
.head 7 +  If bPopulateChildren
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL2.hSql[1])
.head 8 -  Set nStatus = 2
.head 8 -  Set nObjIDParent = nID
.head 8 -  Set nLevel = AEL_Workgroup + 1
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[8])
.head 8 +  While bOk and SqlFetchNext(oSqlL2.hSql[1], nFetch )
.head 9 +  If nTreeURowID != -1
.head 10 -  Set nRowA = GetRowID( nTreeURowID )
.head 10 -  Set nUniqRow = nTreeURowID
.head 10 -  Set nStatus = 1
.head 10 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[5] )
.head 9 +  Else
.head 10 -  Set nRowA = FE_NewRow(nRow)
.head 10 -  Set nUniqRow = GetUniqRowID( nRowA )
.head 10 -  Set nObjID = (nStrainID + 0x10000 * nColony)
.head 10 -  Set nLevel = AEL_Strain + 1
.head 10 -  Set nStatus = 1
.head 10 -  Set nObjIDParent = nID
.head 10 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[0] )
.head 9 -  Call SalTblSetContext( hWndForm, nRowA )
.head 9 -  Set colIDObject =  nStrainID + 0x10000 * nColony
.head 9 -  ! Call SalTblSetColumnText ( hWndForm, SalTblQueryColumnID ( hWndNCol[2]), SalNumberToStrX(nColony,0) )
.head 9 -  Call PopulateStrain( nRowA, FALSE )
.head 8 -  Set bOk = bOk and  DeleteTmpRows(1,nID)
.head 7 +  ! If TRUE
.head 8 -  Call cR_Row.Clear()
.head 8 -  Set cR_Row.sLabel = "Hide"
.head 8 -  Set cR_Row.nID_Obj = -100
.head 8 -  Set cR_Row.nOrder = -100
.head 8 -  Set nRow = FindObject(nRowWG, -100 )
.head 8 +  If nRow = -1
.head 9 -  Set nRow = FE_NewRow(nRowWG)
.head 8 -  Call FE_SetInfo(nRow,cR_Row )
.head 5 +  Function: PopulateStrain
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  Boolean: bPopulateChildren
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nID
.head 7 -  Number: nIDFull
.head 7 -  Number: nColonyNr
.head 7 -  String: sSQL
.head 7 -  String: strNull
.head 7 -  FunctionalVar: cRowSt
.head 8 -  Class: cAERowStrain
.head 7 -  Number: nFallID
.head 7 -  Number: nTreeURowID
.head 7 -  Number: nSCRID
.head 7 -  Number: nFtch
.head 7 -  Number: nRowS
.head 7 -  String: sFilter
.head 7 -  Number: nVas
.head 7 -  Number: nGVO
.head 7 -  Number: nCountRow
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 -  Set nID = colIDObject & 65535
.head 7 -  Set nIDFull = colIDObject
.head 7 -  Set nColonyNr = (colIDObject-nID)/65536
.head 7 -  Set nSCRID = GetIdObject( GetParent( nRow ) )
.head 7 -  Call cRowSt.Init(  )
.head 7 -  ! Prepare SQL statements
.head 7 +  If not oSqlL3.bPrepare
.head 8 -  Set sSQL = "
select s.strain_key,s.mutation1, s.mutation2, s.mutation3, s.mutation4, s.mutation5, s.mutation6, s.mutation7, s.strain_color, s.strain_bg, s2.strain_key, @nullvalue(s.vas,0), @nullvalue(s.GVO,0) 
into :cRowSt.sName, :cRowSt.sMut1, :cRowSt.sMut2, :cRowSt.sMut3, :cRowSt.sMut4, :cRowSt.sMut5, :cRowSt.sMut6,
:cRowSt.sMut7, :cRowSt.nTX_Color, :cRowSt.nBG_Color, :cRowSt.sBgStrain, :nVas, :nGVO
from strain s 
left join strain s2 on (s2.id=s.strain_bg_id)
where s.id=:nID 
 "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL3.hSql[0], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[0], sSQL)
.head 8 -  Set sSQL = "select f.fall_key,  @nullvalue(t.uniqrow,-1)
into :nFallID , :nTreeURowID
from sysadm.animallist f 
left join " || sUserName || ".AnimalListTree t on (t.id_obj=f.fall_key and t.level=4  and ID_parent=:nIDFull ) 
where f.strainid = :nID and scr_id=:nSCRID and f.colony=:nColonyNr
" 
.head 8 +  If not bShowCullingAnimal
.head 9 -  Set sSQL = sSQL || "
and @nullvalue(f.CULLINGID,0) = 0 
"
.head 8 +  If not bShowAnimalMate
.head 9 -  Set sSQL = sSQL || "
and @nullvalue(f.MATEID,0) = 0 
"
.head 8 +  If not bShowAnimalPlanMove
.head 9 -  Set sSQL = sSQL || "
and @nullvalue(f.inPlan,0)= 0 
"
.head 8 -  ! Set sFilter =cAnimalFilter.GetFilterS(  )
.head 8 +  If sFullFilter and sFullFilter != " "
.head 9 -  Set bFillterOn = TRUE
.head 9 -  ! Set sSQL = sSQL || sFilter
.head 9 -  Set sSQL = sSQL || "
and " || sFullFilter
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL3.hSql[1], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL3.hSql[1], sSQL)
.head 8 +  If bOk
.head 9 -  Set oSqlL3.bPrepare = TRUE
.head 8 -  !
.head 7 +  If TRUE
.head 8 -  ! Call SalStatusSetText( hWndForm, 'Populate: ' || sKey )
.head 8 +  ! If hWndProgress
.head 9 -  Call dlgProgress.SetText( "Populate animal list. strain:  " || sKey )
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[0])
.head 8 -  Set bOk = bOk and SqlFetchNext(oSqlL3.hSql[0],nFtch)
.head 8 +  If bOk ! insert info strain
.head 9 -  Set cRowSt.nID_Obj = nIDFull
.head 9 -  Set nSCRID = GetIdObject( GetParent( nRow ) )
.head 9 -  Set cRowSt.nLabelFlags = oSettingsStrain.nFlags
.head 9 -  Set cRowSt.sInfo = D_GetMessageStatic_w_Nr(5020,2) || cRowSt.sName || "
" || D_GetMessageStatic_w_Nr(5020,6) || cRowSt.sMut1 || "
" || D_GetMessageStatic_w_Nr(5020,7) || cRowSt.sMut2 || "
" || D_GetMessageStatic_w_Nr(5020,8) ||cRowSt.sMut3 || "
" || D_GetMessageStatic_w_Nr(5020,9) || cRowSt.sMut4 || "
" || D_GetMessageStatic_w_Nr(5020,10) ||cRowSt.sMut5 || "
" || D_GetMessageStatic_w_Nr(5020,11) || cRowSt.sMut6 || "
" || D_GetMessageStatic_w_Nr(5020,12) || cRowSt.sMut7 || "
" || D_GetMessageStatic_w_Nr(5020,25) || SalNumberToStrX(nColonyNr,0)
.head 9 -  Set cRowSt.sInfo= cRowSt.sInfo || "
" ||D_GetMessageStatic_w_Nr(5020,13) ||cRowSt.sBgStrain
.head 9 +  If nVas
.head 10 -  Call cRowSt.SetState( StrainIsVas )
.head 10 -  Set cRowSt.sInfo= cRowSt.sInfo || "
VAS: " || D_GetMessageStatic_w_Nr(10004,1) 
.head 9 +  Else
.head 10 -  Set cRowSt.sInfo= cRowSt.sInfo || "
VAS: " || D_GetMessageStatic_w_Nr(10005,1) 
.head 9 +  If nGVO
.head 10 -  Call cRowSt.SetState( StrainIsGVO  )
.head 10 -  Set cRowSt.sInfo= cRowSt.sInfo || "
GVO: " || D_GetMessageStatic_w_Nr(10004,1) 
.head 9 +  Else
.head 10 -  Set cRowSt.sInfo= cRowSt.sInfo || "
GVO: " || D_GetMessageStatic_w_Nr(10005,1)
.head 9 -  Set cRowSt.nColonyNr = nColonyNr
.head 9 -  Call FE_SetInfo(nRow,cRowSt )
.head 9 +  If (cRowSt.nBG_Color or cRowSt.nTX_Color) and cRowSt.nBG_Color !=cRowSt.nTX_Color
.head 10 -  Call MTblSetRowTextColor( hWndItem, nRow, cRowSt.nTX_Color, MTSC_REDRAW )
.head 10 -  Call MTblSetRowBackColor( hWndItem, nRow, cRowSt.nBG_Color, MTSC_REDRAW )
.head 9 +  Else
.head 10 -  Call MTblSetRowTextColor( hWndItem, nRow, COLOR_Black, MTSC_REDRAW )
.head 10 -  Call MTblSetRowBackColor( hWndItem, nRow, nBGColor, MTSC_REDRAW )
.head 9 -  Set nUniqRow = GetUniqRowID( nRow )
.head 9 -  Set nStatus = 1
.head 9 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[5] )
.head 7 +  If bPopulateChildren
.head 8 -  Set nStatus = 2
.head 8 -  Set nObjIDParent = nIDFull
.head 8 -  Set nLevel = AEL_Strain + 1
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[8])
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL3.hSql[1])
.head 8 -  Set bOk  =  bOk and SqlGetResultSetCount(  oSqlL3.hSql[1] , nCountRow )
.head 8 +  If hWndProgress and bProgressBarOnPopulate
.head 9 +  If nCountRow = 0
.head 10 -  Set nCountRow = 1
.head 9 -  Call dlgProgress.Init( nCountRow, "Populate strain. Please wait... " )
.head 8 +  While bOk and SqlFetchNext(oSqlL3.hSql[1], nFtch )
.head 9 +  If nTreeURowID != -1
.head 10 -  Set nRowS = GetRowID( nTreeURowID )
.head 10 -  Set nUniqRow = nTreeURowID
.head 10 -  Set nStatus = 1
.head 10 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[5] )
.head 9 +  Else
.head 10 -  Set nRowS = FE_NewRow(nRow)
.head 10 -  Set nUniqRow = GetUniqRowID( nRowS )
.head 10 -  Set nObjID = nFallID
.head 10 -  Set nLevel = AEL_Animal  + 1
.head 10 -  Set nStatus = 1
.head 10 -  Set nObjIDParent = nIDFull
.head 10 -  Set bOk =bOk and SqlExecute( oSqlUTable.hSql[0] )
.head 9 -  Call SalTblSetContext( hWndForm, nRowS )
.head 9 -  Set colIDObject =  nFallID
.head 9 -  Call PopulateAnimal( nRowS, FALSE )
.head 9 -  Set bOk = bOk and  DeleteTmpRows(3, nFallID)
.head 9 +  If hWndProgress and bProgressBarOnPopulate
.head 10 -  Call dlgProgress.Next(  )
.head 5 +  Function: PopulateAnimal
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  Boolean: bPopulateChildren
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nID
.head 7 -  String: sSQL
.head 7 -  String: strNull
.head 7 -  Number: nFetch
.head 7 -  Number: nFallInPlan
.head 7 -  !
.head 7 -  Number: nCulling
.head 7 -  Number: nAlert
.head 7 -  String: sPlanDetails
.head 7 -  String: sDetatilInfo
.head 7 -  String: sPlanLoc
.head 7 -  !
.head 7 -  FunctionalVar: cA_Row
.head 8 -  Class: cAERowAnimal
.head 7 -  String: sVars[2]
.head 6 +  Actions
.head 7 -  Set bOk = TRUE
.head 7 -  Call SalTblSetContext( hWndForm, nRow )
.head 7 -  Set nID = colIDObject
.head 7 -  ! Prepare SQL statements
.head 7 +  If not oSqlL4.bPrepare
.head 8 -  Set sSQL = "select eartag, strain, sex, experiment,batch,age,cage,rack,cullingid,mateid , birthdate,FOREIGNID,genotype , phenotype, BreedingNR
into :cA_Row.sEarTag, :cA_Row.sStrain, :cA_Row.sSex, :cA_Row.sExp, :cA_Row.nBatch, :cA_Row.nAge,
:cA_Row.sCage, :cA_Row.sRack, :nCulling, :cA_Row.nMateID , :cA_Row.dtBirthDate, :cA_Row.sForeign, 
:cA_Row.sGenotype, :cA_Row.sPhenotype, :cA_Row.sBreedingNr
from sysadm.animallist
where fall_key=:nID
 "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL4.hSql[0], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL4.hSql[0], sSQL)
.head 8 -  ! Check Alerts
.head 8 -  Set sSQL = "select l.lst_key || ' date ' || l.LST_ERF_VON , @NULLVALUE(lst.isAlert, 0) + 1
from  sysadm.LST_ERF l, sysadm.leistung lst
where  l.FALL_KEY= :nID
and	l.done= 0
and lst.lst_key = l.lst_key
and lst.tarif_key = l.tarif_key
and lst.einricht_id=l.einricht_id
and @NULLVALUE(l.storniert, 'N') = 'N'
and 	l.LST_ERF_VON<@now
order by 2 desc
into :sPlanDetails, :nAlert "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL4.hSql[1], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL4.hSql[1], sSQL)
.head 8 -  Set sSQL = "select LA2.ITEM_FALL_KEY, bl.stat_key || '/' || bl.gruppe_key 
into :nFallInPlan, :sPlanLoc
from BEWEGUNG_PLAN bp
join bett_locks bl on (bl.planbew_fall=bp.fall_key and bl.planbew_bew=bp.bew_nr )
left join lst_adm_todo_items la on (la.item_fall_key=bp.fall_key and la.item_bew_nr=bp.bew_nr)
join lst_erf s on (s.fall_key=la.fall_key and s.lst_erf_nr=la.lst_erf_nr  and s.done=0 and s.STORNIERT='N' )
left join lst_adm_todo_items la2 on (la2.fall_key=s.fall_key and la2.lst_erf_nr=s.lst_erf_nr) 
where bp.fall_key= :nID "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL4.hSql[2], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL4.hSql[2], sSQL)
.head 8 -  Set sSQL = "select f.fall_key|| ' ' || f.GEB_DATUM || ' ' || f.GESCHL || ' S:' || f.NAME3_ABR || ' L:' || fe.experiment_key 
into :sPlanDetails
from fall f 
left join fall_experiment fe on (fe.fall_key=f.fall_key and @nullvalue(FE.END_DATE,@now+365) >@now)
where f.fall_key=:nFallInPlan "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL4.hSql[3], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL4.hSql[3], sSQL)
.head 8 -  Set sSQL = "select rf.fall_key || ' ' ||f.geschl || ' ' ||  f.name3_abr || ' Start: '|| @DATETOCHAR(rf.rs_fall_start,'yyyy-mm-dd') || ' End: ' || @DATETOCHAR(rf.rs_fall_end,'yyyy-mm-dd')  
into :sPlanDetails
from relship_fall rf
join fall f on (f.fall_key=rf.fall_key and f.einricht_id=rf.einricht_id)
 where rf.relship_id=:cA_Row.nMateID "
.head 8 -  Set bOk = bOk and SqlSetParameter( oSqlL4.hSql[4], DBP_PRESERVE, TRUE, strNull )
.head 8 -  Set bOk = bOk and SqlPrepare(oSqlL4.hSql[4], sSQL)
.head 8 -  ! Set sSQL = "select f.fall_key,  @nullvalue(t.uniqrow,-1)
into :nFallID , :nTreeURowID
from fall f 
left join " || sUserName || ".AnimalListTree t on (t.id_obj=f.fall_key and t.level=2) where f.last_scr_id=:nID " 
.head 8 -  ! Set bOk = bOk and SqlSetParameter( oSqlL2.hSql[1], DBP_PRESERVE, TRUE, strNull )
.head 8 -  ! Set bOk = bOk and SqlPrepare(oSqlL2.hSql[1], sSQL)
.head 8 +  If bOk
.head 9 -  Set oSqlL4.bPrepare = TRUE
.head 8 -  !
.head 7 +  If TRUE ! Execute
.head 8 -  Call cA_Row.Init(  )
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[0])
.head 8 -  Set bOk = bOk and SqlFetchNext(oSqlL4.hSql[0], nFetch )
.head 8 -  !
.head 8 -  Call SalDateToStr( cA_Row.dtBirthDate, s1 )
.head 8 -  Call SalStrLeft( s1, 10, s1 )
.head 8 -  Set sDetatilInfo = D_GetMessageStatic_w_Nr(5020,3) || SalNumberToStrX(nID,0) || "
" || D_GetMessageStatic_w_Nr(5020,14) || cA_Row.sSex || "
" || D_GetMessageStatic_w_Nr(5020,15) || cA_Row.sExp || "
" || D_GetMessageStatic_w_Nr(5020,2) || cA_Row.sStrain || "
" || D_GetMessageStatic_w_Nr(5020,16) ||  cA_Row.sGenotype || "
" || D_GetMessageStatic_w_Nr(5020,17) || s1 || "
" || D_GetMessageStatic_w_Nr(5020,26) || cA_Row.sEarTag || "
" || D_GetMessageStatic_w_Nr(5020,18) || SalNumberToStrX(cA_Row.nBatch,0) || "
" || D_GetMessageStatic_w_Nr(5020,19) ||   SalNumberToStrX(cA_Row.nAge,0) || "
" || D_GetMessageStatic_w_Nr(5020,20) || cA_Row.sRack || "
" || D_GetMessageStatic_w_Nr(5020,21) || cA_Row.sCage
.head 7 +  If TRUE ! Populate Row
.head 8 +  If nCulling
.head 9 -  Call cA_Row.SetState( AnimalIsDead )
.head 8 +  If cA_Row.nMateID
.head 9 -  Call cA_Row.SetState( AnimalInMate )
.head 9 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[4])
.head 9 -  Set sVars[0] = SalNumberToStrX(cA_Row.nMateID,0)
.head 9 -  Set sVars[1] = cA_Row.sBreedingNr
.head 9 -  Set sDetatilInfo = sDetatilInfo || "
 " || D_GetMessageFull(5020,22, sVars ) || "
  "
.head 9 +  While bOk and SqlFetchNext(oSqlL4.hSql[4], nFetch )
.head 10 -  Set sDetatilInfo = sDetatilInfo || sPlanDetails || "
  "
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[1])
.head 8 +  While bOk and SqlFetchNext(oSqlL4.hSql[1], nFetch )
.head 9 +  If not cA_Row.GetState( IsServise  ) and not cA_Row.GetState( IsAlert  )
.head 10 +  If nAlert = 1
.head 11 -  Call cA_Row.SetState( IsServise  )
.head 10 +  Else If nAlert = 2
.head 11 -  Call cA_Row.SetState( IsAlert  )
.head 10 -  Set sDetatilInfo = sDetatilInfo || "
 " || D_GetMessageStatic_w_Nr(5020,23) ||"
  "
.head 9 -  Call SalStrLeft( sPlanDetails, SalStrLength( sPlanDetails )-7 , sPlanDetails )
.head 9 -  Set sDetatilInfo = sDetatilInfo || sPlanDetails || "
  "
.head 8 -  Set sPlanDetails = ""
.head 8 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[2])
.head 8 +  While bOk and SqlFetchNext(oSqlL4.hSql[2], nFetch )
.head 9 +  If not cA_Row.GetState( AnimalInPlanBew )
.head 10 -  Set sDetatilInfo = sDetatilInfo || "
 " || D_GetMessageStatic_w_Nr(5020,24) ||"
  "
.head 10 -  Call cA_Row.SetState( AnimalInPlanBew  )
.head 9 -  Set bOk = bOk and SqlExecute(oSqlL4.hSql[3])
.head 9 +  If bOk and SqlFetchNext(oSqlL4.hSql[3], nFetch )
.head 10 -  Set sDetatilInfo = sDetatilInfo || sPlanDetails || "," || sPlanLoc || "
  "
.head 8 -  Set cA_Row.nID_Obj = nID
.head 8 -  Set cA_Row.bNeedPrefix = bNeedPrefix
.head 8 -  Set cA_Row.sInfo = sDetatilInfo
.head 8 +  If oHandleSelect.RowIsSelected(GetUniqRowID( nRow ))
.head 9 -  Set cA_Row.nCheckRow = 1
.head 8 -  Call FE_SetInfo(nRow,cA_Row )
.head 5 +  Function: PopulateService
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 -  Actions
.head 5 +  Function: PopulateRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oData
.head 8 -  Class: cPositionData
.head 7 -  Number: bCreateProgressBar
.head 6 +  Actions
.head 7 -  Set bAutoSize = TRUE
.head 7 -  Set bCreateProgressBar = FALSE
.head 7 -  Set bProgressBarOnPopulate = FALSE
.head 7 +  If not RowIsExpand(nRow)
.head 8 +  Select Case GetLevel( nRow )
.head 9 +  Case AEL_Root
.head 10 -  Call PopulateRoot( )
.head 10 -  Break
.head 9 +  Case AEL_Workgroup
.head 10 -  Call PopulateWorkgroup(nRow,TRUE)
.head 10 -  Break
.head 9 +  Case AEL_Animal
.head 10 -  Call PopulateAnimal( nRow,TRUE)
.head 10 -  Break
.head 9 +  Case AEL_Service
.head 10 -  Call PopulateService(  )
.head 10 -  Break
.head 9 +  Case AEL_Strain
.head 10 +  If hWndProgress = hWndNULL
.head 11 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,10  )
.head 11 -  Set bCreateProgressBar = TRUE
.head 11 -  Set bProgressBarOnPopulate = TRUE
.head 10 -  Call PopulateStrain( nRow,TRUE )
.head 10 +  If bCreateProgressBar
.head 11 -  Call SalDestroyWindow( hWndProgress )
.head 11 -  Set hWndProgress = hWndNULL
.head 11 -  Set bProgressBarOnPopulate = FALSE
.head 10 -  Break
.head 9 +  Default
.head 10 -  Break
.head 8 -  Call SortTree()
.head 8 -  Call MTblExpandRow( hWndForm, nRow, MTM_ExpandRow )
.head 7 +  Else
.head 8 -  Call MTblCollapseRow( hWndForm, nRow, MTM_CollapseRow )
.head 8 -  Call MTblSetRowFlags( hWndForm, nRow, MTBL_ROW_ISEXPANDED, FALSE, MTSRF_REDRAW )
.head 8 -  ! Call UnselectChild(nRow)
.head 7 -  Set bAutoSize = FALSE
.head 7 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 7 -  Call SetSizeTree()
.head 7 -  Call SalInvalidateWindow( hWndForm )
.head 5 +  Function: FindObject
.head 6 -  Description: Find RowNr with objectID
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nParent
.head 7 -  Number: nID_Object
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFtch
.head 7 -  Number: nRow
.head 6 +  Actions
.head 7 +  If nParent != -1
.head 8 -  Return clsGeneralExplorer.FindObject( nParent, nID_Object )
.head 7 +  Else
.head 8 -  Set nUniqRow = -1
.head 8 -  Set nRow = -1
.head 8 -  Set nLevel = 1
.head 8 -  Set nObjIDParent = -1
.head 8 -  Set nObjID = nID_Object
.head 8 -  Set bOk = SqlExecute( oSqlUTable.hSql[2] ) and SqlFetchNext( oSqlUTable.hSql[2], nFtch )
.head 8 -  Set nRow = GetRowID( nUniqRow )
.head 8 -  Return nRow
.head 5 -  !
.head 5 +  Function: ShowDetatilInfo
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Boolean: bForceCreate
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nX1
.head 7 -  Number: nY1
.head 7 -  Number: nXUnit
.head 7 -  Number: nYUnit
.head 7 -  String: sTitle
.head 6 +  Actions
.head 7 +  If not hDetailInfoAE and bForceCreate
.head 8 -  Call GetWindowRect(hWndAnE, nX1, nY1,nXUnit, nYUnit)
.head 8 -  Set nXUnit = nXUnit - nX1
.head 8 -  Set nYUnit = nYUnit - nY1
.head 8 -  Set nXUnit = SalPixelsToFormUnits ( hWndNULL, nXUnit, FALSE )
.head 8 -  Set nYUnit = SalPixelsToFormUnits ( hWndNULL, nYUnit, TRUE )
.head 8 -  Set nX1 = 3.5
.head 8 -  Set nY1 = nYUnit/3
.head 8 -  Set nXUnit = nXUnit-nX1-0.3
.head 8 -  Set nYUnit = 0.3
.head 8 -  !
.head 8 -  ! Call SalCreateWindowEx( frmDetailInfoInAE, hWndForm, nXUnit, nYUnit, nX1, nY1, CREATE_AsChild | CREATE_Border)
.head 8 -  Call SalCreateWindowEx( frmDetailInfoInAE, hWndForm, nXUnit, nYUnit, nX1, nY1, 0)
.head 7 +  If hDetailInfoAE
.head 8 -  Set sTitle = "Detail information "
.head 8 +  Select Case nSelectedLevel
.head 9 +  Case AEL_Workgroup
.head 10 -  Set sTitle = sTitle || GetSValue( nSelectedRow , "SCREEN" )
.head 10 -  Break
.head 9 +  Case AEL_Strain
.head 10 -  Set sTitle = sTitle || " strain "|| GetSValue( nSelectedRow , "STRAIN" ) || " colony nr " || SalNumberToStrX(GetNValue( nSelectedRow , "COLONY" ) ,0)
.head 10 -  Break
.head 9 +  Case AEL_Animal
.head 10 -  Set sTitle = sTitle || " animal "|| SalNumberToStrX(GetIdObject( nSelectedRow ) ,0)
.head 10 -  Break
.head 8 -  Set frmDetailInfoInAE.mlInfo = hWndForm.clsGeneralExplorer.colDetailInfo
.head 8 -  Call frmDetailInfoInAE.SetTitle( sTitle )
.head 5 -  !
.head 5 +  Function: ActivateRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nActivateRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sTitle
.head 7 -  Number: nRowCheck
.head 6 +  Actions
.head 7 -  Call SalTblSetFocusRow( hWndForm, nActivateRow )
.head 7 +  If nRowSetCont != nActivateRow 
.head 8 -  Call ReAssignPic(nRowSetCont)
.head 7 -  Call ReAssignPic(nActivateRow)
.head 7 -  Set nRowSetCont = nActivateRow 
.head 7 -  Call SalTblSetContext( hWndForm, nActivateRow )
.head 7 -  !
.head 7 -  Set nRowCheck = nActivateRow
.head 7 +  Select Case GetLevel( nRowCheck )
.head 8 +  Case AEL_Animal
.head 9 -  Set sTitle = D_GetMessageStatic_w_Nr(5020,3) || SalNumberToStrX(GetIdObject( nRowCheck ),0)
.head 9 -  Set nRowCheck = GetParent( nRowCheck )
.head 8 +  Case AEL_Strain
.head 9 -  Set sTitle =D_GetMessageStatic_w_Nr(5020,2) || GetSValue(nRowCheck , "STRAIN" ) || " " ||sTitle
.head 9 -  Set nRowCheck = GetParent( nRowCheck )
.head 8 +  Case AEL_Workgroup
.head 9 -  Set sCurrentScreen = GetSValue(nRowCheck , "SCREEN" )
.head 9 -  Set sTitle =D_GetMessageStatic_w_Nr(5020,1) || sCurrentScreen || " " ||sTitle
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Set sTitle = "Animal List: " || sTitle
.head 7 -  Call SalTblSetColumnTitle ( colTree , sTitle)
.head 7 -  Call ActivateSelectedItem()
.head 7 -  Call ShowDetatilInfo(FALSE)
.head 7 -  Call SalSendMsg(hWndStar2000, AM_Refresh,0,0)
.head 5 +  Function: ActivateSelectedItem
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  ! String: sLab
.head 7 -  String: sSelectedAbtKey_Res
.head 7 -  String: sSelectedStatKey_Res
.head 6 +  Actions
.head 7 -  Set nSelectedRow = SalTblQueryContext ( hWndForm ) 
.head 7 -  Set nSelectedLevel = GetLevel( nSelectedRow )
.head 7 -  Call SalTblClearSelection( hWndForm )
.head 7 -  Call SalTblSetRowFlags ( hWndForm, nSelectedRow, ROW_Selected, TRUE )
.head 5 +  Function: DeleteRow
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nRowDel
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowChild
.head 6 +  Actions
.head 7 +  If RowIsParent( nRowDel )
.head 8 -  Set nRowChild = GetFirstChildRow( nRowDel )
.head 8 +  While nRowChild != TBL_Error
.head 9 -  Call DeleteRow(nRowChild)
.head 9 -  Set nRowChild = GetNextChildRow( nRowChild )
.head 8 -  Set nUniqRow = GetUniqRowID( nRowDel )
.head 8 -  Call SqlExecute( oSqlUTable.hSql[1] )
.head 8 -  Call MTblDeleteDescRows( hWndForm, nRowDel, TBL_Adjust )
.head 8 -  Call SalTblDeleteRow( hWndForm, nRowDel, TBL_Adjust )
.head 7 +  Else
.head 8 +  If nRowDel != -1
.head 9 -  Set nUniqRow = GetUniqRowID( nRowDel )
.head 9 -  Call SqlExecute( oSqlUTable.hSql[1] )
.head 9 -  Call MTblDeleteDescRows( hWndForm, nRowDel, TBL_Adjust )
.head 9 -  Call SalTblDeleteRow( hWndForm, nRowDel, TBL_Adjust )
.head 5 +  Function: DeleteTmpRows
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: _nLev
.head 7 -  Number: _nIDParent
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nRow
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set nLevel = _nLev
.head 7 -  Set nStatus = 2
.head 7 -  Set nObjIDParent = _nIDParent
.head 7 -  Set bOk = SqlExecute(oSqlUTable.hSql[4])
.head 7 +  While bOk and SqlFetchNext(oSqlUTable.hSql[4],nFetch )
.head 8 -  Set nRow = GetRowID( nUniqRow )
.head 8 -  Call DeleteRow( nRow )
.head 8 +  ! If hWndProgress 
.head 9 -  Call dlgProgress.Next(  )
.head 7 -  Return bOk
.head 5 +  Function: QuickFilter
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nLevelRefresh 
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nRow
.head 7 -  Number: nCountRow
.head 6 +  Actions
.head 7 +  If nLevelRefresh = AEL_Animal
.head 8 -  Set sFullFilter =cFullFilter.GetSQLString()
.head 8 +  If hWndProgress = hWndNULL
.head 9 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,10  )
.head 8 -  Set oSqlL3.bPrepare = FALSE
.head 8 -  Set oSqlL2.bPrepare = FALSE
.head 8 -  Set nLevel = AEL_Animal + 1
.head 8 -  Set nStatus = 2
.head 8 -  Set bOk = SqlExecute(oSqlUTable.hSql[3])
.head 8 -  Set nLevel = AEL_Strain + 1
.head 8 -  Set nStatus = 2
.head 8 -  Set bOk = SqlExecute(oSqlUTable.hSql[3])
.head 8 -  Set nLevel = AEL_Workgroup + 1
.head 8 -  Set nStatus = 1
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[6])
.head 8 -  Set bOk  =  bOk and SqlGetResultSetCount(  oSqlUTable.hSql[6] , nCountRow )
.head 8 +  If hWndProgress 
.head 9 +  If nCountRow = 0
.head 10 -  Set nCountRow = 1
.head 9 -  Call dlgProgress.Init( nCountRow, "Refresh screens. Please wait... " )
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[6],nFetch )
.head 9 -  Set nRow = GetRowID( nUniqRow )
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Call PopulateWorkgroup( nRow, TRUE )
.head 9 +  If hWndProgress 
.head 10 -  Call dlgProgress.Next(  )
.head 8 -  Set nLevel = AEL_Strain + 1
.head 8 -  Set nStatus = 1
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[6])
.head 8 -  Set bOk  =  bOk and SqlGetResultSetCount(  oSqlUTable.hSql[6] , nCountRow )
.head 8 +  If hWndProgress 
.head 9 +  If nCountRow = 0
.head 10 -  Set nCountRow = 1
.head 9 -  Call dlgProgress.Init( nCountRow, "Refresh animals. Please wait... " )
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[6],nFetch )
.head 9 -  Set nRow = GetRowID( nUniqRow )
.head 9 -  Call SalTblSetContext( hWndForm, nRow )
.head 9 -  Set nSelectedRow = nRow
.head 9 -  Set nSelectedLevel = GetLevel( nSelectedRow )
.head 9 -  Call PopulateStrain( nRow, TRUE )
.head 9 +  If hWndProgress 
.head 10 -  Call dlgProgress.Next(  )
.head 8 -  Set nLevel = AEL_Strain + 1
.head 8 -  Set nStatus = 2
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 8 -  Set bOk  =  bOk and SqlGetResultSetCount(  oSqlUTable.hSql[7] , nCountRow )
.head 8 +  If hWndProgress 
.head 9 +  If nCountRow = 0
.head 10 -  Set nCountRow = 1
.head 9 -  Call dlgProgress.Init( nCountRow, "Delete temp rows. Please wait... " )
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 9 -  Set nRow = GetRowID( nUniqRow )
.head 9 -  Call DeleteRow( nRow )
.head 9 +  If hWndProgress 
.head 10 -  Call dlgProgress.Next(  )
.head 8 -  Set nLevel = AEL_Animal + 1
.head 8 -  Set nStatus = 2
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 8 -  Set bOk  =  bOk and SqlGetResultSetCount(  oSqlUTable.hSql[7] , nCountRow )
.head 8 +  If hWndProgress 
.head 9 +  If nCountRow = 0
.head 10 -  Set nCountRow = 1
.head 9 -  Call dlgProgress.Init( nCountRow, "Delete temp rows. Please wait... " )
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 9 -  Set nRow = GetRowID( nUniqRow )
.head 9 -  Call DeleteRow( nRow )
.head 9 +  If hWndProgress 
.head 10 -  Call dlgProgress.Next(  )
.head 8 +  If hWndProgress 
.head 9 -  Call SalDestroyWindow( hWndProgress )
.head 9 -  Set hWndProgress = hWndNULL
.head 8 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 8 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 8 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 8 -  Call SortTree()
.head 5 +  Function: FullFilter
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nCountRow
.head 7 -  Number: nRow
.head 7 -  Number: nFetch
.head 7 -  Boolean: bOk
.head 7 -  Number: nActRow
.head 6 +  Actions
.head 7 -  Set nActRow= GetUniqRowID( nRowSetCont )
.head 7 -  Set bFillterOn = FALSE
.head 7 -  Set sFullFilter =cFullFilter.GetSQLString()
.head 7 -  Set oSqlL3.bPrepare = FALSE
.head 7 -  Set oSqlL2.bPrepare = FALSE
.head 7 -  Set oSqlL1.bPrepare = FALSE
.head 7 +  If hWndProgress = hWndNULL
.head 8 -  Set hWndProgress = SalCreateWindow( dlgProgress, hWndForm,10  )
.head 7 -  Set nLevel = AEL_Workgroup + 1
.head 7 -  Set nStatus = 2
.head 7 -  Set bOk = SqlExecute(oSqlUTable.hSql[3])
.head 7 -  Set nLevel = AEL_Strain + 1
.head 7 -  Set nStatus = 2
.head 7 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[3])
.head 7 -  Set nLevel = AEL_Animal + 1
.head 7 -  Set nStatus = 2
.head 7 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[3])
.head 7 -  !
.head 7 -  Call PopulateRoot()
.head 7 -  Set nLevel = AEL_Strain + 1
.head 7 -  Set nStatus = 1
.head 7 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 7 -  Set bOk = bOk and SqlGetResultSetCount(  oSqlUTable.hSql[7] , nCountRow )
.head 7 +  If hWndProgress 
.head 8 +  If nCountRow = 0
.head 9 -  Set nCountRow = 1
.head 8 -  Call dlgProgress.Init( nCountRow, "Refresh strains. Please wait... " )
.head 7 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 8 -  Set nRow = GetRowID( nUniqRow )
.head 8 -  Call SalTblSetContext( hWndForm, nRow )
.head 8 -  Set nSelectedRow = nRow
.head 8 -  Set nSelectedLevel = GetLevel( nSelectedRow )
.head 8 -  Call PopulateStrain( nRow, TRUE )
.head 8 +  If hWndProgress 
.head 9 -  Call dlgProgress.Next(  )
.head 7 -  ! Delete temp rows
.head 7 -  Set nLevel = AEL_Workgroup + 1
.head 7 -  Set nStatus = 2
.head 7 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 7 -  Set bOk = bOk and SqlGetResultSetCount(  oSqlUTable.hSql[7] , nCountRow )
.head 7 +  If hWndProgress 
.head 8 +  If nCountRow = 0
.head 9 -  Set nCountRow = 1
.head 8 -  Call dlgProgress.Init( nCountRow, "Delete temp rows. Please wait... " )
.head 7 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 8 -  Set nRow = GetRowID( nUniqRow )
.head 8 -  Call DeleteRow( nRow )
.head 8 +  If hWndProgress 
.head 9 -  Call dlgProgress.Next(  )
.head 7 -  Set nLevel = AEL_Strain + 1
.head 7 -  Set nStatus = 2
.head 7 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 7 -  Set bOk = bOk and SqlGetResultSetCount(  oSqlUTable.hSql[7] , nCountRow )
.head 7 +  If hWndProgress 
.head 8 +  If nCountRow = 0
.head 9 -  Set nCountRow = 1
.head 8 -  Call dlgProgress.Init( nCountRow, "Delete temp rows. Please wait... " )
.head 7 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 8 -  Set nRow = GetRowID( nUniqRow )
.head 8 -  Call DeleteRow( nRow )
.head 8 +  If hWndProgress 
.head 9 -  Call dlgProgress.Next(  )
.head 7 -  Set nLevel = AEL_Animal + 1
.head 7 -  Set nStatus = 2
.head 7 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 7 -  Set bOk = bOk and SqlGetResultSetCount(  oSqlUTable.hSql[7] , nCountRow )
.head 7 +  If hWndProgress 
.head 8 +  If nCountRow = 0
.head 9 -  Set nCountRow = 1
.head 8 -  Call dlgProgress.Init( nCountRow, "Delete temp rows. Please wait... " )
.head 7 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 8 -  Set nRow = GetRowID( nUniqRow )
.head 8 -  Call DeleteRow( nRow )
.head 8 +  If hWndProgress 
.head 9 -  Call dlgProgress.Next(  )
.head 7 +  If hWndProgress 
.head 8 -  Call SalDestroyWindow( hWndProgress )
.head 8 -  Set hWndProgress = hWndNULL
.head 7 -  Set nActRow= GetRowID( nActRow )
.head 7 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 7 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 7 -  Call SetOptionBooleanS("AE", "FilterOn", bFillterOn)
.head 7 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 7 -  Call SortTree()
.head 7 -  Call ActivateRow(GetRowID( nActRow ) )
.head 5 +  Function: GetIDColFromName
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  String: sFindNameCol
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nInd
.head 7 -  String: sNameCol
.head 7 -  Window Handle: hWndCol
.head 6 +  Actions
.head 7 -  Set nInd = 1
.head 7 +  Loop
.head 8 -  Set hWndCol = SalTblGetColumnWindow( hWndItem, nInd, COL_GetID  )
.head 8 +  If hWndCol = hWndNULL
.head 9 -  Set nInd = -1
.head 9 -  Break
.head 8 -  Call SalGetItemName( hWndCol , sNameCol )
.head 8 +  If sFindNameCol = sNameCol
.head 9 -  Break
.head 8 -  Set nInd = nInd + 1
.head 7 -  Return nInd
.head 5 +  Function: SortTree
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Window Handle: hWndColSort[*]
.head 7 -  Number: nSortFlag[*]
.head 7 -  Number: nCount
.head 7 -  Number: nItem
.head 7 -  Number: nIndSort
.head 7 -  FunctionalVar: oSort
.head 8 -  Class: cElement
.head 7 -  Number: nCOL_ID
.head 7 -  Number: nActRow
.head 7 -  Window Handle: hWndColumn
.head 6 +  Actions
.head 7 -  ! Sort Screen
.head 7 -  Set nActRow= GetUniqRowID( nRowSetCont )
.head 7 -  Set bSortOn = FALSE
.head 7 -  Set nIndSort = 0
.head 7 -  !
.head 7 -  Set nItem = 0
.head 7 -  Set nCount = cScreenSort.GetCount(  )
.head 7 +  While nItem < nCount
.head 8 -  Set oSort = cScreenSort.GetRecord( nItem )
.head 8 +  If oSort.nActive = 1
.head 9 +  If oSort.sName = "Screen"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal1" )
.head 10 -  Set hWndColumn = hWndSCol[0]
.head 9 +  ! Else If oSort.sName = "Top Screen"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colTopScr" )
.head 9 +  If hWndColumn
.head 10 -  Set hWndColSort[nIndSort] = hWndColumn
.head 10 +  If oSort.sOrderName  = 'Desc'
.head 11 -  Set nSortFlag[nIndSort] = MTS_DESC | MTS_DT_DEFAULT
.head 10 +  Else
.head 11 -  Set nSortFlag[nIndSort] = MTS_ASC | MTS_DT_DEFAULT
.head 10 -  Set nIndSort = nIndSort + 1
.head 9 -  Set bSortOn = TRUE
.head 8 -  Set nItem = nItem +1
.head 7 +  If nCount = 0
.head 8 -  Set nCOL_ID = GetIDColFromName( "colOrder" )
.head 8 +  If nCOL_ID > 0
.head 9 -  Set hWndColSort[nIndSort] = SalTblGetColumnWindow( hWndItem, nCOL_ID, COL_GetID )
.head 9 -  Set nSortFlag[nIndSort] = MTS_DESC | MTS_DT_DEFAULT
.head 9 -  Set nIndSort = nIndSort + 1
.head 7 +  If nIndSort
.head 8 -  Call MTblSort( hWndItem, hWndColSort, nSortFlag )
.head 7 -  ! Sort Strain
.head 7 -  Call SalArraySetUpperBound( hWndColSort, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( nSortFlag, 1, -1 )
.head 7 -  Set nItem = 0
.head 7 -  Set nIndSort = 0
.head 7 -  Set nCount = cStrainSort.GetCount(  )
.head 7 +  While nItem < nCount
.head 8 -  Set oSort = cStrainSort.GetRecord( nItem )
.head 8 +  If oSort.nActive = 1
.head 9 +  If oSort.sName = "Strain"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal1" )
.head 10 -  Set hWndColumn = hWndSCol[0]
.head 9 +  If hWndColumn
.head 10 -  Set hWndColSort[nIndSort] = hWndColumn
.head 10 +  If oSort.sOrderName  = 'Desc'
.head 11 -  Set nSortFlag[nIndSort] = MTS_DESC | MTS_DT_DEFAULT
.head 10 +  Else
.head 11 -  Set nSortFlag[nIndSort] = MTS_ASC | MTS_DT_DEFAULT
.head 10 -  Set nIndSort = nIndSort + 1
.head 9 -  Set bSortOn = TRUE
.head 8 -  Set nItem = nItem +1
.head 7 +  If nIndSort
.head 8 -  Call MTblSort( hWndItem, hWndColSort, nSortFlag )
.head 7 -  ! Sort Animals
.head 7 -  Set nItem = 0
.head 7 -  Set nIndSort = 0
.head 7 -  Call SalArraySetUpperBound( hWndColSort, 1, -1 )
.head 7 -  Call SalArraySetUpperBound( nSortFlag, 1, -1 )
.head 7 -  Set nCount = cAnimalSort.GetCount(  )
.head 7 +  While nItem < nCount
.head 8 -  Set oSort = cAnimalSort.GetRecord( nItem )
.head 8 +  If oSort.nActive = 1
.head 9 +  If oSort.sName = "Fall"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colIDObject" )
.head 10 -  ! Set hWndColumn = SalTblGetColumnWindow( hWndItem, nCOL_ID , COL_GetID )
.head 10 -  Set hWndColumn = hWndForm.cFallExplorer.colIDObject
.head 9 +  Else If oSort.sName = "Sex"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal2" )
.head 10 -  Set hWndColumn = hWndSCol[1]
.head 9 +  Else If oSort.sName = "Birth date"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colBorn" )
.head 10 -  Set hWndColumn = hWndDtCol[0]
.head 9 +  Else If oSort.sName = "Batch"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colNVal1" )
.head 10 -  Set hWndColumn = hWndNCol[0]
.head 9 +  Else If oSort.sName = "Rack"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal6" )
.head 10 -  Set hWndColumn = hWndSCol[5]
.head 9 +  Else If oSort.sName = "Cage"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal5" )
.head 10 -  Set hWndColumn = hWndSCol[4]
.head 9 +  Else If oSort.sName = "Experiment"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal4" )
.head 10 -  Set hWndColumn = hWndSCol[3]
.head 9 +  Else If oSort.sName = "Genotype"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colSVal8" )
.head 10 -  Set hWndColumn = hWndSCol[7]
.head 9 +  Else If oSort.sName = "MatingID"
.head 10 -  ! Set nCOL_ID = GetIDColFromName( "colNVal3" )
.head 10 -  Set hWndColumn = hWndNCol[2]
.head 9 +  ! Else If oSort.sName = "Mutation1"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "Mutation2"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "Mutation3"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "Mutation4"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "Mutation5"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "Mutation6"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "Mutation7"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colPhenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType1"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType2"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType3"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType4"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType5"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType6"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  ! Else If oSort.sName = "GenoType7"
.head 10 -  Set nCOL_ID = GetIDColFromName( "colGenotype" )
.head 9 +  If hWndColumn
.head 10 -  Set hWndColSort[nIndSort] = hWndColumn
.head 10 +  If oSort.sOrderName  = 'Desc'
.head 11 -  Set nSortFlag[nIndSort] = MTS_DESC | MTS_DT_DEFAULT
.head 10 +  Else
.head 11 -  Set nSortFlag[nIndSort] = MTS_ASC | MTS_DT_DEFAULT
.head 10 -  Set nIndSort = nIndSort + 1
.head 9 -  Set bSortOn = TRUE
.head 8 -  Set nItem = nItem +1
.head 7 -  ! !
.head 7 +  If nIndSort
.head 8 -  Call MTblSort( hWndItem, hWndColSort, nSortFlag )
.head 7 -  Call MTblSortTree( hWndItem, MTST_TOPDOWN )
.head 7 -  Call SetOptionBooleanS("AE", "SortOn", bFillterOn)
.head 7 -  ! !
.head 7 -  Set nActRow= GetRowID( nActRow )
.head 7 -  Call ActivateRow(nActRow)
.head 7 -  ! Set nRowSetCont = SalTblQueryContext( hWndItem )
.head 5 +  Function: CheckStatusObj
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nRow
.head 7 -  Number: nStatusObj
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bStatus
.head 7 -  Number: nLevelLoc
.head 7 -  FunctionalVar: oDataRow
.head 8 -  Class: cFERow
.head 7 -  FunctionalVar: oDataRowParent
.head 8 -  Class: cFERow
.head 6 +  Actions
.head 7 -  Set bStatus=FALSE
.head 7 -  Set nLevelLoc = MTblGetRowLevel( hWndForm, nRow )
.head 7 -  Set oDataRow = FE_GetInfo(nRow)
.head 7 +  Select Case nStatusObj 
.head 8 +  Case AnimalInPlanBew
.head 9 +  If nLevelLoc = AEL_Animal
.head 10 -  Set bStatus = oDataRow.GetState( nStatusObj )
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set bStatus = oDataRow.GetState( nStatusObj )
.head 9 -  Break
.head 7 -  Return bStatus
.head 5 -  !
.head 5 +  Function: LT_GetNumOfNewTransaction1	
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSql_LT
.head 7 -  Boolean: bOk
.head 7 -  Number: nLT
.head 7 -  Number: nFtch
.head 7 -  Number: nCounter
.head 7 -  Number: nCountUpdated
.head 6 +  Actions
.head 7 +  If Not GalConnect( hSql_LT )
.head 8 -  Return 0
.head 7 -  Set nCounter = 5
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql_LT, "
select       max(ID)
from          UNIQUE_ID
where       DESCRIPTION='LT'
into	 :nLT " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSql_LT, nFtch )
.head 7 +  If bOk
.head 8 +  Loop
.head 9 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
Update 	UNIQUE_ID
set 	ID = 1+:nLT
where 	DESCRIPTION = 'LT'   and  ID = :nLT " )
.head 9 -  Set bOk = bOk And  SqlGetModifiedRows ( hSql_LT, nCountUpdated)
.head 9 -  Set nCounter = nCounter - 1
.head 9 +  If nCountUpdated>0 or nCounter = 0
.head 10 -  Break
.head 7 +  If bOk and nCountUpdated>0
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql_LT, "commit")
.head 8 -  Set nLT = nLT+1
.head 7 +  Else
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql_LT, "rollback")
.head 8 -  Call SalMessageBox ( "System could not generate LT ID. Please try later.", "Warning", MB_Ok )
.head 8 -  Set nLT = 0
.head 7 -  Call SqlDisconnect( hSql_LT)
.head 7 -  Return nLT
.head 5 -  !
.head 5 +  Function: CanShowPbOnToolbar
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sParam
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Return FALSE
.head 5 +  Function: CanPlanMating
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  FunctionalVar: cWorkGr
.head 8 -  Class: cAERowScr
.head 7 -  Number: nRowWorkGR
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 -  ! Set bOk = (nSelectedLevel = AEL_Workgroup)
.head 7 -  Set bOk =TRUE
.head 7 -  Set nRowWorkGR = -1
.head 7 +  If bOk
.head 8 +  If nSelectedLevel = AEL_Workgroup
.head 9 -  Set nRowWorkGR = nSelectedRow
.head 8 +  Else If nSelectedLevel = AEL_Strain
.head 9 -  Set nRowWorkGR = GetParent(nSelectedRow)
.head 8 +  Else If nSelectedLevel = AEL_Animal
.head 9 -  Set nRowWorkGR = GetParent(GetParent(nSelectedRow))
.head 8 +  If nRowWorkGR = -1
.head 9 -  Set bOk = FALSE
.head 8 +  Else
.head 9 -  Set cWorkGr = FE_GetInfo( nRowWorkGR  )
.head 9 -  Set bOk = bOk and cWorkGr.GetState( RackIsVirtual )
.head 7 -  Set bOk = bOk and oHandleSelect.bAnySelects
.head 7 -  Set bOk = bOk and (oHandleSelect.nCountMales=1 and oHandleSelect.nCountFemales=nFem)
.head 7 +  If bOk
.head 8 -  Set nI = 0
.head 8 +  While bOk and nI < oHandleSelect.nIndex
.head 9 -  Set bOk = bOk and not CheckStatusObj( GetRowID( oHandleSelect.nRow[nI] ), AnimalInPlanBew )
.head 9 -  Set nI = nI + 1
.head 7 -  Return bOk
.head 5 +  Function: CanSelectAnimals
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 7 -  Number: nChildRow
.head 7 -  Number: nRowStrain
.head 6 +  Actions
.head 7 -  Set bReturn =FALSE
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 -  Set bReturn = (colCheck = 0 )
.head 7 +  Else If nSelectedLevel = AEL_Strain
.head 8 -  Set nChildRow = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nChildRow = TBL_Error or bReturn
.head 10 -  Break
.head 9 +  If not oHandleSelect.RowIsSelected( GetUniqRowID( nChildRow ) )
.head 10 -  Set bReturn = TRUE
.head 9 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 7 +  Else If nSelectedLevel = AEL_Workgroup
.head 8 -  Set nRowStrain = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nRowStrain = TBL_Error or bReturn
.head 10 -  Break
.head 9 -  Set nChildRow = GetFirstChildRow( nRowStrain )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error or bReturn
.head 11 -  Break
.head 10 +  If not oHandleSelect.RowIsSelected( GetUniqRowID( nChildRow ) )
.head 11 -  Set bReturn = TRUE
.head 10 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 9 -  Set nRowStrain = GetNextChildRow( nRowStrain )
.head 7 -  Return bReturn
.head 5 +  Function: CanUnSelectAnimals
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 7 -  Number: nChildRow
.head 7 -  Number: nRowStrain
.head 6 +  Actions
.head 7 -  Set bReturn =FALSE
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 -  Set bReturn = (colCheck = 1 )
.head 7 +  Else If nSelectedLevel = AEL_Strain
.head 8 -  Set nChildRow = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nChildRow = TBL_Error or bReturn
.head 10 -  Break
.head 9 +  If oHandleSelect.RowIsSelected( GetUniqRowID( nChildRow ) )
.head 10 -  Set bReturn = TRUE
.head 9 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 7 +  Else If nSelectedLevel = AEL_Workgroup
.head 8 -  Set nRowStrain = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nRowStrain = TBL_Error or bReturn
.head 10 -  Break
.head 9 -  Set nChildRow = GetFirstChildRow( nRowStrain )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error or bReturn
.head 11 -  Break
.head 10 +  If oHandleSelect.RowIsSelected( GetUniqRowID( nChildRow ) )
.head 11 -  Set bReturn = TRUE
.head 10 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 9 -  Set nRowStrain = GetNextChildRow( nRowStrain )
.head 7 -  Return bReturn
.head 5 +  Function: CanGoToParent
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 6 +  Actions
.head 7 -  Set bReturn = (nSelectedLevel > AEL_Root)
.head 7 -  Return bReturn
.head 5 +  Function: CanJump
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  Number: nDirection ! DIR_Up or DIR_Down
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nRow
.head 6 +  Actions
.head 7 -  Set bOk = FALSE
.head 7 +  If nDirection = DIR_Up
.head 8 -  Set nRow = MTblGetPrevChildRow( hWndForm, nSelectedRow )
.head 7 +  Else If nDirection = DIR_Down
.head 8 -  Set nRow = MTblGetNextChildRow( hWndForm, nSelectedRow )
.head 7 -  Set bOk = (nRow!=TBL_Error)
.head 7 -  ! If nSelectedLevel > AEL_Workgroup
.head 7 -  ! Else If nSelectedLevel = AEL_Workgroup
.head 7 -  Return bOk
.head 5 +  Function: CanExpandCollapseRow
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bReturn
.head 7 -  Number: nChild[*]
.head 6 +  Actions
.head 7 -  Set bReturn = nSelectedLevel < AEL_Animal
.head 7 +  ! If nSelectedLevel = FEL_Workgroup or nSelectedLevel = FEL_Rack
.head 8 -  Set bReturn = bReturn and EnumChildren(nSelectedRow, nChild) > 0
.head 7 -  Set bReturn = bReturn and RowIsParent( nSelectedRow )
.head 7 -  Return bReturn
.head 5 -  !
.head 5 +  Function: Experiment_VirtualCaseX
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number: nFallKey
.head 6 +  Parameters
.head 7 -  String: sExperimentKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFetch
.head 7 -  !
.head 7 -  Number: nFallKey
.head 6 +  Actions
.head 7 +  If SqlPrepareAndExecute( hSqlPopulate1 , "
select max( e.FALL_KEY )
from FALL_EXPERIMENT e, FALL f, VIS_KAT v
where e.EINRICHT_ID = 1
 and e.EXPERIMENT_KEY = :sExperimentKey
 and f.EINRICHT_ID = e.EINRICHT_ID
 and f.FALL_KEY = e.FALL_KEY
 and v.VIS_KAT_KEY = f.VIS_KAT_KEY
 and v.PATIENT = 'N'
into :nFallKey
" )
.head 8 -  Call SqlFetchNext( hSqlPopulate1, nFetch )
.head 7 -  Return nFallKey
.head 5 +  Function: GetVirtFallKey4Experiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: spExperiment
.head 7 -  Receive Number: nrpVirtFallKey
.head 7 -  Receive Number: nrpBewNr
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 +  If Not spExperiment
.head 8 -  Return FALSE
.head 7 -  Set nrpVirtFallKey = Experiment_VirtualCaseX( spExperiment )
.head 7 +  If nrpVirtFallKey = 0
.head 8 -  Return FALSE
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlPopulate1 , "
select bew_nr
 from bewegung b
where	b.EINRICHT_ID = :nEinrichtId
   and	b.FALL_KEY = :nrpVirtFallKey
into	:nrpBewNr
" )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSqlPopulate1, nFetch )
.head 7 +  If Not bOk
.head 8 -  Set nrpVirtFallKey = 0
.head 8 -  Set nrpBewNr = 0
.head 7 -  Return bOk
.head 5 +  Function: InsertAdminLstErf
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Number: nBewNr_AE
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  String: sLAKey
.head 7 -  Date/Time: dtLstErfVon
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewLstErf
.head 7 -  Sql Handle: hSql
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 6 +  Actions
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlPopulate1, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY = :nFallKey
into	:nNewLstErf " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSqlPopulate1, nFetch )
.head 7 +  If Not bOk And nFetch = FETCH_EOF
.head 8 -  Set nNewLstErf = 1
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk And Not nNewLstErf
.head 8 -  Set nNewLstErf = 1
.head 7 -  !
.head 7 +  If nNewLstErf
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSqlPopulate1, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR,
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY,
	Lst_Erf_VON,
	MENGE, STATISTIK, PRZ,
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID,
	FKT, BEW_NR, DONE )
 values (	:nEinrichtId, :nFallKey , :nNewLstErf , SYSDATETIME,
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', :nUserId, 1, :nBewNr_AE , 0 ) " )
.head 8 -  Set bOk = bOk And SqlCommit( hSqlPopulate1 )
.head 8 +  If Not bOk
.head 9 -  Call SqlPrepareAndExecute( hSql, 'rollback' )
.head 9 -  Set nNewLstErf = 0
.head 7 -  Return nNewLstErf
.head 5 +  Function: InsertAdminLstErfX
.head 6 -  Description: performs InsertAdminLstErf with logging into LT tables and without Commit, as part of indivisible set of actions within one transaction
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nFallKey
.head 7 -  Number: nBewNr_AE
.head 7 -  String: sTarifKey
.head 7 -  String: sLstKey
.head 7 -  String: sLAKey
.head 7 -  Date/Time: dtLstErfVon
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nLT
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nNewLstErf
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nNR
.head 7 -  Number: nNR_Detail 
.head 6 +  Actions
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = :nEinrichtId
   and	FALL_KEY = :nFallKey
into	:nNewLstErf " )
.head 7 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 7 +  If Not bOk And nFetch = FETCH_EOF
.head 8 -  Set nNewLstErf = 1
.head 8 -  Set bOk = TRUE
.head 7 +  If bOk And Not nNewLstErf
.head 8 -  Set nNewLstErf = 1
.head 7 -  !
.head 7 +  If nNewLstErf
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR,
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY,
	Lst_Erf_VON,
	MENGE, STATISTIK, PRZ,
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID,
	FKT, BEW_NR, DONE )
 values (	:nEinrichtId, :nFallKey , :nNewLstErf , SYSDATETIME,
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', :nUserId, 1, :nBewNr_AE , 0 ) " )
.head 8 -  ! Logging
.head 8 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql, nLT, 'LST_ERF', 'I')
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert	into LT_VALUES (ID, NAME, KEY1, KEY2, KEY3 ) 
values	(:nNR_Detail, 'insert into LST_ERF', :nEinrichtId, :nFallKey , :nNewLstErf )" ) 
.head 8 -  ! end of log
.head 8 +  If Not bOk
.head 9 -  Set nNewLstErf = 0
.head 7 -  Return nNewLstErf
.head 5 +  Function: PlanedMovement_InsAdmAction
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npVirtFallKey
.head 7 -  Number: npNewLstErfNr
.head 7 -  Number: npFallKey
.head 7 -  Number: npBewPlanNr
.head 7 -  String: spAdminItemKey
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nIdminItemNr
.head 6 +  Actions
.head 7 -  !
.head 7 -  Set bOk = SqlPrepareAndExecute( hSqlPopulate1, "
select	max( ADMIN_ITEM_NR ) + 1
from	LST_ADM_TODO_ITEMS
where	EINRICHT_ID = 1
   and	FALL_KEY = :npVirtFallKey
   and	LST_ERF_NR =  :npNewLstErfNr
into	:nIdminItemNr " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSqlPopulate1, nFetch )
.head 7 +  If Not bOk
.head 8 +  If nFetch = FETCH_EOF
.head 9 -  Set bOk = TRUE
.head 8 +  Else
.head 9 -  Return 0
.head 7 +  If Not nIdminItemNr
.head 8 -  Set nIdminItemNr = 1
.head 7 -  !
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSqlPopulate1, "
insert
into	LST_ADM_TODO_ITEMS (
	EINRICHT_ID, FALL_KEY, LST_ERF_NR,
	ADMIN_ITEM_NR, 	ADMIN_ITEM_KEY,
	ITEM_EINRICHT_ID, ITEM_FALL_KEY, ITEM_BEW_NR )
values (	1, :npVirtFallKey , :npNewLstErfNr, :nIdminItemNr ,
	'" || spAdminItemKey || "', 1, :npFallKey , :npBewPlanNr  )" )
.head 7 +  If bOk
.head 8 -  Set bOk = SqlCommit( hSqlPopulate1 )
.head 7 +  If Not bOk
.head 8 -  Call SqlPrepareAndExecute( hSqlPopulate1, 'rollback' )
.head 8 -  Set nIdminItemNr = 0
.head 7 -  Return nIdminItemNr
.head 5 +  Function: PlanedMovement_InsAdmActionX
.head 6 -  Description: performs PlanedMovement_InsAdmAction using given SQL handle and without "commit", to be used as part of set of actions within one transaction. Also post logs in gs in  LT tables
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: npVirtFallKey
.head 7 -  Number: npNewLstErfNr
.head 7 -  Number: npFallKey
.head 7 -  Number: npBewPlanNr
.head 7 -  String: spAdminItemKey
.head 7 -  Sql Handle: hSql
.head 7 -  Number: nLT
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nFetch
.head 7 -  Number: nIdminItemNr
.head 7 -  Number: nNR
.head 7 -  Number: nNR_Detail
.head 6 +  Actions
.head 7 -  !
.head 7 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( ADMIN_ITEM_NR ) + 1
from	LST_ADM_TODO_ITEMS
where	EINRICHT_ID = 1
   and	FALL_KEY = :npVirtFallKey
   and	LST_ERF_NR =  :npNewLstErfNr
into	:nIdminItemNr " )
.head 7 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 7 +  If Not bOk
.head 8 +  If nFetch = FETCH_EOF
.head 9 -  Set bOk = TRUE
.head 8 +  Else
.head 9 -  Return 0
.head 7 +  If Not nIdminItemNr
.head 8 -  Set nIdminItemNr = 1
.head 7 -  !
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert
into	LST_ADM_TODO_ITEMS (
	EINRICHT_ID, FALL_KEY, LST_ERF_NR,
	ADMIN_ITEM_NR, 	ADMIN_ITEM_KEY,
	ITEM_EINRICHT_ID, ITEM_FALL_KEY, ITEM_BEW_NR )
values (	1, :npVirtFallKey , :npNewLstErfNr, :nIdminItemNr ,
	'" || spAdminItemKey || "', 1, :npFallKey , :npBewPlanNr  )" )
.head 7 -  ! Logging
.head 7 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql, nLT, 'LST_ADM_TODO_ITEMS', 'I')
.head 7 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert	into LT_VALUES (ID, NAME, KEY1, KEY2, KEY3, KEY4 ) 
values	(:nNR_Detail, 'insert into LST_ADM_TODO_ITEMS', 1, :npVirtFallKey , :npNewLstErfNr, :nIdminItemNr  )" ) 
.head 7 -  ! end of log
.head 7 +  If Not bOk
.head 8 -  Set nIdminItemNr = 0
.head 7 -  Return nIdminItemNr
.head 5 +  Function: Animal2Experiment
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Boolean:
.head 6 +  Parameters
.head 7 -  String: sExpParam
.head 7 -  String: sRecParam
.head 7 -  Boolean: bNeedRefresh
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFallKey2Trans[*]
.head 7 -  String: sLicenseKey
.head 7 -  String: sLicenseRecord
.head 7 -  Number: nInd
.head 7 -  Number: nI
.head 7 -  Number: nIndPrint
.head 7 -  Number: nCountSuccess
.head 7 -  Boolean: bOk
.head 7 -  String: sBackMsg
.head 7 -  String: sResultMsg
.head 7 -  FunctionalVar: oRowInfo
.head 8 -  Class: cFERow
.head 7 -  ! *****
.head 7 -  FunctionalVar: oPosSelected
.head 8 -  Class: cPositionData
.head 7 -  !
.head 7 -  String: sCage
.head 6 +  Actions
.head 7 +  If oHandleSelect.bAnySelects
.head 8 -  Set nInd = 0
.head 8 -  Set nI = 0
.head 8 -  Set nIndPrint = 0
.head 8 +  While nInd < oHandleSelect.nIndex
.head 9 +  If GetLevel(GetRowID(oHandleSelect.nRow[nInd])) = AEL_Animal
.head 10 -  Set oRowInfo = FE_GetInfo( GetRowID(oHandleSelect.nRow[nInd]) )
.head 10 +  If oRowInfo.nID_Obj!=-100
.head 11 -  Set nFallKey2Trans[nI] = oRowInfo.nID_Obj
.head 11 -  Set nI = nI + 1
.head 9 -  Set nInd = nInd + 1
.head 7 +  ! Else
.head 8 +  If not EnumChildren( nSelectedRow, nFallKey2Trans )
.head 9 -  Return FALSE
.head 8 -  Call oRefreshCages.AddRow( nSelectedRow )
.head 8 -  Set sCage = sCage || oPosSelected.sCage 
.head 8 -  Set nI = 1
.head 7 +  If sExpParam and sRecParam
.head 8 -  Set sLicenseKey = sExpParam
.head 8 -  Set sLicenseRecord = sRecParam
.head 7 +  Else
.head 8 +  If Not Request_License( sLicenseKey, sLicenseRecord, oPosSelected.sScreen )
.head 9 -  Return FALSE
.head 7 -  Set bOk = TRUE
.head 7 -  Call LockSysadmAction("Add to group...")
.head 7 -  Set nCountSuccess = 0
.head 7 -  Set nInd = 0
.head 7 -  Set bOk = bOk and SqlPrepare(hSqlPopulate, "update fall_experiment set end_date=@now  where fall_key=:nFallKey2Trans[nInd] and experiment_key!=:sLicenseKey and end_date is null  ")
.head 7 +  While bOk and nFallKey2Trans[nInd]
.head 8 -  Set sBackMsg = ''
.head 8 -  Set bOk = bOk and SqlExecute( hSqlPopulate ) 
.head 8 +  If License_AddCaseMsg_ForSession( hSessionGE ,  sLicenseKey, sLicenseRecord, nFallKey2Trans[nInd], '', sBackMsg )
.head 9 -  Set nCountSuccess = nCountSuccess + 1
.head 8 +  Else
.head 9 +  If sBackMsg = ''	! means SqlError happened
.head 10 -  Set bOk = FALSE 
.head 9 +  Else
.head 10 -  Set sResultMsg = sResultMsg || "
" || sBackMsg
.head 8 -  Set nInd = nInd + 1
.head 7 +  If bOk
.head 8 -  Call SqlCommit( hSqlPopulate )
.head 7 +  Else
.head 8 -  Call SqlPrepareAndExecute(hSqlPopulate, "rollback")
.head 7 +  If bOk
.head 8 -  Call LockSysadmAction("...added to group")
.head 8 -  Set sResultMsg = StrX( nCountSuccess ) || " " || GetMessageFromSection( "FALL_GROUPS", 12060, "cases assigned to the License" ) || " " || sLicenseKey  || "
---------------------------------------------------------------------
" || sResultMsg
.head 8 -  ! *****
.head 8 -  Call GalTimedMessageBox( hWndForm, sResultMsg, GetMessage( 202 ), 1000 )
.head 8 -  ! Call RefreshCages(  )
.head 8 +  If bNeedRefresh
.head 9 -  Call SalSendMsg(hWndForm,AM_Refresh,0,1)
.head 7 +  Else
.head 8 -  Call LockSysadmAction("...not added to group")
.head 7 -  Return bOk
.head 5 +  ! Function: Bewegung_DoInsertPlanX23
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Number: 
.head 6 +  Parameters 
.head 7 -  String: sSchema
.head 7 -  Number: nEID
.head 7 -  Number: nFallKey
.head 7 -  Number: nBew_Nr
.head 7 -  Date/Time: dtBewZeit
.head 7 -  String: sBA_Key
.head 7 -  String: sBG1_Key
.head 7 -  String: sBG2_Key
.head 7 -  String: sAbtKey
.head 7 -  String: sStatKey
.head 7 -  String: sGruppeKey
.head 7 -  String: sBettKey
.head 7 -  Number: nAnswerMode	! Ask=0, Yes2All=1, No2All=2
.head 7 -  Sql Handle: hSql1
.head 7 -  Number: nLT
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  Number: nFetch
.head 7 -  Number: nFetch1
.head 7 -  Number: nBewNr_New
.head 7 -  Number: nLock_ID
.head 7 -  String: sStatusText
.head 7 -  Date/Time: dtBis
.head 7 -  String: sConcatString
.head 7 -  Boolean: bLockAcquired
.head 7 -  Number: nNR
.head 7 -  Number: nNR_Detail
.head 7 -  Date/Time: dt_BewZeit_Old
.head 7 -  Number: nLock_ID1
.head 7 -  Number: nLastBewNr
.head 7 -  Boolean: bOk
.head 7 -  Sql Handle: hSql2
.head 6 +  Actions 
.head 7 -  ! Set bOk = bInitialized or Init( 'INS', sSchema, nEID, nFallKey, nBew_Nr, sBA_Key, dtBewZeit, sAbtKey, sStatKey, sGruppeKey, sBettKey, sBG1_Key, nAnswerMode, TRUE )
.head 7 +  ! If Not bOk
.head 8 -  Return 0
.head 7 -  Set bOk = TRUE
.head 7 -  Call SalStatusGetText( hWndForm, sStatusText, 250 )
.head 7 -  Call SalStatusSetText( hWndForm, sStatusText || ' - Do insert PLAN...' )
.head 7 -  Call VisWaitCursor( TRUE )
.head 7 -  Call SqlConnect(hSql2)
.head 7 +  If bOk And sStatKey And sGruppeKey And sBettKey
.head 8 +  ! Loop 
.head 9 +  When SqlError 
.head 10 -  ! Call SqlExtractArgs ( wParam, lParam, hSqlError, nSqlError, nErrorPos )
.head 10 +  ! If nSqlError < 0
.head 11 -  Set nSqlError = - nSqlError
.head 10 -  ! Set nrpSqlErrorNr = nSqlError
.head 10 -  ! Call SqlPrepareAndExecute(h_Sql, "rollback")
.head 10 -  Set bLockAcquired = FALSE
.head 10 -  Return FALSE
.head 9 -  Set bLockAcquired = TRUE
.head 9 -  Set bLockAcquired = bLockAcquired and SqlPrepareAndExecute(hSql1, "lock table xlock")
.head 9 -  Set bLockAcquired = bLockAcquired and SqlPrepareAndExecute(hSql1, "lock table bewegung_plan")
.head 9 -  Set bLockAcquired = bLockAcquired and SqlPrepareAndExecute(hSql1, "lock table bett_locks")
.head 9 +  If bLockAcquired
.head 10 -  Break 
.head 8 -  ! ! Get new Plan-BEW_NR
.head 8 -  Set bOk = SqlPrepareAndExecute( hSql1, "
select	@nullvalue( max( BEW_NR ), 1000 ) + 1
from	BEWEGUNG_PLAN
where	Fall_Key = :nFallKey
into	:nLastBewNr " )
.head 8 -  Set bOk = bOk And SqlFetchNext( hSql1, nFetch )
.head 8 +  If bOk
.head 9 -  Set nBewNr_New = nLastBewNr
.head 8 -  ! !
.head 8 -  ! ! Insert new BEWEGUNG_PLAN
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert into	BEWEGUNG_PLAN
             (	EINRICHT_ID, FALL_KEY, BEW_NR,
	BEW_ZEIT, BA_KEY, BG1_Key, BG2_Key,
	ABT_KEY,
	ENTERED, ENTERED_BY
              )
values   (	:nEID, :nFallKey, :nLastBewNr,
	:dtBewZeit, :sBA_Key, :sBG1_Key, :sBG2_Key,
	:sAbtKey,
	:dtBewZeit, USER
              ) " )
.head 8 -  ! ! Logging "insert into BEWEGUNG_PLAN"
.head 8 -  Set bOk =bOk And  SqlPrepareAndExecute( hSql1, "
select 	@nullvalue(max(NR)+1,1)
from 	LT_DETAIL
where 	LT_NR=:nLT into :nNR " )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSql1, nFetch )
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert 	into LT_DETAIL (LT_NR, NR, OP, TBNAME)
values 	(:nLT,:nNR,'I','BEWEGUNG_PLAN' ) " )
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
select 	ID
from 	LT_DETAIL
where 	LT_NR=:nLT and NR=:nNR and OP='I' and TBNAME ='BEWEGUNG_PLAN'
into	:nNR_Detail " )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSql1, nFetch )
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert	into LT_VALUES (ID, NAME, KEY1, KEY2, KEY3 )
values	( :nNR_Detail, 'BEWEGUNG_PLAN', 	:nEID, :nFallKey, :nLastBewNr )" )
.head 8 -  ! end of logging
.head 8 -  ! ! Insert new BETT_LOCKS
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSql1, "
select	@nullvalue( max( LOCK_ID ), 0 ) + 1
from	BETT_LOCKS
into	:nLock_ID " )
.head 8 -  Set bOk = bOk And SqlFetchNext( hSql1, nFetch )
.head 8 -  !
.head 8 -  ! select min VON >= :dt_BewZeit_New for this FALL
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSql1, Gal_IR( "
select	min( VON )
from	BETT_LOCKS
where	PLANBEW_EINR = :nEID
  and	PLANBEW_FALL = :nFallKey
  and	VON > :dtBewZeit
into	:dtBis ", MDB_GetServerTypeX( hSql1 ) ) )
.head 8 -  Set bOk = bOk And SqlFetchNext( hSql1, nFetch )
.head 8 -  !
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert into	BETT_LOCKS
             (	LOCK_ID, VON, BIS, BL_ART,
	EINRICHT_ID, Stat_Key, Gruppe_Key, Bett_Key,
	PLANBEW_EINR, PLANBEW_FALL, PLANBEW_BEW,
	INFO, pos_id
              )
values   (	:nLock_ID, :dtBewZeit, :dtBis, :sBA_Key,
	:nEID , :sStatKey, :sGruppeKey, :sBettKey,
	:nEID, :nFallKey, :nLastBewNr,
	'BewPlan', 1 ) " )
.head 8 -  ! ! Logging "insert into BETT_LOCKS"
.head 8 -  ! Set bOk =bOk And  SqlPrepareAndExecute( hSql1, "
select 	@nullvalue(max(NR)+1,1)
from 	LT_DETAIL
where 	LT_NR=:nLT into :nNR " )
.head 8 -  ! Set bOk = bOk and SqlFetchNext( hSql1, nFetch )
.head 8 -  Set nNR = nNR+1
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert 	into LT_DETAIL (LT_NR, NR, OP, TBNAME)
values 	(:nLT,:nNR,'I','BETT_LOCKS' ) " )
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
select 	ID
from 	LT_DETAIL
where 	LT_NR=:nLT and NR=:nNR and OP='I'
into	:nNR_Detail " )
.head 8 -  Set bOk = bOk and SqlFetchNext( hSql1, nFetch )
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert	into LT_VALUES (ID, NAME, KEY1 )
values	(:nNR_Detail, 'BETT_LOCKS', :nLock_ID )" )
.head 8 -  ! end of logging
.head 8 -  ! ! Logging "Update BETT_LOCKS" - save values  into LT journal BEFORE update
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql2, "
select  	LOCK_ID, BIS
from 	BETT_LOCKS
where	PLANBEW_EINR =1 
  and	PLANBEW_FALL in( 10000622, 10000623, 10000626)
into 	 :nLock_ID1, :dt_BewZeit_Old
" )
.head 8 +  If SqlFetchNext( hSql2, nFetch1 )
.head 9 -  Set nNR = nNR+1
.head 9 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert 	into LT_DETAIL (LT_NR, NR, OP, TBNAME)
values 	(:nLT,:nNR,'U','BETT_LOCKS' ) " )
.head 9 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
select 	ID
from 	LT_DETAIL
where 	LT_NR=:nLT and NR=:nNR and OP='U'
into	:nNR_Detail " )
.head 9 -  Set bOk = bOk and SqlFetchNext( hSql1, nFetch )
.head 9 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert	into LT_VALUES (ID, NAME, VALD, KEY1 )
values	(:nNR_Detail, 'BETT_LOCKS', :dt_BewZeit_Old,  :nLock_ID1 )" )
.head 9 +  While SqlFetchNext( hSql2, nFetch1 )
.head 10 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
insert	into LT_VALUES (ID, NAME, VALD, KEY1 )
values	(:nNR_Detail, 'BETT_LOCKS', :dt_BewZeit_Old,  :nLock_ID1 )" )
.head 9 -  ! end of logging
.head 8 -  ! update locks set Bis = :dt_BewZeit_New where ( Bis is null or Bis > :dt_BewZeit_New ) and Von < :dt_BewZeit_New
.head 8 -  Set bOk = bOk And SqlPrepareAndExecute( hSql1, "
update	BETT_LOCKS
set	BIS = :dtBewZeit
where	PLANBEW_EINR =1 
  and	PLANBEW_FALL in( 10000622, 10000623, 10000626)" )
.head 7 -  Call VisWaitCursor( FALSE )
.head 7 -  !
.head 7 -  ! Call Finish(  )
.head 7 +  ! If bOk
.head 8 -  Set nBewNr_New = n_BewNr
.head 8 -  Set sConcatString = sAbtKey || ";" || sStatKey || ";" || sGruppeKey || ";" || sBettKey
.head 8 -  Call Notifications_SendBroadcast( nNotification_MovementAffected, sConcatString )
.head 7 -  Call SalStatusSetText( hWndForm, sStatusText )
.head 7 -  Call SqlDisconnect(hSql2)
.head 7 +  If Not bOk
.head 8 -  Set nLastBewNr = 0
.head 7 -  Return nLastBewNr
.head 5 +  Function: PlanMating
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nFem
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Boolean: bOk
.head 7 -  Number: nI
.head 7 -  ! Number: nJ
.head 7 -  ! Number: nA
.head 7 -  String: sExp
.head 7 -  String: sExpRec
.head 7 -  String: sExpTemp
.head 7 -  Number: nFtch
.head 7 -  Number: nVirtFallKey
.head 7 -  Number: nAEBewNr
.head 7 -  Number: nNewLstErfNr
.head 7 -  Number: nBEwNr
.head 7 -  String: sTarif
.head 7 -  Boolean: bExists
.head 7 -  Boolean: bNotInLicence
.head 7 -  Boolean: bSeveralLicence
.head 7 -  Number: nRetMsg
.head 7 -  Number: nRowSel
.head 7 -  String: sVal[1]
.head 7 -  ! Number: nRowFullCages[*]
.head 7 -  Boolean: bClearSelectAnimals
.head 7 -  ! Number: nMale[*]
.head 7 -  ! Number: nFemale[*]
.head 7 -  ! Number: nAnimals[*]
.head 7 -  ! Number: nCountF
.head 7 -  ! Number: nCountM
.head 7 -  ! Number: nCountCages
.head 7 -  ! Number: nCountEmptyCages
.head 7 -  ! cFERow: oCageOpen
.winattr class FunctionalVar:
.head 8 -  Class: cFERow
.end
.head 7 -  ! String: sStrNull
.head 7 -  Date/Time: dtPlanMating
.head 7 -  String: sGrund1
.head 7 -  String: sGrund2
.head 7 -  Number: nScreenID
.head 7 -  Number: nTargetCageID
.head 7 -  String: sTargetScreen
.head 7 -  String: sTargetRack 
.head 7 -  String: sTargetCage 
.head 7 -  Number: nTargetPosID
.head 7 -  Number: nAnimalID
.head 7 -  Sql Handle: hSql_LT
.head 7 -  Number: nLT
.head 7 -  String: sStorn
.head 7 -  Number: nNR
.head 7 -  Number: nNR_Detail
.head 6 +  Actions
.head 7 -  Set bOk = CanPlanMating(nFem)
.head 7 -  Set bClearSelectAnimals = FALSE
.head 7 -  Set bNotInLicence = FALSE
.head 7 -  Set bSeveralLicence = FALSE
.head 7 -  ! Check experiment
.head 7 +  If bOk
.head 8 -  Set nI = 0
.head 8 +  If oHandleSelect.nIndex > 0
.head 9 +  While nI < oHandleSelect.nIndex and not bSeveralLicence
.head 10 +  If sExp = STRING_Null
.head 11 -  Set nRowSel = GetRowID(oHandleSelect.nRow[nI])
.head 11 -  Set sExp = GetSValue(nRowSel , "EXP")
.head 11 +  If sExp = STRING_Null
.head 12 -  Set bOk = FALSE
.head 12 -  Set bNotInLicence = TRUE
.head 11 +  Else
.head 12 -  Set sExpTemp = sExp
.head 10 +  Else
.head 11 -  Set nRowSel = GetRowID(oHandleSelect.nRow[nI])
.head 11 -  Set sExp = GetSValue(nRowSel , "EXP")
.head 11 +  If sExpTemp != STRING_Null and sExpTemp != sExp and sExp != STRING_Null
.head 12 -  Set bOk = FALSE
.head 12 -  Set bNotInLicence = FALSE
.head 12 -  Set bSeveralLicence = TRUE
.head 11 +  Else If sExp = STRING_Null
.head 12 -  Set bOk = FALSE
.head 12 -  Set bNotInLicence = TRUE
.head 10 -  Set nI = nI + 1
.head 8 +  If not bOk
.head 9 +  If bNotInLicence
.head 10 +  If sExpTemp = STRING_Null
.head 11 -  Set nMsgBtn1 = 5014
.head 11 -  Set nMsgBtn2 = 5015
.head 11 -  Set nMsgBtn3 = 10003
.head 11 -  Set nRetMsg = GalMessageBox(D_GetMessageStatic( 11075 ), D_GetMessageStatic_w_Nr( 11078,1 ), MB_UserButtons3)
.head 11 +  If nRetMsg = IDYES
.head 12 +  If SqlPrepareAndExecute( hSqlPopulate , "select EXPERIMENT_KEY from experiment where EXP_SIGNED_P2=3
into :sExp " )
.head 13 -  If SqlFetchNext( hSqlPopulate, nFtch )
.head 13 +  Else
.head 14 -  Set nRetMsg = IDCANCEL
.head 12 +  Else
.head 13 -  Set nRetMsg = IDCANCEL
.head 10 +  Else
.head 11 -  Set nMsgBtn1 = 10004
.head 11 -  Set nMsgBtn2 = 10003
.head 11 -  Set sVal[0] = sExpTemp
.head 11 -  Set nRetMsg = GalMessageBox(D_GetMessageStatic( 11075 ), D_GetMessageFull(11078,2,sVal  ) , MB_UserButtons2)
.head 11 -  Set sExp = sExpTemp
.head 10 +  If nRetMsg = IDYES or nRetMsg = IDOK
.head 11 +  If SqlPrepareAndExecute(hSqlPopulate, " select	ORD_CODE, ORD_DESC||'('||SPECIES||')'
into :sExpRec
from	EXP_SPECIES e
where	EXPERIMENT_KEY = :sExp and STATUS='1'
and NOT exists (select e1.ORD_CODE
	from EXP_SPECIES e1 
	where e.EXPERIMENT_KEY=e1.EXPERIMENT_KEY and e.ORD_CODE||'.1' = e1.ORD_CODE and e1.STATUS='1')")
.head 12 +  If SqlFetchNext( hSqlPopulate, nFtch )
.head 13 -  Set bOk = Animal2Experiment(sExp, sExpRec , FALSE )
.head 12 +  Else
.head 13 -  Set nRetMsg = IDCANCEL
.head 11 +  Else
.head 12 -  Set nRetMsg = IDCANCEL
.head 10 +  Else If nRetMsg = IDNO
.head 11 -  Set bOk = Animal2Experiment("","" , FALSE )
.head 11 -  Set nRowSel = GetRowID(oHandleSelect.nRow[0])
.head 11 -  Set nVirtFallKey = GetIdObject( nRowSel )
.head 11 -  Set bOk = bOk and SqlPrepareAndExecute(hSqlPopulate, "select experiment_key from fall_experiment where fall_key=:nVirtFallKey and end_date is null into :sExp")
.head 11 -  Set bOk = bOk and SqlFetchNext( hSqlPopulate, nFtch )
.head 10 +  Else If nRetMsg = IDCANCEL
.head 11 -  Set bOk = FALSE
.head 10 -  ! Set bFreezeRefresh = FALSE
.head 10 +  If bClearSelectAnimals
.head 11 -  Call oHandleSelect.ReInit(  )
.head 9 +  Else
.head 10 -  Call T_MessageBox_Static(10015,5012,MB_Ok) 
.head 7 -  ! Create plan Mating
.head 7 +  If bOk
.head 8 -  Set bPlanDate = TRUE
.head 8 +  If IDOK != SalModalDialog( dlgKHE_SetBewDatumAndGrund, hWndForm, 'UE', dtPlanMating, sGrund1, sGrund2 )
.head 9 -  Set bOk = FALSE
.head 8 -  Set bPlanDate = FALSE
.head 7 +  If bOk
.head 8 -  Call GetVirtFallKey4Experiment( sExp, nVirtFallKey, nAEBewNr )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulate, "select TARIF_KEY from leistung
where LA_KEY = 'AL'
and LST_KEY = 'MATING'
into :sTarif")
.head 8 -  Set bOk = bOk and SqlFetchNext( hSqlPopulate, nFtch )
.head 8 -  Set nScreenID = GetIdObject( GetParent( GetParent(GetRowID( oHandleSelect.nRow[0] )) ) )
.head 8 -  Set sTargetScreen = GetSValue( GetParent( GetParent(GetRowID( oHandleSelect.nRow[0] )) ), "SCREEN" )
.head 8 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlPopulate , "select g.id, g.stat_key, g.gruppe_key
from  abt_stat a, gruppe g, STATION s
where  a.scr_id = :nScreenID
and	a.rack_ID = s.ID
and 	s.ID = g.RACK_ID
and	s.VIRTUAL = 'J'

and not EXISTS(select	 f.LAST_CAGE_ID
from  fall f
where	     	f.last_CAGE_ID = g.ID
	 and       f.last_BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
	 and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
) 
 and	g.gruppe_KEY not in (select	 bl.gruppe_KEY
				from  BETT_LOCKS bl
   				where	      g.gruppe_KEY=bl.gruppe_KEY
   					 and       (bl.bis>@NOW or bl.bis is null  )
)
into :nTargetCageID, :sTargetRack, :sTargetCage
" )
.head 8 +  If oHandleSelect.bAnySelects
.head 9 -  Set nI = 0
.head 9 +  If SqlFetchNext( hSqlPopulate, nFtch )
.head 10 -  Set nI = 0
.head 10 -  Call LockSysadmAction("Plan service(MATING)...")
.head 10 -  ! Start Logical Transaction here/ Get new LT number.
.head 10 -  Set nLT = LT_GetNumOfNewTransaction()
.head 10 -  Call SqlConnect(hSql_LT)
.head 10 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT ,"Insert into LT ( NR, USER_ID, TYPE, STATUS, START, END) values (:nLT, :nUserId, 10, 1, @NOW, @NOW) ")
.head 10 -  ! Set nNewLstErfNr = InsertAdminLstErf( nVirtFallKey, nAEBewNr, sTarif, "MATING", 'AL', dtPlanMating )
.head 10 -  Set nNewLstErfNr = InsertAdminLstErfX( nVirtFallKey, nAEBewNr, sTarif, "MATING", 'AL', dtPlanMating, hSql_LT, nLT)
.head 10 +  If nNewLstErfNr = 0 
.head 11 -  Set bOk = FALSE
.head 10 -  Set nTargetPosID =  1
.head 10 +  While nI < oHandleSelect.nIndex and bOk
.head 11 -  ! Call _GetPositionID( GetRowID(oHandleSelect.nRow[nI]), oAnimal )
.head 11 -  Set nAnimalID = GetIdObject( GetRowID( oHandleSelect.nRow[nI] ) )
.head 11 -  ! Set nBEwNr = Bewegung_DoInsertPlanX("SYSADM", nEinrichtId, nAnimalID,0, dtPlanMating, "UE", sGrund1,sGrund2,
			sTargetScreen,sTargetRack, sTargetCage, SalNumberToStrX(nTargetPosID, 0), 1)
.head 11 -  Set nBEwNr = Bewegung_DoInsertPlanX2("SYSADM", nEinrichtId, nAnimalID,0, dtPlanMating, "UE", sGrund1,sGrund2,
			sTargetScreen,sTargetRack, sTargetCage, SalNumberToStrX(nTargetPosID, 0), 1, hSql_LT, nLT)
.head 11 +  If nBEwNr = 0 
.head 12 -  Set bOk = FALSE
.head 11 -  ! Call PlanedMovement_InsAdmAction(nVirtFallKey,nNewLstErfNr,nAnimalID, nBEwNr, 'Plan2Real_Bew')
.head 11 -  Set bOk = bOk And PlanedMovement_InsAdmActionX(nVirtFallKey,nNewLstErfNr,nAnimalID, nBEwNr, 'Plan2Real_Bew', hSql_LT, nLT)
.head 11 -  Set nTargetPosID =  nTargetPosID+1
.head 11 -  Set nI = nI + 1
.head 10 +  If SqlExists ("Select * from LST_ADM_TODO_ITEMS where LST_ERF_NR = :nNewLstErfNr  ", bExists)
.head 11 +  If not bExists 
.head 12 -  ! ! ! Logging "Update LST_ERF" - save values before update into LT journal - 1 record will be updated
.head 12 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
select  	STORNIERT
from 	LST_ERF		
where 	LST_ERF_NR = :nNewLstErfNr
and 	EINRICHT_ID = :nEinrichtId
and 	FALL_KEY = :nVirtFallKey 
into 	:sStorn
" )
.head 12 +  If SqlFetchNext( hSql_LT, nFtch )
.head 13 -  Set nNR_Detail = LT_AddRecordToLT_Detail(hSql_LT, nLT, 'LST_ERF', 'U')
.head 13 -  Set bOk = bOk And SqlPrepareAndExecute( hSql_LT, "
insert	into LT_VALUES (ID, NAME, VALS, KEY1,KEY2,KEY3 )
values	(:nNR_Detail, 'STORNIERT', :sStorn,  :nEinrichtId,  :nVirtFallKey, :nNewLstErfNr )" )
.head 13 -  ! end of log
.head 12 -  Set bOk = bOk and SqlPrepareAndExecute( hSql_LT ,"
	Update 	LST_ERF
	set 	STORNIERT = 'J'
	where 	LST_ERF_NR = :nNewLstErfNr
	and 	EINRICHT_ID = :nEinrichtId
	and 	FALL_KEY = :nVirtFallKey ")
.head 10 -  ! DEBGGNGCall SqlPrepareAndExecute( hSql_LT, "Rollback" )
.head 10 +  If bOk
.head 11 -  Call SqlPrepareAndExecute( hSql_LT, "Commit" )
.head 10 +  Else
.head 11 -  Call SqlPrepareAndExecute( hSql_LT, "Rollback" )
.head 10 -  Call SalSendMsg(hWndForm,AM_Refresh,0,1)
.head 10 -  Call SalSendMsg(hWnd_ActToolbar,AM_Refresh,0,0)
.head 10 -  Call LockSysadmAction("...service planned")
.head 5 -  !
.head 5 +  Function: GoToParent
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nParentRow
.head 6 +  Actions
.head 7 -  Set nParentRow = MTblGetParentRow( hWndForm, nSelectedRow )
.head 7 +  If nParentRow!= TBL_Error
.head 8 -  Call ActivateRow( nParentRow )
.head 5 +  Function: Jump
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nDirection ! DIR_Up or DIR_Down
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRow
.head 6 +  Actions
.head 7 +  If nDirection = DIR_Up
.head 8 -  Set nRow = MTblGetPrevChildRow( hWndForm, nSelectedRow )
.head 7 +  Else If nDirection = DIR_Down
.head 8 -  Set nRow = MTblGetNextChildRow( hWndForm, nSelectedRow )
.head 7 +  If nRow!=TBL_Error
.head 8 -  Call ActivateRow( nRow )
.head 5 +  Function: UnSelectAnimals
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildRow
.head 7 -  Number: nRowStrain
.head 7 -  Number: nRowContext
.head 6 +  Actions
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 +  If colCheck = 1
.head 9 -  Call SwitchSelectRow( nSelectedRow )
.head 7 +  Else If nSelectedLevel = AEL_Strain
.head 8 -  Set nRowContext = SalTblQueryContext( hWndForm )
.head 8 -  Set nChildRow = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nChildRow = TBL_Error
.head 10 -  Break
.head 9 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 9 +  If colCheck = 1
.head 10 -  Call SwitchSelectRow( nChildRow )
.head 9 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 8 -  Call SalTblSetContext( hWndForm, nRowContext )
.head 7 +  Else If nSelectedLevel = AEL_Workgroup
.head 8 -  Set nRowContext = SalTblQueryContext( hWndForm )
.head 8 -  Set nRowStrain = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nRowStrain = TBL_Error
.head 10 -  Break
.head 9 -  Set nChildRow = GetFirstChildRow( nRowStrain )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If colCheck = 1
.head 11 -  Call SwitchSelectRow( nChildRow )
.head 10 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 9 -  Set nRowStrain = GetNextChildRow( nRowStrain )
.head 8 -  Call SalTblSetContext( hWndForm, nRowContext )
.head 5 +  Function: SelectAnimals
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nChildRow
.head 7 -  Number: nRowStrain
.head 7 -  Number: nRowContext
.head 6 +  Actions
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 +  If colCheck = 0
.head 9 -  Call SwitchSelectRow( nSelectedRow )
.head 7 +  Else If nSelectedLevel = AEL_Strain
.head 8 -  Set nRowContext = SalTblQueryContext( hWndForm )
.head 8 -  Set nChildRow = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nChildRow = TBL_Error
.head 10 -  Break
.head 9 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 9 +  If colCheck = 0
.head 10 -  Call SwitchSelectRow( nChildRow )
.head 9 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 8 -  Call SalTblSetContext( hWndForm, nRowContext )
.head 7 +  Else If nSelectedLevel = AEL_Workgroup
.head 8 -  Set nRowContext = SalTblQueryContext( hWndForm )
.head 8 -  Set nRowStrain = GetFirstChildRow( nSelectedRow )
.head 8 +  Loop
.head 9 +  If nRowStrain = TBL_Error
.head 10 -  Break
.head 9 -  Set nChildRow = GetFirstChildRow( nRowStrain )
.head 9 +  Loop
.head 10 +  If nChildRow = TBL_Error
.head 11 -  Break
.head 10 -  Call SalTblSetContext( hWndForm, nChildRow )
.head 10 +  If colCheck = 0
.head 11 -  Call SwitchSelectRow( nChildRow )
.head 10 -  Set nChildRow = GetNextChildRow( nChildRow )
.head 9 -  Set nRowStrain = GetNextChildRow( nRowStrain )
.head 8 -  Call SalTblSetContext( hWndForm, nRowContext )
.head 5 -  !
.head 5 +  Function: GetLevelSettings
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  FunctionalVar:
.head 8 -  Class: oSettingsFE
.head 6 +  Parameters
.head 7 -  Number: nRowNr
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  FunctionalVar: oReturn
.head 8 -  Class: oSettingsAE
.head 6 +  Actions
.head 7 +  Select Case GetLevel( nRowNr )
.head 8 +  Case AEL_Root
.head 9 -  Set oReturn = oSettingsRoot
.head 9 -  Break
.head 8 +  Case AEL_Workgroup
.head 9 -  Set oReturn = oSettingsWorkGroup
.head 9 -  Break
.head 8 +  Case AEL_Animal
.head 9 -  Set oReturn = oSettingsAnimal
.head 9 -  Break
.head 8 +  Case AEL_Service
.head 9 -  Set oReturn = oSettingsService
.head 9 -  Break
.head 8 +  Case AEL_Strain
.head 9 -  Set oReturn = oSettingsStrain
.head 9 -  Break
.head 8 +  Default
.head 9 -  Break
.head 7 -  Return oReturn
.head 5 +  Function: GetNameRowLevel
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  String:
.head 6 +  Parameters
.head 7 -  Number: nRowNr
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  String: sReturn
.head 6 +  Actions
.head 7 +  Select Case GetLevel( nRowNr )
.head 8 +  Case AEL_Root
.head 9 -  Set sReturn =  "cAERowRoot"
.head 9 -  Break
.head 8 +  Case AEL_Workgroup
.head 9 -  Set sReturn =  "cAERowScr"
.head 9 -  Break
.head 8 +  Case AEL_Animal
.head 9 -  Set sReturn =  "cAERowAnimal"
.head 9 -  Break
.head 8 +  Case AEL_Service
.head 9 -  Set sReturn =  "cAERowService"
.head 9 -  Break
.head 8 +  Case AEL_Strain
.head 9 -  Set sReturn =  "cAERowStrain"
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set sReturn =  "cFERow"
.head 9 -  Break
.head 7 -  Return sReturn
.head 5 +  Function: GetLevelFlag
.head 6 -  Description:
.head 6 +  Returns
.head 7 -  Number:
.head 6 +  Parameters
.head 7 -  Number: nRowNr
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nReturn
.head 6 +  Actions
.head 7 +  Select Case GetLevel(nRowNr)
.head 8 +  Case AEL_Root
.head 9 -  Set nReturn = oSettingsRoot.nFlags
.head 9 -  Break
.head 8 +  Case AEL_Workgroup
.head 9 -  Set nReturn = oSettingsWorkGroup.nFlags
.head 9 -  Break
.head 8 +  Case AEL_Animal
.head 9 -  Set nReturn = oSettingsAnimal.nFlags
.head 9 -  Break
.head 8 +  Case AEL_Service
.head 9 -  Set nReturn = oSettingsService.nFlags
.head 9 -  Break
.head 8 +  Case AEL_Strain
.head 9 -  Set nReturn = oSettingsStrain.nFlags
.head 9 -  Break
.head 8 +  Default
.head 9 -  Set nReturn = 0
.head 9 -  Break
.head 7 -  Return nReturn
.head 5 +  Function: ReAssignPic
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nCurrentRow
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nLevelLoc
.head 7 -  FunctionalVar: oCheckRow
.head 8 -  Class: cFERow
.head 7 -  Number: nKoefHeightRow
.head 7 -  String: sMaska
.head 7 -  Number: nrHeight
.head 7 -  Number: nPicAssign
.head 7 -  Number: nPicAssignNew
.head 7 -  Number: nFocusRow
.head 7 -  Window Handle: hWndFocusCol
.head 7 -  !
.head 7 -  ! String: sMaska1
.head 7 -  ! Number: nKoef
.head 7 -  ! Number: nSizeFont
.head 7 -  ! Number: nH_Pic
.head 7 -  ! Number: nW_Pic
.head 6 +  Actions
.head 7 -  Set nKoefHeightRow = 0.8
.head 7 -  Set oCheckRow = FE_GetInfo( nCurrentRow )
.head 7 -  Call SalTblSetContext(hWndForm,nCurrentRow )
.head 7 -  Set sMaska=''
.head 7 -  Set nLevelLoc =GetLevel( nCurrentRow )
.head 7 -  Set nFlags = MTSI_ALIGN_LEFT | MTSI_ALIGN_VCENTER  |MTSI_REDRAW
.head 7 -  Set nRowFlags = MTASR_ALLROWS | MTASR_HIDDENROWS
.head 7 +  Select Case nLevelLoc
.head 8 +  Case AEL_Root
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Root' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsRoot.hFont.sName, oSettingsRoot.hFont.nSize, oSettingsRoot.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsRoot.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  Call oSettingsRoot.cPicture.SetNewHeight( nrHeight)
.head 9 -  Set sMaska='H_Main'
.head 9 -  If oSettingsRoot.GetPic(sMaska, nPicAssign)
.head 9 +  ! If nPicAssign = 0 or nPicAssign = NUMBER_Null
.head 10 -  Set sMaska='W_Main'
.head 10 -  If oSettingsWorkGroup.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case AEL_Workgroup
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics WorkGroup' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsWorkGroup.hFont.sName, oSettingsWorkGroup.hFont.nSize, oSettingsWorkGroup.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsWorkGroup.hFont.nSize * 2*nKoefHeightRow )
.head 9 -  Call oSettingsWorkGroup.cPicture.SetNewHeight( nrHeight)
.head 9 -  Set sMaska = oCheckRow.GetSValue( "SCREEN" )
.head 9 -  If oSettingsWorkGroup.GetPic(sMaska, nPicAssign)
.head 9 +  If nPicAssign = 0 or nPicAssign = NUMBER_Null
.head 10 -  Set sMaska='W_Main'
.head 10 -  If oSettingsWorkGroup.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case AEL_Animal
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Animals' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsAnimal.hFont.sName, oSettingsAnimal.hFont.nSize, oSettingsAnimal.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Set nrHeight = SalNumberRound( oSettingsAnimal.hFont.nSize * 2*nKoefHeightRow )
.head 9 +  If TRUE
.head 10 -  Call oSettingsAnimal.cPicture.SetNewHeight( nrHeight )
.head 10 -  !
.head 10 -  Set sMaska='M'
.head 10 +  If oCheckRow.GetSValue( "Sex" ) = 'M'
.head 11 -  Set sMaska=sMaska || "_Male"
.head 10 +  Else
.head 11 -  Set sMaska=sMaska || "_Female"
.head 10 +  If oCheckRow.GetState( AnimalIsDead )
.head 11 -  Set sMaska=sMaska || "_Dead"
.head 10 +  ! If oCheckRow.GetState( AnimalIsLitter )
.head 11 -  Set sMaska=sMaska || "_Pups"
.head 10 +  If oCheckRow.GetState( IsAlert )
.head 11 -  Set sMaska=sMaska || "_Alert"
.head 10 +  If oCheckRow.GetState( IsServise )
.head 11 -  Set sMaska=sMaska || "_Serv"
.head 10 +  If oCheckRow.GetState( AnimalInPlanBew ) and not oCheckRow.GetState( AnimalIsDead )
.head 11 -  Set sMaska=sMaska || "_Plan"
.head 10 +  If colCheck=1
.head 11 -  Set sMaska=sMaska || "_Select"
.head 10 -  If oSettingsAnimal.GetPic(sMaska, nPicAssign)
.head 9 -  Break
.head 8 +  Case AEL_Strain
.head 9 -  Call SalStatusSetText( hWndForm, 'ReAssignPics Strains' )
.head 9 -  Call MTblSetRowFont( hWndForm, nCurrentRow, oSettingsStrain.hFont.sName, oSettingsStrain.hFont.nSize, oSettingsStrain.hFont.nEnh, MTSF_REDRAW )
.head 9 -  ! Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Break
.head 7 +  If nPicAssign != NUMBER_Null ! and not bPics
.head 8 -  Call SalTblQueryFocus( hWndForm, nFocusRow, hWndFocusCol )
.head 8 -  Set nPicAssignNew = MImgCreateCopy( nPicAssign )
.head 8 +  If nFocusRow = nCurrentRow
.head 9 -  Call MImgInvert( nPicAssignNew )
.head 8 -  Call MTblSetCellImageExp( colTree, nCurrentRow, nPicAssignNew, nFlags )
.head 8 -  Call MTblSetCellImage( colTree, nCurrentRow, nPicAssignNew, nFlags )
.head 5 -  !
.head 5 +  Function: Refresh
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nMode ! 8 - refresh all open rows ; 0 - refresh current row and selected rows , 1- Full refresh
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nRowRefresh
.head 7 -  Boolean: bOk
.head 7 -  Boolean: bSelectedRowIsRefershed
.head 7 -  Number: nFetch
.head 7 -  Number: nI
.head 6 +  Actions
.head 7 +  If nMode = 8
.head 8 -  Set nLevel = 1
.head 8 -  Set bOk = SqlExecute(oSqlUTable.hSql[6])
.head 8 -  Set bOk = bOk and SqlFetchNext(oSqlUTable.hSql[6], nFetch)
.head 8 +  If bOk 
.head 9 -  Set nRowRefresh = GetRowID( nUniqRow )
.head 9 -  Call PopulateRoot(  )
.head 8 -  Set nLevel = 2
.head 8 -  Set bOk = SqlExecute(oSqlUTable.hSql[6])
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[6], nFetch)
.head 9 -  Set nRowRefresh = GetRowID( nUniqRow )
.head 9 -  Call PopulateWorkgroup( nRowRefresh, FALSE )
.head 8 -  Set nLevel = 3
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[6])
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[6], nFetch)
.head 9 -  Set nRowRefresh = GetRowID( nUniqRow )
.head 9 -  Call PopulateStrain( nRowRefresh, FALSE )
.head 8 -  Set nLevel = 4
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[6])
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[6], nFetch)
.head 9 -  Set nRowRefresh = GetRowID( nUniqRow )
.head 9 -  Call PopulateAnimal( nRowRefresh, FALSE )
.head 7 +  Else If nMode = 0
.head 8 -  Set bSelectedRowIsRefershed = FALSE
.head 8 -  Set bOk = TRUE
.head 8 +  If oHandleSelect.bAnySelects
.head 9 -  Set nI = 0
.head 9 +  While nI < oHandleSelect.nIndex
.head 10 -  Set nRowRefresh = GetRowID( oHandleSelect.nRow[nI] )
.head 10 -  Set nStatus = 2
.head 10 -  Set nUniqRow = oHandleSelect.nRow[nI]
.head 10 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[5])
.head 10 +  If nRowRefresh != TBL_Error
.head 11 -  Call PopulateAnimal( nRowRefresh, TRUE )
.head 10 +  If nRowRefresh = nSelectedRow
.head 11 -  Set bSelectedRowIsRefershed = TRUE
.head 10 -  Set nI = nI + 1
.head 8 +  If not bSelectedRowIsRefershed
.head 9 -  Set nStatus = 2
.head 9 -  Set nUniqRow = GetUniqRowID( nSelectedRow )
.head 9 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[5])
.head 9 +  Select Case nSelectedLevel
.head 10 +  Case AEL_Root
.head 11 -  Call PopulateRoot( )
.head 11 -  Break
.head 10 +  Case AEL_Workgroup
.head 11 -  Call PopulateWorkgroup(nSelectedRow ,TRUE)
.head 11 -  Break
.head 10 +  Case AEL_Animal
.head 11 -  Call PopulateAnimal( nSelectedRow,TRUE)
.head 11 -  Break
.head 10 +  Case AEL_Strain
.head 11 -  Call PopulateStrain( nSelectedRow,TRUE )
.head 11 -  Break
.head 10 +  Default
.head 11 -  Break
.head 9 -  Call SortTree()
.head 9 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 9 -  Call SetSizeTree()
.head 9 -  Call SalInvalidateWindow( hWndForm )
.head 8 -  Set nLevel = 2
.head 8 -  Set nStatus = 2
.head 8 -  Set bOk = bOk and SqlExecute(oSqlUTable.hSql[7])
.head 8 +  While bOk and SqlFetchNext(oSqlUTable.hSql[7],nFetch )
.head 9 -  Call DeleteRow( GetRowID( nUniqRow ) )
.head 7 +  Else If nMode = 1
.head 8 +  If bNeedRefreshOnShow
.head 9 -  Set bNeedRefreshOnShow = FALSE
.head 9 -  Call FullFilter()
.head 5 +  Function: SearchAnimal
.head 6 -  Description:
.head 6 -  Returns
.head 6 +  Parameters
.head 7 -  Number: nSearchFall
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Sql Handle: hSqlFind
.head 7 -  Boolean: bOk
.head 7 -  Number: nUnRow
.head 7 -  Number: nParentRow
.head 7 -  Number: nFetch
.head 7 -  Number: nScr
.head 7 -  Number: nStrain
.head 6 +  Actions
.head 7 +  If GalConnect(hSqlFind)
.head 8 -  Set bOk = SqlPrepareAndExecute( hSqlFind, "select uniqrow from " || sUserName || ".AnimalListTree 
where level=3 and id_obj=:nSearchFall
into :nUnRow " )
.head 8 -  Set nUnRow = -1
.head 8 +  If bOk
.head 9 +  If SqlFetchNext(hSqlFind, nFetch)
.head 10 -  Set nUnRow = GetRowID( nUnRow )
.head 10 -  Set nParentRow = GetParent( nUnRow )
.head 10 +  If not RowIsExpand( nParentRow )
.head 11 -  Call MTblExpandRow( hWndForm, nParentRow, MTM_ExpandRow )
.head 9 +  Else
.head 10 -  Set bOk = bOk and SqlPrepareAndExecute( hSqlFind, "select f.last_scr_id, c.colony*65536+f.id_strain  from fall f 
join gruppe g on (g.id=f.last_cage_id)
join colony c on (c.scr_id=f.last_scr_id and c.strain_id=f.id_strain and c.rack_id=g.rack_id)

where f.einricht_id=:nEinrichtId and f.fall_key = :nSearchFall into :nScr, :nStrain " )
.head 10 +  If bOk and SqlFetchNext(hSqlFind, nFetch)
.head 11 -  Set nUnRow = FindObject( -1, nScr )
.head 11 +  If nUnRow != -1
.head 12 -  Set nUnRow = FindObject( nUnRow, nStrain)
.head 12 +  If nUnRow != -1
.head 13 -  Call PopulateStrain( nUnRow, TRUE )
.head 13 -  Call MTblExpandRow( hWndForm, nUnRow, MTM_ExpandRow )
.head 13 -  Set nUnRow = FindObject( nUnRow, nSearchFall)
.head 8 -  Call SqlDisconnect( hSqlFind )
.head 8 +  If nUnRow != -1
.head 9 -  Call ActivateRow( nUnRow )
.head 9 -  Call SwitchSelectRow( nUnRow )
.head 5 +  Function: ExpandAll
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nFtch
.head 7 -  Boolean: bOk
.head 7 -  Number: nRowR
.head 7 -  Number: nRowChild
.head 7 -  Number: nRowChild1
.head 6 +  Actions
.head 7 -  Set nLevel =  AEL_Root + 1
.head 7 -  Set bOk = SqlExecute(oSqlUTable.hSql[6])
.head 7 -  Set bOk = bOk and SqlFetchNext( oSqlUTable.hSql[6], nFtch )
.head 7 +  If bOk 
.head 8 -  Set nRowR = GetRowID( nUniqRow )
.head 8 -  Call ExpandRow(nRowR)
.head 8 -  Set nRowChild = GetFirstChildRow( nRowR )
.head 8 +  Loop
.head 9 +  If nRowChild = TBL_Error
.head 10 -  Break
.head 9 -  Call ExpandRow(nRowChild)
.head 9 -  Set nRowChild1 = GetFirstChildRow( nRowChild )
.head 9 +  Loop
.head 10 +  If nRowChild1 = TBL_Error
.head 11 -  Break
.head 10 -  Call ExpandRow(nRowChild1)
.head 10 -  Set nRowChild1 = GetNextChildRow( nRowChild1 )
.head 9 -  Set nRowChild = GetNextChildRow( nRowChild )
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call SqlCreateSession( hSessionGE, "" )
.head 6 -  Call SqlCreateStatement( hSessionGE, hSqlPopulate )
.head 6 -  Call SqlCreateStatement( hSessionGE, hSqlPopulate1 )
.head 6 -  Call oSqlL1.SetSession( hSessionGE )
.head 6 -  Call oSqlL1.InitSqls( 4 )
.head 6 -  Call oSqlL2.SetSession( hSessionGE )
.head 6 -  Call oSqlL2.InitSqls( 4 )
.head 6 -  Call oSqlL3.SetSession( hSessionGE )
.head 6 -  Call oSqlL3.InitSqls( 3 )
.head 6 -  Call oSqlL4.SetSession( hSessionGE )
.head 6 -  Call oSqlL4.InitSqls( 5 )
.head 6 -  Call oSqlUTable.SetSession( hSessionGE )
.head 6 -  Call oSqlUTable.InitSqls( 9 )
.head 6 -  Call CreateTmpTable()
.head 6 -  Set bPopulateOnFirstShow = FALSE
.head 6 -  Set hWndAnE = hWndForm
.head 6 -  ! Set bNeedActivateRow = TRUE
.head 6 -  ! Set bFreezeRefresh = FALSE
.head 6 -  ! Call T_CageCreate()
.head 5 +  On SAM_Destroy
.head 6 -  ! Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 6 +  If hSqlPopulate
.head 7 -  Call SqlDisconnect( hSqlPopulate )
.head 6 +  If hSqlPopulate1
.head 7 -  Call SqlDisconnect( hSqlPopulate1 )
.head 6 -  Call oSqlL1.AllDisconnect(  )
.head 6 -  Call oSqlL2.AllDisconnect(  )
.head 6 -  Call oSqlL3.AllDisconnect(  )
.head 6 -  Call oSqlL4.AllDisconnect(  )
.head 6 -  Call oSqlUTable.AllDisconnect(  )
.head 6 -  Set hWndAnE = hWndNULL
.head 6 +  If hSessionGE
.head 7 -  Call SqlFreeSession( hSessionGE )
.head 5 +  On AM_Activate
.head 6 -  Call FirstPopulate()
.head 6 -  Call Refresh(1)
.head 5 +  On SAM_DoubleClick
.head 6 -  Call PopulateRow(lParam)
.head 6 +  If nSelectedLevel = AEL_Animal
.head 7 -  Call SwitchSelectRow( lParam )
.head 5 +  On SAM_RowSetContext
.head 6 -  Call SalPostMsg(hWndForm, AM_SetFocus , 10, 0)
.head 6 -  Return TRUE
.head 5 +  On AM_SetFocus
.head 6 +  If wParam = 10
.head 7 -  Call SalTblQueryFocus( hWndForm, nSelectedRow, hWndCol )
.head 7 -  Call ActivateRow(nSelectedRow)
.head 6 -  Return TRUE
.head 5 +  On AM_GetState
.head 6 +  Select Case lParam
.head 7 +  Case 1 ! show/hide Discharge  Animal
.head 8 -  Return bShowDischargeAnimal
.head 7 +  Case 2 ! show/hide Plan move
.head 8 -  Return bShowAnimalPlanMove
.head 7 +  Case 3 ! show/hide Mate
.head 8 -  Return bShowAnimalMate
.head 7 +  Case 4 ! show/hide service
.head 8 -  Return bShowService
.head 7 +  Case 5 ! On/off filter
.head 8 -  Return bFillterOn
.head 7 +  Case 6 ! On/Off Sort
.head 8 -  Return bSortOn
.head 7 +  Case 7 ! show/hide Culling  Animal
.head 8 -  Return bShowCullingAnimal
.head 7 +  Default
.head 8 -  Return TRUE
.head 5 +  On AM_Filter
.head 6 -  Call UnSelectAll(  )
.head 6 +  Select Case wParam
.head 7 +  Case 1 ! open combinate filter
.head 8 +  ! If SalModalDialog( dlgFE_Filter , hWndForm, cScreenFilter, cAnimalFilter, cStrainFilter  ) = IDOK
.head 9 -  Call cScreenFilter.Save(  )
.head 9 -  Call cAnimalFilter.Save(  )
.head 9 -  Call cStrainFilter.Save(  )
.head 9 -  Call FullFilter()
.head 8 +  If SalModalDialog( dlgTotalFilter , hWndForm, cFullFilter)= IDOK
.head 9 -  Call cFullFilter.Save(  )
.head 9 -  Call FullFilter()
.head 9 -  Call ExpandAll()
.head 8 -  Break
.head 7 +  Case 0 ! set quickly fiter
.head 8 +  If lParam = 1 ! Dischage animal
.head 9 -  Set bShowDischargeAnimal = not bShowDischargeAnimal
.head 9 -  Call SetOptionBooleanS("AE", "ShowDischargeAnimal", bShowDischargeAnimal)
.head 9 -  Call QuickFilter(AEL_Animal)
.head 9 -  ! Call SalSendMsg( hWndItem,  AM_Refresh, 0, 0)
.head 8 +  Else If lParam = 2 ! plan move
.head 9 -  Set bShowAnimalPlanMove = not bShowAnimalPlanMove
.head 9 -  Call SetOptionBooleanS("AE", "ShowInPlan", bShowAnimalPlanMove)
.head 9 -  Call QuickFilter(AEL_Animal)
.head 9 -  ! Call SalSendMsg( hWndItem,  AM_Refresh, 0, 0)
.head 8 +  Else If lParam = 3 ! mating
.head 9 -  Set bShowAnimalMate = not bShowAnimalMate
.head 9 -  Call SetOptionBooleanS("AE", "ShowInMate", bShowAnimalMate)
.head 9 -  Call QuickFilter(AEL_Animal)
.head 9 -  ! Call SalSendMsg( hWndItem,  AM_Refresh, 0, 0)
.head 8 +  Else If lParam = 4 ! Services
.head 9 -  Set bShowService = not bShowService
.head 9 -  Call SetOptionBooleanS("AE", "ShowServices", bShowService)
.head 9 -  Call SalSendMsg( hWndItem,  AM_Refresh, 0, 0)
.head 8 +  Else If lParam = 5 ! Culling animal
.head 9 -  Set bShowCullingAnimal  = not bShowCullingAnimal
.head 9 -  Call SetOptionBooleanS("AE", "ShowDeathAnimal", bShowCullingAnimal)
.head 9 -  Call QuickFilter(AEL_Animal)
.head 7 +  Default
.head 8 -  Break
.head 6 -  Call SalSendMsg(hWndItem, AM_Refresh,0,0)
.head 5 +  On AM_Sort
.head 6 +  If SalModalDialog( dlgFE_Sort, hWndForm, cScreenSort, cAnimalSort, cStrainSort ) = IDOK
.head 7 -  Call cScreenSort.Save(  )
.head 7 -  Call cAnimalSort.Save(  )
.head 7 -  Call cStrainSort.Save(  )
.head 7 -  Call SortTree()
.head 5 +  On AM_ReloadSettings
.head 6 -  Call oSettingsRoot.cPicture.Reload(  )
.head 6 -  Call oSettingsWorkGroup.cPicture.Reload(  )
.head 6 -  Call oSettingsAnimal.cPicture.Reload(  )
.head 6 -  Call oSettingsStrain.cPicture.Reload(  )
.head 6 -  Call LoadSettings()
.head 6 +  If wParam = 2
.head 7 +  ! If lParam = 1
.head 8 -  Call oSettingsHouse.cPicture.Reload(  )
.head 8 -  Call oSettingsWorkGroup.cPicture.Reload(  )
.head 8 -  Call oSettingsRack.cPicture.Reload(  )
.head 8 -  Call oSettingsCage.cPicture.Reload(  )
.head 8 -  Call oSettingsBett.cPicture.Reload(  )
.head 7 -  Call Refresh(8)
.head 7 -  Call MTblAutoSizeRows( hWndForm, nRowFlags )
.head 6 +  ! If wParam=0
.head 7 -  Call Refresh(1,0)
.head 5 +  On SAM_ContextMenu
.head 6 +  Select Case nSelectedLevel
.head 7 +  Case AEL_Root
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_AE_L4', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case AEL_Workgroup
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_AE_L1', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case AEL_Strain
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_AE_L2', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Case AEL_Animal
.head 8 -  Call SalTrackPopupMenu ( hWndStar2000, 'Menu_AE_L3', TPM_LeftAlign, wParam, lParam )
.head 8 -  Break
.head 7 +  Default
.head 8 -  Break
.head 5 +  On AM_KHE_GotoGrpByFall
.head 6 +  If nSelectedLevel = AEL_Animal
.head 7 -  Call SalSendMsg( hWndStar2000, AM_KHE_GotoBedByFall, 0, GalSetAsWinMsgLParam_Number(  colIDObject ) )
.head 5 +  On AM_Refresh
.head 6 -  Call Refresh( wParam )
.head 6 +  If lParam = 1
.head 7 -  Call UnSelectAll(  )
.head 5 +  On AM_Show
.head 6 +  If wParam = 15 ! ShowDetailInfo
.head 7 +  If hDetailInfoAE
.head 8 -  Call SalDestroyWindow( hDetailInfoAE )
.head 7 +  Else
.head 8 -  Call ShowDetatilInfo(TRUE)
.head 5 +  On WM_KEYDOWN
.head 6 +  If wParam = VK_Shift or wParam = VK_DOWN  or wParam = VK_UP
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 -  Call SwitchSelectRow( nSelectedRow )
.head 6 +  Else
.head 7 -  Call SalSendMsg(hWndStar2000 , WM_KEYDOWN, wParam, lParam )
.head 6 +  ! Else If wParam = VK_DOWN  and VisGetKeyState ( VK_Shift ) & KS_Down 
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 -  Call SwitchSelectRow( nSelectedRow )
.head 6 +  ! Else If wParam = VK_UP and VisGetKeyState ( VK_Shift ) & KS_Down 
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 -  Call SwitchSelectRow( nSelectedRow )
.head 5 +  On WM_KEYUP
.head 6 +  If (wParam = VK_DOWN  or wParam = VK_UP) and VisGetKeyState ( VK_Shift ) & KS_Down 
.head 7 +  If nSelectedLevel = AEL_Animal
.head 8 -  Call SwitchSelectRow( nSelectedRow )
.head 5 +  ! On MTM_CollapseRow
.head 6 -  Call UnselectChild( lParam )
.head 5 +  On AM_Search
.head 6 -  Call SearchAnimal(GalGetAsWinMsgLParam_Number( wParam )  )
.head 5 +  On AM_KHE_Cut
.head 6 +  If CanUnSelectAnimals()
.head 7 -  Call UnSelectAnimals(  )
.head 6 +  Else
.head 7 -  Call SelectAnimals()
.head 3 +  ! Functional Class: cFilterFE
.winattr
.end
.head 4 -  Description: 
.head 4 -  Derived From 
.head 4 -  Class Variables 
.head 4 -  Instance Variables 
.head 4 -  Functions 
.head 3 +  ! Functional Class: cSortFE
.winattr
.end
.head 4 -  Description: 
.head 4 -  Derived From 
.head 4 -  Class Variables 
.head 4 -  Instance Variables 
.head 4 -  Functions 
.head 3 +  ! Functional Class: clsLocation
.winattr
.end
.head 4 -  Description: 
.head 4 -  Derived From 
.head 4 -  Class Variables 
.head 4 +  Instance Variables 
.head 5 -  String: sScreenKey
.head 5 -  String: sRackKey
.head 5 -  String: sCageKey
.head 5 -  String: sPlaceKey
.head 4 +  Functions 
.head 5 +  Function: Init
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  Return TRUE
.head 5 +  Function: SetScreenKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: spScreenKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  ! without check at the moment
.head 7 -  Set sScreenKey = spScreenKey
.head 7 -  Return TRUE
.head 5 +  Function: GetScreenKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  String: 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  Return sScreenKey
.head 5 +  Function: SetRackKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: spRackKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  ! without check at the moment
.head 7 -  Set sRackKey = spRackKey
.head 7 -  Return TRUE
.head 5 +  Function: GetRackKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  String: 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  Return sRackKey
.head 5 +  Function: SetCageKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: spCageKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  ! without check at the moment
.head 7 -  Set sCageKey = spCageKey
.head 7 -  Return TRUE
.head 5 +  Function: GetCageKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  String: 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  Return sCageKey
.head 5 +  Function: SetPlaceKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: spPlaceKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  ! without check at the moment
.head 7 -  Set sPlaceKey = spPlaceKey
.head 7 -  Return TRUE
.head 5 +  Function: GetPlaceKey
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  String: 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 -  Return sPlaceKey
.head 5 +  Function: IsEqual
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  FunctionalVar: oEqualTo
.winattr class
.head 8 -  Class: clsLocation
.end
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 +  If sScreenKey = oEqualTo.GetScreenKey( )
  And sRackKey = oEqualTo.GetRackKey( )
  And sCageKey = oEqualTo.GetCageKey( )
  And sPlaceKey = oEqualTo.GetPlaceKey( )
.head 8 -  Return TRUE
.head 7 +  Else 
.head 8 -  Return FALSE
.head 5 +  Function: IsEmpty
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 +  If sScreenKey Or sRackKey Or sCageKey Or sPlaceKey
.head 8 -  Return FALSE
.head 7 +  Else 
.head 8 -  Return TRUE
.head 5 +  Function: GetCage
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  FunctionalVar: (no name)
.winattr class
.head 8 -  Class: clsLocation
.end
.head 6 -  Parameters 
.head 6 -  Static Variables 
.head 6 +  Local variables 
.head 7 -  FunctionalVar: oCage
.winattr class
.head 8 -  Class: clsLocationCage
.end
.head 6 +  Actions 
.head 7 +  If sScreenKey And sRackKey And sCageKey
.head 8 -  Call oCage.Init( sScreenKey, sRackKey, sCageKey )
.head 7 -  Return oCage
.head 3 +  ! Functional Class: clsLocationScreen
.winattr
.end
.head 4 -  Description: 
.head 4 +  Derived From 
.head 5 -  Class: clsLocation
.head 4 -  Class Variables 
.head 4 -  Instance Variables 
.head 4 +  Functions 
.head 5 +  Function: Init
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: sScreenKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 +  If Not clsLocation.Init( )
.head 8 -  Return FALSE
.head 7 +  If Not SetScreenKey( sScreenKey )
.head 8 -  Return FALSE
.head 7 -  Return TRUE
.head 3 +  ! Functional Class: clsLocationRack
.winattr
.end
.head 4 -  Description: 
.head 4 +  Derived From 
.head 5 -  Class: clsLocationScreen
.head 4 -  Class Variables 
.head 4 -  Instance Variables 
.head 4 +  Functions 
.head 5 +  Function: Init
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 +  If Not clsLocationScreen.Init( sScreenKey )
.head 8 -  Return FALSE
.head 7 +  If Not SetRackKey( sRackKey )
.head 8 -  Return FALSE
.head 7 -  Return TRUE
.head 3 +  ! Functional Class: clsLocationCage
.winattr
.end
.head 4 -  Description: 
.head 4 +  Derived From 
.head 5 -  Class: clsLocationRack
.head 4 -  Class Variables 
.head 4 -  Instance Variables 
.head 4 +  Functions 
.head 5 +  Function: Init
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 +  If Not clsLocationRack.Init( sScreenKey, sRackKey )
.head 8 -  Return FALSE
.head 7 +  If Not SetCageKey( sCageKey )
.head 8 -  Return FALSE
.head 7 -  Return TRUE
.head 3 +  ! Functional Class: clsLocationPlace
.winattr
.end
.head 4 -  Description: 
.head 4 +  Derived From 
.head 5 -  Class: clsLocationCage
.head 4 -  Class Variables 
.head 4 -  Instance Variables 
.head 4 +  Functions 
.head 5 +  Function: Init
.head 6 -  Description: 
.head 6 +  Returns 
.head 7 -  Boolean: 
.head 6 +  Parameters 
.head 7 -  String: sScreenKey
.head 7 -  String: sRackKey
.head 7 -  String: sCageKey
.head 7 -  String: sPlaceKey
.head 6 -  Static Variables 
.head 6 -  Local variables 
.head 6 +  Actions 
.head 7 +  If Not clsLocationCage.Init( sScreenKey, sRackKey, sCageKey )
.head 8 -  Return FALSE
.head 7 +  If Not SetPlaceKey( sPlaceKey )
.head 8 -  Return FALSE
.head 7 -  Return TRUE
.head 3 +  ! Functional Class: cPositionData
.winattr
.end
.head 4 -  Description: 
.head 4 -  Derived From 
.head 4 -  Class Variables 
.head 4 +  Instance Variables 
.head 5 -  Number: nActHandel
.head 5 -  String: sScreen
.head 5 -  String: sRack
.head 5 -  String: sCage
.head 5 -  String: sBett
.head 5 -  Number: nScreenID
.head 5 -  Number: nRackID
.head 5 -  Number: nCageID
.head 5 -  Number: nPosID
.head 4 -  Functions 
.head 2 +  Default Classes
.head 3 -  MDI Window: cBaseMDI
.head 3 -  Form Window:
.head 3 -  Dialog Box:
.head 3 -  Table Window:
.head 3 -  Quest Window:
.head 3 -  Data Field: clsDataFieldHelpedInput
.head 3 -  Spin Field:
.head 3 -  Multiline Field: clsMultilineField
.head 3 -  Pushbutton: clsPbDelete
.head 3 -  Radio Button: clsRadioButton
.head 3 -  Option Button:
.head 3 -  ActiveX:
.head 3 -  Check Box: clsCheckBox
.head 3 -  Child Table: clsChildTableBrowse
.head 3 -  Quest Child Window: cQuickDatabase
.head 3 -  List Box: clsKHExplorerLeft
.head 3 -  Combo Box: clsComboBox
.head 3 -  Picture:
.head 3 -  Vertical Scroll Bar:
.head 3 -  Horizontal Scroll Bar:
.head 3 -  Column: clsColumn
.head 3 -  Background Text:
.head 3 -  Group Box: clsGroupBox
.head 3 -  Line:
.head 3 -  Frame: clsFrame
.head 3 -  Custom Control: cQuickGraph
.head 2 +  Application Actions
.head 3 +  ! On SAM_AppStartup
.head 4 +  If ReadExeArguments(  )
.head 5 -  Call SalCreateWindow( frmAtlantaMain, hWndNULL )
.head 3 +  ! On SAM_AppExit
.head 4 -  Call FinishUserProcess( sUserName, TRUE )
.head 4 -  Call ReleaseUsersConnection( hUsersConnectSQL, sUsersConnectTable, dtUsersConnectStart )
.head 3 +  ! On SAM_SqlError
.head 4 -  Call SqlExtractArgs ( wParam, lParam, hSqlError, nSqlError, nErrorPos )
.head 4 +  If nSqlError < 0
.head 5 -  Set nSqlError = - nSqlError
.head 4 +  If nSqlError = 383
.head 5 -  Call ErrorMessageBox( 1073 )
.head 5 -  Return FALSE
.head 4 +  If hWndForm
.head 5 -  Call SalModalDialog( dlgErrorInformation, hWndForm, wParam, lParam )
.head 4 +  Else 
.head 5 -  Call SalModalDialog( dlgErrorInformation, hWndMDI, wParam, lParam )
.head 4 +  If not ( VisGetKeyState( VK_Shift ) & KS_Down )
.head 5 -  Return FALSE
.head 1 +  ! clsSimpleForm: frmAtlantaMain
.head 2 -  Description: 
.head 2 -  Named Menus 
.head 2 -  Menu 
.head 2 +  Tool Bar 
.head 3 +  Contents 
.head 4 +  Pushbutton: pbRoot
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.CollapseRoot()
.head 4 +  ! clsHintedPushbutton: pbAbt
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.ExpandAbt()
.head 4 +  ! clsHintedPushbutton: pbStat
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.ExpandStat()
.head 4 +  ! clsHintedPushbutton: pbGruppe
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.ExpandGruppe()
.head 4 +  ! clsHintedPushbutton: pbBett
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.ExpandBett()
.head 4 +  ! clsHintedPushbutton: pbFindEmpty
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call FindEmptyBed()
.head 6 +  On SAM_Create
.head 7 -  Set sHint = "Search Free Positions"
.head 7 -  Return SalSendClassMessage(SAM_Create,wParam,lParam)
.head 4 +  Option Button: pbAutoManual
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call EnableDisableButtons()
.head 4 +  Pushbutton: pbScan 
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.ForcedPopulateCurrent()
.head 6 +  On SAM_Create
.head 7 -  Set sHint = "Manual Scanning"
.head 7 -  Return SalSendClassMessage(SAM_Create,wParam,lParam)
.head 4 +  Pushbutton: pbCut
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.Move_CutCurrent()
.head 6 +  On SAM_Create
.head 7 -  Set sHint = "Cut"
.head 7 -  Return SalSendClassMessage(SAM_Create,wParam,lParam)
.head 4 +  Pushbutton: pbPaste
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call lbKHELeft.Move_PasteToCurrent()
.head 6 +  On SAM_Create
.head 7 -  Set sHint = "Paste"
.head 7 -  Return SalSendClassMessage(SAM_Create,wParam,lParam)
.head 4 +  ! clsDataField: dfPurposeHidden
.head 5 -  Message Actions 
.head 2 +  Contents 
.head 3 +  List Box: lbKHELeft
.head 4 -  List Initialization 
.head 4 +  Message Actions 
.head 5 +  ! On SAM_DragCanAutoStart
.head 6 -  Call lbKHELeft.DragDrop(
	 lbKHELeft.GetItemHandle(SalListQuerySelection(lbKHELeft)), 
	lbKHERight, 
	lbKHERight.GetItemHandle(SalListQuerySelection(lbKHERight)), 
	DROP_Child)
.head 6 -  Return TRUE
.head 5 +  ! On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click,wParam,lParam)
.head 6 -  Call pbRoot.Enable()
.head 6 -  Call pbAbt.Enable()
.head 6 -  Call pbStat.Enable()
.head 6 -  Call pbGruppe.Enable()
.head 6 -  Call pbBett.Enable()
.head 6 +  If nSelectedLevel = KHEL_Einrichtung
.head 7 -  Call pbRoot.Disable()
.head 6 +  Else If nSelectedLevel = KHEL_Abteilung
.head 7 -  Call pbAbt.Disable()
.head 6 +  Else If nSelectedLevel = KHEL_Station
.head 7 -  Call pbStat.Disable()
.head 6 +  Else If nSelectedLevel = KHEL_Gruppe
.head 7 -  Call pbGruppe.Disable()
.head 6 +  Else If nSelectedLevel = KHEL_Bett
.head 7 -  Call pbBett.Disable()
.head 3 +  ! clsKHExplorerLeft: lbKHERight
.head 4 -  List Initialization 
.head 4 -  Message Actions 
.head 2 +  Functions 
.head 3 +  Function: FindEmptyBed
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  String: sAbt 
.head 5 -  String: sStat
.head 5 -  String: sGrp
.head 5 -  String: sBett 
.head 4 +  Actions 
.head 5 -  Call lbKHELeft.GetCurrentPosition(sAbt,sStat,sGrp,sBett)
.head 5 -  Call SalCreateWindow(tblSearchEmptyBeds,hWndForm,sAbt,sStat,sGrp)
.head 3 +  Function: SelectPurpose
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: hStat
.head 5 -  Number: nStatInd
.head 5 -  String: sPurposeKey
.head 4 +  Actions 
.head 5 +  If SalModalDialog(dlgPurposeSelect,hWndForm,sPurposeKey) = 1 
.head 6 -  Call lbKHELeft.GetCurrentPosition(s1,s2,s3,s4)
.head 6 -  Call DoImmediate("
update GRUPPE 
set  PURPOSE_KEY = '" || sPurposeKey || "'
where  	EINRICHT_ID = :nEinrichtId
and	GRUPPE_KEY = :s3
and 	STAT_KEY     = :s2
")
.head 6 -  Call DoImmediate("
select COLOR
from PURPOSE
where PURPOSE_KEY ='" || sPurposeKey || "'
into :n1
")
.head 6 -  Call lbKHELeft.SetItemColor( lbKHELeft.nSelectedHandle, n1)
.head 6 -  ! Set hStat = lbKHELeft.GetParent(nSelectedHandle)
.head 6 -  ! Set nStatInd = lbKHELeft.GetItemIndex(hStat)
.head 6 -  ! Call SalListSetSelect ( lbKHELeft, nStatInd )
.head 6 -  ! Call lbKHELeft.DeleteDescendents(nStatInd)
.head 6 -  ! Call lbKHELeft.SetItemPopulated(hStat,FALSE)
.head 6 -  ! Call lbKHELeft.PopulateStation(hStat)
.head 6 -  ! Call lbKHELeft.Expand(nStatInd)
.head 5 -  ! -- If FastHelpGetInput(hWndForm,dfPurposeHidden,AM_Refresh,
"
select p.PURPOSE_KEY, p.PURPOSE_BEZ
from PURPOSE p
where 1=1
order by p.PURPOSE_KEY
","Purposes") and dfPurposeHidden
.head 3 +  Function: EnableDisableButtons
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 -  Call lbKHELeft.SetAutoMode(pbAutoManual)
.head 5 +  If pbAutoManual
.head 6 -  Call SalSetWindowText(pbAutoManual,"Auto")
.head 6 -  Call pbScan.Disable()
.head 5 +  Else 
.head 6 -  Call SalSetWindowText(pbAutoManual,"Man.")
.head 6 -  Call pbScan.Enable()
.head 2 -  Window Parameters 
.head 2 -  Window Variables 
.head 2 +  Message Actions 
.head 3 +  On WM_SIZE
.head 4 -  Call SalSetWindowSize( lbKHELeft, 
	SalPixelsToFormUnits(
		 hWndForm, SalNumberLow(lParam), FALSE) , 
  	SalPixelsToFormUnits(
		hWndForm, SalNumberHigh(lParam), TRUE ))
.head 4 -  ! Call SalSetWindowLoc( lbKHELeft, 
	0,   	0)
.head 4 -  ! Call SalSetWindowSize( lbKHELeft, 
	SalPixelsToFormUnits(
		 hWndForm, SalNumberLow(lParam), FALSE) / 2, 
  	SalPixelsToFormUnits(
		hWndForm, SalNumberHigh(lParam), TRUE ))
.head 4 -  ! Call SalSetWindowLoc( lbKHERight, 
	SalPixelsToFormUnits(
		 hWndForm, SalNumberLow(lParam), FALSE) / 2, 
  	0)
.head 4 -  ! Call SalSetWindowSize( lbKHERight, 
	SalPixelsToFormUnits(
		 hWndForm, SalNumberLow(lParam), FALSE) / 2, 
  	SalPixelsToFormUnits(
		hWndForm, SalNumberHigh(lParam), TRUE ))
.head 3 +  On SAM_Create
.head 4 -  Call SalSetWindowLoc( lbKHELeft, 0, 0)
.head 4 -  Call EnableDisableButtons()
.head 1 +  Dialog Box: dlgKHE_SetBewDatumAndGrund
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 126
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  3.938"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.5"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 -  Background Text: 1
.head 4 -  Resource Id: 57625
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.113"
.head 5 -  Top: 0.26"
.head 5 -  Width:  1.113"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfDatum
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.275"
.head 6 -  Top: 0.219"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Center
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Validate
.head 6 +  If not SalIsValidDateTime( dfDatum )
.head 7 -  ! Call SalMessageBox( 'Datum oder Zeit sind falsch', 'Eingabefehler', MB_Ok )
.head 7 -  Call ErrorMessageBox( 130 )
.head 7 -  Return VALIDATE_Cancel
.head 6 +  Else
.head 7 +  If dfDatum > SalDateCurrent() and not bPlanDate
.head 8 -  Set dfDatum = SalDateCurrent()
.head 3 -  Background Text: 2
.head 4 -  Resource Id: 49310
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.094"
.head 5 -  Width:  0.8"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 7
.head 4 -  Window Location and Size
.head 5 -  Left: 2.913"
.head 5 -  Top: 0.198"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 -  Background Text: 3
.head 4 -  Resource Id: 57626
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.113"
.head 5 -  Top: 0.625"
.head 5 -  Width:  1.113"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Combo Box: cmbBewGrund1
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsComboBoxBewGrund
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.275"
.head 5 -  Top: 0.604"
.head 5 -  Width:  1.3"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 1.177"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Editable? Class Default
.head 4 -  String Type: Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Sorted? Class Default
.head 4 -  Always Show List? Class Default
.head 4 -  Vertical Scroll? Class Default
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  List Initialization
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call InitBewGrund( "'" || spBA_Key || "'", "1" )
.head 6 -  Call Populate()
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 5 +  On SAM_Validate
.head 6 -  Call SalSendClassMessage( SAM_Validate, wParam, lParam )
.head 6 +  If SalListQuerySelection( hWndItem ) = -1
.head 7 -  Call ErrorMessageBox( 129 )
.head 7 -  Return VALIDATE_Cancel
.head 3 -  Background Text: 4
.head 4 -  Resource Id: 49309
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.094"
.head 5 -  Width:  0.8"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 8
.head 4 -  Window Location and Size
.head 5 -  Left: 2.913"
.head 5 -  Top: 0.563"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 -  Background Text: 5
.head 4 -  Resource Id: 57627
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.113"
.head 5 -  Top: 0.979"
.head 5 -  Width:  1.113"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Combo Box: cmbBewGrund2
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsComboBoxBewGrund
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.275"
.head 5 -  Top: 0.958"
.head 5 -  Width:  1.3"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 1.042"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Editable? Class Default
.head 4 -  String Type: Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Sorted? Class Default
.head 4 -  Always Show List? Class Default
.head 4 -  Vertical Scroll? Class Default
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  List Initialization
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call InitBewGrund( "'" || spBA_Key || "'", "2" )
.head 6 -  Call Populate()
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 5 +  On SAM_Validate
.head 6 +  If SalListQuerySelection( hWndItem )  = -1
.head 7 -  Call ErrorMessageBox( 129 )
.head 7 -  Return VALIDATE_Cancel
.head 3 -  Background Text: 6
.head 4 -  Resource Id: 49311
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.094"
.head 5 -  Width:  0.8"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 2 +  Functions
.head 3 +  Function: Zoom
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nZoom
.head 5 -  Number: nXPos
.head 5 -  Number: nYPos
.head 5 -  Number: nWidth
.head 5 -  Number: nHeight
.head 5 -  Window Handle: hWndChild
.head 5 -  Number: nType
.head 5 -  Number: nTypeChild
.head 5 -  String: sNameFont
.head 5 -  Number: nSizeFont
.head 5 -  Number: nEnch
.head 5 -  Number: nDelta
.head 5 -  String: sNameObj
.head 5 -  Number: nI
.head 4 +  Actions
.head 5 -  Set nZoom = GetOptionNumberUW("Dialogs", "Scale culling dialog", 1 )
.head 5 -  Set nType = TYPE_GroupBox |TYPE_PushButton|TYPE_BkgdText	|TYPE_ChildTable| TYPE_DataField|TYPE_ComboBox	
.head 5 -  Set hWndChild = SalGetFirstChild( hWndForm, nType)
.head 5 -  Set nDelta = 0.075
.head 5 -  Call SalSetWindowSize( hWndForm, 3.94*nZoom, 1.5*nZoom - (nDelta*2)*(nZoom-1) )
.head 5 -  Set nI = 0
.head 5 +  Loop
.head 6 +  If hWndChild = hWndNULL
.head 7 -  Break
.head 6 -  Call SalGetItemName( hWndChild, sNameObj )
.head 6 -  Call SalGetWindowLoc( hWndChild, nXPos, nYPos  )
.head 6 -  Call SalGetWindowSize( hWndChild, nWidth, nHeight )
.head 6 -  Set nTypeChild = SalGetType( hWndChild )
.head 6 +  If nTypeChild = TYPE_BkgdText or nTypeChild = TYPE_ComboBox
.head 7 -  Call SalFontGet( hWndChild, sNameFont, nSizeFont, nEnch )
.head 7 -  Call SalFontSet( hWndChild, sNameFont, nSizeFont*nZoom, nEnch*nZoom )
.head 7 -  Call SalSetWindowLoc( hWndChild, nXPos*nZoom, nYPos*nZoom + nI*nDelta )
.head 7 -  Call SalSetWindowSize( hWndChild, nWidth*nZoom, nHeight*nZoom )
.head 6 +  Else If nTypeChild = TYPE_PushButton
.head 7 -  Call SalSetWindowLoc( hWndChild, nXPos*nZoom, nYPos*nZoom + nI*nDelta )
.head 7 +  If SalWindowIsDerivedFromClass(hWndChild, clsPushbutton)
.head 8 -  Call SalSendMsg( hWndChild, AM_BtnResize, nWidth * nZoom*100000,nHeight  * nZoom *100000)
.head 7 +  Else
.head 8 -  Call SalSetWindowSize( hWndChild, nWidth * nZoom, nHeight  * nZoom)
.head 6 +  Else If nTypeChild = TYPE_DataField
.head 7 -  Call SalSetWindowLoc( hWndChild, nXPos*nZoom, nYPos*nZoom+ nI*nDelta )
.head 7 -  Call SalSetWindowSize( hWndChild, nWidth*nZoom, nHeight*nZoom )
.head 6 +  Else If nTypeChild = TYPE_ChildTable
.head 7 -  Call SalFontGet(hWndChild, sNameFont, nSizeFont,  nEnch )
.head 7 -  Call SalFontSet ( hWndChild, sNameFont, nSizeFont*nZoom,  nEnch )
.head 7 -  Call SalSetWindowLoc( hWndChild, nXPos*nZoom, nYPos*nZoom + nI*nDelta )
.head 7 -  Call SalSetWindowSize( hWndChild, nWidth*nZoom, nHeight*nZoom )
.head 6 +  Else
.head 7 -  Call SalSetWindowLoc( hWndChild, nXPos*nZoom, nYPos*nZoom + nI*nDelta )
.head 7 -  Call SalSetWindowSize( hWndChild, nWidth*nZoom, nHeight*nZoom )
.head 6 +  If sNameObj ='pbOk' or sNameObj = 'pbCancel'
.head 7 -  Set nI = nI - 1
.head 6 -  Set hWndChild = SalGetNextChild(  hWndChild, nType)
.head 5 -  Call SalInvalidateWindow(hWndForm)
.head 2 +  Window Parameters
.head 3 -  String: spBA_Key
.head 3 -  Receive Date/Time: dtBewZeit
.head 3 -  Receive String: sGrund1
.head 3 -  Receive String: sGrund2
.head 2 +  Window Variables
.head 3 -  String: sWinTitle
.head 3 -  Number: nIdTitleForm
.head 2 +  Message Actions
.head 3 +  On AM_Ok
.head 4 -  Set dtBewZeit = dfDatum
.head 4 +  If SalIsWindowEnabled( cmbBewGrund1 )
.head 5 -  Set sGrund1 = cmbBewGrund1
.head 4 +  Else
.head 5 -  Set sGrund1 = ''
.head 4 +  If SalIsWindowEnabled( cmbBewGrund2 )
.head 5 -  Set sGrund2 = cmbBewGrund2
.head 4 +  Else
.head 5 -  Set sGrund2 = ''
.head 4 -  !
.head 4 -  Call SalEndDialog( hWndForm, IDOK )
.head 3 +  On SAM_Create
.head 4 -  Call dlgKHE_SetBewDatumAndGrund.Hide()
.head 4 -  Call VisWaitCursor( TRUE )	! FALSE is On SAM_CreateComplete 
.head 4 -  ! Call DoImmediate("
select	BA_BEZ
from	BEW_ART
where	BA_Key = '" || spBA_Key || "'
  and	Einricht_ID = " || StrX( nEinrichtId ) || "
into	:dlgKHE_SetBewDatumAndGrund.sWinTitle ")
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Call Zoom()
.head 4 +  If spBA_Key = 'ST'
.head 5 -  Set nIdTitleForm = 1
.head 4 +  Else If spBA_Key = 'AM'
.head 5 -  Set nIdTitleForm = 2
.head 4 +  Else If spBA_Key = 'AE'
.head 5 -  Set nIdTitleForm = 3
.head 4 +  Else If spBA_Key = 'EE'
.head 5 -  Set nIdTitleForm = 4
.head 4 +  Else If spBA_Key = 'UE'
.head 5 -  Set nIdTitleForm = 5
.head 4 +  Else If spBA_Key = 'VE'
.head 5 -  Set nIdTitleForm = 6
.head 4 +  Else If spBA_Key = 'NS'
.head 5 -  Set nIdTitleForm = 7
.head 4 +  Else If spBA_Key = 'VS'
.head 5 -  Set nIdTitleForm = 8
.head 4 +  Else If spBA_Key = 'IE'
.head 5 -  Set nIdTitleForm = 9
.head 4 +  Else If spBA_Key = 'RE'
.head 5 -  Set nIdTitleForm = 10
.head 4 +  Else
.head 5 -  Set nIdTitleForm = - 1
.head 4 +  If nIdTitleForm>0
.head 5 -  Call dlgKHE_SetBewDatumAndGrund.SetTitleForm( nIdTitleForm )
.head 4 +  ! If sWinTitle
.head 5 -  Call SalSetWindowText( hWndForm, sWinTitle )
.head 4 -  !
.head 4 +  If dtBewZeit
.head 5 -  Set dfDatum = dtBewZeit
.head 4 +  Else
.head 5 -  Set dfDatum = SalDateCurrent(  )
.head 4 -  !
.head 4 +  If cmbBewGrund1.nResultSetCount
.head 5 -  Call DoImmediate("
select	BG1_Key
from	Bew_Grund1
where	BA_Key = '" || spBA_Key || "'
  and	Einricht_ID = " || StrX( nEinrichtId ) || "
  and	Standard = 'J'
into :dlgKHE_SetBewDatumAndGrund.cmbBewGrund1 ")
.head 4 +  Else
.head 5 -  Call cmbBewGrund1.Disable(  )
.head 4 -  !
.head 4 +  If cmbBewGrund2.nResultSetCount
.head 5 -  Call DoImmediate("
select	BG2_Key
from	Bew_Grund2
where	BA_Key = '" || spBA_Key || "'
  and	Einricht_ID = " || StrX( nEinrichtId ) || "
  and	Standard = 'J'
into :dlgKHE_SetBewDatumAndGrund.cmbBewGrund2 ")
.head 4 +  Else
.head 5 -  Call cmbBewGrund2.Disable(  )
.head 4 -  !
.head 4 -  Call SalSetFocus ( pbOk )
.head 4 -  Call VisWaitCursor( FALSE )	! TRUE is On SAM_Create 
.head 4 +  If not GalGetProfileBooleanX( "Settings", "ShowDischargDialog", TRUE, sUserINIFileName ) and (spBA_Key='EE' )
.head 5 -  Call SalSendMsg(dlgKHE_SetBewDatumAndGrund, AM_Ok,0,0)
.head 4 +  If not (SalStrUpperX( ghsGetProfileStringX( 'Settings', 'AskForBewDate', 'YES' ) ) = 'YES') and (spBA_Key='VE' or spBA_Key='UE') and not bPlanDate
.head 5 -  Call SalSendMsg(dlgKHE_SetBewDatumAndGrund, AM_Ok,0,0)
.head 4 +  If bPOC
.head 5 -  Call SalSendMsg(dlgKHE_SetBewDatumAndGrund, AM_Ok,0,0)
.head 4 -  Set hWndDlgEntlasung = hWndForm
.head 4 -  Call dlgKHE_SetBewDatumAndGrund.Show()
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, IDCANCEL )
.head 3 +  On SAM_Destroy
.head 4 -  Set hWndDlgEntlasung= hWndNULL
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 1 +  Dialog Box: dlgKHE_DateOptions
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Date/Time + Planning Options
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  3.413"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 3.594"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 -  Group Box: Planning Mode
.head 4 -  Resource Id: 53918
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsGroupBox
.head 4 -  Window Location and Size
.head 5 -  Left: 0.125"
.head 5 -  Top: 0.104"
.head 5 -  Width:  3.113"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 1.208"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Check Box: cbPlanningMode
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Activate 'Planning' Mode
.head 4 -  Window Location and Size
.head 5 -  Left: 0.113"
.head 5 -  Top: 0.021"
.head 5 -  Width:  2.363"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage( SAM_Click, wParam, lParam )
.head 6 -  Call SwitchUseCurrentTime(  )
.head 3 +  Pushbutton: pbStart
.data CLASSPROPSSIZE
0000: 1900
.enddata
.data CLASSPROPS
0000: 5461624368696C64 4E616D6573000800 74616250726F7000 00
.enddata
.data INHERITPROPS
0000: 0100
.enddata
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsHintedPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.323"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Bold
.head 4 -  Picture File Name: Go.bmp
.head 4 -  Picture Transparent Color: Chartreuse
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Set sHint =  'Start'
.head 6 -  Call SalSendClassMessage(SAM_Create,wParam,lParam)
.head 6 -  Call Disable(  )
.head 5 +  On GM_Click
.head 6 -  Call StartPlanning(  )
.head 3 +  Pushbutton: pbContinueExistingPlanning
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsHintedPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.615"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name: find.bmp
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Set sHint =  'Connect to Existing Planning'
.head 6 -  Call SalSendClassMessage(SAM_Create,wParam,lParam)
.head 6 -  Call Disable(  )
.head 5 +  On GM_Click
.head 6 -  Call ContinuePlanning(  )
.head 3 +  Pushbutton: pbStop
.data CLASSPROPSSIZE
0000: 1900
.enddata
.data CLASSPROPS
0000: 5461624368696C64 4E616D6573000800 74616250726F7000 00
.enddata
.data INHERITPROPS
0000: 0100
.enddata
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsHintedPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.538"
.head 5 -  Top: 0.323"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Bold
.head 4 -  Picture File Name: STOP.BMP
.head 4 -  Picture Transparent Color: Chartreuse
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Set sHint =  'Stop'
.head 6 -  Call SalSendClassMessage(SAM_Create,wParam,lParam)
.head 6 -  Call Disable(  )
.head 5 +  On GM_Click
.head 6 -  Call StopPlanning(  )
.head 3 +  Pushbutton: pbDelete
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPbDelete
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.538"
.head 5 -  Top: 0.615"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  ! clsPbReport: pbShowDetails
.head 4 -  Message Actions 
.head 3 -  Background Text: Started on:
.head 4 -  Resource Id: 61788
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.925"
.head 5 -  Top: 0.385"
.head 5 -  Width:  0.813"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfPlanningStarted
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.75"
.head 6 -  Top: 0.344"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Left
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: License:
.head 4 -  Resource Id: 61787
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.925"
.head 5 -  Top: 0.677"
.head 5 -  Width:  0.813"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfExperiment
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 30
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.75"
.head 6 -  Top: 0.635"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: Virtual Case:
.head 4 -  Resource Id: 61789
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.925"
.head 5 -  Top: 0.969"
.head 5 -  Width:  0.813"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfVirtual_FallKey
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldCustomHelpedInput
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 12
.head 5 -  Data Type: Number
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.75"
.head 6 -  Top: 0.927"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Left
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  ! On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', '', "
select	f.FALL_KEY, f.NAME1, f.NAME3, f.GEB_DATUM, 
	erf.LST_KEY, erf.TARIF_KEY, erf.LST_ERF_NR, erf.LST_ERF_VON
from	FALL f, VIS_KAT v, LST_ERF erf
where	f.EINRICHT_ID = :nEinrichtId
   and	f.GELOESCHT = 'N'
   and	f.VIS_KAT_KEY = v.VIS_KAT_KEY
   and	v.PATIENT = 'N'
   and	erf.EINRICHT_ID = f.EINRICHT_ID
   and	erf.FALL_KEY = f.FALL_KEY
   and	erf.LA_KEY = 'AL'
   and	erf.DONE = 0
 " )
.head 6 -  Call AddHelpColumn( dfVirtual_FallKey, 'Virt.Case', 1 )
.head 6 -  Call AddHelpColumn( dfExperiment, 'License', 1.5 )
.head 6 -  Call AddHelpColumn( hWndNULL, 'Descript.', 1 )
.head 6 -  Call AddHelpColumn( dfPlanningStarted, 'Started On', 1 )
.head 6 -  Call AddHelpColumn( hWndNULL, 'Admin.Srvc.', 1 )
.head 6 -  Call AddHelpColumn( hWndNULL, 'Tarif', 0.7 )
.head 6 -  Call AddHelpColumn( dfLstErfNr_4Plan, 'Lst.Erf.Nr.', 0 )
.head 6 -  Call AddHelpColumn( dfPastNow, 'Plan On', 1 )
.head 5 +  ! On GM_ShowHelpList
.head 6 +  If Not SalSendClassMessage( GM_ShowHelpList, wParam, lParam )
.head 7 -  Return FALSE
.head 6 -  Call Disable(  )
.head 6 -  Return TRUE
.head 3 +  Data Field: dfLstErfNr_4Plan
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: Number
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.head 4 -  Message Actions
.head 3 +  Data Field: dfPastNow
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: Date/Time
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.head 4 -  Message Actions
.head 3 -  !
.head 3 -  Group Box: Settings
.head 4 -  Resource Id: 22342
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsGroupBox
.head 4 -  Window Location and Size
.head 5 -  Left: 0.125"
.head 5 -  Top: 1.469"
.head 5 -  Width:  3.113"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 1.49"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Check Box: cbUseCurrentTime
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Use &Current DateTime
.head 4 -  Window Location and Size
.head 5 -  Left: 0.275"
.head 5 -  Top: 1.677"
.head 5 -  Width:  1.8"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage( SAM_Click, wParam, lParam )
.head 6 -  Call SwitchUseCurrentTime(  )
.head 3 -  Background Text: Manualy Set to:
.head 4 -  Resource Id: 22343
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.688"
.head 5 -  Top: 2.031"
.head 5 -  Width:  1.05"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfDateTime4Refresh
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.75"
.head 6 -  Top: 1.99"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Left
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Validate
.head 6 +  If not SalIsValidDateTime( hWndItem )
.head 7 -  ! Call SalMessageBox( 'Datum oder Zeit sind falsch', 'Eingabefehler', MB_Ok )
.head 7 -  Call ErrorMessageBox( 130 )
.head 7 -  Return VALIDATE_Cancel
.head 3 +  Check Box: cbShowTimeInKHE
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Show &DateTime in KHE
.head 4 -  Window Location and Size
.head 5 -  Left: 0.275"
.head 5 -  Top: 2.302"
.head 5 -  Width:  1.8"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Message Actions
.head 3 +  Check Box: cbShowOnlyReal
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Show only &Real Movements
.head 4 -  Window Location and Size
.head 5 -  Left: 0.275"
.head 5 -  Top: 2.583"
.head 5 -  Width:  2.775"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.913"
.head 5 -  Top: 3.104"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.713"
.head 5 -  Top: 3.104"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 2 +  Functions
.head 3 +  Function: SwitchUseCurrentTime
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 +  If cbPlanningMode
.head 6 -  Set cbUseCurrentTime = FALSE
.head 6 -  Call cbUseCurrentTime.Disable(  )
.head 6 -  Set cbShowOnlyReal = FALSE
.head 6 -  Call cbShowOnlyReal.Disable(  )
.head 6 -  Call pbStart.Disable(  )
.head 6 -  Call pbContinueExistingPlanning.Disable(  )
.head 6 -  Call pbStop.Enable(  )
.head 6 -  Call pbDelete.Enable(  )
.head 5 +  Else
.head 6 -  Call cbUseCurrentTime.Enable(  )
.head 6 -  Call cbShowOnlyReal.Enable(  )
.head 6 -  Call pbStart.Enable(  )
.head 6 -  Call pbContinueExistingPlanning.Enable(  )
.head 6 -  Call pbStop.Disable(  )
.head 6 -  Call pbDelete.Disable(  )
.head 5 -  !
.head 5 +  If cbUseCurrentTime
.head 6 -  Call dfDateTime4Refresh.Disable(  )
.head 6 -  Call cbShowTimeInKHE.Enable(  )
.head 5 +  Else
.head 6 -  Call dfDateTime4Refresh.Enable(  )
.head 6 -  ! Set cbShowTimeInKHE = TRUE
.head 6 -  Call cbShowTimeInKHE.Disable(  )
.head 3 +  Function: StartPlanning
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Date/Time: dtPlan_Started_Loc
.head 5 -  String: sPlan_Experiment_Loc
.head 5 -  Number: nPlan_Fall_Key_Loc
.head 5 -  Number: nPlan_LstErfNr_Loc
.head 5 -  Number: nPlan_AEBewNr_Loc
.head 5 -  String: sPlan_TarifKey_Loc
.head 5 -  String: sPlan_dfLstKey_Loc
.head 4 +  Actions
.head 5 -  Set dtPlan_Started_Loc = dtPlan_Started
.head 5 -  Set sPlan_Experiment_Loc = sPlan_Experiment
.head 5 -  Set nPlan_Fall_Key_Loc = nPlan_Fall_Key
.head 5 +  If Not SalModalDialog( dlgKHE_StartPlanningMode, hWndForm, dfDateTime4Refresh, dtPlan_Started_Loc, sPlan_Experiment_Loc, 
		     nPlan_Fall_Key_Loc, nPlan_AEBewNr_Loc, sPlan_TarifKey_Loc, sPlan_dfLstKey_Loc, nPlan_LstErfNr_Loc, brpMatingMode )
.head 6 -  Return FALSE
.head 5 -  Set cbPlanningMode = TRUE
.head 5 -  Set dtPlan_Started = dtPlan_Started_Loc
.head 5 -  Set sPlan_Experiment = sPlan_Experiment_Loc
.head 5 -  Set nPlan_Fall_Key = nPlan_Fall_Key_Loc
.head 5 -  Set nPlan_LstErfNr = nPlan_LstErfNr_Loc
.head 5 -  Set nPlan_AEBewNr = nPlan_AEBewNr_Loc
.head 5 -  Set sPlan_TarifKey = sPlan_TarifKey_Loc
.head 5 -  Set sPlan_dfLstKey = sPlan_dfLstKey_Loc
.head 5 -  Set dfDateTime4Refresh = dtPlan_Started
.head 5 -  Set dfPlanningStarted = dtPlan_Started
.head 5 -  Set dfExperiment = sPlan_Experiment
.head 5 -  Set dfVirtual_FallKey = nPlan_Fall_Key
.head 5 -  Call SwitchUseCurrentTime(  )
.head 5 -  Call SalPostMsg( hWndForm, AM_Ok, 0, 0 )
.head 5 -  Return TRUE
.head 3 +  Function: StopPlanning
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Set cbPlanningMode = FALSE
.head 5 -  Call SwitchUseCurrentTime(  )
.head 5 -  ! !!!!!! IB 18.07.2007
.head 5 -  Set brpMatingMode = FALSE
.head 5 -  Set cbUseCurrentTime =TRUE
.head 5 -  Set cbShowOnlyReal =TRUE
.head 5 -  Call hWndKHE.clsKHExplorerLeft.DeleteLst_Erf_NrWithoutMovement ()
.head 5 -  Return TRUE
.head 3 +  Function: ContinuePlanning
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Call dfVirtual_FallKey.Enable(  )
.head 5 -  Call SalSendMsg( dfVirtual_FallKey, GM_ShowHelpList, 0, 0 )
.head 5 +  If dfVirtual_FallKey
.head 6 -  Set cbPlanningMode = TRUE
.head 6 -  Set sPlan_Experiment = dfExperiment
.head 6 -  Set nPlan_Fall_Key = dfVirtual_FallKey
.head 6 -  Set nPlan_LstErfNr = dfLstErfNr_4Plan
.head 6 -  Set dtPlan_Started = dfPlanningStarted
.head 6 -  Set dfDateTime4Refresh = dfPastNow
.head 6 -  Call SwitchUseCurrentTime(  )
.head 6 -  Call SwitchUseCurrentTime(  )
.head 3 +  Function: DeletePlanning
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  ! Delete from BETT_LOCKS, BEWEGUNG_PLAN, LST_ADM_TODO_ITEMS, LST_ERF (AL)
.head 5 +  If IDNO = SalMessageBox( GetMessage( 6 ),
'Besttigung', MB_YesNo | MB_IconQuestion | MB_DefButton2 )
.head 6 -  Return FALSE
.head 5 -  Return DoCloseTransaction( DoImmediate( "
delete from BETT_LOCKS b where exists (
select ADMIN_ITEM_NR from LST_ADM_TODO_ITEMS i
where	i.ITEM_EINRICHT_ID = b.PLANBEW_EINR
  and	i.ITEM_FALL_KEY = b.PLANBEW_FALL
  and	i.ITEM_BEW_NR = b.PLANBEW_BEW
  and	i.EINRICHT_ID = :nEinrichtId
  and	i.FALL_KEY = :dlgKHE_DateOptions.dfVirtual_FallKey
  and	i.LST_ERF_NR = :dlgKHE_DateOptions.dfLstErfNr_4Plan )
;
delete from BEWEGUNG_PLAN b where exists (
select ADMIN_ITEM_NR from LST_ADM_TODO_ITEMS i
where	i.ITEM_EINRICHT_ID = b.EINRICHT_ID
  and	i.ITEM_FALL_KEY = b.FALL_KEY
  and	i.ITEM_BEW_NR = b.BEW_NR
  and	i.EINRICHT_ID = :nEinrichtId
  and	i.FALL_KEY = :dlgKHE_DateOptions.dfVirtual_FallKey
  and	i.LST_ERF_NR = :dlgKHE_DateOptions.dfLstErfNr_4Plan )
;
delete from  LST_ADM_TODO_ITEMS
where	EINRICHT_ID = :nEinrichtId
  and	FALL_KEY = :dlgKHE_DateOptions.dfVirtual_FallKey
  and	LST_ERF_NR = :dlgKHE_DateOptions.dfLstErfNr_4Plan
;
delete from  LST_ERF
where	EINRICHT_ID = :nEinrichtId
  and	FALL_KEY = :dlgKHE_DateOptions.dfVirtual_FallKey
  and	LST_ERF_NR = :dlgKHE_DateOptions.dfLstErfNr_4Plan
" ) )
.head 2 +  Window Parameters
.head 3 -  Receive Boolean: brpPlanningMode
.head 3 -  Receive Boolean: brpMatingMode
.head 3 -  Receive Date/Time: dtrpDateTime4Refresh
.head 3 -  Receive Boolean: brpUseCurrentTime
.head 3 -  Receive Boolean: brpShowTimeInKHE
.head 3 -  Receive Boolean: brpShowOnlyReal
.head 3 -  Receive Date/Time: dtPlan_Started
.head 3 -  Receive String: sPlan_Experiment
.head 3 -  Receive Number: nPlan_Fall_Key
.head 3 -  Receive Number: nPlan_LstErfNr
.head 3 -  Receive Number: nPlan_AEBewNr
.head 3 -  Receive String: sPlan_TarifKey
.head 3 -  Receive String: sPlan_dfLstKey
.head 2 +  Window Variables
.head 3 -  Boolean: bReady
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalCenterWindow( hWndItem )
.head 4 -  Set bReady = TRUE
.head 4 +  If bReady
.head 5 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 +  Else
.head 5 -  Call SalHideWindow( hWndItem )
.head 5 -  Call SalPostMsg( hWndItem, AM_Cancel, 0, 0 ) 
.head 3 +  On SAM_CreateComplete
.head 4 +  If Not bReady
.head 5 -  Return FALSE
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Set cbPlanningMode = brpPlanningMode
.head 4 -  Set dfDateTime4Refresh = dtrpDateTime4Refresh
.head 4 +  If SalIsNull( dfDateTime4Refresh )
.head 5 -  Set dfDateTime4Refresh = SalDateCurrent(  )
.head 4 +  Set cbUseCurrentTime = brpUseCurrentTime
.head 5 -  ! Set cbUseCurrentTime = GalConfig_GetBool( "KHE", "UseCurrentTime", TRUE, cfgUSER )
.head 4 +  Set cbShowTimeInKHE = brpShowTimeInKHE
.head 5 -  ! Set cbShowTimeInKHE = GalConfig_GetBool( "KHE", "ShowTime", TRUE, cfgUSER )
.head 4 -  Set cbShowOnlyReal = brpShowOnlyReal
.head 4 -  Call SwitchUseCurrentTime(  )
.head 4 +  If brpPlanningMode
.head 5 -  Set dfPlanningStarted = dtPlan_Started
.head 5 -  Set dfVirtual_FallKey = nPlan_Fall_Key
.head 5 -  Set dfExperiment = sPlan_Experiment
.head 5 -  Set dfLstErfNr_4Plan = nPlan_LstErfNr
.head 3 +  On AM_Ok
.head 4 +  If Not cbUseCurrentTime
.head 5 +  If SalIsNull( dfDateTime4Refresh )
.head 6 -  Call SalSetFocus( dfDateTime4Refresh )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 20, 'The DateTime is empty !' ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If Not SalSendMsg( dfDateTime4Refresh, GM_IsCorrect, 0, 0 )
.head 6 -  Call SalSetFocus( dfDateTime4Refresh )
.head 6 -  Return FALSE
.head 5 -  !
.head 5 -  Set dtrpDateTime4Refresh = dfDateTime4Refresh
.head 4 +  If cbPlanningMode
.head 5 +  If dfDateTime4Refresh < dfPlanningStarted
.head 6 -  Call SalSetFocus( dfDateTime4Refresh )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 21, 'The DateTime should not be earlier then Start Planning DateTime !' ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 4 -  !
.head 4 +  Set brpUseCurrentTime = cbUseCurrentTime
.head 5 -  ! Call GalConfig_SetBool( "KHE", "UseCurrentTime", cbUseCurrentTime, cfgUSER )
.head 4 -  Set brpShowTimeInKHE = cbShowTimeInKHE
.head 4 -  Set brpShowOnlyReal = cbShowOnlyReal
.head 4 -  Set bR2DLoadSettings=TRUE
.head 4 -  Set brpPlanningMode = cbPlanningMode
.head 4 -  Call GalConfig_SetBool( "KHE", "ShowTime", brpShowTimeInKHE, cfgUSER )
.head 4 +  If brpPlanningMode
.head 5 -  Call GalSetProfileBoolean( "Rack 2D View", "PlannedMode", brpPlanningMode, sUserINIFileName )
.head 5 -  Call GalSetProfileString( "Rack 2D View", "PlannedExp", dfExperiment, sUserINIFileName )
.head 5 -  Set bR2DLoadSettings=TRUE
.head 5 +  If hWndRack2DView and VisWinIsWindow( hWndRack2DView )
.head 6 -  ! Call SalSendMsg(hWndRack2DView, AM_CloseAllCages, 0, 0)
.head 6 -  ! Call hWndRack2DView.frmKHE2DView.ClearStateOfCages( )
.head 6 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshHoldState, 0 )
.head 5 +  If hWndRack2DViewVirt and VisWinIsWindow( hWndRack2DViewVirt )
.head 6 -  ! Call SalSendMsg(hWndRack2DViewVirt, AM_CloseAllCages, 0, 0)
.head 6 -  ! Call hWndRack2DView.frmKHE2DView.ClearStateOfCages( )
.head 6 -  Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshHoldState, 0 )
.head 4 +  Else
.head 5 -  Set bReady = GalGetProfileBooleanX( "Rack 2D View", "PlannedMode", FALSE, sUserINIFileName )
.head 5 -  Call GalSetProfileBoolean( "Rack 2D View", "PlannedMode", brpPlanningMode, sUserINIFileName )
.head 5 +  If hWndRack2DView and bReady!
.head 6 -  ! Call hWndRack2DView.frmKHE2DView._CloseAllCages()
.head 6 -  ! Call SalSendMsg(hWndRack2DView, AM_CloseAllCages, 0, 0)
.head 6 -  ! Call hWndKHE.clsKHExplorerLeft.KHE_RefreshAllCages()
.head 6 -  ! Call hWndRack2DView.frmKHE2DView.ClearStateOfCages( )
.head 6 -  Call SalSendMsg( hWndRack2DView, AM_Refresh, RACK2D_RefreshTimeChanged, 0 )
.head 5 +  If hWndRack2DViewVirt and bReady!
.head 6 -  ! Call hWndRack2DView.frmKHE2DView._CloseAllCages()
.head 6 -  ! Call SalSendMsg(hWndRack2DViewVirt, AM_CloseAllCages, 0, 0)
.head 6 -  ! Call hWndRack2DView.frmKHE2DView.ClearStateOfCages( )
.head 6 -  Call SalSendMsg( hWndRack2DViewVirt, AM_Refresh, RACK2D_RefreshTimeChanged, 0 )
.head 6 -  ! Call SalSendMsg(hWndRack2DViewVirt, SAM_Close, 0, 0)
.head 4 -  Call SalSetFocus(hWndKHE)
.head 4 -  Call SalEndDialog( hWndForm, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, FALSE )
.head 3 +  On AM_Delete
.head 4 +  If DeletePlanning()
.head 5 -  Call StopPlanning()
.head 1 +  Dialog Box: dlgKHE_StartPlanningMode
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Start Planning
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  4.325"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 3.01"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? No
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 -  Group Box: License
.head 4 -  Resource Id: 60390
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsGroupBox
.head 4 -  Window Location and Size
.head 5 -  Left: 0.1"
.head 5 -  Top: 0.073"
.head 5 -  Width:  4.038"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.833"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Check Box: cb4Experiment
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: License
.head 4 -  Window Location and Size
.head 5 -  Left: 0.313"
.head 5 -  Top: 0.25"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage( SAM_Click, wParam, lParam )
.head 6 -  Call OnClick_cb4Experiment(  )
.head 3 -  Background Text: License:
.head 4 -  Resource Id: 37772
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.163"
.head 5 -  Top: 0.292"
.head 5 -  Width:  1.163"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfExperiment
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldFastHelpedInput
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 30
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.363"
.head 6 -  Top: 0.25"
.head 6 -  Width:  2.413"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  ! On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  ! Call Initialize( '', "
select	e.EXPERIMENT_KEY, e.START_DATE
from	EXPERIMENT e, BEN_Experiment be, EXP_SPECIES es
where	e.EXPERIMENT_KEY = :MyValue
and	( e.STATUS in ( 'S', 'IP' ) or e.STATUS is NULL )
and	be.BENUTZER_ID = :nUserId
and          be.EINRICHT_ID = :nEinrichtId
and 	be.EXPERIMENT_KEY = e.EXPERIMENT_KEY
and (es.ABT_KEY = 'BU30E' or es.ABT_KEY is NULL)
and     e.EXPERIMENT_KEY = es.EXPERIMENT_KEY
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfExperimentStarted
", "
select	e.EXPERIMENT_KEY, e.EXP_SUBJECT
from	EXPERIMENT e, BEN_Experiment be, EXP_SPECIES es
where	( e.STATUS in ( 'S', 'IP' ) or e.STATUS is NULL )
and	be.BENUTZER_ID = :nUserId
and          be.EINRICHT_ID = :nEinrichtId
and 	be.EXPERIMENT_KEY = e.EXPERIMENT_KEY
and (es.ABT_KEY = 'BU30E' or es.ABT_KEY is NULL)
and     e.EXPERIMENT_KEY = es.EXPERIMENT_KEY
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 -  Call SetPlanDateDefault(  )
.head 6 -  Call GetVirtFallKey4Experiment( dfExperiment, nVirtFallKey, nAEBewNr )
.head 6 -  Return TRUE
.head 5 +  On GM_ShowHelpList
.head 6 +  If sScreen = STRING_Null
.head 7 -  Call Initialize( '', "
select	e.EXPERIMENT_KEY, e.START_DATE
from	EXPERIMENT e, BEN_Experiment be
where	e.EXPERIMENT_KEY = :MyValue
and	( e.STATUS in ( 'S', 'IP' ) or e.STATUS is NULL )
and	be.BENUTZER_ID = :nUserId
and          be.EINRICHT_ID = :nEinrichtId
and 	be.EXPERIMENT_KEY = e.EXPERIMENT_KEY

into	:sProper, 
	:dlgKHE_StartPlanningMode.dfExperimentStarted
", "
select	e.EXPERIMENT_KEY, e.EXP_SUBJECT
from	EXPERIMENT e, BEN_Experiment be
where	( e.STATUS in ( 'S', 'IP' ) or e.STATUS is NULL )
and	be.BENUTZER_ID = :nUserId
and          be.EINRICHT_ID = :nEinrichtId
and 	be.EXPERIMENT_KEY = e.EXPERIMENT_KEY

" )
.head 6 +  Else
.head 7 -  Call Initialize( '', "
select	e.EXPERIMENT_KEY, e.START_DATE
from	EXPERIMENT e, BEN_Experiment be, EXP_SPECIES es
where	e.EXPERIMENT_KEY = :MyValue
and	( e.STATUS in ( 'S', 'IP' ) or e.STATUS is NULL )
and	be.BENUTZER_ID = :nUserId
and          be.EINRICHT_ID = :nEinrichtId
and 	be.EXPERIMENT_KEY = e.EXPERIMENT_KEY
and         (es.ABT_KEY = :dlgKHE_StartPlanningMode.sScreen or
		 not exists(select s.ABT_KEY from EXP_SPECIES s where s.abt_key=:dlgKHE_StartPlanningMode.sScreen))
and     e.EXPERIMENT_KEY = es.EXPERIMENT_KEY
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfExperimentStarted
", "
select	e.EXPERIMENT_KEY, e.EXP_SUBJECT
from	EXPERIMENT e, BEN_Experiment be, EXP_SPECIES es
where	( e.STATUS in ( 'S', 'IP' ) or e.STATUS is NULL )
and	be.BENUTZER_ID = :nUserId
and          be.EINRICHT_ID = :nEinrichtId
and 	be.EXPERIMENT_KEY = e.EXPERIMENT_KEY
and (es.ABT_KEY =  :dlgKHE_StartPlanningMode.sScreen or
		 not exists(select s.ABT_KEY from EXP_SPECIES s where s.abt_key=:dlgKHE_StartPlanningMode.sScreen))
and     e.EXPERIMENT_KEY = es.EXPERIMENT_KEY
" )
.head 6 -  Call SalSendClassMessage( GM_ShowHelpList, wParam, lParam )
.head 3 -  Background Text: License Start:
.head 4 -  Resource Id: 61791
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.163"
.head 5 -  Top: 0.583"
.head 5 -  Width:  1.163"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfExperimentStarted
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.363"
.head 6 -  Top: 0.542"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Left
.head 5 -  Format: dd.MM.yyyy hhhh:mm
.head 5 -  Country: Class Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: 99.99.9999 99:99
.head 4 -  Message Actions
.head 3 +  Data Field: dfVirtFallKey
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldNr
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 12
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Group Box: Admin.Service
.head 4 -  Resource Id: 37771
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsGroupBox
.head 4 -  Window Location and Size
.head 5 -  Left: 0.1"
.head 5 -  Top: 1.021"
.head 5 -  Width:  4.038"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.833"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 -  Background Text: Service:
.head 4 -  Resource Id: 60391
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.163"
.head 5 -  Top: 1.25"
.head 5 -  Width:  1.163"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfLstKey
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldFastHelpedInput
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 8
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.363"
.head 6 -  Top: 1.208"
.head 6 -  Width:  0.75"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	LST_KEY, LST_BEZ, TARIF_KEY
from	LEISTUNG
where	EINRICHT_ID = :nEinrichtId
   and	LST_KEY = :MyValue
   and	CANCELED = 'N'
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfLstBez, 
	:dlgKHE_StartPlanningMode.dfTarifKey
", "
select	LST_KEY, LST_BEZ || ' (' || TARIF_KEY || ')'
from	LEISTUNG
where	EINRICHT_ID = :nEinrichtId
   and	CANCELED = 'N'
   and	LA_KEY = 'AL'
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfLstBez )
.head 6 -  Return TRUE
.head 3 -  Background Text: Tarif:
.head 4 -  Resource Id: 18341
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 2.225"
.head 5 -  Top: 1.25"
.head 5 -  Width:  0.75"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfTarifKey
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldFastHelpedInput
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 6
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 3.025"
.head 6 -  Top: 1.208"
.head 6 -  Width:  0.75"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	TARIF_KEY
from	TARIF
where	TARIF_KEY = :MyValue
   and	EINRICHT_ID = :nEinrichtId
into	:sProper
", "
select	TARIF_KEY, TARIF_BEZ
from	TARIF
where	CANCELED = 'N'
   and	EINRICHT_ID = :nEinrichtId
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfLstBez )
.head 6 -  Return TRUE
.head 3 +  Data Field: dfLstBez
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 50
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.363"
.head 6 -  Top: 1.51"
.head 6 -  Width:  2.413"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: Start Planning on:
.head 4 -  Resource Id: 61793
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.8"
.head 5 -  Top: 2.01"
.head 5 -  Width:  1.3"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfPlanningStarted
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 2.15"
.head 6 -  Top: 1.969"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Left
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Validate
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Return VALIDATE_Ok
.head 6 +  If not SalIsValidDateTime( hWndItem )
.head 7 -  ! Call SalMessageBox( 'Datum oder Zeit sind falsch', 'Eingabefehler', MB_Ok )
.head 7 -  Call ErrorMessageBox( 130 )
.head 7 -  Return VALIDATE_Cancel
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.3"
.head 5 -  Top: 2.281"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 2.35"
.head 5 -  Top: 2.281"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Check Box: cbMatingMode
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: MatingMode
.head 4 -  Window Location and Size
.head 5 -  Left: 1.088"
.head 5 -  Top: 1.906"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Message Actions
.head 2 +  Functions
.head 3 +  Function: OnClick_cb4Experiment
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 +  If cb4Experiment
.head 6 -  Call dfExperiment.Enable(  )
.head 5 +  Else
.head 6 -  Call dfExperiment.Disable(  )
.head 3 +  Function: CreateNewPlan
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 +  If SalIsNull( dfPlanningStarted )
.head 6 -  Call SalSetFocus( dfPlanningStarted )
.head 6 -  Call SalMessageBox( GetMessageX( 130, 'Date/Time is wrong !' ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If cb4Experiment
.head 6 +  If SalIsNull( dfExperiment )
.head 7 -  Call SalSetFocus( dfExperiment )
.head 7 -  Call SalMessageBox( GetMessageFromSection( "KHE", 12, "An Experiment License is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 6 +  If dfPlanningStarted < dfExperimentStarted
.head 7 -  Call SalSetFocus( dfPlanningStarted )
.head 7 -  Call SalMessageBox( GetMessageFromSection( "KHE", 13, "The Planning Start date should not be earlier then the License Start date !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 6 +  If Not nVirtFallKey
.head 7 -  Call GetVirtFallKey4Experiment( dfExperiment, nVirtFallKey, nAEBewNr )
.head 5 +  Else
.head 6 -  Call SalClearField( dfExperiment )
.head 5 +  If dfPlanningStarted < SalDateCurrent(  )
.head 6 -  Call SalSetFocus( dfPlanningStarted )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 14, "The Planning Start date should be in the future !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfLstKey )
.head 6 -  Call SalSetFocus( dfLstKey )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 16, "Admin.Service is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfTarifKey )
.head 6 -  Call SalSetFocus( dfTarifKey )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 17, "Tarif for the Admin.Service is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 -  !
.head 5 +  If Not nVirtFallKey
.head 6 -  Return FALSE
.head 5 -  Set nNewLstErfNr = InsertAdminLstErf( nVirtFallKey, nAEBewNr, dfTarifKey, dfLstKey, 'AL', dfPlanningStarted )
.head 5 +  If nNewLstErfNr = 0
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 19, "Could not create an LST_ERF record for the Virtual Case !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 -  !
.head 5 -  Set dtPlan_Started = dfPlanningStarted
.head 5 -  Set sPlan_Experiment = dfExperiment
.head 5 -  Set nPlan_Fall_Key = nVirtFallKey
.head 5 -  Set nPlan_AEBewNr = nAEBewNr
.head 5 -  Set sPlan_TarifKey = dfTarifKey
.head 5 -  Set sPlan_dfLstKey = dfLstKey
.head 5 -  Set nPlan_LstErfNr = nNewLstErfNr
.head 5 -  Set brpMatingMode = cbMatingMode
.head 5 -  Return TRUE
.head 3 +  Function: InsertAdminLstErf
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  Number: nFallKey
.head 5 -  Number: nBewNr_AE
.head 5 -  String: sTarifKey
.head 5 -  String: sLstKey
.head 5 -  String: sLAKey
.head 5 -  Date/Time: dtLstErfVon
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nNewLstErf
.head 5 -  Sql Handle: hSql
.head 5 -  Boolean: bOk
.head 5 -  Number: nFetch
.head 4 +  Actions
.head 5 +  If Not GalConnect( hSql )
.head 6 -  Return 0
.head 5 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	FALL_KEY = " || StrX( nFallKey ) || "
into	:nNewLstErf " )
.head 5 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 5 +  If Not bOk And nFetch = FETCH_EOF
.head 6 -  Set nNewLstErf = 1
.head 6 -  Set bOk = TRUE
.head 5 +  If bOk And Not nNewLstErf
.head 6 -  Set nNewLstErf = 1
.head 5 -  !
.head 5 +  If nNewLstErf
.head 6 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR, 
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY, 
	Lst_Erf_VON, 
	MENGE, STATISTIK, PRZ, 
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID, 
	FKT, BEW_NR, DONE )
 values (	" || StrX( nEinrichtId ) || ", " || StrX( nFallKey ) || ", " || StrX( nNewLstErf ) || ", SYSDATETIME, 
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', " || StrX( nUserId ) || ", 1, " || StrX( nBewNr_AE ) || ", 0 ) " )
.head 6 -  Set bOk = bOk And SqlCommit( hSql ) 
.head 6 +  If Not bOk
.head 7 -  Call SqlPrepareAndExecute( hSql, 'rollback' )
.head 7 -  Set nNewLstErf = 0
.head 5 -  Call SqlDisconnect( hSql )
.head 5 -  Return nNewLstErf
.head 3 +  Function: SetPlanDateDefault
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 +  If SalIsNull( dfExperimentStarted )
.head 6 +  If SalIsNull( dfPlanningStarted )
.head 7 -  Set dfPlanningStarted = SalDateCurrent(  ) + 1
.head 5 +  Else
.head 6 +  If Not SalIsNull( dfPlanningStarted ) And ( dfPlanningStarted < dfExperimentStarted Or dfPlanningStarted < SalDateCurrent(  ) )
.head 7 -  Call SalClearField( dfPlanningStarted )
.head 6 +  If SalIsNull( dfPlanningStarted )
.head 7 +  If dfExperimentStarted > SalDateCurrent(  )
.head 8 -  Set dfPlanningStarted = dfExperimentStarted
.head 7 +  Else
.head 8 -  Set dfPlanningStarted = SalDateCurrent(  ) + 1
.head 3 +  Function: GetVirtFallKey4Experiment
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  String: spExperiment
.head 5 -  Receive Number: nrpVirtFallKey
.head 5 -  Receive Number: nrpBewNr
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Sql Handle: hSql
.head 5 -  Boolean: bOk
.head 5 -  Number: nFetch
.head 4 +  Actions
.head 5 +  If Not spExperiment
.head 6 -  Return FALSE
.head 5 -  Set nrpVirtFallKey = Experiment_VirtualCase( spExperiment )
.head 5 +  If nrpVirtFallKey = 0
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 31, "A Virtual Case does not exist for the License !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If Not GalConnect( hSql )
.head 6 -  Return FALSE
.head 5 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	f.LAST_BEW_NR
from	FALL f
where	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.FALL_KEY = :nrpVirtFallKey
into	:nrpBewNr
" )
.head 5 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 5 -  Call SqlDisconnect( hSql )
.head 5 +  If Not bOk
.head 6 -  Set nrpVirtFallKey = 0
.head 6 -  Set nrpBewNr = 0
.head 5 -  Return bOk
.head 3 +  ! Function: GetVirtFallKey4Experiment
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 +  Parameters 
.head 5 -  String: spExperiment
.head 5 -  Receive Number: nrpVirtFallKey
.head 5 -  Receive Number: nrpBewNr
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSql
.head 5 -  Boolean: bOk
.head 5 -  Number: nFetch
.head 4 +  Actions 
.head 5 +  If Not spExperiment
.head 6 -  Return FALSE
.head 5 +  If Not GalConnect( hSql )
.head 6 -  Return FALSE
.head 5 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	f.FALL_KEY, f.LAST_BEW_NR
into	:nrpVirtFallKey, :nrpBewNr
from	FALL_EXPERIMENT fe, FALL f, VIS_KAT v
where	f.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	f.GELOESCHT = 'N'
   and	f.VIS_KAT_KEY = v.VIS_KAT_KEY
   and	v.PATIENT = 'N'
   and	fe.EINRICHT_ID = f.EINRICHT_ID
   and	fe.FALL_KEY = f.FALL_KEY
   and	fe.EXPERIMENT_KEY = '" || spExperiment || "'
order by	f.FALL_KEY " )
.head 5 -  Set bOk = bOk And SqlFetchNext( hSql, nFetch )
.head 5 -  Call SqlDisconnect( hSql )
.head 5 +  If Not bOk
.head 6 -  Set nrpVirtFallKey = 0
.head 6 -  Set nrpBewNr = 0
.head 6 +  If nFetch = FETCH_EOF
.head 7 -  Set bOk = TRUE
.head 5 +  If bOk And nrpVirtFallKey = 0
.head 6 +  If nrpVirtFallKey = 0
.head 7 -  Call SalMessageBox( GetMessageFromSection( "KHE", 31, "A Virtual Case does not exist for the Experiment !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 5 -  Return bOk
.head 3 +  Function: GetSelectedScreen
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  String:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sAbt
.head 5 -  String: sStat
.head 5 -  String: sGruppe
.head 5 -  String: sBett
.head 4 +  Actions
.head 5 -  Call frmAtlantaMain.lbKHELeft.GetPosition(frmAtlantaMain.lbKHELeft.nSelectedHandle, sAbt, sStat, sGruppe, sBett)
.head 5 -  Return sAbt
.head 2 +  Window Parameters
.head 3 -  Date/Time: dtDefaultStartDateTime
.head 3 -  Receive Date/Time: dtPlan_Started
.head 3 -  Receive String: sPlan_Experiment
.head 3 -  Receive Number: nPlan_Fall_Key
.head 3 -  Receive Number: nPlan_AEBewNr
.head 3 -  Receive String: sPlan_TarifKey
.head 3 -  Receive String: sPlan_dfLstKey
.head 3 -  Receive Number: nPlan_LstErfNr
.head 3 -  Receive Boolean: brpMatingMode
.head 2 +  Window Variables
.head 3 -  Number: nVirtFallKey
.head 3 -  Number: nAEBewNr
.head 3 -  Number: nNewLstErfNr
.head 3 -  Date/Time: dtNow
.head 3 -  String: sScreen
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Call SalCenterWindow( hWndItem )
.head 4 -  Set cb4Experiment = TRUE
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Set dtNow = SalDateCurrent(  )
.head 4 -  Set dfPlanningStarted = dtDefaultStartDateTime
.head 4 +  If SalDateConstruct( SalDateYear( dfPlanningStarted ), SalDateMonth( dfPlanningStarted ), SalDateDay( dfPlanningStarted ), 0, 0, 0 ) <= 
   SalDateConstruct( SalDateYear( dtNow ), SalDateMonth( dtNow ), SalDateDay( dtNow ), 0, 0, 0 )
.head 5 -  Set dfPlanningStarted = dfPlanningStarted + 1
.head 4 -  Set sScreen = GetSelectedScreen(  )
.head 4 -  Call SalSendMsg( dfExperiment, GM_ShowHelpList, wParam, lParam )
.head 3 +  On AM_Ok
.head 4 -  Call DoImmediate ("select MATING from LEISTUNG 
	 where LST_KEY = :dlgKHE_StartPlanningMode.dfLstKey
	and TARIF_KEY = :dlgKHE_StartPlanningMode.dfTarifKey
	into :dlgKHE_StartPlanningMode.cbMatingMode")
.head 4 +  If CreateNewPlan(  )
.head 5 -  Call SalEndDialog( hWndForm, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, FALSE )
.head 1 +  ! clsSimpleDialogBox: dlgKHE_StartPlanningMode_V1
.head 2 -  Description: 
.head 2 +  Tool Bar 
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 -  Group Box: Experiment
.head 3 +  Check Box: cb4Experiment
.head 4 +  Message Actions 
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage( SAM_Click, wParam, lParam )
.head 6 -  Call OnClick_cb4Experiment(  )
.head 3 +  Data Field: dfExperiment
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	EXPERIMENT_KEY, START_DATE
from	EXPERIMENT
where	EXPERIMENT_KEY = :MyValue
and	( STATUS in ( 'S', 'IP' ) or STATUS is NULL )
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfExperimentStarted
", "
select	EXPERIMENT_KEY, CONDITIONS 
from	EXPERIMENT
where	( STATUS in ( 'S', 'IP' ) or STATUS is NULL )
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 -  Call SetPlanDateDefault(  )
.head 6 -  Return TRUE
.head 3 -  Background Text: Experiment Start:
.head 3 +  Data Field: dfExperimentStarted
.head 4 -  Message Actions 
.head 3 -  Group Box: Virtual Case
.head 3 -  Group Box: Admin.Service
.head 3 -  Background Text: Vis.Category:
.head 3 +  Data Field: dfVisKatKey
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	VIS_KAT_KEY, VIS_KAT_BEZ
from	VIS_KAT
where	VIS_KAT_KEY = :MyValue
   and	CANCELED = 0
   and	PATIENT = 'N'
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfVisKatBez
", "
select	VIS_KAT_KEY, VIS_KAT_BEZ
from	VIS_KAT
where	CANCELED = 0
   and	PATIENT = 'N'
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfVisKatBez )
.head 6 -  Return TRUE
.head 3 +  Data Field: dfVisKatBez
.head 4 -  Message Actions 
.head 3 -  Background Text: Short Descr.:
.head 3 +  Data Field: dfName3
.head 4 +  Message Actions 
.head 5 +  On GM_Create
.head 6 -  Set dfName3 = 'Planning'
.head 3 -  Background Text: Service:
.head 3 +  Data Field: dfLstKey
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	LST_KEY, LST_BEZ, TARIF_KEY
from	LEISTUNG
where	EINRICHT_ID = :nEinrichtId
   and	LST_KEY = :MyValue
   and	CANCELED = 'N'
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfLstBez, 
	:dlgKHE_StartPlanningMode.dfTarifKey
", "
select	LST_KEY, LST_BEZ || ' (' || TARIF_KEY || ')'
from	LEISTUNG
where	EINRICHT_ID = :nEinrichtId
   and	CANCELED = 'N'
   and	LA_KEY = 'AL'
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfLstBez )
.head 7 -  Set sTarifKey = ''
.head 6 -  Return TRUE
.head 3 -  Background Text: Tarif:
.head 3 +  Data Field: dfTarifKey
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	TARIF_KEY
from	TARIF
where	TARIF_KEY = :MyValue
   and	EINRICHT_ID = :nEinrichtId
into	:sProper
", "
select	TARIF_KEY, TARIF_BEZ
from	TARIF
where	CANCELED = 'N'
   and	EINRICHT_ID = :nEinrichtId
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfLstBez )
.head 7 -  Set sTarifKey = ''
.head 6 -  Return TRUE
.head 3 +  Data Field: dfLstBez
.head 4 -  Message Actions 
.head 3 -  Background Text: Start Planning on:
.head 3 +  Data Field: dfPlanningStarted
.head 4 +  Message Actions 
.head 5 +  On SAM_Validate
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Return VALIDATE_Ok
.head 6 +  If not SalIsValidDateTime( hWndItem )
.head 7 -  ! Call SalMessageBox( 'Datum oder Zeit sind falsch', 'Eingabefehler', MB_Ok )
.head 7 -  Call ErrorMessageBox( 130 )
.head 7 -  Return VALIDATE_Cancel
.head 3 +  Pushbutton: pbOk
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbCancel
.head 4 -  Message Actions 
.head 2 +  Functions 
.head 3 +  Function: OnClick_cb4Experiment
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If cb4Experiment
.head 6 -  Call dfExperiment.Enable(  )
.head 5 +  Else 
.head 6 -  Call dfExperiment.Disable(  )
.head 3 +  Function: CreateNewPlan
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nNewFall
.head 5 -  Number: nNewBewNr
.head 5 -  Number: nNewLstErfNr
.head 4 +  Actions 
.head 5 +  If SalIsNull( dfPlanningStarted )
.head 6 -  Call SalSetFocus( dfPlanningStarted )
.head 6 -  Call SalMessageBox( GetMessageX( 130, 'Date/Time is wrong !' ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If cb4Experiment
.head 6 +  If SalIsNull( dfExperiment )
.head 7 -  Call SalSetFocus( dfExperiment )
.head 7 -  Call SalMessageBox( GetMessageFromSection( "KHE", 12, "An Experiment is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 6 +  If dfPlanningStarted < dfExperimentStarted
.head 7 -  Call SalSetFocus( dfPlanningStarted )
.head 7 -  Call SalMessageBox( GetMessageFromSection( "KHE", 13, "The Planning Start date should not be earlier then the Experiment Start date !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 5 +  Else 
.head 6 -  Call SalClearField( dfExperiment )
.head 5 +  If dfPlanningStarted < SalDateCurrent(  )
.head 6 -  Call SalSetFocus( dfPlanningStarted )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 14, "The Planning Start date should be in the future !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfVisKatKey )
.head 6 -  Call SalSetFocus( dfVisKatKey )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 15, "Vis.Category is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfLstKey )
.head 6 -  Call SalSetFocus( dfLstKey )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 16, "Admin.Service is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfTarifKey )
.head 6 -  Call SalSetFocus( dfTarifKey )
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 17, "Tarif for the Admin.Service is not specified !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 -  !
.head 5 -  Set nNewFall = CreateNewFall( nNewBewNr )
.head 5 +  If nNewFall = 0
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 18, "Could not create a Virtual Case !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 -  Set nNewLstErfNr = InsertAdminLstErf( nNewFall, nNewBewNr, dfTarifKey, dfLstKey, 'AL', dfPlanningStarted )
.head 5 +  If nNewLstErfNr = 0
.head 6 -  Call SalMessageBox( GetMessageFromSection( "KHE", 19, "Could not create an LST_ERF record for the Virtual Case !" ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 -  Set dtPlan_Started = dfPlanningStarted
.head 5 -  Set sPlan_Experiment = dfExperiment
.head 5 -  Set nPlan_Fall_Key = nNewFall
.head 5 -  Set nPlan_LstErfNr = nNewLstErfNr
.head 5 -  Return TRUE
.head 3 +  Function: CreateNewFall
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Number: 
.head 4 +  Parameters 
.head 5 -  Receive Number: nBewNr_AE
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  String: sName
.head 5 -  String: sVorname
.head 5 -  String: sGebName
.head 5 -  Date/Time: dtGebDatum
.head 5 -  String: sSex
.head 5 -  String: sStrasse
.head 5 -  String: sZusatz
.head 5 -  String: sOrt
.head 5 -  String: sPLZ
.head 5 -  String: sAdresseCategoryKey
.head 5 -  String: sFallartKey
.head 5 -  String: sStatus
.head 5 -  String: sVisKatKey
.head 5 -  Date/Time: dtAEDatum
.head 5 -  String: sAbteilungKey
.head 5 -  String: sStationKey
.head 5 -  String: sGruppeKey
.head 5 -  String: sBettKey
.head 5 -  !
.head 5 -  : objCreator
.head 5 -  Boolean: bWithCommit
.head 5 -  Number: nNewFall
.head 4 +  Actions 
.head 5 +  If cb4Experiment
.head 6 -  Set sName = dfExperiment
.head 6 -  ! Set dtGebDatum = dfExperimentStarted
.head 5 +  Else 
.head 6 -  Set sName = 'Virtual'
.head 6 -  ! Set dtGebDatum = SalDateCurrent(  )
.head 5 -  Set dtGebDatum = SalDateCurrent(  )
.head 5 -  Set sVorname = dfName3
.head 5 -  Set sSex = 'M'
.head 5 -  Set sFallartKey = 'ST'
.head 5 -  Set sStatus = 'A'
.head 5 -  Set sVisKatKey = dfVisKatKey
.head 5 -  Set dtAEDatum = dfPlanningStarted
.head 5 -  Set bWithCommit = TRUE
.head 5 -  Call VisWaitCursor( TRUE )
.head 5 -  Set nNewFall = objCreator.Aufnahme(
	sName, sVorname, sGebName, dtGebDatum, sSex,
	sStrasse, sZusatz, sOrt, sPLZ, sAdresseCategoryKey,
	sFallartKey, sStatus, sVisKatKey, dtAEDatum,
	sAbteilungKey, sStationKey, sGruppeKey, sBettKey,
	nUserId, bWithCommit )
.head 5 -  Set nBewNr_AE = objCreator.nBewNr_AE
.head 5 -  Call VisWaitCursor( FALSE )
.head 5 -  Return nNewFall
.head 3 +  Function: InsertAdminLstErf
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Number: 
.head 4 +  Parameters 
.head 5 -  Number: nFallKey
.head 5 -  Number: nBewNr_AE
.head 5 -  String: sTarifKey
.head 5 -  String: sLstKey
.head 5 -  String: sLAKey
.head 5 -  Date/Time: dtLstErfVon
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nNewLstErf
.head 5 -  Sql Handle: hSql
.head 5 -  Boolean: bOk
.head 5 -  Number: nFetch
.head 4 +  Actions 
.head 5 +  If Not GalConnect( hSql )
.head 6 -  Return 0
.head 5 -  Set bOk = SqlPrepareAndExecute( hSql, "
select	max( Lst_Erf_NR ) + 1
from	Lst_Erf
where	EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and	FALL_KEY = " || StrX( nFallKey ) || "
into	:nNewLstErf " )
.head 5 -  Set bOk = bOk and SqlFetchNext( hSql, nFetch )
.head 5 +  If Not bOk And nFetch = FETCH_EOF
.head 6 -  Set nNewLstErf = 1
.head 6 -  Set bOk = TRUE
.head 5 +  If bOk And Not nNewLstErf
.head 6 -  Set nNewLstErf = 1
.head 5 -  !
.head 5 +  If nNewLstErf
.head 6 -  Set bOk = bOk And SqlPrepareAndExecute( hSql, "
insert into Lst_Erf
          ( 	EINRICHT_ID, FALL_KEY, Lst_Erf_NR, 
	ERF_DATUM, TARIF_KEY, LST_KEY, LA_KEY, 
	Lst_Erf_VON, 
	MENGE, STATISTIK, PRZ, 
	STORNIERT, NACHBERECHNUNG, BENUTZER_ID, 
	FKT, BEW_NR, DONE )
 values (	" || StrX( nEinrichtId ) || ", " || StrX( nFallKey ) || ", " || StrX( nNewLstErf ) || ", SYSDATETIME, 
	'" || sTarifKey || "', '" || sLstKey || "', '" || sLAKey || "', :dtLstErfVon,
	1, 'N', 100, 'N', 'N', " || StrX( nUserId ) || ", 1, " || StrX( nBewNr_AE ) || ", 0 ) " )
.head 6 -  Set bOk = bOk And SqlCommit( hSql ) 
.head 6 +  If Not bOk
.head 7 -  Call SqlPrepareAndExecute( hSql, 'rollback' )
.head 7 -  Set nNewLstErf = 0
.head 5 -  Call SqlDisconnect( hSql )
.head 5 -  Return nNewLstErf
.head 3 +  Function: SetPlanDateDefault
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If SalIsNull( dfExperimentStarted )
.head 6 +  If SalIsNull( dfPlanningStarted )
.head 7 -  Set dfPlanningStarted = SalDateCurrent(  ) + 1
.head 5 +  Else 
.head 6 +  If Not SalIsNull( dfPlanningStarted ) And ( dfPlanningStarted < dfExperimentStarted Or dfPlanningStarted < SalDateCurrent(  ) )
.head 7 -  Call SalClearField( dfPlanningStarted )
.head 6 +  If SalIsNull( dfPlanningStarted )
.head 7 +  If dfExperimentStarted > SalDateCurrent(  )
.head 8 -  Set dfPlanningStarted = dfExperimentStarted
.head 7 +  Else 
.head 8 -  Set dfPlanningStarted = SalDateCurrent(  ) + 1
.head 2 +  Window Parameters 
.head 3 -  Receive Date/Time: dtPlan_Started
.head 3 -  Receive String: sPlan_Experiment
.head 3 -  Receive Number: nPlan_Fall_Key
.head 3 -  Receive Number: nPlan_LstErfNr
.head 2 +  Window Variables 
.head 3 -  String: sTarifKey
.head 2 +  Message Actions 
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Call SalCenterWindow( hWndItem )
.head 4 -  Set cb4Experiment = TRUE
.head 3 +  On AM_Ok
.head 4 +  If CreateNewPlan(  )
.head 5 -  Call SalEndDialog( hWndForm, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, FALSE )
.head 1 +  ! clsSimpleDialogBox: dlgKHE_UseExistingPlanning
.head 2 -  Description: 
.head 2 +  Tool Bar 
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 -  Group Box: Experiment
.head 3 +  Check Box: cb4Experiment
.head 4 +  Message Actions 
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage( SAM_Click, wParam, lParam )
.head 6 -  Call OnClick_cb4Experiment(  )
.head 3 +  Data Field: dfExperiment
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	EXPERIMENT_KEY, START_DATE
from	EXPERIMENT
where	EXPERIMENT_KEY = :MyValue
and	( STATUS in ( 'S', 'IP' ) or STATUS is NULL )
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfExperimentStarted
", "
select	EXPERIMENT_KEY, CONDITIONS 
from	EXPERIMENT
where	( STATUS in ( 'S', 'IP' ) or STATUS is NULL )
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 -  Call SetPlanDateDefault(  )
.head 6 -  Return TRUE
.head 3 -  Background Text: Experiment Start:
.head 3 +  Data Field: dfExperimentStarted
.head 4 -  Message Actions 
.head 3 -  Group Box: Case
.head 3 -  Group Box: Admin.Service
.head 3 +  Check Box: cbUseExistingFall
.head 4 +  Message Actions 
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage( SAM_Click, wParam, lParam )
.head 6 -  Call OnClick_cbUseExistingFall(  )
.head 3 +  Data Field: dfVirtFallKey
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	@string(f.FALL_KEY, 0), f.NAME3,
	vk.VIS_KAT_KEY, vk.VIS_KAT_BEZ
from	FALL f, VIS_KAT vk
where	f.FALL_KEY = @value( :MyValue )
   and	f.EINRICHT_ID = :nEinrichtId
   and	f.VIS_KAT_KEY = vk.VIS_KAT_KEY
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfName3, 
	:dlgKHE_StartPlanningMode.dfVisKatKey, 
	:dlgKHE_StartPlanningMode.dfVisKatBez
", "
select	f.FALL_KEY, f.NAME1
from	FALL f, VIS_KAT vk
where	f.EINRICHT_ID = :nEinrichtId
   and	f.GELOESCHT = 'N'
   and	f.NAME1 = :dlgKHE_StartPlanningMode.dfExperiment
   and	f.VIS_KAT_KEY = vk.VIS_KAT_KEY
   and	vk.CANCELED = 0
   and	vk.PATIENT = 'N'
" )
.head 3 -  Background Text: Vis.Category:
.head 3 +  Data Field: dfVisKatKey
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	VIS_KAT_KEY, VIS_KAT_BEZ
from	VIS_KAT
where	VIS_KAT_KEY = :MyValue
   and	CANCELED = 0
   and	PATIENT = 'N'
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfVisKatBez
", "
select	VIS_KAT_KEY, VIS_KAT_BEZ
from	VIS_KAT
where	CANCELED = 0
   and	PATIENT = 'N'
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfVisKatBez )
.head 6 -  Return TRUE
.head 3 +  Data Field: dfVisKatBez
.head 4 -  Message Actions 
.head 3 -  Background Text: Short Descr.:
.head 3 +  Data Field: dfName3
.head 4 +  Message Actions 
.head 5 +  On GM_Create
.head 6 -  Set dfName3 = 'Planning'
.head 3 -  Background Text: Service:
.head 3 +  Data Field: dfLstKey
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( '', "
select	LST_KEY, LST_BEZ, TARIF_KEY
from	LEISTUNG
where	LST_KEY = :MyValue
   and	CANCELED = 'N'
into	:sProper, 
	:dlgKHE_StartPlanningMode.dfLstBez, 
	:dlgKHE_StartPlanningMode.sTarifKey
", "
select	LST_KEY, LST_BEZ || ' (' || TARIF_KEY || ')'
from	LEISTUNG
where	CANCELED = 'N'
   and	LA_KEY = 'AL'
" )
.head 5 +  On GM_IsCorrect
.head 6 +  If Not SalSendClassMessage( GM_IsCorrect, wParam, lParam )
.head 7 -  Return FALSE
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Call SalClearField( dfLstBez )
.head 7 -  Set sTarifKey = ''
.head 6 -  Return TRUE
.head 3 +  Data Field: dfLstBez
.head 4 -  Message Actions 
.head 3 -  Background Text: Start Planning on:
.head 3 +  Data Field: dfPlanningStarted
.head 4 +  Message Actions 
.head 5 +  On SAM_Validate
.head 6 +  If SalIsNull( hWndItem )
.head 7 -  Return VALIDATE_Ok
.head 6 +  If not SalIsValidDateTime( hWndItem )
.head 7 -  ! Call SalMessageBox( 'Datum oder Zeit sind falsch', 'Eingabefehler', MB_Ok )
.head 7 -  Call ErrorMessageBox( 130 )
.head 7 -  Return VALIDATE_Cancel
.head 3 +  Pushbutton: pbOk
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbCancel
.head 4 -  Message Actions 
.head 2 +  Functions 
.head 3 +  Function: OnClick_cbUseExistingFall
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If cbUseExistingFall
.head 6 -  Call dfVirtFallKey.Enable(  )
.head 6 -  Call dfVisKatKey.Disable(  )
.head 6 -  Call dfName3.Disable(  )
.head 5 +  Else 
.head 6 -  Call dfVirtFallKey.Disable(  )
.head 6 -  Call dfVisKatKey.Enable(  )
.head 6 -  Call dfName3.Enable(  )
.head 6 -  Set dfName3 = 'Planning'
.head 3 +  Function: OnClick_cb4Experiment
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If cb4Experiment
.head 6 -  Call dfExperiment.Enable(  )
.head 6 -  Call cbUseExistingFall.Enable(  )
.head 6 -  Call OnClick_UseExistingFall(  )
.head 5 +  Else 
.head 6 -  Call dfExperiment.Disable(  )
.head 6 -  Set cbUseExistingFall = FALSE
.head 6 -  Call cbUseExistingFall.Disable(  )
.head 6 -  Call dfVirtFallKey.Disable(  )
.head 6 -  Call dfVisKatKey.Disable(  )
.head 3 +  Function: CreateNewPlan
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nNewFall
.head 4 +  Actions 
.head 5 +  If SalIsNull( dfPlanningStarted )
.head 6 -  Call SalSetFocus( dfPlanningStarted )
.head 6 -  Call SalMessageBox( GetMessageX( 130, 'Date/Time is wrong !' ), GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If cb4Experiment
.head 6 +  If SalIsNull( dfExperiment )
.head 7 -  Call SalSetFocus( dfExperiment )
.head 7 -  Call SalMessageBox( "An Experiment is not specified !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 6 +  If dfPlanningStarted < dfExperimentStarted
.head 7 -  Call SalSetFocus( dfPlanningStarted )
.head 7 -  Call SalMessageBox( "The Planning Start date should not be earlier then the Experiment Start date !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 5 +  Else 
.head 6 -  Call SalClearField( dfExperiment )
.head 5 +  If dfPlanningStarted < SalDateCurrent(  )
.head 6 -  Call SalSetFocus( dfPlanningStarted )
.head 6 -  Call SalMessageBox( "The Planning Start date should be in the future !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfVisKatKey )
.head 6 -  Call SalSetFocus( dfVisKatKey )
.head 6 -  Call SalMessageBox( "Vis.Category is not specified !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If SalIsNull( dfLstKey )
.head 6 -  Call SalSetFocus( dfLstKey )
.head 6 -  Call SalMessageBox( "Admin.Service is not specified !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 +  If cbUseExistingFall
.head 6 +  If SalIsNull( dfVirtFallKey )
.head 7 -  Call SalSetFocus( dfVirtFallKey )
.head 7 -  Call SalMessageBox( "Case Nr. is not specified !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 5 +  Else 
.head 6 -  Set nNewFall = CreateNewFall(  )
.head 6 +  If nNewFall = 0
.head 7 -  Call SalMessageBox( "Could not create a Virtual Case !", GetMessageX( 203, 'Error' ), MB_IconExclamation )
.head 7 -  Return FALSE
.head 6 -  Set dfVirtFallKey = nNewFall
.head 5 -  Set dtPlan_Started = dfPlanningStarted
.head 5 -  Set sPlan_Experiment = dfExperiment
.head 5 -  Set nPlan_Fall_Key = dfVirtFallKey
.head 5 -  Return TRUE
.head 3 +  Function: CreateNewFall
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Number: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  String: sName
.head 5 -  String: sVorname
.head 5 -  String: sGebName
.head 5 -  Date/Time: dtGebDatum
.head 5 -  String: sSex
.head 5 -  String: sStrasse
.head 5 -  String: sZusatz
.head 5 -  String: sOrt
.head 5 -  String: sPLZ
.head 5 -  String: sAdresseCategoryKey
.head 5 -  String: sFallartKey
.head 5 -  String: sStatus
.head 5 -  String: sVisKatKey
.head 5 -  Date/Time: dtAEDatum
.head 5 -  String: sAbteilungKey
.head 5 -  String: sStationKey
.head 5 -  String: sGruppeKey
.head 5 -  String: sBettKey
.head 5 -  !
.head 5 -  : objCreator
.head 5 -  Boolean: bWithCommit
.head 5 -  Number: nNewFall
.head 4 +  Actions 
.head 5 +  If cb4Experiment
.head 6 -  Set sName = dfExperiment
.head 6 -  Set dtGebDatum = dfExperimentStarted
.head 5 +  Else 
.head 6 -  Set sName = 'Virtual'
.head 6 -  Set dtGebDatum = SalDateCurrent(  )
.head 5 -  Set sVorname = dfName3
.head 5 -  Set sSex = 'M'
.head 5 -  Set sFallartKey = 'ST'
.head 5 -  Set sStatus = 'A'
.head 5 -  Set sVisKatKey = dfVisKatKey
.head 5 -  Set dtAEDatum = dfPlanningStarted
.head 5 -  Set bWithCommit = TRUE
.head 5 -  Call VisWaitCursor( TRUE )
.head 5 -  Set nNewFall = objCreator.Aufnahme(
	sName, sVorname, sGebName, dtGebDatum, sSex,
	sStrasse, sZusatz, sOrt, sPLZ, sAdresseCategoryKey,
	sFallartKey, sStatus, sVisKatKey, dtAEDatum,
	sAbteilungKey, sStationKey, sGruppeKey, sBettKey,
	nUserId, bWithCommit )
.head 5 -  Call VisWaitCursor( FALSE )
.head 5 -  Return nNewFall
.head 3 +  Function: SetPlanDateDefault
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If SalIsNull( dfExperimentStarted )
.head 6 +  If SalIsNull( dfPlanningStarted )
.head 7 -  Set dfPlanningStarted = SalDateCurrent(  ) + 1
.head 5 +  Else 
.head 6 +  If Not SalIsNull( dfPlanningStarted ) And ( dfPlanningStarted < dfExperimentStarted Or dfPlanningStarted < SalDateCurrent(  ) )
.head 7 -  Call SalClearField( dfPlanningStarted )
.head 6 +  If SalIsNull( dfPlanningStarted )
.head 7 +  If dfExperimentStarted > SalDateCurrent(  )
.head 8 -  Set dfPlanningStarted = dfExperimentStarted
.head 7 +  Else 
.head 8 -  Set dfPlanningStarted = SalDateCurrent(  ) + 1
.head 2 +  Window Parameters 
.head 3 -  Receive Date/Time: dtPlan_Started
.head 3 -  Receive String: sPlan_Experiment
.head 3 -  Receive Number: nPlan_Fall_Key
.head 2 +  Window Variables 
.head 3 -  String: sTarifKey
.head 2 +  Message Actions 
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Call SalCenterWindow( hWndItem )
.head 4 -  Set cb4Experiment = TRUE
.head 3 +  On AM_Ok
.head 4 +  If CreateNewPlan(  )
.head 5 -  Call SalEndDialog( hWndForm, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, FALSE )
.head 1 +  Dialog Box: dlgPurposeSelect
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Select Purpose
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  4.063"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 2.792"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: Default
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Child Table: tblPurposes
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableList
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.063"
.head 6 -  Width:  3.838"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 2.135"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: 1000
.head 5 -  Discardable? No
.head 4 +  Contents
.head 5 +  Column: colPURPOSE_KEY
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Purpose Key
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  1.2"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colPURPOSE_BEZ
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Purpose Bez
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  2.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Functions
.head 4 -  Window Variables
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Set nPopulateMode = TBL_FillAll
.head 6 -  Call Initialize("
select PURPOSE_KEY, PURPOSE_BEZ
from PURPOSE
order by PURPOSE_KEY
into 	:dlgPurposeSelect.tblPurposes.colPURPOSE_KEY,
	:dlgPurposeSelect.tblPurposes.colPURPOSE_BEZ ")
.head 5 +  On SAM_DoubleClick
.head 6 -  Call SalTblSetFlagsAnyRows ( hWndForm, ROW_Selected, FALSE, ROW_Selected, 0 )
.head 6 -  Call SalSendMsg( dlgPurposeSelect, AM_Ok, 0, 0 )
.head 5 +  On AM_Refresh
.head 6 +  If Not SalSendClassMessage( AM_Refresh, wParam, lParam )
.head 7 -  Return FALSE
.head 6 -  Set nEmptyRow = SalTblInsertRow( hWndForm, 0 )
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.563"
.head 5 -  Top: 2.26"
.head 5 -  Width:  1.038"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 2.9"
.head 5 -  Top: 2.26"
.head 5 -  Width:  1.038"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  Receive String: sPurposeKey
.head 2 +  Window Variables
.head 3 -  Number: nEmptyRow
.head 2 +  Message Actions
.head 3 +  On AM_Ok
.head 4 +  If SalIsNull( tblPurposes.colPURPOSE_KEY )
.head 5 -  Set sPurposeKey = ''
.head 4 +  Else
.head 5 -  Set sPurposeKey = tblPurposes.colPURPOSE_KEY
.head 4 -  Call SalEndDialog( hWndForm, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, FALSE )
.head 1 +  ! clsSimpleDialogBox: dlgKHESuchen
.head 2 -  Description: 
.head 2 +  Tool Bar 
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 -  Background Text: Text :
.head 3 +  Data Field: dfSuchen
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Set sHint = GetMessageXX( 1059, 'Suchen', sGhsMSG_Hint_FileName )
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  ! Call SalSendClassMessageNamed( clsDataField, SAM_Create, wParam, lParam )
.head 3 +  Pushbutton: pbOk
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbCancel
.head 4 -  Message Actions 
.head 2 -  Functions 
.head 2 -  Window Parameters 
.head 2 +  Window Variables 
.head 3 -  String: sSuchen
.head 2 +  Message Actions 
.head 3 +  On AM_Ok
.head 4 -  Set sSuchen = dfSuchen
.head 4 -  Call SalEndDialog( dlgKHESuchen, 0 )
.head 4 -  ! Call SalMessageBox(tlbKHE.sSuchen, '!', 0)
.head 4 -  Call frmAtlantaMain.lbKHELeft.Search(frmAtlantaMain.sSuchen)
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( dlgKHESuchen, 0 )
.head 1 +  ! clsSimpleDialogBox: dlgSelectPredefinedColor
.winattr class Dialog Box:
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Select Color
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Display Style? Etched
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  4.35"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 4.131"
.head 4 -  Height Editable? Yes
.head 3 -  Absolute Screen Location? Yes
.head 3 -  Font Name: Default
.head 3 -  Font Size: Default
.head 3 -  Font Enhancement: Default
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? No
.head 3 -  Horizontal Scroll? No
.end
.head 2 -  Description: 
.head 2 +  Tool Bar 
.winattr
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: 0.35"
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? No
.head 4 -  Toolbar Docking Orientation: Top | Bottom
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? No
.end
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 +  Child Table: tblColors
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableList
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  4.167"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 3.298"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  View: Table
.head 5 -  Allow Row Sizing? No
.head 5 -  Lines Per Row: Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Default
.head 5 -  Discardable? Yes
.end
.head 4 +  Contents 
.head 5 +  Column: colCOLOR
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Color
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  1.75"
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 5 +  Column: colCOLOR_Name
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Name
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  1.933"
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 5 +  Column: colCOLOR_Index
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Color
.head 6 -  Visible? No
.head 6 -  Editable? Yes
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Left
.head 6 -  Width:  2.567"
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 4 -  Functions 
.head 4 -  Window Variables 
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call MTblSubClass( hWndForm )
.head 6 -  Set nIndex = 0
.head 6 -  Call objColors.Init()
.head 6 +  While nIndex < objColors.hash.GetSize()
.head 7 -  Set nRow = SalTblInsertRow ( tblColors, TBL_MaxRow)
.head 7 -  Set colCOLOR_Index = objColors.hash.GetByIndex(nIndex)
.head 7 -  Set colCOLOR_Name = objColors.hash.asNAME[nIndex]
.head 7 -  ! Call XSalTblSetCellBackColor(colCOLOR, colCOLOR_Index)
.head 7 -  Call MTblSetCellBackColor( colCOLOR, nRow, colCOLOR_Index, 1 )
.head 7 -  Set nIndex = nIndex + 1
.head 5 +  On SAM_CreateComplete
.head 6 -  Call SalTblSetFlagsAnyRows ( tblColors, ROW_New		, FALSE, ROW_New		, 0 )
.head 5 +  On SAM_Click
.head 6 -  Call SalTblSetFlagsAnyRows ( tblColors, ROW_Selected, FALSE, ROW_Selected, 0 )
.head 5 +  On WM_LBUTTONUP
.head 6 -  Call SalTblSetFlagsAnyRows ( tblColors, ROW_Selected, FALSE, ROW_Selected, 0 )
.head 5 +  On WM_LBUTTONDBLCLK
.head 6 -  Call SalSendMsg(dlgSelectPredefinedColor, AM_Ok,0,0)
.head 3 +  Pushbutton: pbOk
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.967"
.head 5 -  Top: 3.357"
.head 5 -  Width:  1.05"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: (none)
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: OK.BMP
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbCancel
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 3.1"
.head 5 -  Top: 3.357"
.head 5 -  Width:  1.05"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Esc
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: CANCEL.BMP
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 2 -  Functions 
.head 2 +  Window Parameters 
.head 3 -  Receive Number: nColor
.head 2 +  Window Variables 
.head 3 -  FunctionalVar: objColors
.winattr class
.head 4 -  Class: clsColorsDark
.end
.head 3 -  Number: nIndex
.head 3 -  Number: nRow
.head 2 +  Message Actions 
.head 3 +  On AM_Ok
.head 4 -  Set nColor = tblColors.colCOLOR_Index
.head 4 -  Call SalEndDialog( hWndForm, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, FALSE )
.head 1 +  ! clsSimpleDialogBox: dlgSelectCages
.winattr class Dialog Box:
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Print Cage Cards
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Display Style? Etched
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: 5.375"
.head 4 -  Top: 3.938"
.head 4 -  Width:  7.025"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 3.781"
.head 4 -  Height Editable? Yes
.head 3 -  Absolute Screen Location? Yes
.head 3 -  Font Name: Default
.head 3 -  Font Size: Default
.head 3 -  Font Enhancement: Default
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? No
.head 3 -  Horizontal Scroll? No
.end
.head 2 -  Description: 
.head 2 +  Tool Bar 
.winattr
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: 0.35"
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? No
.head 4 -  Toolbar Docking Orientation: Top | Bottom
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? No
.end
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 +  Pushbutton: pbSelectAll
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPbMarkSelectAllPic
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: &A
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.01"
.head 5 -  Width:  0.35"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: F3
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: SELALL.BMP
.head 4 -  Picture Transparent Color: Dark Green
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbSelect
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPbMarkSelectPic
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: &S
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.3"
.head 5 -  Width:  0.35"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: (none)
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: SELECT.BMP
.head 4 -  Picture Transparent Color: Dark Green
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbUnselect
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPbMarkUnselectPic
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: &U
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.59"
.head 5 -  Width:  0.35"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: (none)
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: UNSELECT.BMP
.head 4 -  Picture Transparent Color: Dark Green
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbUnselectAll
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPbMarkUnselectAllPic
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: &N
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.89"
.head 5 -  Width:  0.35"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: F4
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: SELNONE.BMP
.head 4 -  Picture Transparent Color: Dark Green
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Child Table: tblCages
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableBrowseMark
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.33"
.head 6 -  Top: 0.0"
.head 6 -  Width:  6.6"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 3.083"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  View: Table
.head 5 -  Allow Row Sizing? No
.head 5 -  Lines Per Row: Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: 10000
.head 5 -  Discardable? No
.end
.head 4 +  Contents 
.head 5 +  Column: colRackKey
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Rack
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 5 +  Column: colCageKey
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Cage
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 5 +  Column: colCageDescription
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Cage Description
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 5 +  Column: colPurpose
.winattr class
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Purpose
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Default
.head 6 -  Data Type: String
.head 6 -  Justify: Left
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Input Mask: Unformatted
.head 6 -  Cell Options
.head 7 -  Cell Type? Standard
.head 7 -  Multiline Cell? No
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Yes
.head 8 -  Vertical Scroll? Yes
.head 8 -  Auto Drop Down? No
.head 8 -  Allow Text Editing? Yes
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Yes
.end
.head 6 -  List Values 
.head 6 -  Message Actions 
.head 4 -  Functions 
.head 4 +  Window Variables 
.head 5 -  String: sSQL
.head 5 -  String: sRackKey
.head 5 -  String: sCageKey
.head 5 -  Number: nPassedObjects
.head 5 -  Number: nCounter
.head 5 -  String: sSQLCondition
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Set nPopulateMode = TBL_FillAll
.head 6 -  Set hWndCurrentChildTableMark = hWndItem
.head 6 +  If SalArrayIsEmpty( dlgSelectCages.cLocations )
.head 7 -  Return FALSE
.head 6 -  Call SalArrayGetUpperBound( dlgSelectCages.cLocations, 1, nPassedObjects )
.head 6 -  Set nPassedObjects = nPassedObjects + 1
.head 6 -  Set nCounter = 0
.head 6 -  Set sSQLCondition = ''
.head 6 +  While (nCounter < nPassedObjects)
.head 7 -  Set sRackKey = dlgSelectCages.cLocations[nCounter].GetRackKey( )
.head 7 -  Set sCageKey = dlgSelectCages.cLocations[nCounter].GetCageKey( )
.head 7 +  If sRackKey
.head 8 +  If sSQLCondition
.head 9 -  Set sSQLCondition = sSQLCondition || "
	or
"
.head 8 -  Set sSQLCondition = sSQLCondition || "
	(	g.STAT_KEY = '" || sRackKey || "'"
.head 8 +  If sCageKey
.head 9 -  Set sSQLCondition = sSQLCondition || "
	   and	g.GRUPPE_KEY = '" || sCageKey || "'"
.head 8 -  Set sSQLCondition = sSQLCondition || " )"
.head 7 -  Set nCounter = nCounter + 1
.head 6 +  If Not sSQLCondition
.head 7 -  Set sSQLCondition = "1 = 1"
.head 6 -  Set sSQL = "
select	g.STAT_KEY, g.GRUPPE_KEY, g.GRUPPE_BEZ, g.PURPOSE_KEY
from 	GRUPPE g, BETT b
where	g.EINRICHT_ID = b.EINRICHT_ID
   and 	g.STAT_KEY = b.STAT_KEY
   and	g.GRUPPE_KEY = b.GRUPPE_KEY
   and	g.CANCELED = 'N'
   and	b.CANCELED = 'N'
   and	g.EINRICHT_ID = " || StrX( nEinrichtId ) || "
   and 	(
"
.head 6 -  Set sSQL = sSQL || sSQLCondition || "
	)
"
.head 6 -  Set sSQL = sSQL || "
group by	g.STAT_KEY, g.GRUPPE_KEY, g.GRUPPE_BEZ, g.PURPOSE_KEY
having	count( b.BETT_KEY) > 0
order by   g.GRUPPE_KEY
into	:dlgSelectCages.tblCages.colRackKey, :dlgSelectCages.tblCages.colCageKey, :dlgSelectCages.tblCages.colCageDescription, :dlgSelectCages.tblCages.colPurpose
"
.head 6 -  Call Initialize( sSQL )
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 5 +  On SAM_DoubleClick
.head 6 -  Call ViewCageCard( tblCages.colRackKey, tblCages.colCageKey )
.head 3 +  Pushbutton: pbViewCageCard
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: View Cage Card
.head 4 -  Window Location and Size
.head 5 -  Left: 0.325"
.head 5 -  Top: 3.156"
.head 5 -  Width:  1.2"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: (none)
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 +  Message Actions 
.head 5 +  On SAM_Click
.head 6 +  ! If FillTableOfCages(  )
.head 7 -  ! 1 - view
.head 7 -  Call SalEndDialog( hWndForm, 1 )
.head 6 -  Call ViewCageCard( tblCages.colRackKey, tblCages.colCageKey )
.head 3 +  Pushbutton: pbPrintCageCard
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Print Cage Cards
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 3.156"
.head 5 -  Width:  1.2"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: (none)
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 +  Message Actions 
.head 5 +  On SAM_Click
.head 6 +  If FillTableOfCages(  )
.head 7 -  ! 2 - print
.head 7 -  Call SalEndDialog( hWndForm, 2 )
.head 3 +  Pushbutton: pbCancel
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Cancel
.head 4 -  Window Location and Size
.head 5 -  Left: 5.725"
.head 5 -  Top: 3.156"
.head 5 -  Width:  1.2"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: (none)
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 +  Message Actions 
.head 5 +  On SAM_Click
.head 6 -  ! 0 - cancel
.head 6 -  Call SalEndDialog( hWndForm, 0 )
.head 2 +  Functions 
.head 3 +  Function: FillTableOfCages
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nRow
.head 5 -  Boolean: bOk
.head 4 +  Actions 
.head 5 +  If Not SalTblAnyRows( tblCages, ROW_Edited, 0 )
.head 6 -  Call SalMessageBox( "Nothing is selected!", "Warning!", MB_IconExclamation )
.head 6 -  Return FALSE
.head 5 -  Call SalWaitCursor( TRUE )
.head 5 -  Set bOk = CageCard_Multi_ClearArr( )
.head 5 -  Set nRow = TBL_MinRow
.head 5 +  While bOk
.head 6 +  If Not SalTblFindNextRow( tblCages, nRow, ROW_Edited, 0 )
.head 7 -  Break 
.head 6 -  Set bOk = bOk And SalTblSetContext( tblCages, nRow )
.head 6 -  Set bOk = bOk And CageCard_Multi_Add2Arr( tblCages.colRackKey, tblCages.colCageKey )
.head 5 -  Set bOk = DoCloseTransaction( bOk ) And bOk
.head 5 -  Call SalWaitCursor( FALSE )
.head 5 -  Return bOk
.head 3 +  Function: ViewCageCard
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 +  Parameters 
.head 5 -  String: sStatKey
.head 5 -  String: sGruppeKey
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If frmAtlantaMain.lbKHELeft.KHE_CageFormularWithLitter ( sStatKey, sGruppeKey )
.head 6 +  If frmAtlantaMain.lbKHELeft.KHE_RackIsIntensiv( sStatKey )
.head 7 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '4', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 6 +  Else 
.head 7 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '2', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 5 +  Else 
.head 6 +  If frmAtlantaMain.lbKHELeft.KHE_RackIsIntensiv( sStatKey )
.head 7 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '3', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 6 +  Else 
.head 7 -  Call Formular_CageCardX( sStatKey, sGruppeKey, dtKHK_RefreshTime, '1', Not SHOW_EXTERNAL, Not AUTO_PRINT )
.head 2 +  Window Parameters 
.head 3 -  FunctionalVar: cLocations[*]
.winattr class
.head 4 -  Class: clsLocation
.end
.head 3 -  String: sWinTitle
.head 2 -  Window Variables 
.head 2 +  Message Actions 
.head 3 +  On SAM_Create
.head 4 +  If sWinTitle
.head 5 -  Call SalSetWindowText( hWndForm, sWinTitle )
.head 4 -  Call SalSetDefButton( pbViewCageCard )
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 3 +  On SAM_CreateComplete
.head 4 +  If SalArrayIsEmpty( cLocations )
.head 5 -  Call SalMessageBox( "Passed parameters are wrong!", "Internal Error!", MB_IconStop )
.head 5 -  Call SalPostMsg( hWndForm, SAM_Close, 0, 0 )
.head 5 -  Return FALSE
.head 4 -  Call SalTblSetRow( tblCages, TBL_SetFirstRow )
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 1 +  Dialog Box: dlgKHEItemSearch
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 363
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? No
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: 3.713"
.head 4 -  Top: 1.885"
.head 4 -  Width:  3.288"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.354"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: Default
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 -  Background Text: 1
.head 4 -  Resource Id: 24728
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: -0.013"
.head 5 -  Top: 0.323"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.417"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Right
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Bold
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfTarget
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 12
.head 5 -  Data Type: String
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.1"
.head 6 -  Top: 0.271"
.head 6 -  Width:  1.788"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.281"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Bold
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: 2
.head 4 -  Resource Id: 59506
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 3
.head 4 -  Window Location and Size
.head 5 -  Left: 0.288"
.head 5 -  Top: 0.781"
.head 5 -  Width:  0.85"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.292"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 4
.head 4 -  Window Location and Size
.head 5 -  Left: 2.038"
.head 5 -  Top: 0.781"
.head 5 -  Width:  0.85"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.292"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Esc
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  String: sTargetType
.head 3 -  Receive String: sSearchItem
.head 3 -  ! Window Handle: hWndMainForm
.head 3 -  ! Boolean: bPreservResultSet
.head 2 +  Window Variables
.head 3 -  Number: nHelpContext_ID
.head 3 -  String: sTitle
.head 2 +  Message Actions
.head 3 +  On AM_Ok
.head 4 +  If dfTarget
.head 5 -  Set sSearchItem = dfTarget
.head 5 -  Call SalEndDialog( hWndForm, TRUE )
.head 4 +  Else
.head 5 -  Call SalSetFocus(dfTarget)
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndForm, 0 )
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Set dlgKHEItemSearch.sVars[0] = sTargetType
.head 4 -  Call SetTitleForm(1)
.head 4 +  If not bShowDebugInfo
.head 5 -  Call SalSetWindowLabelText ( dfTarget, sTargetType || ':' )
.head 1 +  Dialog Box: dlgCage_Checked
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Cage Checked
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  5.263"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.156"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.1"
.head 5 -  Top: 0.625"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 3.35"
.head 5 -  Top: 0.625"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Data Field: dfCom
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.188"
.head 6 -  Top: 0.323"
.head 6 -  Width:  4.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: Comment:
.head 4 -  Resource Id: 27060
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundText
.head 4 -  Window Location and Size
.head 5 -  Left: 0.288"
.head 5 -  Top: 0.094"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 2 +  Functions
.head 3 +  Function: Init
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nBedAmount
.head 5 -  Number: hBeds[*]
.head 5 -  String: sBedLabel
.head 5 -  Number: nInd
.head 5 -  Number: nTypeOfBAR
.head 5 -  Boolean: bAnySkip
.head 4 +  Actions
.head 5 -  Set sGruppeKey=hWndKHE.clsKHExplorerLeft.GetKey_ByHandle(hWndKHE.clsKHExplorerLeft.nSelectedHandle)
.head 5 -  Set nInd = 0
.head 5 -  Set nBedAmount = hWndKHE.clsKHExplorerLeft.EnumChildren( hWndKHE.clsKHExplorerLeft.nSelectedHandle, hBeds )
.head 5 +  While nInd < nBedAmount 
.head 6 -  Set sBedLabel = hWndKHE.clsKHExplorerLeft.GetItemText( hBeds[ nInd ] )
.head 6 +  If hWndKHE.clsKHExplorerLeft.bPlanningMode
.head 7 -  Return FALSE
.head 6 +  If SalStrScan( sBedLabel, "{" ) >=0	
.head 7 -  Set nFallR=hWndKHE.clsKHExplorerLeft.GetFallKey_FromLable(sBedLabel)
.head 7 -  Call DoImmediate("Select EXPERIMENT_KEY 
		     from FALL_EXPERIMENT 
		     where EINRICHT_ID = :nEinrichtId
		     and  FALL_KEY=:dlgCage_Checked.nFallR
		     into :dlgCage_Checked.sExpKey")
.head 7 -  Set nFallV=Experiment_VirtualCase(sExpKey)
.head 7 +  If nFallV
.head 8 -  Return TRUE
.head 6 -  Set nInd = nInd + 1
.head 5 -  Return FALSE
.head 2 -  Window Parameters
.head 2 +  Window Variables
.head 3 -  String: sGruppeKey
.head 3 -  Number: nFallR
.head 3 -  Number: nFallV
.head 3 -  Number: nLstNrPP
.head 3 -  Number: nLstNrP
.head 3 -  String: sExpKey
.head 3 -  String: sLstKey
.head 3 -  String: sTarifKey
.head 3 -  String: sLaKey
.head 3 -  Date/Time: dtBuh
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 +  If not DoImmediate("Select  LA_KEY, TARIF_KEY, LST_KEY from LEISTUNG
		where LST_KEY='CCH'
		into	:dlgCage_Checked.sLaKey,
			:dlgCage_Checked.sTarifKey,
			:dlgCage_Checked.sLstKey")
.head 5 -  Call SalSendMsg(dlgCage_Checked, SAM_Close, wParam, lParam )
.head 4 +  If not Init()
.head 5 -  Call SalSendMsg(dlgCage_Checked, SAM_Close, wParam, lParam )
.head 4 -  Set dfCom='Ok'
.head 3 +  On AM_Ok
.head 4 -  Set dfCom=sGruppeKey||" : "||dfCom
.head 4 -  Set dtBuh=SalDateCurrent( )
.head 4 -  Call DoImmediate("Select  (@NULLVALUE(MAX(LST_ERF_NR),0)+1) from LST_ERF
		where EINRICHT_ID= :nEinrichtId
		           and FALL_KEY= :dlgCage_Checked.nFallV
		into    :dlgCage_Checked.nLstNrP")
.head 4 -  Set nLstNrPP=nLstNrP
.head 4 -  Call DoImmediate("Insert into LST_ERF (LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR,
			        LST_ERF_VON,  STORNIERT, IND_BEGR ,DONE)
	     values (	:dlgCage_Checked.sLaKey,
			:dlgCage_Checked.sTarifKey,
			:dlgCage_Checked.sLstKey,
			:dlgCage_Checked.nFallV,
			'N',
			:nEinrichtId,
			:dlgCage_Checked.nLstNrPP,
			:dlgCage_Checked.dtBuh,
			'N',
                                                :dlgCage_Checked.dfCom,'1'); commit")
.head 4 -  Call SalSendClassMessage( AM_Ok, wParam, lParam )
.head 1 +  ! clsDialogOkCancel: dlgCage_Changed
.winattr class Dialog Box:
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Cage Checked
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Display Style? Etched
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  5.263"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 1.156"
.head 4 -  Height Editable? Yes
.head 3 -  Absolute Screen Location? Yes
.head 3 -  Font Name: Default
.head 3 -  Font Size: Default
.head 3 -  Font Enhancement: Default
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.end
.head 2 -  Description: 
.head 2 +  Tool Bar 
.winattr
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: 0.35"
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? No
.head 4 -  Toolbar Docking Orientation: Top | Bottom
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? No
.end
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 +  Pushbutton: pbOk
.winattr
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.1"
.head 5 -  Top: 0.625"
.head 5 -  Width:  0.975"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: OK.BMP
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbCancel
.winattr
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 3.35"
.head 5 -  Top: 0.625"
.head 5 -  Width:  0.975"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Esc
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: CANCEL.BMP
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Data Field: dfCom
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: String
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.188"
.head 6 -  Top: 0.323"
.head 6 -  Width:  4.9"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.end
.head 4 -  Message Actions 
.head 3 -  Background Text: Comment:
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundText
.head 4 -  Window Location and Size
.head 5 -  Left: 0.288"
.head 5 -  Top: 0.094"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Justify: Left
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.end
.head 2 +  Functions 
.head 3 +  Function: CC
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 -  Local variables 
.head 4 +  Actions 
.head 5 +  If Not GalConnect(hSql)
.head 6 -  Return FALSE
.head 5 -  Call GetPosition( nSelectedHandle, sAbtKeySrc, sStatKeySrc, sGrpKeySrc, sBettKey )
.head 5 -  Set nInd = 0
.head 5 -  Set nBedAmount = EnumChildren( nSelectedHandle, hBeds )
.head 5 +  While nInd < nBedAmount 
.head 6 -  Set sBedLabel = GetItemText( hBeds[ nInd ] )
.head 6 +  If bPlanningMode
.head 7 -  Return FALSE
.head 6 +  If SalStrScan( sBedLabel, "{" ) >=0	
.head 7 -  Set nFallR=GetFallKey_FromLable(sBedLabel)

.head 7 -  Call SqlPrepareAndExecute(hSql, 'commit')
.head 7 -  Call SqlDisconnect(hSql)
.head 7 -  Call DoImmediate("Select  LA_KEY, TARIF_KEY, LST_KEY from LEISTUNG
		where LST_KEY='CC'
		into	:sLaKey,
			:sTarifKey,
			:sLstKey")

.head 7 -  Call SalMessageBox( sLaKey||','||sTarifKey||','||sLstKey, '',MB_Ok )
.head 7 -  Call DoImmediate("Select  (@NULLVALUE(MAX(LST_ERF_NR),0)+1) from LST_ERF
		where EINRICHT_ID= :nEinrichtId
		           and FALL_KEY= :nFallR
		into    :nLstNrP")
.head 7 -  Call SalMessageBox( SalNumberToStrX(nFallR,0)||','||SalNumberToStrX(nLstNrP,0), '',MB_Ok )
.head 7 -  Set nLstNrPP=nLstNrP
.head 7 -  Set dfCom=sGrpKeySrc||" : "||'Ok'
.head 7 -  Set dtBuh=SalDateCurrent( )
.head 7 -  Call DoImmediate("Insert into LST_ERF (LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR,
			        LST_ERF_VON,  STORNIERT, IND_BEGR ,DONE)
	     values (	'||sLaKey||',
			'||sTarifKey||',
			'||sLstKey||',
			:nFallR,
			'N',
			:nEinrichtId,
			:nLstNrPP,
			:dtBuh,
			'N',
                                                dfCom,
                                                 '1'); commit")

.head 7 -  Call SalMessageBox( '', '',MB_Ok )
.head 7 +  If nFallR
.head 8 -  Return TRUE
.head 6 -  Set nInd = nInd + 1
.head 5 -  Call SalSendMsg ( dlgCage_changed, AM_Ok, 0, 0)
.head 5 -  Call SalMessageBox( 'FUNCTION OK', '',MB_Ok )
.head 2 -  Window Parameters 
.head 2 +  Window Variables 
.head 3 -  Sql Handle: hSql
.head 3 -  Number: nFetch
.head 3 -  String: sNull
.head 3 -  String: sBG1
.head 3 -  String: sBG2
.head 3 -  String: sBedLabel
.head 3 -  String: sAbtKeySrc
.head 3 -  String: sBettKey
.head 3 -  String: sGrpKeySrc
.head 3 -  String: sStatKeySrc
.head 3 -  String: sLaKey
.head 3 -  String: sTarifKey
.head 3 -  String: sLstKey
.head 3 -  Number: nInd
.head 3 -  Number: nBedAmount
.head 3 -  Number: nFallR
.head 3 -  Number: nLstNrPP
.head 3 -  Number: nLstNrP
.head 3 -  Date/Time: dtBuh
.head 3 -  Number: hBeds[*]
.head 2 +  Message Actions 
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 +  If not CC()
.head 5 -  Call SalSendMsg(dlgCage_Changed, SAM_Close, wParam, lParam )
.head 3 +  On AM_Ok
.head 4 -  Call SalSendClassMessage( AM_Ok, wParam, lParam )
.head 1 +  Dialog Box: dlgIRServices
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title:
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  7.963"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 3.437"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 5.1"
.head 5 -  Top: 2.792"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click, 0, 0)
.head 6 +  If Not IR_GetFallsForIRService2 (tblIRs.colRem8, tblIRs.colRem9, tblIRs.colRem12,  hWndKHE.clsKHExplorerLeft.sFallsAvailableForCurrentIR ,nCountParam)
.head 7 -  Call SalMessageBox( "There are no animals fulfilling selected Internal Order","Animal search...", MB_Ok )
.head 7 -  Return FALSE
.head 6 -  Call hWndKHE.clsKHExplorerLeft.GotoGruppeByFallKey( SalStrToNumber (hWndKHE.clsKHExplorerLeft.sFallsAvailableForCurrentIR[0]), hWndKHE.clsExplorerLeft.bAutoScan )
.head 6 -  ! Call hWndKHE.clsKHExplorerLeft.GotoGruppeByFallKey( SalStrToNumber (sFallsAvailableForCurrentIR[0]), hWndKHE.clsExplorerLeft.bAutoScan )
.head 6 -  Set nOrderIdParam=tblIRs.colRem8
.head 6 -  Set nPosNrParam=tblIRs.colRem9
.head 6 -  Set nLstErfNrParam=tblIRs.colRem12
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 6.25"
.head 5 -  Top: 2.792"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Child Table: tblIRs
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableBrowse
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.188"
.head 6 -  Top: 0.156"
.head 6 -  Width:  7.5"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 2.333"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Class Default
.head 5 -  Discardable? Class Default
.head 4 +  Contents
.head 5 +  Column: colRem1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: WorkList Nr
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Service Key
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem3
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Strain Key
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem4
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Sex
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.417"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem13
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Screen
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem5
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Quantity
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.767"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem6
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Weight
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.717"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem7
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Age
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.45"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem8
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Order ID
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.917"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem9
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Order Position Nr
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  1.183"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem10
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: License
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.883"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem11
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: License Record
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem12
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Lst.Erf. Nr
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem14
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Functions
.head 4 +  Window Variables
.head 5 -  String: sSQL
.head 5 -  String: sAbtKey
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage(SAM_Create, 0, 0)
.head 6 -  Set sSQL = "select	lk.LST_WORK_KEY,
	lk.LST_KEY,
	
	s.STRAIN_KEY,
	pos.SEX,
	lk.MENGE,
	pos.WEIGHT,
	pos.AGE,
	lk.INT_ORDER_ID,
	lk.INT_POS_NR,
	exp.EXPERIMENT_KEY,
	exp.ORD_CODE,
	lk.Lst_Erf_NR,
	exp.ABT_KEY,
	lk.Lst_Erf_VON 
  from	Lst_Erf lk, LEISTUNG l, le, FALL f, ANML_ORDER_INT_POS pos, ANML_ORDER_INT ord, LST_WORK lw, EXP_SPECIES exp, STRAIN_N s
where	l.EINRICHT_ID = lk.EINRICHT_ID
   and	l.EINRICHT_ID = 1
   and	l.TARIF_KEY = lk.TARIF_KEY
   and	l.LST_KEY = lk.LST_KEY
   and	lk.STORNIERT = 'N'
   and	lk.DONE = 0
   and	l.IA_DEV= 1
   and	f.GELOESCHT = 'N'
   and	f.STATUS = 'A'
   and	lk.FALL_KEY = f.FALL_KEY
   and	f.EINRICHT_ID = 1
   and	lk.EINRICHT_ID = f.EINRICHT_ID
   and	lk.FALL_KEY = f.FALL_KEY
   and	le.LE_ID = f.LE_ID
   and	lk.INT_ORDER_ID = ord.ORDER_ID
   and	lk.INT_POS_NR = pos.POS_NR
   and	pos.ORDER_ID = ord.ORDER_ID
   and	pos.ID_STRAIN = s.ID
   and	lw.LST_WORK_KEY = lk.LST_WORK_KEY
   and	l.ABT_KEY = :sAbtKey
   and       exp.ORD_CODE=pos.ORD_CODE
   and	exp.EXPERIMENT_KEY=ord.EXPERIMENT_KEY
  order by 1 desc
"
.head 6 -  Set sSQL = sSQL || "
   into	:colRem1, :colRem2, :colRem3, :colRem4, :colRem5, :colRem6, :colRem7, :colRem8, :colRem9, :colRem10, :colRem11, :colRem12, :colRem13, :colRem14
"
.head 6 -  Call Initialize(sSQL)
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click, 0, 0)
.head 6 +  If colRem13=''
.head 7 -  Call pbTarget.Disable()
.head 6 +  Else
.head 7 -  Call pbTarget.Enable()
.head 3 +  Pushbutton: pbSource
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Source
.head 4 -  Window Location and Size
.head 5 -  Left: 0.488"
.head 5 -  Top: 2.792"
.head 5 -  Width:  0.9"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 +  If Not IR_GetFallsForIRService2 (tblIRs.colRem8, tblIRs.colRem9, tblIRs.colRem12,  hWndKHE.clsKHExplorerLeft.sFallsAvailableForCurrentIR ,nCountParam)
.head 7 -  Call SalMessageBox( "There are no animals fulfilling selected Internal Order","Animal search...", MB_Ok )
.head 7 -  Return FALSE
.head 6 -  Call hWndKHE.clsKHExplorerLeft.GotoGruppeByFallKey( SalStrToNumber (hWndKHE.clsKHExplorerLeft.sFallsAvailableForCurrentIR[0]), hWndKHE.clsExplorerLeft.bAutoScan )
.head 3 +  Pushbutton: pbTarget
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Target
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 2.792"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call hWndKHE.clsKHExplorerLeft.GoToAbt( tblIRs.colRem13)
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  String: sAbtKeyP
.head 3 -  Receive Number: nOrderIdParam
.head 3 -  Receive Number: nPosNrParam
.head 3 -  Receive Number: nLstErfNrParam
.head 3 -  Receive Number: nCountParam
.head 2 +  Window Variables
.head 3 -  String: sStatKey
.head 3 -  String: sGruppeKey
.head 3 -  String: sBettKey
.head 3 -  String: sStrain_Key
.head 3 -  String: sSex
.head 3 -  Number: nAge
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage(SAM_Create, 0, 0)
.head 4 -  Set tblIRs.sAbtKey=sAbtKeyP
.head 1 +  Form Window: frmIRServices
.head 2 -  Class: clsSimpleForm
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Internal Deliveries
.head 2 -  Icon File:
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? No
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Automatically Created at Runtime? Class Default
.head 3 -  Initial State: Class Default
.head 3 -  Maximizable? Class Default
.head 3 -  Minimizable? Class Default
.head 3 -  Allow Child Docking? No
.head 3 -  Docking Orientation: All
.head 3 -  System Menu? Class Default
.head 3 -  Resizable? Yes
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  10.0"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 3.354"
.head 4 -  Height Editable? Class Default
.head 3 -  Form Size
.head 4 -  Width:  Class Default
.head 4 -  Height: Class Default
.head 4 -  Number of Pages: Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 2 -  Description:
.head 2 -  Named Menus
.head 2 -  Menu
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? No
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Child Table: tblIRs
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableBrowse
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.188"
.head 6 -  Top: 0.156"
.head 6 -  Width:  9.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 2.333"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Class Default
.head 5 -  Discardable? Class Default
.head 4 +  Contents
.head 5 +  Column: colRem1
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: WorkList Nr
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.917"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCom
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Comment
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  1.183"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem2
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Service Key
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.233"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem3
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Strain Key
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSorScreen
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Source
Screen
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSorStat
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Source
Room/Rack
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSorGruppe
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Source
Cage Slot
.head 6 -  Visible? Yes
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem4
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Sex
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.4"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem13
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Target
Screen
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem5
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Quantity
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.583"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem6
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Weight
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.567"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem7
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Age
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.45"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem9
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Order Position Nr
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  1.183"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem10
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: License
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.883"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem8
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Order ID
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.333"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem11
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: License Record
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem12
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Lst.Erf. Nr
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Number
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRem14
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colSorCage
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title:
.head 6 -  Visible? No
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Functions
.head 4 +  Window Variables
.head 5 -  String: sSQL
.head 5 -  String: sWorkList
.head 4 +  Message Actions
.head 5 +  On SAM_FetchRowDone
.head 6 -  Call SalSendClassMessage(SAM_Create, 0, 0)
.head 6 -  Call DoImmediate  (" select f.LAST_CAGE_NR, gr.GRUPPE_KEY, f.LAST_ABT_KEY, f.LAST_STAT_KEY
     from FALL f, GRUPPE gr, FALL_EXPERIMENT fe
     where    fe.LST_ERF_NR = :frmIRServices.tblIRs.colRem12
     and       fe.EXPERIMENT_KEY = :frmIRServices.tblIRs.colRem10
     and       fe.ORD_CODE = :frmIRServices.tblIRs.colRem11
     and       f.FALL_KEY = fe.FALL_KEY
     and       gr.UNIQ_NR = f.LAST_CAGE_NR
     group by  f.LAST_CAGE_NR, gr.GRUPPE_KEY, f.LAST_ABT_KEY, f.LAST_STAT_KEY
     into :frmIRServices.tblIRs.colSorCage, :frmIRServices.tblIRs.colSorGruppe,:frmIRServices.tblIRs.colSorScreen,:frmIRServices.tblIRs.colSorStat
     ")
.head 6 -  Return TRUE
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage(SAM_Create, 0, 0)
.head 6 -  Set sSQL = "select	lk.LST_WORK_KEY,
	lk.LST_KEY,
	
	s.STRAIN_KEY,
	pos.SEX,
	lk.MENGE,
	pos.WEIGHT,
	pos.AGE,
	lk.INT_ORDER_ID,
	lk.INT_POS_NR,
	exp.EXPERIMENT_KEY,
	exp.ORD_CODE,
	lk.Lst_Erf_NR,
	exp.ABT_KEY,
	lk.Lst_Erf_VON,
	lw.LST_WORK_BEZ 
  from	Lst_Erf lk, LEISTUNG l, le, FALL f, ANML_ORDER_INT_POS pos, ANML_ORDER_INT ord, LST_WORK lw, EXP_SPECIES exp, STRAIN_N s
where	l.EINRICHT_ID = lk.EINRICHT_ID
   and	l.EINRICHT_ID = 1
   and	l.TARIF_KEY = lk.TARIF_KEY
   and	l.LST_KEY = lk.LST_KEY
   and	lk.STORNIERT = 'N'
   and	lk.DONE = 0
   and	l.IA_DEV= 1
   and	f.GELOESCHT = 'N'
   and	f.STATUS = 'A'
   and	lk.FALL_KEY = f.FALL_KEY
   and	f.EINRICHT_ID = 1
   and	lk.EINRICHT_ID = f.EINRICHT_ID
   and	lk.FALL_KEY = f.FALL_KEY
   and	le.LE_ID = f.LE_ID
   and	lk.INT_ORDER_ID = ord.ORDER_ID
   and	lk.INT_POS_NR = pos.POS_NR
   and	pos.ORDER_ID = ord.ORDER_ID
   and	pos.ID_STRAIN = s.ID
   and	lw.LST_WORK_KEY = lk.LST_WORK_KEY
   and	lk.LST_WORK_KEY = :sWorkList
   and       exp.ORD_CODE=pos.ORD_CODE
   and	exp.EXPERIMENT_KEY=ord.EXPERIMENT_KEY
  order by 1 desc
"
.head 6 -  Set sSQL = sSQL || "
   into	:colRem1, :colRem2, :colRem3, :colRem4, :colRem5, :colRem6, :colRem7, :colRem8, :colRem9, :colRem10, :colRem11, :colRem12, :colRem13, :colRem14, :colCom
"
.head 6 -  Call Initialize(sSQL)
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click, 0, 0)
.head 6 +  If colRem13=''
.head 7 -  Call pbTarget.Disable()
.head 6 +  Else
.head 7 -  Call pbTarget.Enable()
.head 6 -  Call pbSource.Enable()
.head 3 +  Pushbutton: pbSource
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Source
.head 4 -  Window Location and Size
.head 5 -  Left: 0.488"
.head 5 -  Top: 2.625"
.head 5 -  Width:  0.9"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalSendClassMessage(SAM_Click, 0, 0)
.head 6 +  If Not IR_GetFallsForIRService2 (tblIRs.colRem8, tblIRs.colRem9, tblIRs.colRem12,  hWndKHE.clsKHExplorerLeft.sFallsAvailableForCurrentIR ,nCountParam)
.head 7 -  Call SalMessageBox( "There are no animals fulfilling selected Internal Order","Animal search...", MB_Ok )
.head 7 -  Return FALSE
.head 6 -  Call hWndKHE.clsKHExplorerLeft.GotoGruppeByFallKey( SalStrToNumber (hWndKHE.clsKHExplorerLeft.sFallsAvailableForCurrentIR[0]), hWndKHE.clsExplorerLeft.bAutoScan )
.head 6 -  Set hWndKHE.clsKHExplorerLeft.nInternalRequestOrderId=tblIRs.colRem8
.head 6 -  Set hWndKHE.clsKHExplorerLeft.nInternalRequestOrderPosNr=tblIRs.colRem9
.head 6 -  Set hWndKHE.clsKHExplorerLeft.nInternalRequestLstErfNr=tblIRs.colRem12
.head 6 -  Set hWndKHE.clsKHExplorerLeft.nInternalRequestCount=nCountParam
.head 6 -  Set hWndKHE.clsKHExplorerLeft.bInternalRequestMode = TRUE
.head 6 -  Return TRUE
.head 3 +  Pushbutton: pbTarget
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Target
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 2.625"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call hWndKHE.clsKHExplorerLeft.GoToAbt( tblIRs.colRem13)
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 8.3"
.head 5 -  Top: 2.625"
.head 5 -  Width:  0.888"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalSendMsg(frmIRServices,SAM_Close,0,0)
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  String: sWorkListP
.head 2 +  Window Variables
.head 3 -  Number: nCountParam
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage(SAM_Create, 0, 0)
.head 4 -  Set tblIRs.sWorkList=sWorkListP
.head 4 -  Call pbSource.Disable()
.head 4 -  Call pbTarget.Disable()
.head 3 +  On SAM_Close
.head 4 -  Set hWndKHE.clsKHExplorerLeft.bMove_HasInClipboard = FALSE
.head 4 -  Set hWndKHE.clsKHExplorerLeft.bInternalRequestMode = FALSE
.head 4 -  Call SalSendClassMessage(SAM_Close, 0, 0)
.head 1 +  Dialog Box: dlgFallNumber2Cut
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title:
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  3.413"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.719"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: Class Default
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: Class Default
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Combo Box: cmbSex
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsComboBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Window Location and Size
.head 5 -  Left: 2.288"
.head 5 -  Top: 0.354"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.646"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Editable? Class Default
.head 4 -  String Type: Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Sorted? Class Default
.head 4 -  Always Show List? Class Default
.head 4 -  Vertical Scroll? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Input Mask: Class Default
.head 4 +  List Initialization
.head 5 -  Text: M
.head 5 -  Text: F
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Set cbSex = 1
.head 3 +  Check Box: cbSex
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Sex
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 0.323"
.head 5 -  Width:  0.5"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 +  If cbSex = 0
.head 7 -  Set cmbSex = ''
.head 6 +  Else
.head 7 -  Set cmbSex = 'M'
.head 3 +  Data Field: dfQuantity
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Number
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 2.288"
.head 6 -  Top: 0.573"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: 999999
.head 4 -  Message Actions
.head 3 -  Background Text: Quantity:
.head 4 -  Resource Id: 27061
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 1.588"
.head 5 -  Top: 0.594"
.head 5 -  Width:  0.6"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfInCage
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Number
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.888"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.5"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.229"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? No
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: 3D Face Color
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: In Cage:
.head 4 -  Resource Id: 27062
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.094"
.head 5 -  Width:  0.6"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfMale
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Number
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.388"
.head 6 -  Top: 0.323"
.head 6 -  Width:  1.0"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: M:
.head 4 -  Resource Id: 27063
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.344"
.head 5 -  Width:  0.2"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfFemale
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Number
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.388"
.head 6 -  Top: 0.573"
.head 6 -  Width:  1.0"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: F:
.head 4 -  Resource Id: 27064
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.594"
.head 5 -  Width:  0.2"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Check Box: cbSelectAll
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Select All
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 0.073"
.head 5 -  Width:  0.9"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 +  If cbSelectAll = 1
.head 7 -  Set dfQuantity = nBedsWhereFallsAre
.head 7 -  Call dfQuantity.Disable ()
.head 7 -  Set cmbSex = ' '
.head 7 -  Call cmbSex.Disable ()
.head 7 -  Set cbSex = 0
.head 7 -  Call cbSex.Disable ()
.head 6 +  Else
.head 7 -  Set dfQuantity = NUMBER_Null
.head 7 -  Call dfQuantity.Enable ()
.head 7 -  Call cmbSex.Enable ()
.head 7 -  Call cbSex.Enable ()
.head 2 +  Functions
.head 3 +  Function: DefiniteSex
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nBedAmount
.head 5 -  Number: hBeds[*]
.head 5 -  String: sBedLabel
.head 5 -  Number: nInd
.head 5 -  Number: nTypeOfBAR
.head 5 -  Boolean: bAnySkip
.head 4 +  Actions
.head 5 -  Set nInd = 0
.head 5 -  Set nBedsWhereFallsAreM = 0
.head 5 -  Set nBedsWhereFallsAreF = 0
.head 5 -  Set nBedsWhereFallsAre = 0
.head 5 -  Set nBedAmount = hWndKHE.clsKHExplorerLeft.EnumChildren( hSourceGrp, hBeds )
.head 5 +  While nInd < nBedAmount 
.head 6 -  Set sBedLabel = hWndKHE.clsKHExplorerLeft.GetItemText( hBeds[ nInd ] )
.head 6 +  If SalStrScan( sBedLabel, "{" ) >=0	
.head 7 -  Set nTypeOfBAR = hWndKHE.clsKHExplorerLeft.GetTypeOfMove_FromLable( sBedLabel )
.head 7 +  If nTypeOfBAR >= 0	
.head 8 +  If bCheckForPlan
.head 9 +  If (nTypeOfBAR = nTYPE_PLAN) And Not hWndKHE.clsKHExplorerLeft.bPlanningMode
.head 10 -  Return 0
.head 8 +  If bExpOnlyIfPlan and hWndKHE.clsKHExplorerLeft.bPlanningMode
.head 9 +  If hWndKHE.clsKHExplorerLeft.HasHandlePlanExpFall( hBeds[ nInd ] )
.head 10 -  Set hpBedsWhereFallsAre[ nBedsWhereFallsAre ] = hBeds[ nInd ]
.head 10 -  Set nBedsWhereFallsAre = nBedsWhereFallsAre + 1
.head 10 +  ! If SalStrScan( hWndKHE.clsKHExplorerLeft.GetItemText( hpItem ), "M" ) >= 0   
.head 11 -  Set nBedsWhereFallsAreM = nBedsWhereFallsAreM + 1
.head 10 +  If SalStrScan( sBedLabel, ", M," ) >=0
.head 11 -  Set nBedsWhereFallsAreM = nBedsWhereFallsAreM + 1
.head 10 +  Else
.head 11 -  Set nBedsWhereFallsAreF = nBedsWhereFallsAreF + 1
.head 9 +  Else
.head 10 -  Set bAnySkip = TRUE
.head 8 +  Else
.head 9 -  Set hpBedsWhereFallsAre[ nBedsWhereFallsAre ] = hBeds[ nInd ]
.head 9 -  Set nBedsWhereFallsAre = nBedsWhereFallsAre + 1
.head 9 +  ! If SalStrScan( hWndKHE.clsKHExplorerLeft.GetItemText( hpItem ), "M" ) >= 0   
.head 10 -  Set nBedsWhereFallsAreM = nBedsWhereFallsAreM + 1
.head 9 +  If SalStrScan( sBedLabel, ", M," ) >=0
.head 10 -  Set nBedsWhereFallsAreM = nBedsWhereFallsAreM + 1
.head 9 +  Else
.head 10 -  Set nBedsWhereFallsAreF = nBedsWhereFallsAreF + 1
.head 6 -  Set nInd = nInd + 1
.head 2 +  Window Parameters
.head 3 -  Number: hSourceGrp
.head 3 -  Receive Number: hpBedsWhereFallsAre[*]
.head 3 -  Boolean: bCheckForPlan
.head 3 -  Boolean: bExpOnlyIfPlan
.head 3 -  Boolean: bWarnIfSkipNotExp
.head 3 -  Receive Number: nFallQuantity
.head 3 -  Receive String: sFallSex
.head 2 +  Window Variables
.head 3 -  Number: nBedsWhereFallsAreM
.head 3 -  Number: nBedsWhereFallsAre
.head 3 -  Number: nBedsWhereFallsAreF
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Call DefiniteSex ()
.head 4 -  Set dfMale = nBedsWhereFallsAreM
.head 4 -  Set dfFemale = nBedsWhereFallsAreF
.head 4 -  Set dfInCage = nBedsWhereFallsAre
.head 3 +  On AM_Ok
.head 4 +  If cbSelectAll = 1
.head 5 -  Set nFallQuantity = dfInCage
.head 4 +  Else
.head 5 -  Set nFallQuantity = dfQuantity
.head 4 +  If cbSex = 1
.head 5 -  Set sFallSex = cmbSex
.head 4 +  Else
.head 5 -  Set sFallSex = ' '
.head 4 +  If (cmbSex = 'M' and  dfQuantity <= dfMale) or (cmbSex = 'F' and  dfQuantity <= dfFemale) or (cbSex = 0 and  dfQuantity <= dfInCage)
.head 5 -  Call SalSendClassMessage( AM_Ok, wParam, lParam )
.head 4 +  Else
.head 5 -  Call SalMessageBox ('check inputed quantity', 'incorrect data', 0)
.head 1 +  Table Window: tblEarTags
.head 2 -  Class: clsTableEdit
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 373
.head 2 -  Icon File:
.head 2 -  Accessories Enabled? Yes
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Visible at Design time? Yes
.head 3 -  Automatically Created at Runtime? No
.head 3 -  Initial State: Normal
.head 3 -  Maximizable? Yes
.head 3 -  Minimizable? Yes
.head 3 -  System Menu? Yes
.head 3 -  Resizable? Yes
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  10.833"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 3.56"
.head 4 -  Height Editable? Yes
.head 3 -  Font Name: MS Sans Serif
.head 3 -  Font Size: 8
.head 3 -  Font Enhancement: None
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 3 -  View: Table
.head 3 -  Allow Row Sizing? No
.head 3 -  Lines Per Row: Default
.head 3 -  Allow Child Docking? No
.head 3 -  Docking Orientation: All
.head 2 -  Memory Settings
.head 3 -  Maximum Rows in Memory: Default
.head 3 -  Discardable? Yes
.head 2 -  Description:
.head 2 -  Named Menus
.head 2 -  Menu
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: 0.313"
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Teal
.head 4 -  Resizable? Class Default
.head 3 +  Contents
.head 4 +  ! clsPbExit: pbExit
.winattr class Pushbutton:
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPbExit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 1
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? No
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? No
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: EXIT_PAR.BMP
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  ! clsPbUpdate: pbUpdate
.winattr class Pushbutton:
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPbUpdate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 2
.head 5 -  Window Location and Size
.head 6 -  Left: 0.7"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: F6
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: UPDATE.BMP
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 +  ! While SalTblFindNextRow ( tblEarTags, nCurrentRow, ROW_Edited, 0)
.head 8 -  Call SalTblSetContext( tblEarTags, nCurrentRow )
.head 8 -  Call DoImmediateSingle ("Select le_id from le where TRANSPONDER_ID =:tblEarTags.colTransponderID", bExists)
.head 8 +  If bExists
.head 9 -  Call SalTblSetFocusRow( tblEarTags, nCurrentRow )
.head 9 -  Set tblEarTags.colEarTag = ''
.head 9 -  Set bFlag = TRUE
.head 7 +  ! If bFlag
.head 8 -  Call SalMessageBox ("Several transponders have already existed", "Error", 0)
.head 7 -  Set bOk = TRUE
.head 7 -  Call SalWaitCursor ( TRUE )
.head 7 -  Set bFlag = FALSE
.head 7 -  Set nCurrentRow = -1
.head 7 +  While SalTblFindNextRow ( tblEarTags, nCurrentRow, ROW_Edited, 0)
.head 8 -  Call SalTblSetContext( tblEarTags, nCurrentRow )
.head 8 -  Call DoImmediateSingle ("Select l.le_id from le l, fall f 
			where l.TRANSPONDER_ID =:tblEarTags.colTransponderID
			and l.le_id = f.le_id
			and f.fall_key != :tblEarTags.colMouseID", bExists)
.head 8 +  If bExists
.head 9 -  Call SalTblSetFocusRow( tblEarTags, nCurrentRow )
.head 9 -  Set tblEarTags.colTransponderID = ''
.head 9 -  Set bFlag = TRUE
.head 8 -  Set bOk = bOk and DoImmediate("
update	FALL set
	name1=:tblEarTags.colEarTag
where	fall_key = :tblEarTags.colMouseID
and	Einricht_id = :nEinrichtId;

update	LE set
	TRANSPONDER_ID =:tblEarTags.colTransponderID,
	name1=:tblEarTags.colEarTag
where	le_id = :tblEarTags.colLE_ID;

update adresse set
	name1 = :tblEarTags.colEarTag
where	adresse_id = :tblEarTags.colAdresse_ID")
.head 7 +  If bFlag
.head 8 -  Call SalMessageBox ("Some of the transponders are already registred", "Error", 0)
.head 7 +  If bOk
.head 8 -  Call DoImmediate ("commit")
.head 7 +  If not bOk
.head 8 -  Call DoImmediate ("rollback")
.head 7 -  Call SalSendMsg (pbRefresh, SAM_Click, wParam, lParam)
.head 7 -  Call SalPostMsg( hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 7 -  Call SalWaitCursor ( FALSE )
.head 7 -  Call SalSendClassMessage(SAM_Click,0,0)
.head 4 +  ! clsPbRefresh: pbRefresh
.winattr class Pushbutton:
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPbRefresh
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 3
.head 5 -  Window Location and Size
.head 6 -  Left: 0.35"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: REFRESH.BMP
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call SalTblReset ( tblEarTags )
.head 7 -  Call tbl_Populate ()
.head 7 -  ! Set bFormDirty = FALSE
.head 7 -  ! Call SalDisableWindow( pbUpdate )
.head 7 -  Call SalSendClassMessage(SAM_Click,0,0)
.head 4 +  Pushbutton: pbExit
.head 5 -  Class Child Ref Key: 66
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 1
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbRefresh
.head 5 -  Class Child Ref Key: 71
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 3
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbUpdate
.head 5 -  Class Child Ref Key: 56
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 2
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbInsert
.head 5 -  Class Child Ref Key: 55
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbUndo
.head 5 -  Class Child Ref Key: 57
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbDelete
.head 5 -  Class Child Ref Key: 58
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbPrint
.head 5 -  Class Child Ref Key: 59
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbFirst
.head 5 -  Class Child Ref Key: 67
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbPrev
.head 5 -  Class Child Ref Key: 68
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbNext
.head 5 -  Class Child Ref Key: 69
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbLast
.head 5 -  Class Child Ref Key: 70
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Data Field: dfRack
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataField
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? No
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 2.688"
.head 7 -  Top: 0.042"
.head 7 -  Width:  1.0"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 4
.head 5 -  Resource Id: 23509
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Data Field: dfCage
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataField
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? No
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 4.588"
.head 7 -  Top: 0.042"
.head 7 -  Width:  1.2"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 5
.head 5 -  Resource Id: 23510
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 -  Background Text: 6
.head 5 -  Resource Id: 24833
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundTextRight
.head 5 -  Window Location and Size
.head 6 -  Left: 1.688"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 -  Background Text: 7
.head 5 -  Resource Id: 24834
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundTextRight
.head 5 -  Window Location and Size
.head 6 -  Left: 3.688"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 +  Pushbutton: pbEarTags
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 8
.head 5 -  Window Location and Size
.head 6 -  Left: 1.07"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.638"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 +  If SalStrToNumber (colEarTag) <= 0 or SalStrScan ( colEarTag, '.' ) > -1 or SalStrScan ( colEarTag, ',' ) > -1
.head 8 -  Call SalMessageBox ('impossible to create EarTags automatically', 'Error', 0)
.head 8 -  Return FALSE
.head 7 -  Set bFk = FALSE
.head 7 -  Set nLength1 = 0
.head 7 -  Set nLength2 = 0
.head 7 +  If SalStrLeftX ( colEarTag, 1) = '0'
.head 8 -  Set nLength1 = SalStrLength (colEarTag)
.head 8 -  Set nEarTag = SalStrToNumber (colEarTag) + 1
.head 8 -  Set sEarTag = SalNumberToStrX(nEarTag, 0)
.head 8 -  Set nLength2 = SalStrLength (sEarTag)
.head 8 +  While nLength1>nLength2
.head 9 -  Set sEarTag = '0'||sEarTag
.head 9 -  Set nLength2 = nLength2 +1
.head 7 +  Else
.head 8 -  Set nEarTag = SalStrToNumber (colEarTag) + 1
.head 8 -  Set sEarTag = SalNumberToStrX(nEarTag, 0)
.head 7 -  Set nFallKey = colMouseID
.head 7 -  Set nCurrentRow = TBL_MinRow
.head 7 +  Loop
.head 8 +  If not SalTblFindNextRow ( tblEarTags, nCurrentRow, 0, 0 )									
.head 9 -  Break
.head 8 -  Call SalTblSetContext ( tblEarTags, nCurrentRow)
.head 8 +  If bFk
.head 9 -  Set colEarTag = sEarTag
.head 9 -  Set nEarTag = nEarTag + 1
.head 9 -  Set sEarTag = SalNumberToStrX(nEarTag, 0)
.head 9 -  Set nLength2 = SalStrLength (sEarTag)
.head 9 +  While nLength1>nLength2
.head 10 -  Set sEarTag = '0'||sEarTag
.head 10 -  Set nLength2 = nLength2 +1
.head 9 -  Call SalTblSetRowFlags( tblEarTags, nCurrentRow, ROW_Edited, TRUE)
.head 8 +  If colMouseID = nFallKey
.head 9 -  Set bFk = TRUE
.head 2 +  Contents
.head 3 +  Column: colMouseID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 9
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colStrain
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 10
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colSex
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 11
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colAge
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 12
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colColor
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 13
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colEarTag
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 14
.head 4 -  Visible? Yes
.head 4 -  Editable? Yes
.head 4 -  Maximum Data Length: 48
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colTransponderID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 15
.head 4 -  Visible? Yes
.head 4 -  Editable? Yes
.head 4 -  Maximum Data Length: 20
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  1.333"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colLE_ID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 16
.head 4 -  Visible? No
.head 4 -  Editable? Yes
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  1.333"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colAdresse_ID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 17
.head 4 -  Visible? No
.head 4 -  Editable? Yes
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  1.333"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.head 4 -  List Values
.head 4 -  Message Actions
.head 2 +  Functions
.head 3 +  Function: tbl_Populate
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Sql Handle: hSqlSelect
.head 4 +  Actions
.head 5 +  If GalConnect( hSqlSelect )
.head 6 -  Call SalTblPopulate( tblEarTags, hSqlSelect, "
select f.fall_key, s.STRAIN_KEY, g.geschl_abr, l.name1, l.transponder_id, l.color, l.le_id, l.adresse_id, @INT((@NOW-f.GEB_DATUM)/7)
from FALL f, BEWEGUNG b, le l, geschlecht g, STRAIN_N s
where f.last_bew_nr = b.bew_nr
and b.fall_key = f.fall_key
and f.le_id = l.le_id
and f.ID_STRAIN = s.ID
and b.ba_key <> 'EE'
and g.geschl_key = f.geschl
and b.stat_key = :tblEarTags.sStatKey
and b.gruppe_key = :tblEarTags.sGruppeKey
and b.abt_key = :tblEarTags.sAbtKey
and f.geloescht = 'N'
into :tblEarTags.colMouseID, :tblEarTags.colStrain, :tblEarTags.colSex, :tblEarTags.colEarTag,
	:tblEarTags.colTransponderID, :tblEarTags.colColor, :tblEarTags.colLE_ID, :tblEarTags.colAdresse_ID, :tblEarTags.colAge", TBL_FillAll )
.head 6 -  Call SqlDisconnect( hSqlSelect )
.head 3 +  Function: May_I_Continue
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nResDlg
.head 4 +  Actions
.head 5 +  If (SalTblAnyRows( hWndForm, ROW_Edited | ROW_New | ROW_MarkDeleted, 0 ) ) and SalIsWindowVisible (pbUpdate)
.head 6 -  Set nResDlg = SalModalDialog( dlgAskAboutUpdate, hWndForm )
.head 6 +  If nResDlg = 0		!Continue editing
.head 7 -  Return FALSE
.head 6 +  Else If nResDlg = 1		!Update
.head 7 -  Return SalSendMsg( pbUpdate, SAM_Click, 0, 0 )
.head 6 +  Else If nResDlg = -1		!Discasrd
.head 7 -  ! Set bWasDelete = FALSE
.head 7 -  ! Return _RefreshTable( )
.head 5 -  Return TRUE
.head 2 +  Window Parameters
.head 3 -  String: sAbtKey
.head 3 -  String: sStatKey
.head 3 -  String: sGruppeKey
.head 2 +  Window Variables
.head 3 -  Number: nCurrentRow
.head 3 -  Number: nEarTag
.head 3 -  Boolean: bFk
.head 3 -  Boolean: bFlag
.head 3 -  Number: nFallKey
.head 3 -  Number: nLength1
.head 3 -  Number: nLength2
.head 3 -  String: sEarTag
.head 3 -  Boolean: bOk
.head 3 -  Boolean: bExists
.head 3 -  Boolean: bFormDirty
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call tbl_Populate ()
.head 4 -  Set dfCage = sGruppeKey
.head 4 -  Set dfRack = sStatKey
.head 4 -  Call Initialize("select f.fall_key, s.STRAIN_KEY, g.geschl_abr, l.name1, l.transponder_id, l.color, l.le_id, l.adresse_id, @INT((@NOW-f.GEB_DATUM)/7)
from FALL f, BEWEGUNG b, le l, geschlecht g, STRAIN_N s
where f.last_bew_nr = b.bew_nr
and b.fall_key = f.fall_key
and f.le_id = l.le_id
and f.ID_STRAIN = s.ID
and b.ba_key <> 'EE'
and g.geschl_key = f.geschl
and b.stat_key = :tblEarTags.sStatKey
and b.gruppe_key = :tblEarTags.sGruppeKey
and b.abt_key = :tblEarTags.sAbtKey
and f.geloescht = 'N'
into :tblEarTags.colMouseID, :tblEarTags.colStrain, :tblEarTags.colSex, :tblEarTags.colEarTag,
	:tblEarTags.colTransponderID, :tblEarTags.colColor, :tblEarTags.colLE_ID, :tblEarTags.colAdresse_ID, :tblEarTags.colAge",
"
select f.fall_key, s.STRAIN_KEY, g.geschl_abr, l.name1, l.transponder_id, l.color, l.le_id, l.adresse_id, @INT((@NOW-f.GEB_DATUM)/7)
from FALL f, BEWEGUNG b, le l, geschlecht g, STRAIN_N s
where f.last_bew_nr = b.bew_nr
and b.fall_key = f.fall_key
and f.le_id = l.le_id
and f.ID_STRAIN = s.ID
and b.ba_key <> 'EE'
and g.geschl_key = f.geschl
and b.stat_key = :tblEarTags.sStatKey
and b.gruppe_key = :tblEarTags.sGruppeKey
and b.abt_key = :tblEarTags.sAbtKey
and f.geloescht = 'N'
into :tblEarTags.colMouseID, :tblEarTags.colStrain, :tblEarTags.colSex, :tblEarTags.colEarTag,
	:tblEarTags.colTransponderID, :tblEarTags.colColor, :tblEarTags.colLE_ID, :tblEarTags.colAdresse_ID, :tblEarTags.colAge",

"", 
"",
"")
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 3 +  On AM_Update
.head 4 +  While SalTblFindNextRow ( tblEarTags, nCurrentRow, ROW_Edited, 0)
.head 5 -  Call SalTblSetContext( tblEarTags, nCurrentRow )
.head 5 -  Call DoImmediateSingle ("Select le_id from le where TRANSPONDER_ID =:tblEarTags.colTransponderID", bExists)
.head 5 +  If bExists
.head 6 -  Call SalTblSetFocusRow( tblEarTags, nCurrentRow )
.head 6 -  Set tblEarTags.colEarTag = ''
.head 6 -  Set bFlag = TRUE
.head 4 +  If bFlag
.head 5 -  Call SalMessageBox ("Several transponders have already existed", "Error", 0)
.head 4 -  Set bOk = TRUE
.head 4 -  Call SalWaitCursor ( TRUE )
.head 4 -  Set bFlag = FALSE
.head 4 -  Set nCurrentRow = -1
.head 4 +  While SalTblFindNextRow ( tblEarTags, nCurrentRow, ROW_Edited, 0)
.head 5 -  Call SalTblSetContext( tblEarTags, nCurrentRow )
.head 5 -  Call DoImmediateSingle ("Select l.le_id from le l, fall f 
			where l.TRANSPONDER_ID =:tblEarTags.colTransponderID
			and l.le_id = f.le_id
			and f.fall_key != :tblEarTags.colMouseID", bExists)
.head 5 +  If bExists
.head 6 -  Call SalTblSetFocusRow( tblEarTags, nCurrentRow )
.head 6 -  Set tblEarTags.colTransponderID = ''
.head 6 -  Set bFlag = TRUE
.head 5 -  Set bOk = bOk and DoImmediate("
update	FALL set
	name1=:tblEarTags.colEarTag
where	fall_key = :tblEarTags.colMouseID
and	Einricht_id = :nEinrichtId;

update	LE set
	TRANSPONDER_ID =:tblEarTags.colTransponderID,
	name1=:tblEarTags.colEarTag
where	le_id = :tblEarTags.colLE_ID;

update adresse set
	name1 = :tblEarTags.colEarTag
where	adresse_id = :tblEarTags.colAdresse_ID")
.head 4 +  If bFlag
.head 5 -  Call SalMessageBox ("Some of the transponders are already registred", "Error", 0)
.head 4 +  If bOk
.head 5 -  Call DoImmediate ("commit")
.head 4 +  If not bOk
.head 5 -  Call DoImmediate ("rollback")
.head 4 -  Call SalSendMsg (pbRefresh, SAM_Click, wParam, lParam)
.head 4 -  Call SalPostMsg( hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 4 -  Call SalWaitCursor ( FALSE )
.head 4 -  Call SalSendClassMessage( AM_Update, wParam, lParam )
.head 3 +  On AM_Refresh
.head 4 -  Call SalTblReset ( tblEarTags )
.head 4 -  Call tbl_Populate ()
.head 4 -  Call SalSendClassMessage( AM_Refresh, wParam, lParam )
.head 3 +  On GM_NEED_TOOLBAR_RESIZE
.head 4 -  Return TRUE
.head 3 +  On GM_SeekRow
.head 4 -  ! Return TRUE
.head 4 -  Return SalSendClassMessage( GM_SeekRow, wParam, lParam )
.head 3 +  On GM_LoseFocus
.head 4 -  Return TRUE
.head 1 +  Dialog Box: dlgAskForMoveScreen
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Transfer Cage
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? No
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: 2.575"
.head 4 -  Top: 2.125"
.head 4 -  Width:  3.563"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.021"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.588"
.head 5 -  Top: 0.531"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 0.531"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 -  Background Text: Screen for transfer:
.head 4 -  Resource Id: 41992
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundText
.head 4 -  Window Location and Size
.head 5 -  Left: 0.988"
.head 5 -  Top: 0.01"
.head 5 -  Width:  1.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.25"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: 10
.head 4 -  Font Enhancement: Bold
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfExp_AdrID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDF_Help
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: String
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.24"
.head 6 -  Width:  0.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Yes
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call oHelp.AddColumn( "Screen", DT_String, dfExp_AdrID )
.head 6 -  Call oHelp.AddColumn( "Short Title", DT_String, dfExpKey1 )
.head 6 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 7 -  Call oHelp.Init( "select a.abt_key, a.abt_bez
from sysadm.abt_stat ABT
 join sysadm.ben_abteilung BA on (BA.scr_id=ABT.scr_id  and ba.benutzer_id=:nUserId )
 join sysadm.abteilung A on (a.id=ABT.scr_id)
where ABT.stat_key='" || sCurrentRack || "' and ABT.einricht_id=:nEinrichtId
and ABT.abt_Key<>'" || sCurrentScreen || "'", " screen" )
.head 6 +  Else
.head 7 -  Call oHelp.Init( "select distinct abt.abt_key, a.abt_bez
from sysadm.abteilung A
join abt_stat ABT on (abt.scr_id=a.id)
join sysadm.ben_abteilung BA on ( BA.scr_id=A.id and ba.benutzer_id= :nUserId)
where a.abt_key<>'" || sCurrentScreen || "'", " screen" )
.head 6 -  Call SetHLParam(oHelp)
.head 3 +  Data Field: dfExpKey1
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.088"
.head 6 -  Top: 0.24"
.head 6 -  Width:  2.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  String: sCurrentScreen
.head 3 -  String: sCurrentRack
.head 2 +  Window Variables
.head 3 -  String: sAbtSelect
.head 3 -  ! String: sAbt_Key_Tmp
.head 3 -  String: sAbtForUser
.head 3 -  String: sInnerScreen
.head 3 -  Boolean: bEx
.head 3 -  FunctionalVar: oHelp
.head 4 -  Class: cfHelpListData
.head 3 -  String: sKey
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Set sAbtForUser = GetAbteilungsAllowedForUser( nUserId )
.head 4 -  ! Set dfExp_AdrID = sCurrentScreen
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 5 -  Call DoImmediate("
select a.abt_key, a.abt_bez from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
 where ABT.stat_key=:dlgAskForMoveScreen.sCurrentRack 
    and ABT.abt_key<>:dlgAskForMoveScreen.sCurrentScreen
    and BA.scr_id=ABT.scr_id 
    and ba.benutzer_id= :nUserId
    and a.id=ba.scr_id 
 order by a.abt_key asc
into :dlgAskForMoveScreen.sKey, :dlgAskForMoveScreen.dfExpKey1")
.head 5 -  ! Call DoImmediate("
select abt_key, abt_bez from abteilung 
where abt_key = (
 select min(a.abt_key) from abt_stat ABT, ben_abteilung BA, abteilung A 
 where ABT.stat_key=:dlgAskForMoveScreen.sCurrentRack and BA.ABT_KEY=ABT.abt_key and ba.benutzer_id=:nUserId and ba.abt_key=a.abt_key 
 and ABT.einricht_id=:nEinrichtId and ABT.abt_key<>:dlgAskForMoveScreen.sCurrentScreen) 
into :dlgAskForMoveScreen.dfExp_AdrID, :dlgAskForMoveScreen.dfExpKey1")
.head 4 +  Else
.head 5 -  Call DoImmediate("
select distinct abt.abt_key, a.abt_bez from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
 where 
     ABT.abt_key<>:dlgAskForMoveScreen.sCurrentScreen
    and BA.scr_id=ABT.scr_id 
    and ba.benutzer_id= :nUserId
    and a.id=ba.scr_id 
order by a.abt_key asc
into :dlgAskForMoveScreen.sKey, :dlgAskForMoveScreen.dfExpKey1")
.head 4 -  Set dfExp_AdrID = sKey
.head 3 +  On AM_Ok
.head 4 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 5 -  Call SqlExists( "select *
from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
where ABT.stat_key=:dlgAskForMoveScreen.sCurrentRack and ABT.einricht_id=:nEinrichtId and ABT.abt_key = :dlgAskForMoveScreen.dfExp_AdrID
and BA.ABT_KEY=ABT.abt_key  and ba.benutzer_id=:nUserId and BA.einricht_id=ABT.einricht_id
and ba.abt_key=a.abt_key and a.einricht_id=ABT.einricht_id and ABT.abt_Key<>:dlgAskForMoveScreen.sCurrentScreen", bEx )
.head 4 +  Else
.head 5 -  Call SqlExists( "select *
from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
where  ABT.einricht_id=:nEinrichtId and ABT.abt_key = :dlgAskForMoveScreen.dfExp_AdrID
and BA.ABT_KEY=ABT.abt_key  and ba.benutzer_id=:nUserId and BA.einricht_id=ABT.einricht_id
and ba.abt_key=a.abt_key and a.einricht_id=ABT.einricht_id and ABT.abt_Key<>:dlgAskForMoveScreen.sCurrentScreen", bEx )
.head 4 +  If bEx
.head 5 -  Set hWndKHE.clsKHExplorerLeft.sMoveScreen = dfExp_AdrID
.head 5 -  Call SalEndDialog( hWndItem, (dfExp_AdrID != sCurrentScreen) and (dfExp_AdrID !="") )
.head 4 +  Else
.head 5 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 6 -  Call SalMessageBox( "Screen " || dfExp_AdrID || " not allowed for rack " || sCurrentRack , "Error", MB_Ok )
.head 5 +  Else
.head 6 -  Call SalMessageBox( "User don't have access in screen " || dfExp_AdrID  , "Error", MB_Ok )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndItem, FALSE )
.head 1 +  Dialog Box: dlgAskForMoveInScreen
.head 2 -  Class: cDlgUseOption
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Transfer Cage
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? No
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: 2.575"
.head 4 -  Top: 2.125"
.head 4 -  Width:  3.563"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.021"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 -  Background Text: Workgroup for transfer:
.head 4 -  Resource Id: 56750
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundText
.head 4 -  Window Location and Size
.head 5 -  Left: 0.888"
.head 5 -  Top: 0.01"
.head 5 -  Width:  2.3"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: 0.25"
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: 10
.head 4 -  Font Enhancement: Bold
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfExp_AdrID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDF_Help
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: String
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.24"
.head 6 -  Width:  0.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Yes
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call oHelp.AddColumn( "Workgroup", DT_String, dfExp_AdrID )
.head 6 -  Call oHelp.AddColumn( "Short Title", DT_String, dfExpKey1 )
.head 6 -  Call oHelp.AddColumn( "Id", DT_Number, hWndNULL )
.head 6 -  Call oHelp.HideShowColumn( 2, TRUE )
.head 6 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 7 -  Call oHelp.Init( "select a.abt_key, a.abt_bez,a.id
from sysadm.abt_stat ABT
 join sysadm.ben_abteilung BA on (BA.scr_id=ABT.scr_id  and ba.benutzer_id=:nUserId )
 join sysadm.abteilung A on (a.id=ABT.scr_id)
where ABT.stat_key='" || sCurrentRack || "' and ABT.einricht_id=:nEinrichtId
and ABT.abt_Key<>'" || sCurrentScreen || "'", " screen" )
.head 6 +  Else
.head 7 -  Call oHelp.Init( "select distinct abt.abt_key, a.abt_bez ,a.id
from sysadm.abteilung A
join abt_stat ABT on (abt.scr_id=a.id)
join sysadm.ben_abteilung BA on ( BA.scr_id=A.id and ba.benutzer_id= :nUserId)
where a.abt_key<>'" || sCurrentScreen || "'", " screen" )
.head 6 -  Call SetHLParam(oHelp)
.head 3 +  Data Field: dfExpKey1
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 1.088"
.head 6 -  Top: 0.24"
.head 6 -  Width:  2.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDlgUseOption
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.588"
.head 5 -  Top: 0.531"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDlgUseOption
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 0.531"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 2 +  Functions
.head 3 +  Function: OK
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 6 -  Call SqlExists( "select *
from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
where ABT.stat_key=:dlgAskForMoveInScreen.sCurrentRack and ABT.einricht_id=:nEinrichtId and ABT.abt_key = :dlgAskForMoveInScreen.dfExp_AdrID
and BA.ABT_KEY=ABT.abt_key  and ba.benutzer_id=:nUserId and BA.einricht_id=ABT.einricht_id
and ba.abt_key=a.abt_key and a.einricht_id=ABT.einricht_id and ABT.abt_Key<>:dlgAskForMoveInScreen.sCurrentScreen", bEx )
.head 5 +  Else
.head 6 -  Call SqlExists( "select *
from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
where  ABT.einricht_id=:nEinrichtId and ABT.abt_key = :dlgAskForMoveInScreen.dfExp_AdrID
and BA.ABT_KEY=ABT.abt_key  and ba.benutzer_id=:nUserId and BA.einricht_id=ABT.einricht_id
and ba.abt_key=a.abt_key and a.einricht_id=ABT.einricht_id and ABT.abt_Key<>:dlgAskForMoveInScreen.sCurrentScreen", bEx )
.head 5 +  If bEx
.head 6 -  Set sScrMove = dfExp_AdrID
.head 6 -  Set oRetV = oHelp.GetValue( 2 )
.head 6 -  Set nScrIDMove = oRetV.nValue
.head 6 -  Call SalEndDialog( hWndItem, (dfExp_AdrID != sCurrentScreen) and (dfExp_AdrID !="") )
.head 5 +  Else
.head 6 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 7 -  Call SalMessageBox( "Screen " || dfExp_AdrID || " not allowed for rack " || sCurrentRack , "Error", MB_Ok )
.head 6 +  Else
.head 7 -  Call SalMessageBox( "User don't have access in screen " || dfExp_AdrID  , "Error", MB_Ok )
.head 3 +  Function: CANCEL
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Call SalEndDialog( hWndItem, FALSE )
.head 3 +  Function: Scale
.head 4 -  Description:
.head 4 -  Returns
.head 4 +  Parameters
.head 5 -  Number: nScaleFactor
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Window Handle: hWnd
.head 5 -  Number: nX
.head 5 -  Number: nY
.head 5 -  Number: nW
.head 5 -  Number: nH
.head 5 -  Number: nHCombo
.head 5 -  String: sFont
.head 5 -  Number: nFontSize
.head 5 -  Number: nEnch
.head 5 -  Number: nClientX
.head 5 -  Number: nClientY
.head 5 -  Number: nClientW
.head 5 -  Number: nClientH
.head 5 -  Number: nWindowType
.head 5 -  Window Handle: hLabel
.head 4 +  Actions
.head 5 -  Set hWnd = SalGetFirstChild(hWndForm, TYPE_Any)
.head 5 +  While hWnd != hWndNULL
.head 6 -  Call SalGetWindowLoc(hWnd, nX, nY)
.head 6 -  Call SalGetWindowSize(hWnd, nW, nH)
.head 6 +  If SalGetType(hWnd) = TYPE_FormWindow
.head 7 -  Call SalSendMsg(hWnd, AM_Zoom, nScaleFactor, 0)
.head 6 +  Else
.head 7 +  If SalGetType(hWnd) = TYPE_ComboBox
.head 8 -  Set nHCombo = SalSendMsg(hWnd, 0x0154, -1, 0)
.head 7 -  Call SalFontGet(hWnd, sFont, nFontSize, nEnch)
.head 7 -  Set nX = nX * nScaleFactor
.head 7 -  Set nY = nY * nScaleFactor
.head 7 -  Set nW = nW * nScaleFactor
.head 7 -  Set nH = nH * nScaleFactor
.head 7 -  Call SalSetWindowLoc(hWnd, nX, nY)
.head 7 -  Call SalSetWindowSize(hWnd, nW, nH)
.head 7 +  If SalGetType(hWnd) = TYPE_ComboBox
.head 8 -  Call SalSendMsg(hWnd, 0x0153, -1, nHCombo * nScaleFactor)
.head 8 -  Set nH = SalPixelsToFormUnits(hWndForm, nHCombo * nScaleFactor, TRUE)
.head 7 -  Call SalFontSet(hWnd, sFont, nFontSize * nScaleFactor, nEnch)
.head 7 -  Set nWindowType = SalGetType(hWnd)
.head 7 +  If (nWindowType != TYPE_Line) and (nWindowType != TYPE_Frame) and (nWindowType != TYPE_BkgdText)
.head 8 -  Set hLabel = SalGetWindowLabel(hWnd)
.head 8 +  ! If hLabel != hWndNULL
.head 9 -  Call SalGetWindowLoc(hLabel, nClientX, nClientY)
.head 9 -  Call SalGetWindowSize(hLabel, nClientW, nClientH)
.head 9 -  Call SalSetWindowLoc(hLabel, nClientX, nY + (nH - nClientH) / 2)
.head 6 -  Set hWnd = SalGetNextChild(hWnd, TYPE_Any)
.head 5 -  Call SalGetWindowSize(hWndForm, nW, nH)
.head 5 -  Call SalSetWindowSize(hWndForm, nW* nScaleFactor , nH * nScaleFactor )
.head 2 +  Window Parameters
.head 3 -  String: sCurrentScreen
.head 3 -  String: sCurrentRack
.head 3 -  Receive String: sScrMove
.head 3 -  Receive Number: nScrIDMove
.head 2 +  Window Variables
.head 3 -  String: sAbtSelect
.head 3 -  ! String: sAbt_Key_Tmp
.head 3 -  String: sAbtForUser
.head 3 -  String: sInnerScreen
.head 3 -  Boolean: bEx
.head 3 -  FunctionalVar: oHelp
.head 4 -  Class: cfHelpListData
.head 3 -  String: sKey
.head 3 -  FunctionalVar: oRetV
.head 4 -  Class: cdHelpRetData
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Set sAbtForUser = GetAbteilungsAllowedForUser( nUserId )
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 5 -  Call DoImmediate("
select a.abt_key, a.abt_bez from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
 where ABT.stat_key=:dlgAskForMoveInScreen.sCurrentRack 
    and ABT.abt_key<>:dlgAskForMoveInScreen.sCurrentScreen
    and BA.scr_id=ABT.scr_id 
    and ba.benutzer_id= :nUserId
    and a.id=ba.scr_id 
 order by a.abt_key asc
into :dlgAskForMoveInScreen.sKey, :dlgAskForMoveInScreen.dfExpKey1")
.head 4 +  Else
.head 5 -  Call DoImmediate("
select distinct abt.abt_key, a.abt_bez from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
 where 
     ABT.abt_key<>:dlgAskForMoveInScreen.sCurrentScreen
    and BA.scr_id=ABT.scr_id 
    and ba.benutzer_id= :nUserId
    and a.id=ba.scr_id 
order by a.abt_key asc
into :dlgAskForMoveInScreen.sKey, :dlgAskForMoveInScreen.dfExpKey1")
.head 4 -  Set dfExp_AdrID = sKey
.head 4 -  Call SalSendMsg(dfExp_AdrID,WM_KEYDOWN, VK_F1,0 )
.head 3 +  ! On AM_Ok
.head 4 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 5 -  Call SqlExists( "select *
from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
where ABT.stat_key=:dlgAskForMoveScreen.sCurrentRack and ABT.einricht_id=:nEinrichtId and ABT.abt_key = :dlgAskForMoveScreen.dfExp_AdrID
and BA.ABT_KEY=ABT.abt_key  and ba.benutzer_id=:nUserId and BA.einricht_id=ABT.einricht_id
and ba.abt_key=a.abt_key and a.einricht_id=ABT.einricht_id and ABT.abt_Key<>:dlgAskForMoveScreen.sCurrentScreen", bEx )
.head 4 +  Else 
.head 5 -  Call SqlExists( "select *
from sysadm.abt_stat ABT, sysadm.ben_abteilung BA, sysadm.abteilung A
where  ABT.einricht_id=:nEinrichtId and ABT.abt_key = :dlgAskForMoveScreen.dfExp_AdrID
and BA.ABT_KEY=ABT.abt_key  and ba.benutzer_id=:nUserId and BA.einricht_id=ABT.einricht_id
and ba.abt_key=a.abt_key and a.einricht_id=ABT.einricht_id and ABT.abt_Key<>:dlgAskForMoveScreen.sCurrentScreen", bEx )
.head 4 +  If bEx
.head 5 -  ! Set hWndKHE.clsKHExplorerLeft.sMoveScreen = dfExp_AdrID
.head 5 -  Set sScrMove = dfExp_AdrID
.head 5 -  Set oRetV = oHelp.GetValue( 2 )
.head 5 -  Set nScrIDMove = oRetV.nValue
.head 5 -  Call SalMessageBox(SalNumberToStrX(nScrIDMove,0), "f" , 0)
.head 5 -  Call SalEndDialog( hWndItem, (dfExp_AdrID != sCurrentScreen) and (dfExp_AdrID !="") )
.head 4 +  Else 
.head 5 +  If sCurrentRack != STRING_Null and sCurrentRack != ""
.head 6 -  Call SalMessageBox( "Screen " || dfExp_AdrID || " not allowed for rack " || sCurrentRack , "Error", MB_Ok )
.head 5 +  Else 
.head 6 -  Call SalMessageBox( "User don't have access in screen " || dfExp_AdrID  , "Error", MB_Ok )
.head 3 +  ! On AM_Cancel
.head 4 -  Call SalEndDialog( hWndItem, FALSE )
.head 1 +  Dialog Box: dlgSelectCageType
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Select Cage Type
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  5.375"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 2.375"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.7"
.head 5 -  Top: 1.958"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 3.05"
.head 5 -  Top: 1.958"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Child Table: tblType
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableBrowse
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.073"
.head 6 -  Width:  5.1"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 1.833"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Class Default
.head 5 -  Discardable? Class Default
.head 4 +  Contents
.head 5 +  Column: colType
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Type
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  1.35"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colNR
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsNumberColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Num Pl
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colDesc
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: Description
.head 6 -  Visible? Class Default
.head 6 -  Editable? Class Default
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  3.95"
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 -  Functions
.head 4 -  Window Variables
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 6 -  Call Initialize( "Select TYPE_KEY, COUNT_PL, DESC
		from CAGE_TYPES
		into :colType,:colNR,:colDesc" )
.head 5 +  On WM_LBUTTONDBLCLK
.head 6 -  Call SalSendMsg(dlgSelectCageType,AM_Ok,0,0)
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  Receive String: sType
.head 2 -  Window Variables
.head 2 +  Message Actions
.head 3 +  ! On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Call DefiniteSex ()
.head 4 -  Set dfMale = nBedsWhereFallsAreM
.head 4 -  Set dfFemale = nBedsWhereFallsAreF
.head 4 -  Set dfInCage = nBedsWhereFallsAre
.head 3 +  On AM_Ok
.head 4 -  Set sType=tblType.colType
.head 4 -  Call SalSendClassMessage( AM_Ok, wParam, lParam )
.head 1 +  Dialog Box: dlgAddAlert
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 321
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? No
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: 2.575"
.head 4 -  Top: 2.125"
.head 4 -  Width:  4.725"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.5"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 1
.head 4 -  Window Location and Size
.head 5 -  Left: 1.288"
.head 5 -  Top: 1.115"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 2
.head 4 -  Window Location and Size
.head 5 -  Left: 2.388"
.head 5 -  Top: 1.115"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Standard
.head 4 -  Message Actions
.head 3 +  Data Field: dfSrvKey
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.323"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: 3
.head 4 -  Resource Id: 32453
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Data Field: dfSrvName
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.888"
.head 6 -  Top: 0.323"
.head 6 -  Width:  3.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: 4
.head 4 -  Resource Id: 32454
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Data Field: dfDt
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 2.888"
.head 6 -  Top: 0.04"
.head 6 -  Width:  1.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 -  Background Text: 5
.head 4 -  Resource Id: 32455
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 -  Background Text: 6
.head 4 -  Resource Id: 15023
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundText
.head 4 -  Window Location and Size
.head 5 -  Left: 1.888"
.head 5 -  Top: 0.094"
.head 5 -  Width:  0.9"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Right
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 -  Background Text: 7
.head 4 -  Resource Id: 15024
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.088"
.head 5 -  Top: 0.65"
.head 5 -  Width:  0.6"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Justify: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 3 +  Data Field: dfComment
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.688"
.head 6 -  Top: 0.6"
.head 6 -  Width:  3.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 +  Check Box: cbApplyParents
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 9
.head 4 -  Window Location and Size
.head 5 -  Left: 0.588"
.head 5 -  Top: 0.85"
.head 5 -  Width:  1.3"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Message Actions
.head 3 +  Check Box: cbDoneImmediately
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 10
.head 4 -  Window Location and Size
.head 5 -  Left: 2.688"
.head 5 -  Top: 0.85"
.head 5 -  Width:  1.4"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Message Actions
.head 3 +  Data Field: dfTarifKey
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldHelpedInput
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 3.688"
.head 6 -  Top: 1.073"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call Initialize( "", "select l.tarif_key,'' from leistung l, tarif t
	where l.tarif_key = :MyValue and l.einricht_id=:nEinrichtId and l.lst_key=:dlgAddAlert.sSrvKey 
	        and  t.einricht_id= l.einricht_id
	      and t.tarif_key=l.tarif_key
	      and t.canceled='N'	
       into :sProper", "
select l.tarif_key,'' from leistung l, tarif t
	where l.einricht_id=:nEinrichtId and l.lst_key=:dlgAddAlert.sSrvKey 
	        and  t.einricht_id= l.einricht_id
	      and t.tarif_key=l.tarif_key
	      and t.canceled='N'	
" )
.head 6 -  Set dfTarifKey.sHelpBoxTitle = 'Tarif '
.head 6 -  Return SalSendClassMessage( SAM_Create, wParam, lParam )
.head 3 -  Background Text: 11
.head 4 -  Resource Id: 32456
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Data Field: dfLitter
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDF_Help
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Number
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Create
.head 6 -  Call SalSendClassMessage(SAM_Create,wParam,lParam)
.head 6 -  ! Call oHL_Litter.Init("select  l.litter_id, 'Pups: ' || count(lc.child_nr)
  from relship_fall rf, litter l, litter_child lc
where rf.einricht_id=:nEinrichtId
   and rf.fall_key=:nFall
   and l.family_relship_id = rf.relship_id 
   and l.miss=0
  and lc.litter_id=l.litter_id
  and lc.fall_key is null
group by 1"," litter_id")
.head 6 -  Call oHL_Litter.AddColumn("Litter ID", DT_Number, dfLitter)
.head 6 -  Call oHL_Litter.AddColumn("Description", DT_String, hWndNULL )
.head 6 -  ! Call SetHLParam(oHL_Litter)
.head 5 +  On AM_PrepareHelp
.head 6 -  Call oHL_Litter.Init("select  l.litter_id, 'Pups: ' || count(lc.child_nr)
  from relship_fall rf, litter l, litter_child lc
where rf.einricht_id=:nEinrichtId
   and rf.fall_key=" || SalNumberToStrX(nFall,0) || "
   and l.family_relship_id = rf.relship_id 
   and l.miss=0
  and lc.litter_id=l.litter_id
  and lc.fall_key is null
group by 1"," litter_id")
.head 6 -  Call SetHLParam(oHL_Litter)
.head 6 -  Call SalSendMsg(dfLitter,WM_KEYDOWN,VK_F1,0)
.head 3 -  Background Text: 12
.head 4 -  Resource Id: 32457
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 2 +  Functions
.head 3 +  Function: PrepareFilter
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Sql Handle: hSqlBase
.head 5 -  String: sName
.head 5 -  Number: nFetch
.head 4 +  Actions
.head 5 +  If not GalConnect( hSqlBase )
.head 6 -  Return FALSE
.head 5 -  Call SqlPrepareAndExecute(hSqlBase , "select l.lst_key, l.lst_bez, l.SRV_LMT_ID, Immediately_Done
  				from  leistung l
				      where l.id=:nSrvID
        					    
  					 into :sSrvKey, :sSrvName, :nForSrv , :dlgAddAlert.cbDoneImmediately  ")
.head 5 +  If SqlFetchNext(hSqlBase,nFetch)
.head 6 -  Set sName = sSrvKey
.head 6 +  If hWndKHE.clsNewExplorer.nSelectedLevel = KHEL_Gruppe
.head 7 +  If nForSrv = 1 or nForSrv=2 or nForSrv=4 or nForSrv=5 or nForSrv=6
.head 8 -  Set cbApplyParents=TRUE
.head 8 -  Call cbApplyParents.Disable(  )
.head 8 +  If nForSrv=6
.head 9 -  Set bApplyToPups = TRUE
.head 7 +  Else If nForSrv=3
.head 8 -  Set cbApplyParents=FALSE
.head 8 -  Call cbApplyParents.Disable(  )
.head 7 +  Else
.head 8 -  ! Set cbApplyParents=FALSE
.head 8 -  Call cbApplyParents.Enable(  )
.head 8 +  If nForSrv=6
.head 9 -  Set bApplyToPups = TRUE
.head 6 +  Else If hWndKHE.clsNewExplorer.nSelectedLevel = KHEL_Bett
.head 7 +  If nForSrv=6
.head 8 -  Set bApplyToPups = TRUE
.head 5 -  Call SqlDisconnect( hSqlBase )
.head 3 +  Function: ApplyAlert
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Sql Handle: hSqlFilter
.head 5 -  Boolean: bOk
.head 5 -  Boolean: bAnyMail
.head 5 -  FunctionalVar: cCageSel
.head 6 -  Class: cPositionData
.head 5 -  FunctionalVar: cAnimal
.head 6 -  Class: cPositionData
.head 5 -  String: sAbtKey
.head 5 -  String: sStatKey
.head 5 -  String: sGrpKey
.head 5 -  String: sBettKey
.head 5 -  Number: nFalls[*]
.head 5 -  ! Number: nFallLoc
.head 5 -  Number: nCount
.head 5 -  Number: nI
.head 5 -  Number: nBound
.head 5 -  Number: nDone
.head 5 -  Number: nScrID
.head 5 -  Number: nCageID
.head 5 -  Boolean: bSelect
.head 5 -  String: sSrV
.head 5 -  Number: nLMT
.head 5 -  Session Handle: hSession
.head 5 -  Number: nCagesRefresh[*]
.head 5 -  Number: nIndC
.head 4 +  Actions
.head 5 -  Set bOk = TRUE
.head 5 -  Set nIndC = 0
.head 5 -  Set bAnyMail = FALSE
.head 5 +  If SqlCreateSession( hSession, "" )
.head 6 +  If SqlCreateStatement( hSession, hSqlFilter)
.head 7 -  Set bOk = bOk and SqlSetIsolationLevel( hSqlFilter, "RL" )
.head 7 -  Set bOk = bOk and SqlSetParameter( hSqlFilter, DBP_PRESERVE , TRUE, "" )
.head 7 -  Set bOk = bOk and SqlPrepare(hSqlFilter, "select l.lst_key,-1
 			into :sSrV, :nLMT
  				from  leistung l, fall f, geschlecht g, srv_limit s
				      where l.id=:nSrvID
        					  and	f.EINRICHT_ID = :nEinrichtId
 					  and	f.FALL_KEY = :nFall
					  and g.geschl_key=f.geschl
                                                                                 and ( @nullvalue(l.SRV_LMT_ID,0)=0
				    	
                                     or ( l.SRV_LMT_ID=4 and f.VIS_KAT_KEY != 'V')
                                     or (l.SRV_LMT_ID<3 and s.id=l.SRV_LMT_ID and g.geschl_abr=s.abr))
                       union
 select  l.lst_key,l.SRV_LMT_ID
      from sysadm.fall f join sysadm.geschlecht g  on g.geschl_key=f.geschl
             join sysadm.relship_fall rf on (rf.einricht_id=f.einricht_id and rf.fall_key=f.fall_key and rf.FALLROLLE_KEY='PARENT')
             join sysadm.litter li on (li.FAMILY_RELSHIP_ID=rf.RELSHIP_ID and li.miss=0)
            left join litter_child lc on (lc.litter_id=li.litter_id and lc.fall_key is null and lc.dead=0)
       , sysadm.leistung l
       where f.EINRICHT_ID = :nEinrichtId
	  and	f.FALL_KEY =  :nFall
  	  and  f.VIS_KAT_KEY != 'V'
          and G.GESCHL_KEY ='W'
          and l.id=:nSrvID
	  and l.la_key='ML'
          and ( (l.SRV_LMT_ID=5)
                or (l.SRV_LMT_ID=6 and lc.litter_id>0) )
group by 1,2 ")
.head 7 +  If bOk
.head 8 +  If frmAtlantaMain.bShowStationsliste
.head 9 -  Set bSelect = SalArrayIsEmpty(hWndAnE.cFallExplorer.oHandleSelect.nRow )
.head 8 +  Else
.head 9 -  Set bSelect = SalArrayIsEmpty(hWndKHE.clsNewFE.oHandleSelect.nRow)
.head 8 +  If bSelect
.head 9 +  If frmAtlantaMain.bShowStationsliste
.head 10 +  If hWndAnE.cFallExplorer.GetSValue( hWndAnE.cFallExplorer.nSelectedRow, "SEX" )
.head 11 -  Set nFall = hWndAnE.cFallExplorer.GetIdObject( hWndAnE.cFallExplorer.nSelectedRow )
.head 11 +  If nFall
.head 12 -  Set sGrpKey=""
.head 12 -  Set nCageID = NUMBER_Null
.head 12 -  Set nDone = InsertServiceINT_ForSession(hSession,  nSrvID,nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment, nScrID, nCageID, 0,dlgAddAlert.cbDoneImmediately, TRUE   )
.head 12 +  If nDone = 1
.head 13 -  Set bOk = TRUE
.head 12 +  Else If nDone = 0
.head 13 -  Set bOk = FALSE
.head 9 +  Else
.head 10 -  Call hWndKHE.clsNewExplorer._GetPositionID( hWndKHE.clsNewExplorer.nSelectedRow, cCageSel )
.head 10 -  Set nScrID = cCageSel.nScreenID
.head 10 -  Set nCageID = cCageSel.nCageID
.head 10 -  Set nCagesRefresh[nIndC] = nCageID
.head 10 -  Set nIndC = nIndC + 1
.head 10 +  If hWndKHE.clsNewExplorer.nSelectedLevel=KHEL_Bett
.head 11 -  Set nFall = hWndKHE.clsNewExplorer.GetIdObject( hWndKHE.clsNewExplorer.nSelectedRow )
.head 11 -  Set sGrpKey=""
.head 11 +  If bApplyToPups
.head 12 -  Call SalSendMsg(dfLitter,AM_PrepareHelp,0,0)
.head 12 -  Set nDone = InsertServiceOnPupsINT_ForSession( hSession ,nFall,dfLitter, nSrvID,dlgAddAlert.dfDt  )
.head 11 +  Else
.head 12 -  Set nDone = InsertServiceINT_ForSession( hSession ,nSrvID,nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment, nScrID, nCageID, 0,dlgAddAlert.cbDoneImmediately, TRUE   )
.head 11 +  If nDone = 1
.head 12 -  Set bOk = TRUE
.head 11 +  Else If nDone = 0
.head 12 -  Set bOk = FALSE
.head 10 +  Else
.head 11 +  If cbApplyParents
.head 12 -  Set nCount = hWndKHE.clsNewExplorer.EnumChildren(  hWndKHE.clsNewExplorer.nSelectedRow, nFalls )
.head 12 +  While nCount>0
.head 13 -  Set nFall = nFalls[nCount-1]
.head 13 +  If nFall
.head 14 +  If (SqlExecute(hSqlFilter) and SqlFetchNext(hSqlFilter,nTmp))
.head 15 +  If nLMT = 6
.head 16 -  Call SalSendMsg(dfLitter,AM_PrepareHelp,0,0)
.head 16 -  Set nDone = InsertServiceOnPupsINT_ForSession( hSession ,nFall,dfLitter, nSrvID,dlgAddAlert.dfDt  )
.head 15 +  Else
.head 16 -  Set nDone = InsertServiceINT_ForSession( hSession,  nSrvID,nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment, nScrID, nCageID,0, dlgAddAlert.cbDoneImmediately, TRUE   )
.head 15 +  If nDone = 1
.head 16 -  Set bOk = TRUE
.head 15 +  Else If nDone = 0
.head 16 -  Set bOk = FALSE
.head 13 -  Set nCount = nCount-1
.head 11 +  Else
.head 12 -  Set sGrpKey = cCageSel.sCage
.head 12 -  Set nFall = hWndKHE.clsNewFE.GetLicenseFall()
.head 12 -  Set nDone = InsertServiceINT_ForSession( hSession, nSrvID,nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment, nScrID, nCageID, 0,dlgAddAlert.cbDoneImmediately, TRUE   )
.head 12 +  If nDone = 1
.head 13 -  Set bOk = TRUE
.head 12 +  Else If nDone = 0
.head 13 -  Set bOk = FALSE
.head 8 +  Else
.head 9 +  If frmAtlantaMain.bShowStationsliste
.head 10 -  Set nBound = hWndAnE.cFallExplorer.oHandleSelect.nIndex - 1
.head 9 +  Else
.head 10 -  Set nBound = hWndKHE.clsNewFE.oHandleSelect.nIndex - 1
.head 9 -  Set nI = 0
.head 9 +  While nI<= nBound
.head 10 +  If frmAtlantaMain.bShowStationsliste
.head 11 -  Set nFall = hWndAnE.cFallExplorer.GetIdObject( hWndAnE.cFallExplorer.GetRowID(hWndAnE.cFallExplorer.oHandleSelect.nRow[nI]) )
.head 11 -  Set nCageID = NUMBER_Null
.head 10 +  Else
.head 11 -  Set nFall = hWndKHE.clsNewFE.GetIdObject( hWndKHE.clsNewFE.GetRowID(hWndKHE.clsNewFE.oHandleSelect.nRow[nI]) )
.head 11 -  Call hWndKHE.clsNewFE._GetPositionID( hWndKHE.clsNewFE.GetRowID(hWndKHE.clsNewFE.oHandleSelect.nRow[nI]), cAnimal )
.head 11 -  Set nScrID = cAnimal.nScreenID
.head 11 -  Set nCageID = cAnimal.nCageID
.head 11 +  If SalStrScan(sGrpKeyStatic, cAnimal.sCage) = -1
.head 12 -  Set sGrpKeyStatic = sGrpKeyStatic || cAnimal.sCage ||","
.head 12 -  Set nCagesRefresh[nIndC] = cAnimal.nCageID
.head 12 -  Set nIndC = nIndC + 1
.head 10 +  If nFall
.head 11 +  If (SqlExecute(hSqlFilter) and SqlFetchNext(hSqlFilter,nTmp))
.head 12 +  If nLMT = 6
.head 13 -  Call SalSendMsg(dfLitter,AM_PrepareHelp,0,0)
.head 13 -  Set nDone = InsertServiceOnPupsINT_ForSession(hSession, nFall,dfLitter, nSrvID,dlgAddAlert.dfDt  )
.head 12 +  Else
.head 13 -  Set nDone = InsertServiceINT_ForSession(hSession,  nSrvID,nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment, nScrID, nCageID, 0,dlgAddAlert.cbDoneImmediately, TRUE   )
.head 12 +  If nDone = 1
.head 13 -  Set bOk = TRUE
.head 12 +  Else If nDone = 0
.head 13 -  Set bOk = FALSE
.head 10 -  Set nI=nI+1
.head 7 +  If bOk
.head 8 -  Call SqlCommit( hSqlFilter )
.head 7 +  Else
.head 8 -  Call SqlPrepareAndExecute( hSqlFilter, "rollback" )
.head 7 +  If bOk and frmAtlantaMain.bShowStationsliste
.head 8 -  Call SalSendMsg( hWndAnE , AM_Refresh, 0, 1 )
.head 7 +  If bOk
.head 8 +  While nIndC > 0
.head 9 -  Call SalSendMsg(hWndStar2000, AM_Refresh, 1, nCagesRefresh[nIndC - 1] )
.head 9 -  Set nIndC = nIndC - 1
.head 7 +  If dlgAddAlert.cbDoneImmediately and VisWinIsWindow( hWnd_MR4Lst )
.head 8 -  Call SalSendMsg( hWnd_MR4Lst, AM_Control, 0, 0 )
.head 7 -  Call SqlDisconnect(hSqlFilter)
.head 6 -  Call SqlFreeSession( hSession )
.head 5 -  Return bOk
.head 3 +  Function: GetAutoDone
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Boolean: bExists
.head 5 -  Boolean: bDone
.head 4 +  Actions
.head 5 -  ! Call SqlExists( "select autodoneservice from leistung 
		where lst_key=:dlgAddAlert.sSrvKey
		    and einricht_id=:nEinrichtId 
		    and tarif_key=:dlgAddAlert.dfTarifKey
                                into :bDone ", bExists  )
.head 5 -  Call SqlExists( "select autodoneservice from leistung 
		where id=:dlgAddAlert.nSrvID
		
                                into :bDone ", bExists  )
.head 5 -  Return bDone
.head 3 +  Function: GetIDScreen
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  String: sScrKey
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nScrID
.head 5 -  Sql Handle: hSql
.head 5 -  Number: nFetch
.head 4 +  Actions
.head 5 -  Set nScrID = -100
.head 5 +  If GalConnect( hSql )
.head 6 +  If SqlPrepareAndExecute( hSql, "select id from abteilung where abt_key=:sScrKey and einricht_id=:nEinrichtId into :nScrID " )
.head 7 -  Call SqlFetchNext( hSql, nFetch )
.head 6 -  Call SqlDisconnect( hSql )
.head 5 -  Return nScrID
.head 3 +  Function: GetIDCage
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  String: sRack
.head 5 -  String: sCage
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nCageID
.head 5 -  Sql Handle: hSql
.head 5 -  Number: nFetch
.head 4 +  Actions
.head 5 -  Set nCageID = -100
.head 5 +  If GalConnect( hSql )
.head 6 +  If SqlPrepareAndExecute( hSql, "select id from gruppe where stat_key=:sRack and gruppe_key=:sCage and einricht_id=:nEinrichtId into :nCageID " )
.head 7 -  Call SqlFetchNext( hSql, nFetch )
.head 6 -  Call SqlDisconnect( hSql )
.head 5 -  Return nCageID
.head 3 +  Function: Scale
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Window Handle: hWnd
.head 5 -  Number: nX
.head 5 -  Number: nY
.head 5 -  Number: nW
.head 5 -  Number: nH
.head 5 -  Number: nHCombo
.head 5 -  String: sFont
.head 5 -  Number: nFontSize
.head 5 -  Number: nEnch
.head 5 -  Number: nClientX
.head 5 -  Number: nClientY
.head 5 -  Number: nClientW
.head 5 -  Number: nClientH
.head 5 -  Number: nWindowType
.head 5 -  Window Handle: hLabel
.head 5 -  Number: nScaleFactor
.head 4 +  Actions
.head 5 -  Set nScaleFactor = GetOptionNumberUW("Dialogs", "Scale dialog", 1 )
.head 5 -  Set hWnd = SalGetFirstChild(hWndForm, TYPE_Any)
.head 5 +  While hWnd != hWndNULL
.head 6 -  Call SalGetWindowLoc(hWnd, nX, nY)
.head 6 -  Call SalGetWindowSize(hWnd, nW, nH)
.head 6 +  If SalGetType(hWnd) = TYPE_FormWindow
.head 7 -  Call SalSendMsg(hWnd, AM_Zoom, nScaleFactor, 0)
.head 6 +  Else
.head 7 +  If SalGetType(hWnd) = TYPE_ComboBox
.head 8 -  Set nHCombo = SalSendMsg(hWnd, 0x0154, -1, 0)
.head 7 -  Call SalFontGet(hWnd, sFont, nFontSize, nEnch)
.head 7 -  Set nX = nX * nScaleFactor
.head 7 -  Set nY = nY * nScaleFactor
.head 7 -  Set nW = nW * nScaleFactor
.head 7 -  Set nH = nH * nScaleFactor
.head 7 -  Call SalSetWindowLoc(hWnd, nX, nY)
.head 7 -  Call SalSetWindowSize(hWnd, nW, nH)
.head 7 +  If SalGetType(hWnd) = TYPE_ComboBox
.head 8 -  Call SalSendMsg(hWnd, 0x0153, -1, nHCombo * nScaleFactor)
.head 8 -  Set nH = SalPixelsToFormUnits(hWndForm, nHCombo * nScaleFactor, TRUE)
.head 7 -  Call SalFontSet(hWnd, sFont, nFontSize * nScaleFactor, nEnch)
.head 7 -  Set nWindowType = SalGetType(hWnd)
.head 7 +  If (nWindowType != TYPE_Line) and (nWindowType != TYPE_Frame) and (nWindowType != TYPE_BkgdText)
.head 8 -  Set hLabel = SalGetWindowLabel(hWnd)
.head 8 +  If hLabel != hWndNULL
.head 9 -  Call SalGetWindowLoc(hLabel, nClientX, nClientY)
.head 9 -  Call SalGetWindowSize(hLabel, nClientW, nClientH)
.head 9 -  Call SalSetWindowLoc(hLabel, nClientX, nY + (nH - nClientH) / 2)
.head 6 -  Set hWnd = SalGetNextChild(hWnd, TYPE_Any)
.head 6 -  ! Set hWnd = SalGetNextChild(hWnd, TYPE_ComboBox)
.head 5 -  Call SalGetWindowSize(hWndForm, nW, nH)
.head 5 -  Call SalSetWindowSize(hWndForm, nW* nScaleFactor + nClientW, nH * nScaleFactor )
.head 2 +  Window Parameters
.head 3 -  Number: nSrvID
.head 3 -  ! String: sSrvKey
.head 3 -  ! String: sSrvName
.head 3 -  String: sParam
.head 3 -  Boolean: bAuto
.head 2 +  Window Variables
.head 3 -  String: sSrvKey
.head 3 -  String: sSrvName
.head 3 -  String: sAbtSelect
.head 3 -  ! String: sAbt_Key_Tmp
.head 3 -  String: sAbtForUser
.head 3 -  String: sInnerScreen
.head 3 -  Number: nFall
.head 3 -  Number: nForSrv
.head 3 -  Boolean: bImmediately
.head 3 -  Boolean: bApplyToMice
.head 3 -  Sql Handle: hSQL_Temp
.head 3 -  Number: nFetch
.head 3 -  Number: nWait
.head 3 -  Number: nLstErfNrDone
.head 3 -  String: sGrpKeyStatic
.head 3 -  Number: nLstID
.head 3 -  Boolean: bApplyToPups
.head 3 -  FunctionalVar: oHL_Litter
.head 4 -  Class: cfHelpListData
.head 3 -  Number: nW
.head 3 -  Number: nH
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Set hWndDlgAddAlert = hWndForm
.head 4 -  Call SalGetWindowSize(hWndForm, nW, nH)
.head 4 -  Call SalSendClassMessage(SAM_Create, wParam, lParam)
.head 4 -  Call SalSetWindowSize(hWndForm, nW, nH)
.head 4 -  Set cbApplyParents = GalGetProfileBooleanX('Alerts','ApplyParents', FALSE, sUserINIFileName )
.head 4 -  Set bApplyToPups = FALSE
.head 4 -  Call PrepareFilter()
.head 4 -  Set dfSrvName = sSrvName
.head 4 -  Set dfSrvKey = sSrvKey
.head 4 +  If SalIsWindowVisible( hWndKHE )
.head 5 +  If hWndKHE.clsNewFE.GetLicenseFall()=0 or hWndKHE.clsNewFE.oHandleSelect.bAnySelects 
.head 6 -  Set cbApplyParents=TRUE
.head 6 -  Call cbApplyParents.Disable(  )
.head 5 +  If hWndKHE.clsNewExplorer.nSelectedLevel=FEL_Cage
.head 6 -  Call cbApplyParents.Show(  )
.head 5 +  Else
.head 6 -  Call cbApplyParents.Hide(  )
.head 4 +  If SalIsWindowVisible( hWndAnE )
.head 5 -  Call cbApplyParents.Hide(  )
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Call Scale()
.head 4 +  If sParam = STRING_Null
.head 5 -  Set dfDt = hWndKHE.clsNewExplorer.GetTime4Refresh(  )
.head 4 +  Else
.head 5 -  Set dfDt = hWndKHE.clsNewExplorer.GetTime4Refresh(  )+ SalStrToNumber( sParam )/24
.head 4 -  Call dfLitter.Hide(  )
.head 4 -  Call SalSetFocus( dlgAddAlert.cbDoneImmediately )
.head 4 +  If bAuto
.head 5 -  Call SalSendMsg( hWndForm, AM_Ok, 0, 0 )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndItem, FALSE )
.head 3 +  On AM_Ok
.head 4 +  If ApplyAlert()
.head 5 +  If not VisWinIsWindow( hWnd_MR4Lst ) 
.head 6 -  Call SalEndDialog( hWndItem, TRUE)
.head 5 +  Else
.head 6 -  Call SalHideWindow( hWndDlgAddAlert )
.head 3 +  On AM_Done
.head 4 -  Return SalSendMsg( dlgAddAlert, SAM_Close, 0, 0 )
.head 3 +  On SAM_Destroy
.head 4 -  Set hWndDlgAddAlert=hWndNULL
.head 4 -  Call SalPostMsg( frmAtlantaMain, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 4 +  If SalIsWindowVisible( hWndRack2DView )
.head 5 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrpKeyStatic ))
.head 4 +  If SalIsWindowEnabled( cbApplyParents )
.head 5 +  If cbApplyParents
.head 6 -  Set bApplyToMice = TRUE
.head 5 +  Else
.head 6 -  Set bApplyToMice = FALSE
.head 5 -  Call GalSetProfileBoolean( "Services",  "Apply to Mice",  bApplyToMice ,sUserINIFileName  )
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 1 +  ! clsSimpleDialogBox: dlgAddAlert
.winattr class Dialog Box:
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Add Service
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Display Style? Etched
.head 3 -  Visible at Design time? No
.head 3 -  Type of Dialog: Modal
.head 3 -  Allow Dock to Parent? No
.head 3 -  Docking Orientation: All
.head 3 -  Window Location and Size
.head 4 -  Left: 2.575"
.head 4 -  Top: 2.125"
.head 4 -  Width:  4.725"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 1.5"
.head 4 -  Height Editable? Yes
.head 3 -  Absolute Screen Location? Yes
.head 3 -  Font Name: Default
.head 3 -  Font Size: Default
.head 3 -  Font Enhancement: Default
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 3 -  Resizable? No
.head 3 -  Vertical Scroll? Yes
.head 3 -  Horizontal Scroll? Yes
.end
.head 2 -  Description: 
.head 2 +  Tool Bar 
.winattr
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: 0.35"
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? No
.head 4 -  Toolbar Docking Orientation: Top | Bottom
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? No
.end
.head 3 -  Contents 
.head 2 +  Contents 
.head 3 +  Pushbutton: pbOk
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.288"
.head 5 -  Top: 1.115"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Enter
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: OK.BMP
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Pushbutton: pbCancel
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 2.388"
.head 5 -  Top: 1.115"
.head 5 -  Width:  1.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.29"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Keyboard Accelerator: Esc
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Picture File Name: CANCEL.BMP
.head 4 -  Picture Transparent Color: Gray
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Button Appearance: Standard
.end
.head 4 -  Message Actions 
.head 3 +  Data Field: dfSrvKey
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: String
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.323"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.end
.head 4 -  Message Actions 
.head 3 +  Data Field: dfSrvName
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: String
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.888"
.head 6 -  Top: 0.323"
.head 6 -  Width:  3.7"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.end
.head 4 -  Message Actions 
.head 3 +  Data Field: dfDt
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 10
.head 5 -  Data Type: Date/Time
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 3.288"
.head 6 -  Top: 0.04"
.head 6 -  Width:  1.3"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: dd.MM.yyyy hhhh:mm:ss
.head 5 -  Country: United Kingdom
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: 99.99.9999 99:99
.end
.head 4 -  Message Actions 
.head 3 -  Background Text: Service Date:
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundText
.head 4 -  Window Location and Size
.head 5 -  Left: 2.288"
.head 5 -  Top: 0.094"
.head 5 -  Width:  0.9"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Justify: Right
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.end
.head 3 -  Background Text: Comment:
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsBackgroundTextRight
.head 4 -  Window Location and Size
.head 5 -  Left: 0.088"
.head 5 -  Top: 0.65"
.head 5 -  Width:  0.6"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Justify: Right
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.end
.head 3 +  Data Field: dfComment
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: String
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.688"
.head 6 -  Top: 0.6"
.head 6 -  Width:  3.9"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.end
.head 4 -  Message Actions 
.head 3 +  Check Box: cbApplyParents
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Apply to Mice
.head 4 -  Window Location and Size
.head 5 -  Left: 0.588"
.head 5 -  Top: 0.85"
.head 5 -  Width:  1.3"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.25"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.end
.head 4 -  Message Actions 
.head 3 +  Check Box: cbDoneImmediately
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsCheckBox
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Immediately "Done"
.head 4 -  Window Location and Size
.head 5 -  Left: 2.688"
.head 5 -  Top: 0.85"
.head 5 -  Width:  1.4"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.25"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: None
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.end
.head 4 -  Message Actions 
.head 3 +  Data Field: dfTarifKey
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldHelpedInput
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: String
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 3.688"
.head 6 -  Top: 1.073"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.end
.head 4 +  Message Actions 
.head 5 +  On SAM_Create
.head 6 -  Call Initialize( "", "select l.tarif_key,'' from leistung l, tarif t
	where l.tarif_key = :MyValue and l.einricht_id=:nEinrichtId and l.lst_key=:dlgAddAlert.sSrvKey 
	        and  t.einricht_id= l.einricht_id
	      and t.tarif_key=l.tarif_key
	      and t.canceled='N'	
       into :sProper", "
select l.tarif_key,'' from leistung l, tarif t
	where l.einricht_id=:nEinrichtId and l.lst_key=:dlgAddAlert.sSrvKey 
	        and  t.einricht_id= l.einricht_id
	      and t.tarif_key=l.tarif_key
	      and t.canceled='N'	
" )
.head 6 -  Set dfTarifKey.sHelpBoxTitle = 'Tarif '
.head 6 -  Return SalSendClassMessage( SAM_Create, wParam, lParam )
.head 2 +  Functions 
.head 3 +  ! Function: PrepareAlertMail
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 +  Parameters 
.head 5 -  Number: nFall
.head 5 -  String: sAbt
.head 5 -  String: sRack
.head 5 -  String: sCage
.head 5 -  Receive Sql Handle: hSql
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nFetch
.head 5 -  Number: nMesID
.head 5 -  Boolean: bResult
.head 5 -  String: sRec
.head 5 -  String: sRecBox
.head 5 -  String: sRecStr
.head 5 -  String: sRecBoxStr
.head 5 -  String: sSubject
.head 5 -  Long String: sBody
.head 5 -  String: sOldChair
.head 4 +  Actions 
.head 5 -  Set sLogicalChain='E-MAIL'
.head 5 -  Set sRecStr = ""
.head 5 -  Set sRecBoxStr = ""
.head 5 +  If SqlPrepareAndExecute(hSql, "select a.name1, a.email
from fall_experiment e, exp_zus_adresse ea, adresse a
where 
e.fall_key = :nFall
and e.einricht_id = :nEinrichtId
and e.experiment_key = ea.experiment_key
and e.einricht_id = ea.einricht_id
and ea.adresse_id = a.adresse_id
and ea.takealerts = 1
and a.email is not null into :sRec, :sRecBox")
.head 6 +  While SqlFetchNext(hSql, nFetch)
.head 7 -  Set sRecStr = sRecStr||sRec||","
.head 7 -  Set sRecBoxStr = sRecBoxStr||sRecBox||","
.head 6 -  Call SqlPrepareAndExecute(hSql, "select email from abteilung where abt_key = :sAbt into :sRec")
.head 6 +  If SqlFetchNext(hSql, nFetch)
.head 7 -  Set sRecStr = ","||sRecStr
.head 7 -  Set sRecBoxStr = sRec||","||sRecBoxStr
.head 6 +  If sRecBoxStr
.head 7 -  Set sRecStr = SalStrLeftX(sRecStr, SalStrLength(sRecStr)-1)
.head 7 -  Set sRecBoxStr = SalStrLeftX(sRecBoxStr, SalStrLength(sRecBoxStr)-1)
.head 7 -  ! Call SqlPrepareAndExecute(hSql, "select max(id)+1 from email into :nMesID")
.head 7 -  ! Call SqlFetchNext(hSql, nFetch)
.head 7 -  Set nMesID=SalStrToNumber(GetNewKey( "EMAIL", "ID" ) )
.head 7 -  Set sLogicalChain=sOldChair
.head 7 +  If nMesID = NUMBER_Null 
.head 8 -  Set nMesID = 0
.head 7 -  Call SqlPrepareAndExecute(hSql, "select benutzer_name from benutzer where benutzer_id = :nUserId into :sRec")
.head 7 -  Call SqlFetchNext(hSql, nFetch)
.head 7 -  Set sSubject = dfSrvKey||" ALERT is setted for Fall "||SalNumberToStrX(nFall, 0)
.head 7 -  Call SalDateToStr(dfDt, sRecBox)
.head 7 -  Set sBody = dfSrvKey||" ("||dfSrvName||")
Screen: "||sAbt||"
Rack: "||sRack||"
Cage: "||sCage||"
Raised by "||sRec||" at "||sRecBox||"
With comment: "||dfComment
.head 7 +  If SqlPrepareAndExecute(hSql, "insert into email values (:nMesID, :sRecStr, :sRecBoxStr, :sSubject, :sBody, :nUserId, :dfDt, 0,0)")
.head 8 -  Set bResult = TRUE
.head 5 -  Return bResult
.head 3 +  ! Function: ApplyAlert
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nFalls[*]
.head 5 -  Number: nFall
.head 5 -  Sql Handle: hSql
.head 5 -  Sql Handle: hSqlMax
.head 5 -  Sql Handle: hSqlSample
.head 5 -  String: sLA_KEY
.head 5 -  String: sTARIF_KEY
.head 5 -  Number: nMax
.head 5 -  Boolean: bOk
.head 5 -  Number: nTmp
.head 5 -  String: sAbtKey
.head 5 -  String: sStatKey
.head 5 -  String: sGrpKey
.head 5 -  String: sBettKey
.head 5 -  String: sGrpKeyStatic
.head 5 -  Number: nCount
.head 5 -  Number: nAlertNeedMail
.head 5 -  Boolean: bAnyMail
.head 5 -  Number: nBound
.head 5 -  Number: nI
.head 5 -  Number: nNeedsSample
.head 5 -  Number: nSampleID
.head 5 -  String: sSQL
.head 4 +  Actions 
.head 5 -  Set bOk = FALSE
.head 5 -  Set bAnyMail = FALSE
.head 5 +  If GalConnect(hSql) and GalConnect(hSqlMax) and GalConnect(hSqlSample)
.head 6 +  If SqlPrepareAndExecute(hSql,"select LA_KEY, TARIF_KEY, @NULLVALUE(notify_email,0), @NULLVALUE(needs_med_sample,0) from LEISTUNG where LST_KEY = :sSrvKey into :sLA_KEY, :sTARIF_KEY, :nAlertNeedMail, :nNeedsSample")
.head 7 -  Call SqlFetchNext(hSql, nTmp)
.head 6 -  Call SqlPrepare(hSqlMax, "select @NULLVALUE(MAX(LST_ERF_NR),0)+1 from LST_ERF where Einricht_ID = :nEinrichtId and Fall_Key = :nFall into :nMax")
.head 6 -  Call SqlPrepare(hSqlSample, "Insert into MED_SAMPLE(Einricht_id, Med_Sample_ID ) values (:nEinrichtId, :nSampleID )")
.head 6 -  Set sSQL = "insert into LST_ERF(LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR,
			         LST_ERF_VON, STORNIERT,IND_BEGR, GRUPPE_KEY,STAT_KEY, BENUTZER_ID, DONE, LST_ERF_BIS, ERF_DATUM"
.head 6 +  If nNeedsSample
.head 7 -  Set sSQL = sSQL||", med_sample_id"
.head 6 -  Set sSQL = sSQL||")
values (:sLA_KEY, :sTARIF_KEY, :sSrvKey, :nFall, 'N', :nEinrichtId, :nMax, :dlgAddAlert.dfDt, 'N', :dlgAddAlert.dfComment, :sGrpKey, :sStatKey, :nUserId, :dlgAddAlert.cbDoneImmediately,"
.head 6 +  If dlgAddAlert.cbDoneImmediately
.head 7 -  Set sSQL = sSQL||":dlgAddAlert.dfDt"
.head 6 +  Else 
.head 7 -  Set sSQL = sSQL||"''"
.head 6 -  Set sSQL = sSQL||",:dlgAddAlert.dfDt"
.head 6 +  If nNeedsSample
.head 7 -  Set sSQL = sSQL||",:nSampleID"
.head 6 -  Set sSQL = sSQL||")"
.head 6 -  Call SqlPrepare(hSql, sSQL)
.head 6 -  Call SalArrayGetUpperBound (HandleToPlace, 1, nBound )
.head 6 +  If nBound <=0
.head 7 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(hWndKHE.clsKHExplorerLeft.nSelectedHandle, sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 7 +  If hWndKHE.clsKHExplorerLeft.nSelectedLevel=KHEL_Bett
.head 8 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 8 -  Set sGrpKey=""
.head 8 +  If SqlExecute(hSqlMax)
.head 9 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 9 +  If nNeedsSample
.head 10 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 10 -  Call SqlExecute(hSqlSample)
.head 9 +  If SqlExecute(hSql)
.head 10 -  Set bOk = TRUE
.head 10 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 11 -  ! try to prepare message
.head 11 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 7 +  Else 
.head 8 +  If cbApplyParents
.head 9 -  Set nCount = hWndKHE.clsExplorerLeft.EnumChildren( hWndKHE.clsExplorerLeft.nSelectedHandle, nFalls )
.head 9 +  While nCount>0
.head 10 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetFallKey_ByHandle(nFalls[nCount-1])
.head 10 +  If nFall
.head 11 -  Set bOk = FALSE
.head 11 +  If SqlExecute(hSqlMax)
.head 12 +  If SqlFetchNext(hSqlMax, nTmp)
.head 13 +  If nNeedsSample
.head 14 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 14 -  Call SqlExecute(hSqlSample)
.head 13 +  If SqlExecute(hSql)
.head 14 -  Set bOk = TRUE
.head 14 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 15 -  ! try to preparemessage
.head 15 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 10 -  Set nCount = nCount-1
.head 8 +  Else 
.head 9 -  Set sGrpKey = sGrpKeyStatic
.head 9 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 9 +  If SqlExecute(hSqlMax)
.head 10 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 10 +  If nNeedsSample
.head 11 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 11 -  Call SqlExecute(hSqlSample)
.head 10 +  If SqlExecute(hSql)
.head 11 -  Set bOk = TRUE
.head 11 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 12 -  ! try to preparemessage
.head 12 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 6 +  Else 
.head 7 -  Set nI = 0
.head 7 +  While nI<= nBound
.head 8 -  Set nFall = HandleToPlace[nI,0]
.head 8 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(HandleToPlace[nI,1], sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 8 +  If nFall
.head 9 -  Set bOk = FALSE
.head 9 +  If SqlExecute(hSqlMax)
.head 10 +  If SqlFetchNext(hSqlMax, nTmp)
.head 11 +  If nNeedsSample
.head 12 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 12 -  Call SqlExecute(hSqlSample)
.head 11 +  If SqlExecute(hSql)
.head 12 -  Set bOk = TRUE
.head 12 -  Call hWndKHE.clsKHExplorerLeft.PopulateAndExpand(HandleToPlace[nI,1], TRUE)
.head 12 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 13 -  ! try to preparemessage
.head 13 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 8 -  Set nI=nI+1
.head 6 +  If bOk !***********************
.head 7 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 7 +  If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrpKeyStatic ))
.head 6 +  Else 
.head 7 -  Call SqlPrepareAndExecute(hSql, "rollback")
.head 6 -  Call SqlDisconnect(hSql)
.head 6 -  Call SqlDisconnect(hSqlMax)
.head 6 -  Call SqlDisconnect(hSqlSample)
.head 3 +  ! Function: ApplyAlert2
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nFalls[*]
.head 5 -  Number: nFall
.head 5 -  Sql Handle: hSql
.head 5 -  Sql Handle: hSqlMax
.head 5 -  Sql Handle: hSqlSample
.head 5 -  Sql Handle: hSqlFilter
.head 5 -  String: sLA_KEY
.head 5 -  String: sTARIF_KEY
.head 5 -  Number: nMax
.head 5 -  Boolean: bOk
.head 5 -  Number: nTmp
.head 5 -  String: sAbtKey
.head 5 -  String: sStatKey
.head 5 -  String: sGrpKey
.head 5 -  String: sBettKey
.head 5 -  String: sGrpKeyStatic
.head 5 -  Number: nCount
.head 5 -  Number: nAlertNeedMail
.head 5 -  Boolean: bAnyMail
.head 5 -  Number: nBound
.head 5 -  Number: nI
.head 5 -  Number: nNeedsSample
.head 5 -  Number: nNeedsConfirm
.head 5 -  Number: nSampleID
.head 5 -  String: sSQL
.head 4 +  Actions 
.head 5 -  Set bOk = FALSE
.head 5 -  Set bAnyMail = FALSE
.head 5 +  If GalConnect(hSql) and GalConnect(hSqlMax) and GalConnect(hSqlSample) and GalConnect(hSqlFilter)
.head 6 +  If SqlPrepareAndExecute(hSql,"select LA_KEY, TARIF_KEY, @NULLVALUE(notify_email,0), @NULLVALUE(needs_med_sample,0), @NULLVALUE(NEEDS_CONFIRM,0) from LEISTUNG where LST_KEY = :sSrvKey into :sLA_KEY, :sTARIF_KEY, 
:nAlertNeedMail, :nNeedsSample, :nNeedsConfirm")
.head 7 -  Call SqlFetchNext(hSql, nTmp)
.head 6 -  Call SqlPrepare(hSqlMax, "select @NULLVALUE(MAX(LST_ERF_NR),0)+1 from LST_ERF where Einricht_ID = :nEinrichtId and Fall_Key = :nFall into :nMax")
.head 6 -  Call SqlPrepare(hSqlSample, "Insert into MED_SAMPLE(Einricht_id, Med_Sample_ID ) values (:nEinrichtId, :nSampleID )")
.head 6 -  Call SqlPrepare(hSqlFilter, "select l.lst_key
  				from  leistung l, fall f, geschlecht g, srv_limit s
				      where l.lst_key=:sSrvKey
        					  and	f.EINRICHT_ID = :nEinrichtId
 					  and	f.FALL_KEY = :nFall
					  and g.geschl_key=f.geschl
                                                                                  and (l.SRV_LMT_ID is null 
                                                                                       or l.SRV_LMT_ID=0 
                                                                                        or (l.SRV_LMT_ID>0 and s.id=l.SRV_LMT_ID and g.geschl_abr=s.abr)) 
                                           
group by 1 ")
.head 6 -  Set sSQL = "insert into LST_ERF(LA_KEY, TARIF_KEY, LST_KEY, FALL_KEY, STATISTIK, EINRICHT_ID,LST_ERF_NR,
			         LST_ERF_VON, STORNIERT,IND_BEGR, GRUPPE_KEY,STAT_KEY, BENUTZER_ID, DONE, LST_ERF_BIS, ERF_DATUM"
.head 6 +  If nNeedsSample
.head 7 -  Set sSQL = sSQL||", med_sample_id"
.head 6 -  Set sSQL = sSQL||")
values (:sLA_KEY, :sTARIF_KEY, :sSrvKey, :nFall, 'N', :nEinrichtId, :nMax, :dlgAddAlert.dfDt, 'N', :dlgAddAlert.dfComment, :sGrpKey, :sStatKey, :nUserId, :dlgAddAlert.cbDoneImmediately,"
.head 6 +  If dlgAddAlert.cbDoneImmediately
.head 7 -  Set sSQL = sSQL||":dlgAddAlert.dfDt"
.head 6 +  Else 
.head 7 -  Set sSQL = sSQL||"''"
.head 6 -  Set sSQL = sSQL||",:dlgAddAlert.dfDt"
.head 6 +  If nNeedsSample
.head 7 -  Set sSQL = sSQL||",:nSampleID"
.head 6 -  Set sSQL = sSQL||")"
.head 6 -  Call SqlPrepare(hSql, sSQL)
.head 6 -  Call SalArrayGetUpperBound (HandleToPlace, 1, nBound )
.head 6 +  If nBound <=0
.head 7 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(hWndKHE.clsKHExplorerLeft.nSelectedHandle, sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 7 +  If hWndKHE.clsKHExplorerLeft.nSelectedLevel=KHEL_Bett
.head 8 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 8 -  Set sGrpKey=""
.head 8 +  If SqlExecute(hSqlMax)
.head 9 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 9 +  If nNeedsSample
.head 10 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 10 -  Call SqlExecute(hSqlSample)
.head 9 +  If SqlExecute(hSql)
.head 10 -  Set bOk = TRUE
.head 10 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 11 -  ! try to prepare message
.head 11 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 7 +  Else 
.head 8 +  If cbApplyParents
.head 9 -  Set nCount = hWndKHE.clsExplorerLeft.EnumChildren( hWndKHE.clsExplorerLeft.nSelectedHandle, nFalls )
.head 9 -  Set bOk = FALSE
.head 9 +  While nCount>0
.head 10 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetFallKey_ByHandle(nFalls[nCount-1])
.head 10 +  If nFall
.head 11 +  If SqlExecute(hSqlMax) and (SqlExecute(hSqlFilter) and SqlFetchNext(hSqlFilter,nTmp))
.head 12 +  If SqlFetchNext(hSqlMax, nTmp)
.head 13 +  If nNeedsSample
.head 14 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 14 -  Call SqlExecute(hSqlSample)
.head 13 +  If SqlExecute(hSql)
.head 14 -  Set bOk = TRUE
.head 14 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 15 -  ! try to preparemessage
.head 15 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 10 -  Set nCount = nCount-1
.head 8 +  Else 
.head 9 -  Set sGrpKey = sGrpKeyStatic
.head 9 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 9 +  If SqlExecute(hSqlMax)
.head 10 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 10 +  If nNeedsSample
.head 11 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 11 -  Call SqlExecute(hSqlSample)
.head 10 +  If SqlExecute(hSql)
.head 11 -  Set bOk = TRUE
.head 11 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 12 -  ! try to preparemessage
.head 12 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 6 +  Else 
.head 7 -  Set nI = 0
.head 7 +  While nI<= nBound
.head 8 -  Set nFall = HandleToPlace[nI,0]
.head 8 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(HandleToPlace[nI,1], sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 8 +  If nFall
.head 9 -  Set bOk = FALSE
.head 9 +  If SqlExecute(hSqlMax)
.head 10 +  If SqlFetchNext(hSqlMax, nTmp)
.head 11 +  If nNeedsSample
.head 12 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 12 -  Call SqlExecute(hSqlSample)
.head 11 +  If SqlExecute(hSql)
.head 12 -  Set bOk = TRUE
.head 12 -  Call hWndKHE.clsKHExplorerLeft.PopulateAndExpand(HandleToPlace[nI,1], TRUE)
.head 12 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 13 -  ! try to preparemessage
.head 13 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 8 -  Set nI=nI+1
.head 6 +  If bOk !***********************
.head 7 -  Call SqlPrepareAndExecute(hSql, "commit")
.head 7 +  If SalIsWindowVisible( hWndRack2DView )
.head 8 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrpKeyStatic ))
.head 6 +  Else 
.head 7 -  Call SqlPrepareAndExecute(hSql, "rollback")
.head 6 -  Call SqlDisconnect(hSql)
.head 6 -  Call SqlDisconnect(hSqlMax)
.head 6 -  Call SqlDisconnect(hSqlSample)
.head 6 -  Call SqlDisconnect(hSqlFilter)
.head 3 +  Function: PrepareFilter
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSqlBase
.head 5 -  String: sName
.head 5 -  Number: nFetch
.head 4 +  Actions 
.head 5 +  If not GalConnect( hSqlBase )
.head 6 -  Return FALSE
.head 5 -  ! Call SqlPrepareAndExecute(hSqlBase , "select ml.name,l.SRV_LMT_ID
  				from mlhalerts ml, leistung l
				      where ml.Origin=:sSrvKey
        					  and ml.ORIGINTABLE='LEISTUNG'
					  and l.lst_key=ml.ORIGIN
  					 into :sName, :nForSrv")
.head 5 -  Call SqlPrepareAndExecute(hSqlBase , "select ml.name, l.SRV_LMT_ID, l.ID
  				from sysadm.mlhalerts_view ml, leistung l
				      where ml.name=:sSrvKey
        					    and l.id=ml.id
  					 into :sName, :nForSrv , :nLstID")
.head 5 +  If SqlFetchNext(hSqlBase,nFetch)
.head 6 +  If hWndKHE.clsKHExplorerLeft.nSelectedLevel = KHEL_Gruppe
.head 7 +  If nForSrv = 1 or nForSrv=2 or nForSrv=4
.head 8 -  Set cbApplyParents=TRUE
.head 8 -  Call cbApplyParents.Disable(  )
.head 7 +  Else If nForSrv=3
.head 8 -  Set cbApplyParents=FALSE
.head 8 -  Call cbApplyParents.Disable(  )
.head 7 +  Else 
.head 8 -  ! Set cbApplyParents=FALSE
.head 8 -  Call cbApplyParents.Enable(  )
.head 5 -  Call SqlDisconnect( hSqlBase )
.head 3 +  Function: ApplyAlert
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: hSqlFilter
.head 5 -  Boolean: bOk
.head 5 -  Boolean: bAnyMail
.head 5 -  String: sAbtKey
.head 5 -  String: sStatKey
.head 5 -  String: sGrpKey
.head 5 -  String: sBettKey
.head 5 -  Number: nFalls[*]
.head 5 -  ! Number: nFallLoc
.head 5 -  Number: nCount
.head 5 -  Number: nI
.head 5 -  Number: nBound
.head 5 -  Number: nDone
.head 4 +  Actions 
.head 5 -  Set bOk = TRUE
.head 5 -  Set bAnyMail = FALSE
.head 5 +  If GalConnect(hSqlFilter)
.head 6 -  ! Call SqlPrepare(hSqlFilter, "select l.lst_key
  				from  leistung l, fall f, geschlecht g, srv_limit s
				      where l.lst_key=:sSrvKey
        					  and	f.EINRICHT_ID = :nEinrichtId
 					  and	f.FALL_KEY = :nFall
					  and g.geschl_key=f.geschl
                                                                                 and ( @nullvalue(l.SRV_LMT_ID,0)=0
				    	
                                     or ( l.SRV_LMT_ID=4 and f.VIS_KAT_KEY != 'V')	
                                     or (l.SRV_LMT_ID>0 and s.id=l.SRV_LMT_ID and g.geschl_abr=s.abr)) 
                                           
group by 1 ")
.head 6 -  Call SqlPrepare(hSqlFilter, "select l.lst_key
  				from  leistung l, fall f, geschlecht g, srv_limit s
				      where l.lst_key=:sSrvKey
        					  and	f.EINRICHT_ID = :nEinrichtId
 					  and	f.FALL_KEY = :nFall
					  and g.geschl_key=f.geschl
                                                                                 and ( @nullvalue(l.SRV_LMT_ID,0)=0
				    	
                                     or ( l.SRV_LMT_ID=4 and f.VIS_KAT_KEY != 'V')	
                                     or (l.SRV_LMT_ID>0 and s.id=l.SRV_LMT_ID and g.geschl_abr=s.abr)) 
                                           
group by 1 ")
.head 6 -  Call SalArrayGetUpperBound (HandleToPlace, 1, nBound )
.head 6 +  If nBound <=0
.head 7 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(hWndKHE.clsKHExplorerLeft.nSelectedHandle, sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 7 +  If hWndKHE.clsKHExplorerLeft.nSelectedLevel=KHEL_Bett
.head 8 -  ! Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 8 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetFallKey_ByHandle(hWndKHE.clsKHExplorerLeft.nSelectedHandle)
.head 8 -  Set sGrpKey=""
.head 8 -  ! Set bOk = bOk and InsertService( sSrvKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.cbDoneImmediately, TRUE )
.head 8 -  Set nDone = InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment , sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE )
.head 8 +  If nDone = 1
.head 9 -  Set bOk = TRUE
.head 8 +  Else If nDone = 0
.head 9 -  Set bOk = FALSE
.head 8 +  ! Else If nDone = WAIT_WEANWIDGET
.head 9 -  Set nWait = nDone
.head 9 -  Call WaitOnOff( TRUE )
.head 9 -  Call SalHideWindow( dlgAddAlert )
.head 9 -  Set bOk = FALSE
.head 8 +  ! Else If nDone = WAIT_LITTERWIDGET
.head 9 -  Call WaitOnOff( TRUE )
.head 9 -  Call OpenService( nFall, nLstErfNrDone, TRUE )
.head 9 -  Set bOk = TRUE
.head 8 -  ! Set bOk = bOk and InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment , sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE )
.head 7 +  Else 
.head 8 +  If cbApplyParents
.head 9 -  Set nCount = hWndKHE.clsExplorerLeft.EnumChildren( hWndKHE.clsExplorerLeft.nSelectedHandle, nFalls )
.head 9 +  While nCount>0
.head 10 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetFallKey_ByHandle(nFalls[nCount-1])
.head 10 +  If nFall
.head 11 +  If (SqlExecute(hSqlFilter) and SqlFetchNext(hSqlFilter,nTmp))
.head 12 +  ! If SqlFetchNext(hSqlMax, nTmp)
.head 13 +  If nNeedsSample
.head 14 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 14 -  Call SqlExecute(hSqlSample)
.head 13 +  If SqlExecute(hSql)
.head 14 -  Set bOk = TRUE
.head 14 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 15 -  ! try to preparemessage
.head 15 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 12 -  ! Set bOk = bOk and InsertService( sSrvKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.cbDoneImmediately, TRUE  )
.head 12 -  ! Set bOk = bOk and InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment , sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE )
.head 12 -  Set nDone = InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment , sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE )
.head 12 +  If nDone = 1
.head 13 -  Set bOk = TRUE
.head 12 +  Else If nDone = 0
.head 13 -  Set bOk = FALSE
.head 12 +  ! Else If nDone = WAIT_WEANWIDGET
.head 13 -  Set nWait = nDone
.head 13 -  Call WaitOnOff( TRUE )
.head 13 -  Call SalHideWindow( dlgAddAlert )
.head 13 -  Set bOk = FALSE
.head 10 -  Set nCount = nCount-1
.head 8 +  Else 
.head 9 -  Set sGrpKey = sGrpKeyStatic
.head 9 -  Set nFall = hWndKHE.clsKHExplorerLeft.GetLicenseFall()
.head 9 +  ! If SqlExecute(hSqlMax)
.head 10 -  Call SqlFetchNext(hSqlMax, nTmp)
.head 10 +  If nNeedsSample
.head 11 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 11 -  Call SqlExecute(hSqlSample)
.head 10 +  If SqlExecute(hSql)
.head 11 -  Set bOk = TRUE
.head 11 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 12 -  ! try to preparemessage
.head 12 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql)
.head 9 -  ! Set bOk = bOk and InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment, sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE  )
.head 9 -  Set nDone = InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment , sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE )
.head 9 +  If nDone = 1
.head 10 -  Set bOk = TRUE
.head 9 +  Else If nDone = 0
.head 10 -  Set bOk = FALSE
.head 9 +  ! Else If nDone = WAIT_WEANWIDGET
.head 10 -  Set nWait = nDone
.head 10 -  Call WaitOnOff( TRUE )
.head 10 -  Call SalHideWindow( dlgAddAlert )
.head 10 -  Set bOk = FALSE
.head 6 +  Else 
.head 7 -  Set nI = 0
.head 7 +  While nI<= nBound
.head 8 -  Set nFall = HandleToPlace[nI,0]
.head 8 -  Call hWndKHE.clsKHExplorerLeft.GetPosition(HandleToPlace[nI,1], sAbtKey, sStatKey, sGrpKeyStatic, sBettKey )
.head 8 +  If nFall
.head 9 +  ! If SqlExecute(hSqlMax)
.head 10 +  If SqlFetchNext(hSqlMax, nTmp)
.head 11 +  If nNeedsSample
.head 12 -  Call MedSample_GetNewID(nSampleID, FALSE)
.head 12 -  Call SqlExecute(hSqlSample)
.head 11 +  If SqlExecute(hSql)
.head 12 -  Set bOk = TRUE
.head 12 -  Call hWndKHE.clsKHExplorerLeft.PopulateAndExpand(HandleToPlace[nI,1], TRUE)
.head 12 +  If hWndKHE.clsKHExplorerLeft.bUseEmail and nAlertNeedMail
.head 13 -  ! try to preparemessage
.head 13 -  Set bAnyMail = PrepareAlertMail(nFall, sAbtKey, sStatKey, sGrpKeyStatic, hSql) or bAnyMail
.head 9 +  If (SqlExecute(hSqlFilter) and SqlFetchNext(hSqlFilter,nTmp))
.head 10 -  ! Set bOk = bOk and InsertService( sSrvKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.cbDoneImmediately, TRUE  )
.head 10 -  Set nDone = InsertService( sSrvKey, sSrvName,dfTarifKey, nFall, dlgAddAlert.dfDt, dlgAddAlert.dfComment , sAbtKey, sStatKey, sGrpKeyStatic, dlgAddAlert.cbDoneImmediately, TRUE )
.head 10 +  If nDone = 1
.head 11 -  Set bOk = TRUE
.head 10 +  Else If nDone = 0
.head 11 -  Set bOk = FALSE
.head 10 +  ! Else If nDone = WAIT_WEANWIDGET
.head 11 -  Set nWait = nDone
.head 11 -  Call WaitOnOff( TRUE )
.head 11 -  Call SalHideWindow( dlgAddAlert )
.head 11 -  Set bOk = FALSE
.head 10 +  ! Else If nDone = WAIT_LITTERWIDGET
.head 11 -  Call WaitOnOff( TRUE )
.head 11 -  Call OpenService( nFall, nLstErfNrDone, TRUE )
.head 11 -  Set bOk = TRUE
.head 10 +  If bOk
.head 11 -  Call hWndKHE.clsKHExplorerLeft.PopulateAndExpand(HandleToPlace[nI,1], TRUE)
.head 8 -  Set nI=nI+1
.head 6 +  ! If SalIsWindowVisible( hWndRack2DView )
.head 7 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrpKeyStatic ))
.head 6 +  If dlgAddAlert.cbDoneImmediately and VisWinIsWindow( hWnd_MR4Lst ) 
.head 7 -  Call SalSendMsg( hWnd_MR4Lst, AM_Control, 0, 0 )
.head 6 -  Call SqlDisconnect(hSqlFilter)
.head 6 -  Return bOk
.head 3 +  Function: GetAutoDone
.head 4 -  Description: 
.head 4 +  Returns 
.head 5 -  Boolean: 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Boolean: bExists
.head 5 -  Boolean: bDone
.head 4 +  Actions 
.head 5 -  Call SqlExists( "select autodoneservice from leistung 
		where lst_key=:dlgAddAlert.sSrvKey
		    and einricht_id=:nEinrichtId 
		    and tarif_key=:dlgAddAlert.dfTarifKey
                                into :bDone ", bExists  )
.head 5 -  Return bDone
.head 3 +  ! Function: WaitOnOff
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 +  Parameters 
.head 5 -  Boolean: bWait
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Sql Handle: h_Sql
.head 5 -  Number: nFetch
.head 4 +  Actions 
.head 5 +  If GalConnect( h_Sql )
.head 6 +  If bWait
.head 7 -  Call SqlPrepareAndExecute( h_Sql, "select max(LST_ERF_NR) from lst_erf
			             where einricht_id = :nEinrichtId
      				and fall_key=:nFall
      				and lst_key=:dlgAddAlert.sSrvKey
into :nLstErfNrDone
" )
.head 7 -  Call SqlFetchNext( h_Sql, nFetch )
.head 6 +  Else 
.head 7 -  Set dfDt = hWndKHE.clsKHExplorerLeft.GetTime4Refresh(  )
.head 7 +  If SqlPrepareAndExecute( h_Sql, "select l.lst_key
  				from  leistung l, fall f, geschlecht g, srv_limit s
				      where l.lst_key=:sSrvKey
        					  and	f.EINRICHT_ID = :nEinrichtId
 					  and	f.FALL_KEY = :nFall
					  and g.geschl_key=f.geschl
                                                                                 and ( @nullvalue(l.SRV_LMT_ID,0)=0
				    	
                                     or ( l.SRV_LMT_ID=4 and f.VIS_KAT_KEY != 'V')	
                                     or (l.SRV_LMT_ID>0 and s.id=l.SRV_LMT_ID and g.geschl_abr=s.abr)) 
                                           
group by 1
" ) and SqlFetchNext( h_Sql, nFetch )
.head 8 -  Call DoneServiceWithoutCheck( sSrvKey, nFall, nLstErfNrDone, dfDt, TRUE )
.head 6 -  Call SqlDisconnect( h_Sql )
.head 2 +  Window Parameters 
.head 3 -  String: sSrvKey
.head 3 -  String: sSrvName
.head 3 -  String: sParam
.head 3 -  Boolean: bAuto
.head 2 +  Window Variables 
.head 3 -  String: sAbtSelect
.head 3 -  ! String: sAbt_Key_Tmp
.head 3 -  String: sAbtForUser
.head 3 -  String: sInnerScreen
.head 3 -  Number: nFall
.head 3 -  Number: nForSrv
.head 3 -  Boolean: bImmediately
.head 3 -  Boolean: bApplyToMice
.head 3 -  Sql Handle: hSQL_Temp
.head 3 -  Number: nFetch
.head 3 -  Number: nWait
.head 3 -  Number: nLstErfNrDone
.head 3 -  String: sGrpKeyStatic
.head 3 -  Number: nLstID
.head 2 +  Message Actions 
.head 3 +  On SAM_Create
.head 4 -  Set hWndDlgAddAlert = hWndForm
.head 4 -  Call SalSendClassMessage(SAM_Create, 0, 0)
.head 4 -  Set dfSrvName = sSrvName
.head 4 -  Set dfSrvKey = sSrvKey
.head 4 +  If sParam = STRING_Null
.head 5 -  ! Set dfDt = SalDateCurrent()
.head 5 -  Set dfDt = hWndKHE.clsKHExplorerLeft.GetTime4Refresh(  )
.head 4 +  Else 
.head 5 -  Set dfDt = hWndKHE.clsKHExplorerLeft.GetTime4Refresh(  )+ SalStrToNumber( sParam )/24
.head 4 -  Set cbApplyParents = GalGetProfileBooleanX('Alerts','ApplyParents', FALSE, sUserINIFileName )
.head 4 -  ! Set cbDoneImmediately = GalGetProfileBooleanX('Alerts','DoneImmediately', FALSE, sUserINIFileName )
.head 4 -  ! Call SalSetFocus(dfComment)
.head 4 -  Call PrepareFilter()
.head 4 +  If hWndKHE.clsKHExplorerLeft.GetLicenseFall()=0
.head 5 -  Set cbApplyParents=TRUE
.head 5 -  Call cbApplyParents.Disable(  )
.head 4 +  If hWndKHE.clsKHExplorerLeft.nSelectedLevel=KHEL_Gruppe
.head 5 -  Call cbApplyParents.Show(  )
.head 4 +  Else 
.head 5 -  Call cbApplyParents.Hide(  )
.head 4 -  ! Call GalGetProfileBoolean( "Services" , "Immediately Done", FALSE, bImmediately , sUserINIFileName  )
.head 4 +  ! If SalIsWindowEnabled( cbApplyParents )
.head 5 -  ! Call GalGetProfileBoolean( "Services" , "Apply to Mice", FALSE, bApplyToMice , sUserINIFileName  )
.head 5 -  ! Set cbApplyParents = bApplyToMice
.head 5 -  Call SqlExists( "select MICE from leistung 
		where lst_key=:dlgAddAlert.sSrvKey
		    and einricht_id=:nEinrichtId 
		    and tarif_key=:dlgAddAlert.dfTarifKey
                                into :dlgAddAlert.cbApplyParents ", bApplyToMice )
.head 4 -  ! If bImmediately
.head 4 -  ! Set bImmediately = TRUE
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendMsg( dfTarifKey, WM_LBUTTONDBLCLK,0,0 )
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Call GalConnect( hSQL_Temp )
.head 4 -  Call SqlPrepareAndExecute( hSQL_Temp, "
select  Immediately_Done from leistung 
		where lst_key=:dlgAddAlert.sSrvKey
		    and einricht_id=:nEinrichtId 
		    and tarif_key=:dlgAddAlert.dfTarifKey
                                into :dlgAddAlert.cbDoneImmediately 
" )
.head 4 -  Call SqlFetchNext( hSQL_Temp, nFetch )
.head 4 -  Call SqlDisconnect( hSQL_Temp )
.head 4 +  ! If SalIsWindowEnabled( cbApplyParents )
.head 5 -  Call GalGetProfileBoolean( "Services" , "Apply to Mice", FALSE, bApplyToMice , sUserINIFileName  )
.head 5 -  Set cbApplyParents = bApplyToMice
.head 4 +  ! Else
.head 5 -  Set cbApplyParents = FALSE
.head 4 +  ! If not SalIsWindowEnabled( cbApplyParents )
.head 5 -  ! Call SqlExists( "select MICE from leistung 
		where lst_key=:dlgAddAlert.sSrvKey
		    and einricht_id=:nEinrichtId 
		    and tarif_key=:dlgAddAlert.dfTarifKey
                                into :dlgAddAlert.cbApplyParents ", bApplyToMice )
.head 5 -  Set cbApplyParents = 0
.head 4 -  ! Set cbDoneImmediately = GetAutoDone(  )
.head 4 -  Call SalSetFocus( dlgAddAlert.cbDoneImmediately )
.head 4 +  If bAuto
.head 5 -  Call SalSendMsg( hWndForm, AM_Ok, 0, 0 )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndItem, FALSE )
.head 3 +  On AM_Ok
.head 4 -  ! Set sComment = dfComment
.head 4 -  ! If CheckAlert(  )
.head 4 +  If ApplyAlert()
.head 5 -  ! Call SalPostMsg( frmAtlantaMain, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 5 +  If not VisWinIsWindow( hWnd_MR4Lst ) 
.head 6 -  Call SalEndDialog( hWndItem, TRUE)
.head 5 +  Else 
.head 6 -  Call SalHideWindow( hWndDlgAddAlert )
.head 4 +  ! Else
.head 5 -  Call SalMessageBox( "Services which are an intervention can only be perfomed under a license!", "Warning!", 0 )
.head 3 +  On AM_Done
.head 4 -  Return SalSendMsg( dlgAddAlert, SAM_Close, 0, 0 )
.head 3 +  On SAM_Destroy
.head 4 -  Set hWndDlgAddAlert=hWndNULL
.head 4 -  Call SalPostMsg( frmAtlantaMain, AM_KHE_ForcedPopulateCurrent, 0, 0 )
.head 4 +  If SalIsWindowVisible( hWndRack2DView )
.head 5 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrpKeyStatic ))
.head 4 +  ! If cbDoneImmediately
.head 5 -  Set bImmediately = TRUE
.head 4 +  ! Else
.head 5 -  Set bImmediately = FALSE
.head 4 -  ! Call GalSetProfileBoolean( "Services", "Immediately Done",  bImmediately ,sUserINIFileName  )
.head 4 +  If SalIsWindowEnabled( cbApplyParents )
.head 5 +  If cbApplyParents
.head 6 -  Set bApplyToMice = TRUE
.head 5 +  Else 
.head 6 -  Set bApplyToMice = FALSE
.head 5 -  Call GalSetProfileBoolean( "Services",  "Apply to Mice",  bApplyToMice ,sUserINIFileName  )
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 3 +  ! On AM_WidgetDone
.head 4 +  If nWait  = WAIT_WEANWIDGET
.head 5 -  Set nWait = 0 
.head 5 +  If wParam = 1
.head 6 -  Call WaitOnOff( FALSE )
.head 5 -  Call SalEndDialog( hWndItem, TRUE)
.head 1 +  Dialog Box: dlgPluggedTime
.head 2 -  Class: clsSimpleDialogBox
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Date of Plugged
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? Class Default
.head 3 -  Docking Orientation: Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  2.525"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 0.958"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Vertical Scroll? Class Default
.head 3 -  Horizontal Scroll? Class Default
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Data Field: dfPluggDate
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDataFieldDateTime
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  Data Type: Class Default
.head 5 -  Editable? Class Default
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: 0.488"
.head 6 -  Top: 0.156"
.head 6 -  Width:  1.5"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Border? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Format: Class Default
.head 5 -  Country: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Input Mask: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonOk
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.388"
.head 5 -  Top: 0.49"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbuttonCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.388"
.head 5 -  Top: 0.49"
.head 5 -  Width:  0.7"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  Receive Date/Time: dtPluggDate
.head 2 -  Window Variables
.head 2 +  Message Actions
.head 3 +  On AM_Ok
.head 4 +  If dfPluggDate = DATETIME_Null
.head 5 -  Call SalMessageBox ('You must enter the Date!', 'Error', 0)
.head 5 -  Return FALSE
.head 4 +  If dfPluggDate != DATETIME_Null
.head 5 -  Set dtPluggDate = dfPluggDate
.head 4 -  Call SalEndDialog( hWndItem, TRUE )
.head 3 +  On AM_Cancel
.head 4 -  Call SalEndDialog( hWndItem, FALSE )
.head 3 +  On SAM_Create
.head 4 -  Set dfPluggDate = SalDateCurrent ( )
.head 4 -  Call SalSendClassMessage (SAM_Create, wParam, lParam)
.head 1 +  ! clsTableBrowse: c
.winattr class Table Window:
.head 2 -  Class: clsTableBrowse
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Breeding Book
.head 2 -  Icon File:
.head 2 -  Accessories Enabled? Yes
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Visible at Design time? Yes
.head 3 -  Automatically Created at Runtime? No
.head 3 -  Initial State: Normal
.head 3 -  Maximizable? Yes
.head 3 -  Minimizable? Yes
.head 3 -  System Menu? Yes
.head 3 -  Resizable? Yes
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  20.433"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 4.43"
.head 4 -  Height Editable? Yes
.head 3 -  Font Name: MS Sans Serif
.head 3 -  Font Size: 8
.head 3 -  Font Enhancement: None
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 3 -  View: Table
.head 3 -  Allow Row Sizing? No
.head 3 -  Lines Per Row: Default
.head 3 -  Allow Child Docking? No
.head 3 -  Docking Orientation: All
.head 2 -  Memory Settings
.head 3 -  Maximum Rows in Memory: Default
.head 3 -  Discardable? Yes
.end
.head 2 -  Description: 
.head 2 -  Named Menus 
.head 2 -  Menu 
.head 2 +  Tool Bar 
.winattr
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? Yes
.head 4 -  Size: 0.698"
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? No
.head 4 -  Toolbar Docking Orientation: Top | Bottom
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Gray
.head 4 -  Resizable? No
.end
.head 3 +  Contents 
.head 4 +  Pushbutton: pbExit
.winattr
.head 5 -  Class Child Ref Key: 66
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 +  Message Actions 
.head 6 +  ! On SAM_Click
.head 7 -  Call Refresh(  )
.head 4 +  Pushbutton: pbRefresh
.winattr
.head 5 -  Class Child Ref Key: 71
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: Enter
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 +  Message Actions 
.head 6 +  On SAM_Click
.head 7 -  Call Refresh(  )
.head 4 +  Pushbutton: pbUpdate
.winattr
.head 5 -  Class Child Ref Key: 56
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbInsert
.winattr
.head 5 -  Class Child Ref Key: 55
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbUndo
.winattr
.head 5 -  Class Child Ref Key: 57
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbDelete
.winattr
.head 5 -  Class Child Ref Key: 58
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbPrint
.winattr
.head 5 -  Class Child Ref Key: 59
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbFirst
.winattr
.head 5 -  Class Child Ref Key: 67
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbPrev
.winattr
.head 5 -  Class Child Ref Key: 68
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbNext
.winattr
.head 5 -  Class Child Ref Key: 69
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbLast
.winattr
.head 5 -  Class Child Ref Key: 70
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableEdit
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: Default
.head 6 -  Top: Default
.head 6 -  Width:  Default
.head 6 -  Width Editable? Yes
.head 6 -  Height: Default
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: None
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Data Field: dfRoom
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldNr
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 20
.head 6 -  Data Type: Number
.head 6 -  Editable? Yes
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 1.588"
.head 7 -  Top: 0.021"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? Yes
.head 6 -  Border? Yes
.head 6 -  Justify: Left
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: Unformatted
.end
.head 5 -  Message Actions 
.head 4 +  Data Field: dfDay
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldNr
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 20
.head 6 -  Data Type: Number
.head 6 -  Editable? Yes
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 3.688"
.head 7 -  Top: 0.021"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? Yes
.head 6 -  Border? Yes
.head 6 -  Justify: Left
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: Unformatted
.end
.head 5 -  Message Actions 
.head 4 +  Data Field: dfDate
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDateTime
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 10
.head 6 -  Data Type: Date/Time
.head 6 -  Editable? Yes
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 5.788"
.head 7 -  Top: 0.021"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? Yes
.head 6 -  Border? Yes
.head 6 -  Justify: Left
.head 6 -  Format: dd.MM.yyyy hhhh:mm:ss
.head 6 -  Country: United Kingdom
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: 99.99.9999 99:99:99
.end
.head 5 -  Message Actions 
.head 4 +  Check Box: cbWeanedLitter
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsCheckBox
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: Show Only Not Weaned  Litters
.head 5 -  Window Location and Size
.head 6 -  Left: 6.788"
.head 6 -  Top: 0.01"
.head 6 -  Width:  2.2"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 5 -  Message Actions 
.head 4 +  Data Field: dfBatch
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldNr
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 20
.head 6 -  Data Type: Number
.head 6 -  Editable? Yes
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 1.588"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? Yes
.head 6 -  Border? Yes
.head 6 -  Justify: Left
.head 6 -  Format: Unformatted
.head 6 -  Country: Default
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: Unformatted
.end
.head 5 +  Message Actions 
.head 6 +  On WM_LBUTTONDBLCLK
.head 7 -  Call SalSendMsg( df7, WM_LBUTTONDBLCLK,  0, 0 )
.head 7 -  Set dfBatch = GetBatch( df7 )
.head 7 -  Set dfStartDate = SalDateWeekBegin  ( df7 )
.head 7 -  Set dfFinishDate = dfStartDate + 6
.head 7 -  Set cbUseInterval = TRUE
.head 7 -  Call SalPostMsg( hWndBreedingBook, AM_Breeding_Refresh, wParam, lParam )
.head 4 +  Data Field: dfStartDate
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 10
.head 6 -  Data Type: Date/Time
.head 6 -  Editable? Yes
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 3.688"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? Yes
.head 6 -  Border? Yes
.head 6 -  Justify: Center
.head 6 -  Format: dd.MM.yyyy
.head 6 -  Country: United Kingdom
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: 99.99.9999
.end
.head 5 -  Message Actions 
.head 4 +  Data Field: dfFinishDate
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 10
.head 6 -  Data Type: Date/Time
.head 6 -  Editable? Yes
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 5.788"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? Yes
.head 6 -  Border? Yes
.head 6 -  Justify: Center
.head 6 -  Format: dd.MM.yyyy
.head 6 -  Country: United Kingdom
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: 99.99.9999
.end
.head 5 -  Message Actions 
.head 4 +  Data Field: df7
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: 10
.head 6 -  Data Type: Date/Time
.head 6 -  Editable? No
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 0.088"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Yes
.head 7 -  Height: 0.25"
.head 7 -  Height Editable? Yes
.head 6 -  Visible? No
.head 6 -  Border? Yes
.head 6 -  Justify: Center
.head 6 -  Format: dd.MM.yyyy
.head 6 -  Country: United Kingdom
.head 6 -  Font Name: MS Sans Serif
.head 6 -  Font Size: 8
.head 6 -  Font Enhancement: None
.head 6 -  Text Color: Default
.head 6 -  Background Color: Default
.head 6 -  Input Mask: 99.99.9999
.end
.head 5 -  Message Actions 
.head 4 -  Background Text: Room:
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 0.988"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.5"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Justify: Left
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 4 -  Background Text: Batch:
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 0.988"
.head 6 -  Top: 0.406"
.head 6 -  Width:  0.6"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Justify: Left
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 4 -  Background Text: Start Date:
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 2.888"
.head 6 -  Top: 0.406"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Justify: Left
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 4 -  Background Text: Finish Date:
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 4.988"
.head 6 -  Top: 0.406"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Justify: Left
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 4 -  Background Text: Age To Wean:
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 2.688"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.9"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Justify: Left
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 4 -  Background Text: Wean date:
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 4.988"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Justify: Left
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 4 +  Check Box: cbUseInterval
.winattr class
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsCheckBox
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: Use Interval
.head 5 -  Window Location and Size
.head 6 -  Left: 6.788"
.head 6 -  Top: 0.406"
.head 6 -  Width:  1.4"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbExit
.winattr
.head 5 -  Class Child Ref Key: 21
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.013"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? No
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? No
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: EXIT_PAR.BMP
.head 5 -  Picture Transparent Color: Gray
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbRefresh
.winattr
.head 5 -  Class Child Ref Key: 20
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.363"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: REFRESH.BMP
.head 5 -  Picture Transparent Color: Gray
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbFirst
.winattr
.head 5 -  Class Child Ref Key: 16
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.713"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: TOPREC.BMP
.head 5 -  Picture Transparent Color: Gray
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbPrev
.winattr
.head 5 -  Class Child Ref Key: 17
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: 1.063"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: PREVREC.BMP
.head 5 -  Picture Transparent Color: Gray
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbNext
.winattr
.head 5 -  Class Child Ref Key: 18
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: 1.413"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: NEXTREC.BMP
.head 5 -  Picture Transparent Color: Gray
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 4 +  Pushbutton: pbLast
.winattr
.head 5 -  Class Child Ref Key: 19
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title:
.head 5 -  Window Location and Size
.head 6 -  Left: 1.763"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Keyboard Accelerator: (none)
.head 5 -  Font Name: MS Sans Serif
.head 5 -  Font Size: 8
.head 5 -  Font Enhancement: None
.head 5 -  Picture File Name: LASTREC.BMP
.head 5 -  Picture Transparent Color: Gray
.head 5 -  Image Style: Single
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Button Appearance: Standard
.end
.head 5 -  Message Actions 
.head 2 +  Contents 
.head 3 +  Column: ColBatch
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Batch
Of Birthday
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.983"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColDateWeaned
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Due To 
Wean Date
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Date/Time
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: dd.MM.yyyy
.head 4 -  Country: Default
.head 4 -  Input Mask: 99.99.9999
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColWeekday
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Week Day
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  1.3"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColFamily_name
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Family name /
Family code
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  1.317"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColDays
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Age
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.8"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColStrain
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Strain
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColRelship
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Relship ID
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColHepi_date
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Birth Date
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Date/Time
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: dd.MM.yyyy
.head 4 -  Country: Default
.head 4 -  Input Mask: 99.99.9999
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColFemales
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Females
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.85"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColMales
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Males
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.783"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColUnk
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Unk
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.75"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColWeanedFemales
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Weaned
Females
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  1.117"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColWeanedMales
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Weaned
Males
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  1.067"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColWeanedTotal
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Weaned
Total
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.9"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColCage_NR
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Cage NR
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColRack
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Rack
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColCage
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Cage
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: String
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: ColRoom
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Room
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  0.717"
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 3 +  Column: colLitterID
.winattr class
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Litter
.head 4 -  Visible? No
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Left
.head 4 -  Width:  Default
.head 4 -  Width Editable? Yes
.head 4 -  Format: Unformatted
.head 4 -  Country: Default
.head 4 -  Input Mask: Unformatted
.head 4 -  Cell Options
.head 5 -  Cell Type? Standard
.head 5 -  Multiline Cell? No
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Yes
.head 6 -  Vertical Scroll? Yes
.head 6 -  Auto Drop Down? No
.head 6 -  Allow Text Editing? Yes
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Yes
.end
.head 4 -  List Values 
.head 4 -  Message Actions 
.head 2 +  Functions 
.head 3 +  Function: Refresh
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  String: sSelectRack
.head 5 -  String: sRack
.head 5 -  String: sInRack
.head 5 -  String: sSelectFamilyName
.head 5 -  String: sSelectSexLitter
.head 5 -  Sql Handle: hSqlSelectRack
.head 5 -  Number: nFetch
.head 5 -  Sql Handle: hSqlSelectFamilyName
.head 5 -  Sql Handle: hSqlSelectSexLitter
.head 5 -  Number: nNewRow
.head 5 -  Number: nFetchLitter
.head 5 -  Number: nCountSex
.head 5 -  String: sSexLitter
.head 5 -  Number: nLitterId
.head 5 -  Number: ndayss
.head 5 -  Date/Time: dtDate
.head 5 -  String: sSelectWeanedLiter
.head 5 -  String: sCountSex
.head 5 -  Date/Time: dtAEDate
.head 5 -  Sql Handle: hSqlSelectWeanedLiter
.head 5 -  Number: nFall
.head 5 -  Sql Handle: hSqlSelectFamely
.head 5 -  Sql Handle: hSqlSelectCage
.head 4 +  Actions 
.head 5 -  Call VisWaitCursor(TRUE)
.head 5 -  Set ndayss = dfDay
.head 5 -  Call SalTblReset( tblBreeding )
.head 5 -  Set sSelectRack = "select    as.STAT_KEY
from    ABTEILUNG a, BEN_ABTEILUNG b,  ABT_STAT as"
.head 5 +  If dfRoom
.head 6 -  Set sSelectRack = sSelectRack || ", STATION s"
.head 5 -  Set sSelectRack = sSelectRack || "
where  b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	b.BENUTZER_ID= " || StrX( nUserId ) || "
and  a.EINRICHT_ID=b.EINRICHT_ID
and 	a.ABT_KEY = b.ABT_KEY
and	a.CANCELED = 'N'
and	a.WITH_BEDS = 'J'
and 	as.ABT_KEY = a.ABT_KEY
and  as.EINRICHT_ID=a.EINRICHT_ID"
.head 5 +  If dfRoom
.head 6 -  Set sSelectRack = sSelectRack || "
and  	s.EINRICHT_ID= as.EINRICHT_ID
and 	s.STAT_KEY = as.STAT_KEY
and	s.CURRNUM = " || StrX( dfRoom )
.head 5 -  Set sSelectRack = sSelectRack || "
group by as.STAT_KEY
into :sRack"
.head 5 +  If not GalConnect( hSqlSelectRack )
.head 6 -  Return FALSE
.head 5 -  Call SqlPrepareAndExecute( hSqlSelectRack, sSelectRack )
.head 5 +  While SqlFetchNext( hSqlSelectRack, nFetch )
.head 6 +  If sInRack
.head 7 -  Set sInRack = sInRack || ", "
.head 6 -  Set sInRack = sInRack || "'" || sRack || "'"
.head 5 -  Call SqlDisconnect( hSqlSelectRack )
.head 5 -  Set sSelectFamilyName = "
select   F.NAME3, rf.relship_id,  @DATEVALUE(:dfDate) -  l.geb_datum,
	bew.CAGE_NR,
	f.fall_key, s.CURRNUM, l.litter_id, l.geb_datum
from   relship_fall rf, RELATIONSHIP rs,Fall F,
	 litter l, bewegung bew, STATION s
where rf.fallrolle_key = 'PARENT'
and rf.fall_key=f.fall_key
and rs.RELSHIP_ID= rf.relship_id
and f.geschl='W'
and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0"
.head 5 +  If cbWeanedLitter and not dfStartDate and not dfFinishDate
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and :dfDate >= @NULLVALUE(l.geb_datum, 12-31-2199)
and  :ndayss <=  (@DATEVALUE(:dfDate) -  l.geb_datum) "
.head 5 +  If cbUseInterval
.head 6 +  If dfStartDate
.head 7 -  Set sSelectFamilyName = sSelectFamilyName || "
and :dfStartDate  <=  @NULLVALUE(l.geb_datum + :ndayss , 12-31-2199)"
.head 6 +  If dfFinishDate
.head 7 -  Set sSelectFamilyName = sSelectFamilyName || "
and :dfFinishDate  >= @NULLVALUE(l.geb_datum + :ndayss, 12-31-2199)"
.head 5 -  Set sSelectFamilyName = sSelectFamilyName || "
and bew.fall_key = f.fall_key
and bew.EINRICHT_ID =f.EINRICHT_ID 
and   bew.STAT_KEY  in ( " ||sInRack|| ") 
and bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
and       bew.bew_zeit <= :dfDate
and       (bew.bew_zeit_bis>:dfDate or bew.bew_zeit_bis is null  )
and	s.STAT_KEY = bew.STAT_KEY"
.head 5 +  If cbWeanedLitter
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and (exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id
	 and fall_key is null
	and dead = 0) or not exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id))"
.head 5 -  Set sSelectFamilyName = sSelectFamilyName || "
group by  f.name3, rf.relship_id, l.geb_datum,  bew.CAGE_NR, f.fall_key,  s.CURRNUM, l.litter_id
into :ColStrain, :ColRelship, :ColDays, :ColCage_NR, :nFall,  :ColRoom, :nLitterId, :dtDate
order by 3 DESC"
.head 5 -  Set sSelectSexLitter = "
select count(lc.LITTER_ID)
from    LITTER_CHILD lc
where  lc.litter_id = :nLitterId
and	lc.DEAD = 0
and	lc.GESCHLECHT= :sSexLitter
into :nCountSex
"
.head 5 -  Set sSelectWeanedLiter = "
select lc.GESCHLECHT, f.AE_DATUM
from    LITTER_CHILD lc, FALL f
where  lc.litter_id = :nLitterId
and	f.fall_key = lc.fall_key
into :sCountSex, :dtAEDate
"
.head 5 -  Call GalConnect( hSqlSelectFamely )
.head 5 -  Call GalConnect( hSqlSelectCage )
.head 5 -  Call SqlPrepare( hSqlSelectFamely, "
select @NULLVALUE( rs.FAMILY_CODE, rs.FAMILY_NAME )
from   relship_fall rf, RELATIONSHIP rs
where rf.fall_key=:nFall
and rf.fallrolle_key = 'MATE'
and rs.RELSHIP_ID= rf.relship_id
into :ColFamily_name
" )
.head 5 -  Call SqlPrepare( hSqlSelectCage, "
select STAT_KEY, GRUPPE_KEY
from   GRUPPE
where UNIQ_NR = :ColCage_NR

into :ColRack, :ColCage
" )
.head 5 +  If sInRack
.head 6 +  If GalConnect( hSqlSelectFamilyName )
.head 7 -  Call SqlPrepareAndExecute( hSqlSelectFamilyName, sSelectFamilyName )
.head 7 +  If GalConnect( hSqlSelectSexLitter )
.head 8 -  Call GalConnect( hSqlSelectWeanedLiter )
.head 8 -  Call SqlPrepare( hSqlSelectWeanedLiter, sSelectWeanedLiter )
.head 8 -  Set nNewRow = SalTblInsertRow( tblBreeding, TBL_MaxRow )
.head 8 +  While SqlFetchNext( hSqlSelectFamilyName, nFetch )
.head 9 -  Call SqlExecute( hSqlSelectFamely )
.head 9 -  Call SqlFetchNext( hSqlSelectFamely, nFetchLitter )
.head 9 -  Call SqlExecute( hSqlSelectCage )
.head 9 -  Call SqlFetchNext( hSqlSelectCage, nFetchLitter )
.head 9 -  Call SqlPrepare( hSqlSelectSexLitter, sSelectSexLitter )
.head 9 -  Set sSexLitter = "W"
.head 9 -  Call SqlExecute( hSqlSelectSexLitter )
.head 9 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 9 -  Set ColFemales = nCountSex
.head 9 -  Set nCountSex = 0
.head 9 -  Set sSexLitter = "M"
.head 9 -  Call SqlExecute( hSqlSelectSexLitter )
.head 9 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 9 -  Set ColMales = nCountSex
.head 9 -  Set nCountSex = 0
.head 9 -  Set sSexLitter = "U"
.head 9 -  Call SqlPrepareAndExecute( hSqlSelectSexLitter, "
select count(lc.LITTER_ID)
from    LITTER_CHILD lc
where  lc.litter_id = :nLitterId
and	lc.DEAD = 0
and	@NULLVALUE(LC.GESCHLECHT, 'U') = :sSexLitter
into :nCountSex
")
.head 9 -  ! Call SqlExecute( hSqlSelectSexLitter )
.head 9 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 9 -  Set ColUnk = nCountSex
.head 9 -  Set nCountSex = 0
.head 9 -  Set ColBatch = GetBatch( dtDate )
.head 9 -  Set ColHepi_date = dtDate
.head 9 -  Call SqlExecute( hSqlSelectWeanedLiter )
.head 9 -  Set colLitterID = nLitterId
.head 9 +  While SqlFetchNext( hSqlSelectWeanedLiter, nFetchLitter )
.head 10 +  If sCountSex = 'W'
.head 11 -  Set ColWeanedFemales = ColWeanedFemales + 1
.head 10 +  If sCountSex = 'M'
.head 11 -  Set ColWeanedMales = ColWeanedMales + 1
.head 9 -  Set ColWeanedTotal = ColWeanedFemales + ColWeanedMales
.head 9 +  If dtAEDate
.head 10 -  Set dtDate = dtAEDate
.head 10 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Gray, TRUE )
.head 10 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Gray, TRUE )
.head 9 +  Else 
.head 10 -  Set dtDate = dtDate + dfDay
.head 10 +  If ColDays > dfDay
.head 11 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Red, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Red, TRUE )
.head 10 +  If ColDays = dfDay
.head 11 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Green, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Green, TRUE )
.head 9 -  Set ColDateWeaned = dtDate
.head 9 +  Select Case ( SalDateWeekday ( dtDate  ) )
.head 10 +  Case 0
.head 11 -  Set ColWeekday = 'Saturday'
.head 11 -  Break 
.head 10 +  Case 1
.head 11 -  Set ColWeekday = 'Sunday'
.head 11 -  Break 
.head 10 +  Case 2
.head 11 -  Set ColWeekday= 'Monday'
.head 11 -  Break 
.head 10 +  Case 3
.head 11 -  Set ColWeekday= 'Tuesday'
.head 11 -  Break 
.head 10 +  Case 4
.head 11 -  Set ColWeekday= 'Wednesday'
.head 11 -  Break 
.head 10 +  Case 5
.head 11 -  Set ColWeekday = 'Thursday'
.head 11 -  Break 
.head 10 +  Case 6
.head 11 -  Set ColWeekday = 'Friday'
.head 11 -  Break 
.head 10 +  Default 
.head 11 -  Set ColWeekday = ''
.head 11 -  Break 
.head 9 -  ! Call SalTblSetRowFlags( tblBreeding, nNewRow, ROW_New, FALSE )
.head 9 -  Set nNewRow = SalTblInsertRow( tblBreeding, TBL_MaxRow )
.head 9 -  Set dtAEDate = DATETIME_Null
.head 8 -  Call SalTblDeleteRow(tblBreeding, nNewRow, 0)
.head 7 -  Call SqlDisconnect( hSqlSelectFamilyName )
.head 7 -  Call SqlDisconnect( hSqlSelectSexLitter )
.head 7 -  Call SqlDisconnect( hSqlSelectFamely )
.head 7 -  Call SqlDisconnect( hSqlSelectCage )
.head 7 -  Call SalTblQueryLinesPerRow( tblBreeding, nFetchLitter )
.head 5 -  Call VisWaitCursor(FALSE)
.head 5 -  ! Call and bew.BEW_NR in (select max(bb.BEW_NR)
	from bewegung bb
	where bb.fall_key = f.fall_key)
.head 3 +  Function: FocusRow
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 +  Parameters 
.head 5 -  Number: nCageNR
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  Number: nMinRow
.head 5 -  Number: nTempRow
.head 5 -  Window Handle: hWndFocus
.head 4 +  Actions 
.head 5 +  If not nCageNR 
.head 6 -  Return FALSE
.head 5 +  If nCageNR = ColCage_NR
.head 6 -  Return TRUE
.head 5 -  Call SalTblQueryFocus (tblBreeding, nTempRow, ColCage_NR)
.head 5 -  Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, FALSE )
.head 5 -  Set hWndFocus = SalGetFocus()
.head 5 -  Set nMinRow = TBL_MinRow 
.head 5 +  Loop 
.head 6 +  If SalTblFindNextRow ( tblBreeding, nMinRow, 0, 0)
.head 7 +  If nCageNR = SalStrToNumber( VisTblGetCell( tblBreeding, nMinRow, ColCage_NR ))
.head 8 -  Call SalTblSetFocusRow  (tblBreeding, nMinRow)
.head 8 -  Call SalTblSetRowFlags( tblBreeding, nMinRow, ROW_Selected, TRUE )
.head 8 -  Break 
.head 6 +  Else 
.head 7 -  Call SalTblSetFocusRow  (tblBreeding, nTempRow)
.head 7 -  Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, TRUE )
.head 7 -  Break 
.head 5 -  Call SalSetFocus( hWndFocus )
.head 3 +  Function: LoadSettings
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  String: sRoom
.head 4 +  Actions 
.head 5 -  Set dfDate =  frmAtlantaMain.lbKHELeft.GetTime4Refresh()
.head 5 -  Set dfBatch = GetBatch( dfDate )
.head 5 -  Set dfStartDate = SalDateWeekBegin  ( dfDate )
.head 5 -  Set dfFinishDate = dfStartDate + 6
.head 5 -  Set cbWeanedLitter = GalGetProfileBooleanX( "BREEDINGBOOS", "WeanedLitter", TRUE, sUserINIFileName )
.head 5 -  Set cbUseInterval = GalGetProfileBooleanX( "BREEDINGBOOS", "UseInterval", TRUE, sUserINIFileName )
.head 5 -  Set sRoom = GalGetProfileStringX( "BREEDINGBOOS", "Room", "" , sUserINIFileName )
.head 5 +  If sRoom != STRING_Null
.head 6 -  Set dfRoom = SalStrToNumber( sRoom )
.head 5 -  Set dfDay = GalGetProfileNumberX( "BREEDINGBOOS", "Day", 21, sUserINIFileName )
.head 3 +  Function: SaveSettings
.head 4 -  Description: 
.head 4 -  Returns 
.head 4 -  Parameters 
.head 4 -  Static Variables 
.head 4 +  Local variables 
.head 5 -  String: sRoom
.head 4 +  Actions 
.head 5 -  Call GalSetProfileBoolean("BREEDINGBOOS",'WeanedLitter', cbWeanedLitter, sUserINIFileName )
.head 5 -  Call GalSetProfileBoolean("BREEDINGBOOS",'UseInterval', cbUseInterval, sUserINIFileName )
.head 5 +  If dfRoom = NUMBER_Null
.head 6 -  Set sRoom = ""
.head 5 +  Else 
.head 6 -  Set sRoom = SalNumberToStrX( dfRoom, 0 )
.head 5 -  Call SalSetProfileString( "BREEDINGBOOS", "Room", sRoom, sUserINIFileName )
.head 5 -  Call GalSetProfileNumber( "BREEDINGBOOS", "Day", dfDay, sUserINIFileName )
.head 2 -  Window Parameters 
.head 2 +  Window Variables 
.head 3 -  Number: nCageNR
.head 2 +  Message Actions 
.head 3 +  On SAM_Create
.head 4 -  Call Initialize( "", "", "", "", "" )
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam , lParam )
.head 4 -  Call LoadSettings()
.head 4 -  ! Set dfDate =  frmAtlantaMain.lbKHELeft.GetTime4Refresh()
.head 4 -  ! Set dfDay = 21
.head 4 -  ! Set dfBatch = GetBatch( dfDate )
.head 4 -  ! Set dfStartDate = SalDateWeekBegin  ( dfDate )
.head 4 -  ! Set dfFinishDate = dfStartDate + 6
.head 4 -  Call Refresh()
.head 3 +  On SAM_Destroy
.head 4 -  Call SaveSettings(  )
.head 4 -  Set hWndBreedingBook = hWndNULL
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam , lParam )
.head 3 -  ! On SAM_Close
.head 3 +  On SAM_DoubleClick
.head 4 -  Set nCageNR = ColCage_NR
.head 4 -  Call SalSendMsg( hWndStar2000 , AM_GoToCageNR, nCageNR, lParam )
.head 4 +  If cbWeanedLitter
.head 5 -  Call SalPostMsg( hWndStar2000 , AM_OpenDL, colLitterID, 0)
.head 3 +  On AM_Breeding_Focus
.head 4 -  Call FocusRow( wParam)
.head 3 +  On AM_Breeding_Refresh
.head 4 -  Call Refresh(  )
.head 3 +  On AM_Breeding_OpenDL
.head 4 +  If wParam = ColCage_NR and cbWeanedLitter
.head 5 -  Set hWndStar2000.nHandleForExclude = frmAtlantaMain.lbKHELeft.nSelectedHandle
.head 5 -  Call SalPostMsg( hWndStar2000 , AM_OpenDL, colLitterID, 0)
.head 1 +  Table Window: tblBreeding
.head 2 -  Class: clsTableBrowse
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 221
.head 2 -  Icon File: KHEFLDUN-MF_L.BMP
.data RESOURCE 2 0 1 3558503428
0000: F201000024010000 0000000000000000 020080424DF20100 0000037600000028
0020: 0000000027000000 1300000000010004 000000037C010000 C40EBC000000FFAF
0040: 8000030080800080 0068000080808081 00C0C0C000808480 0000FF00000300FF
0060: FF00FF00680000FF FFFF8D00FF00FFFE FFFFE1F0FFFFFFFF DFF07EFFF9E09F99
0080: FFFFFFEDF0FF0F99 9FFFFFDEFFF03EFF F999109F9999FFFF 9FFF4190F8888888
00A0: FFA4FFFFF99FFF11 99FFF9F0F8FF50FF FFF8FFFF9982FFFF FF9F9F9F9190F8FF
00C0: FFF8E5FF9FFFC69F 9FFF9099FFF8FF99 A0FFFFF99F9F9F1D 90FFF8F0D4F0FFF9
00E0: 99D199FFF9F051FF F8FFFFF9E69FFFFF 99F0F8FFF891F999 FFFFF9DBFFF019FF
0100: F89FFFFF5D9FFFFF 55F08888FFDD9F99 95FFFFF0FF5EFF99 F95E9FFFFFEDF0FF
0120: F1F99999D9FFFFF0 FEFFFFEDF0FFFFDF F0FEFFFF01F0
.enddata
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Visible at Design time? Yes
.head 3 -  Automatically Created at Runtime? No
.head 3 -  Initial State: Class Default
.head 3 -  Maximizable? Class Default
.head 3 -  Minimizable? Class Default
.head 3 -  System Menu? Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  20.483"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: Class Default
.head 4 -  Height Editable? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  View: Class Default
.head 3 -  Allow Row Sizing? Class Default
.head 3 -  Lines Per Row: Class Default
.head 3 -  Allow Child Docking? Class Default
.head 3 -  Docking Orientation: Class Default
.head 2 -  Memory Settings
.head 3 -  Maximum Rows in Memory: Class Default
.head 3 -  Discardable? Class Default
.head 2 -  Description:
.head 2 -  Named Menus
.head 2 -  Menu
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: 0.698"
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 +  Contents
.head 4 +  Pushbutton: pbExit
.head 5 -  Class Child Ref Key: 21
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 1
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbRefresh
.head 5 -  Class Child Ref Key: 20
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 2
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 -  Call Refresh(  0)
.head 4 +  Pushbutton: pbFirst
.head 5 -  Class Child Ref Key: 16
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 3
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbPrev
.head 5 -  Class Child Ref Key: 17
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 4
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbNext
.head 5 -  Class Child Ref Key: 18
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 5
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbLast
.head 5 -  Class Child Ref Key: 19
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 6
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Data Field: dfRoom
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldNr
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 3.088"
.head 7 -  Top: 0.021"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 7
.head 5 -  Resource Id: 65142
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Data Field: dfDay
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldNr
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 3.688"
.head 7 -  Top: 0.021"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? No
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 8
.head 5 -  Resource Id: 65143
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Data Field: dfDate
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDateTime
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 5.188"
.head 7 -  Top: 0.021"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 9
.head 5 -  Resource Id: 65144
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Check Box: cbWeanedLitter
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsCheckBox
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 10
.head 5 -  Window Location and Size
.head 6 -  Left: 6.188"
.head 6 -  Top: 0.01"
.head 6 -  Width:  2.2"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Message Actions
.head 4 +  Data Field: dfBatch
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldNr
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 0.988"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 +  Message Actions
.head 6 +  On WM_LBUTTONDBLCLK
.head 7 -  Call SalSendMsg( df7, WM_LBUTTONDBLCLK,  0, 0 )
.head 7 +  If df7 = DATETIME_Null
.head 8 -  Return FALSE
.head 7 -  Set dfBatch = GetBatch( df7 )
.head 7 -  Set dfStartDate = SalDateWeekBegin  ( df7 )
.head 7 -  Set dfFinishDate = dfStartDate + 6
.head 7 -  Set cbUseInterval = TRUE
.head 7 -  Call SalPostMsg( hWndBreedingBook, AM_Breeding_Refresh, wParam, lParam )
.head 4 -  Background Text: 11
.head 5 -  Resource Id: 65145
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Data Field: dfStartDate
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 3.088"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 12
.head 5 -  Resource Id: 65146
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Data Field: dfFinishDate
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 5.188"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 13
.head 5 -  Resource Id: 65147
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Data Field: df7
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDate
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? No
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 0.088"
.head 7 -  Top: 0.406"
.head 7 -  Width:  0.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? No
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 -  Message Actions
.head 4 -  Background Text: 14
.head 5 -  Resource Id: 65148
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 0.0"
.head 6 -  Top: 0.0"
.head 6 -  Width:  0.0"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.0"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 -  Background Text: 15
.head 5 -  Resource Id: 51133
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 2.288"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.5"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 -  Background Text: 16
.head 5 -  Resource Id: 51134
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 0.388"
.head 6 -  Top: 0.406"
.head 6 -  Width:  0.6"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 -  Background Text: 17
.head 5 -  Resource Id: 51135
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 2.288"
.head 6 -  Top: 0.406"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 -  Background Text: 18
.head 5 -  Resource Id: 51136
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 4.388"
.head 6 -  Top: 0.406"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 -  Background Text: 19
.head 5 -  Resource Id: 51137
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 2.688"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.9"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? No
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 -  Background Text: 20
.head 5 -  Resource Id: 51138
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 4.388"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.7"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 +  Check Box: cbUseInterval
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsCheckBox
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 21
.head 5 -  Window Location and Size
.head 6 -  Left: 6.188"
.head 6 -  Top: 0.406"
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbDown
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 22
.head 5 -  Window Location and Size
.head 6 -  Left: 1.3"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name: NEXTREC.BMP
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 -  Set nPaype = nPaype + 1
.head 7 -  Call Refresh(  1)
.head 4 +  Pushbutton: pbUp
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 23
.head 5 -  Window Location and Size
.head 6 -  Left: 1.0"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name: PREVREC.BMP
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 -  Set nPaype = nPaype - 1
.head 7 -  Call Refresh(  2)
.head 4 +  Pushbutton: pbStart
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 24
.head 5 -  Window Location and Size
.head 6 -  Left: 0.7"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name: TOPREC.BMP
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 -  Set nPaype =  1
.head 7 -  Call Refresh(  4)
.head 7 -  Call pbUp.Disable(  )
.head 7 -  Call pbStart.Disable(  )
.head 7 -  Call pbDown.Enable(  )
.head 7 -  Call pbFinish.Enable(  )
.head 4 +  Pushbutton: pbFinish
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 25
.head 5 -  Window Location and Size
.head 6 -  Left: 1.6"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name: LASTREC.BMP
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 -  Set nPaype = 2
.head 7 -  Call Refresh(  5)
.head 7 -  Call pbDown.Disable(  )
.head 7 -  Call pbFinish.Disable(  )
.head 7 -  Call pbUp.Enable(  )
.head 7 -  Call pbStart.Enable(  )
.head 2 +  Contents
.head 3 +  Column: ColBatch
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 26
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.983"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColDateWeaned
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 27
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Date/Time
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: dd.MM.yyyy
.head 4 -  Country: Class Default
.head 4 -  Input Mask: 99.99.9999
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColWeekday
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 28
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  1.3"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColFamily_name
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 29
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  1.317"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColDays
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 30
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.8"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColStrain
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 31
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColRelship
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 32
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColHepi_date
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 33
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Date/Time
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: dd.MM.yyyy
.head 4 -  Country: Class Default
.head 4 -  Input Mask: 99.99.9999
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColFemales
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 34
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.85"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColMales
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 35
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.783"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColUnk
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 36
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.75"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColWeanedFemales
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 37
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  1.117"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColWeanedMales
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 38
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  1.067"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColWeanedTotal
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 39
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.9"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColCage_NR
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 40
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColRack
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 41
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColCage
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 42
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColRoom
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 43
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  0.717"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colLitterID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 44
.head 4 -  Visible? No
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 2 +  Functions
.head 3 +  Function: Refresh
.head 4 -  Description:
.head 4 -  Returns
.head 4 +  Parameters
.head 5 -  Number: nTipy
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sSelectRack
.head 5 -  String: sRack
.head 5 -  String: sInRack
.head 5 -  String: sSelectFamilyName
.head 5 -  String: sSelectSexLitter
.head 5 -  Sql Handle: hSqlSelectRack
.head 5 -  Number: nFetch
.head 5 -  Sql Handle: hSqlSelectFamilyName
.head 5 -  Sql Handle: hSqlSelectSexLitter
.head 5 -  Number: nNewRow
.head 5 -  Number: nFetchLitter
.head 5 -  Number: nCountSex
.head 5 -  String: sSexLitter
.head 5 -  Number: nLitterId
.head 5 -  Number: ndayss
.head 5 -  Date/Time: dtDate
.head 5 -  String: sSelectWeanedLiter
.head 5 -  String: sCountSex
.head 5 -  Date/Time: dtAEDate
.head 5 -  Sql Handle: hSqlSelectWeanedLiter
.head 5 -  Number: nFall
.head 5 -  Sql Handle: hSqlSelectFamely
.head 5 -  Sql Handle: hSqlSelectCage
.head 5 -  Sql Handle: hSqlSelectStrainParent
.head 5 -  String: sSelectStrainParent
.head 5 -  String: sSelectStrain
.head 5 -  String: sStrainF
.head 5 -  String: sStrainM
.head 5 -  String: sStrain
.head 5 -  String: sStrainT
.head 5 -  Sql Handle: hSqlSelectStrain
.head 5 -  Boolean: bOk
.head 5 -  Number: i
.head 5 -  Number: nSD
.head 5 -  Number: nSLID
.head 5 -  Number: nFD
.head 5 -  Number: nFLID
.head 5 -  Number: nCount
.head 5 -  Sql Handle: hSqlSelectStartLID
.head 5 -  String: sSelectStartLID
.head 4 +  Actions
.head 5 -  Call VisWaitCursor(TRUE)
.head 5 -  Set ndayss = dfDay
.head 5 -  Set nSD = nStartD
.head 5 -  Set nFD = nFinishD
.head 5 -  Set nSLID = nStartLID
.head 5 -  Set nFLID = nFinishLID
.head 5 +  If nTipy = 0
.head 6 -  Set nStartD = 0
.head 6 -  Set nFinishD = 0
.head 6 -  Set nStartLID = 0
.head 6 -  Set nFinishLID = 0
.head 6 -  Set nPaype = 2
.head 6 -  ! Call pb8.Disable(  )
.head 5 +  Else If nTipy = 1
.head 6 -  Set nStartD = 0
.head 6 -  Set nStartLID = 0
.head 5 +  Else If nTipy = 2
.head 6 -  Set nFinishD = 0
.head 6 -  Set nFinishLID = 0
.head 5 +  Else If nTipy = 3
.head 6 -  Set nFD = nStartD
.head 6 -  Set nFLID = nStartLID
.head 5 +  Else If nTipy = 4
.head 6 -  Set nPaype = 1
.head 5 -  Call SalTblReset( tblBreeding )
.head 5 -  Call SalGetWindowSize (tblBreeding, nX, nY)
.head 5 -  Set nY = (nY - 2.143)/0.226
.head 5 -  Set sSelectRack = "select    as.STAT_KEY
from    ABTEILUNG a, BEN_ABTEILUNG b,  ABT_STAT as"
.head 5 +  If dfRoom
.head 6 -  Set sSelectRack = sSelectRack || ", STATION s"
.head 5 -  Set sSelectRack = sSelectRack || "
where  b.EINRICHT_ID = " || StrX( nEinrichtId ) || "
and	b.BENUTZER_ID= " || StrX( nUserId ) || "
and  a.EINRICHT_ID=b.EINRICHT_ID
and 	a.ABT_KEY = b.ABT_KEY
and	a.CANCELED = 'N'
and	a.WITH_BEDS = 'J'
and 	as.ABT_KEY = a.ABT_KEY
and  as.EINRICHT_ID=a.EINRICHT_ID"
.head 5 +  If dfRoom
.head 6 -  Set sSelectRack = sSelectRack || "
and  	s.EINRICHT_ID= as.EINRICHT_ID
and 	s.STAT_KEY = as.STAT_KEY
and	s.CURRNUM = " || StrX( dfRoom )
.head 5 -  Set sSelectRack = sSelectRack || "
group by as.STAT_KEY
into :sRack"
.head 5 +  If not GalConnect( hSqlSelectRack )
.head 6 -  Return FALSE
.head 5 -  Call SqlPrepareAndExecute( hSqlSelectRack, sSelectRack )
.head 5 +  While SqlFetchNext( hSqlSelectRack, nFetch )
.head 6 +  If sInRack
.head 7 -  Set sInRack = sInRack || ", "
.head 6 -  Set sInRack = sInRack || "'" || sRack || "'"
.head 5 -  Call SqlDisconnect( hSqlSelectRack )
.head 5 +  If nTipy = 0 and  sInRack
.head 6 -  Set sSelectStartLID = "
select     @DATEVALUE(:dfDate) -  l.geb_datum, l.litter_id
from   relship_fall rf, RELATIONSHIP rs,Fall F,
	 litter l, bewegung bew, STATION s
where rf.fallrolle_key = 'PARENT'
and rf.fall_key=f.fall_key
and rs.RELSHIP_ID= rf.relship_id
and f.geschl='W'
and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0
and :dfDate >= @NULLVALUE(l.geb_datum, 12-31-2199)
and  :ndayss <=  (@DATEVALUE(:dfDate) -  l.geb_datum)
and bew.fall_key = f.fall_key
and bew.EINRICHT_ID =f.EINRICHT_ID
and   bew.STAT_KEY  in ( " ||sInRack|| ")
and bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
and       bew.bew_zeit <= :dfDate
and       (bew.bew_zeit_bis>:dfDate or bew.bew_zeit_bis is null  )
and	s.STAT_KEY = bew.STAT_KEY
and (exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id
	 and fall_key is null
	and dead = 0) or not exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id))
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :nFD, :nFLID
order by 1 DESC, 2"
.head 6 +  If not GalConnect( hSqlSelectStartLID )
.head 7 -  Return FALSE
.head 6 -  Call SqlPrepareAndExecute( hSqlSelectStartLID, sSelectStartLID )
.head 6 +  If SqlFetchNext( hSqlSelectStartLID, nFetch )
.head 7 -  Set nTipy = 3
.head 6 +  Else
.head 7 -  Set nTipy = 4
.head 6 -  Call SqlDisconnect( hSqlSelectStartLID )
.head 5 -  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.head 5 -  Set sSelectFamilyName = "
select   rf.relship_id,  @DATEVALUE(:dfDate) -  l.geb_datum,
	bew.CAGE_NR,
	s.CURRNUM, l.litter_id, l.geb_datum
from   relship_fall rf, RELATIONSHIP rs,Fall F,
	 litter l, bewegung bew, STATION s
where rf.fallrolle_key = 'PARENT'
and rf.fall_key=f.fall_key
and rs.RELSHIP_ID= rf.relship_id
and f.geschl='W'
and	@nullvalue( f.GELOESCHT, 'N' ) != 'J'
and l.family_relship_id = rf.relship_id
and @NULLVALUE(l.miss, 0) = 0"
.head 5 +  If cbWeanedLitter and not dfStartDate and not dfFinishDate
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and :dfDate >= @NULLVALUE(l.geb_datum, 12-31-2199)
and  :ndayss <=  (@DATEVALUE(:dfDate) -  l.geb_datum) "
.head 5 +  If cbUseInterval
.head 6 +  If dfStartDate
.head 7 -  Set sSelectFamilyName = sSelectFamilyName || "
and :dfStartDate  <=  @NULLVALUE(l.geb_datum + :ndayss , 12-31-2199)"
.head 6 +  If dfFinishDate
.head 7 -  Set sSelectFamilyName = sSelectFamilyName || "
and :dfFinishDate  >= @NULLVALUE(l.geb_datum + :ndayss, 12-31-2199)"
.head 5 -  Set sSelectFamilyName = sSelectFamilyName || "
and bew.fall_key = f.fall_key
and bew.EINRICHT_ID =f.EINRICHT_ID
and   bew.STAT_KEY  in ( " ||sInRack|| ")
and bew.BA_KEY in ( 'AE', 'VE', 'UE', 'RE' )
and	@nullvalue( bew.GELOESCHT, 'N' ) != 'J'
and       bew.bew_zeit <= :dfDate
and       (bew.bew_zeit_bis>:dfDate or bew.bew_zeit_bis is null  )
and	s.STAT_KEY = bew.STAT_KEY"
.head 5 +  If cbWeanedLitter
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and (exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id
	 and fall_key is null
	and dead = 0) or not exists(select child_nr
	from sysadm.litter_child
	where litter_id = l.litter_id))"
.head 5 +  If nTipy = 1
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and ((@DATEVALUE(:dfDate) -  l.geb_datum < :nFD) or (@DATEVALUE(:dfDate) -  l.geb_datum = :nFD and l.litter_id > :nFLID ))"
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :ColRelship, :ColDays, :ColCage_NR, :ColRoom, :nLitterId, :dtDate
order by 2 DESC, 5"
.head 5 +  If nTipy = 2
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and ((@DATEVALUE(:dfDate) -  l.geb_datum > :nSD) or (@DATEVALUE(:dfDate) -  l.geb_datum = :nSD and l.litter_id < :nSLID ))"
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :ColRelship, :ColDays, :ColCage_NR, :ColRoom, :nLitterId, :dtDate
order by 2 , 5 DESC"
.head 5 +  If nTipy = 0 or nTipy =4
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :ColRelship, :ColDays, :ColCage_NR, :ColRoom, :nLitterId, :dtDate
order by 2 DESC, 5"
.head 5 +  If nTipy = 3
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
and ((@DATEVALUE(:dfDate) -  l.geb_datum < :nFD) or (@DATEVALUE(:dfDate) -  l.geb_datum = :nFD and l.litter_id >= :nFLID ))"
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :ColRelship, :ColDays, :ColCage_NR, :ColRoom, :nLitterId, :dtDate
order by 2 DESC, 5"
.head 5 +  If nTipy = 5
.head 6 -  Set sSelectFamilyName = sSelectFamilyName || "
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :ColRelship, :ColDays, :ColCage_NR, :ColRoom, :nLitterId, :dtDate
order by 2 , 5 DESC"
.head 5 -  ! Set sSelectFamilyName = sSelectFamilyName || "
group by   rf.relship_id, l.geb_datum,  bew.CAGE_NR, s.CURRNUM, l.litter_id
into  :ColRelship, :ColDays, :ColCage_NR, :ColRoom, :nLitterId, :dtDate
order by 2 DESC, 5"
.head 5 -  Set sSelectSexLitter = "
select count(lc.LITTER_ID)
from    LITTER_CHILD lc
where  lc.litter_id = :nLitterId
and	lc.DEAD = 0
and	lc.GESCHLECHT= :sSexLitter
into :nCountSex
"
.head 5 -  Set sSelectWeanedLiter = "
select lc.GESCHLECHT, f.AE_DATUM
from    LITTER_CHILD lc, FALL f
where  lc.litter_id = :nLitterId
and	f.fall_key = lc.fall_key
into :sCountSex, :dtAEDate
"
.head 5 -  Set sSelectStrainParent = "
select  s.strain_key, f.geschl
from   relship_fall rf, fall f, litter l, strain_n s
where l.litter_id = :nLitterId
and l.family_relship_id = rf.relship_id
and rf.fallrolle_key = 'PARENT'
and rf.EINRICHT_ID =f.EINRICHT_ID
and rf.fall_key = f.fall_key
and f.ID_strain = s.ID
into :sStrain, :sCountSex
"
.head 5 -  ! Set sSelectStrain = "
select  STRAIN_KEY
from   strain_n
where STR_FATHER = :sStrainM
and STR_MOTHER = :sStrainF
into :ColStrain
"
.head 5 -  Set sSelectStrain = "
select litterstrain from parents_view
where FATHERSTRAIN = :sStrainM
and MOTHERSTRAIN = :sStrainF
into :ColStrain
"
.head 5 +  If sInRack
.head 6 +  If GalConnect( hSqlSelectFamilyName )
.head 7 -  Call GalConnect( hSqlSelectFamely )
.head 7 -  Call GalConnect( hSqlSelectCage )
.head 7 -  Call SqlPrepare( hSqlSelectFamely, "
select @NULLVALUE( rs.FAMILY_CODE, rs.FAMILY_NAME )
from    RELATIONSHIP rs, LITTER l
where  LITTER_ID= :nLitterId
and rs.RELSHIP_ID= l.PLACE_RELSHIP_ID
and rs.RELTYPE_KEY = 'MATE'
into :ColFamily_name
" )
.head 7 -  Call SqlPrepare( hSqlSelectCage, "
select STAT_KEY, GRUPPE_KEY
from   GRUPPE
where UNIQ_NR = :ColCage_NR

into :ColRack, :ColCage
" )
.head 7 -  Call SqlPrepareAndExecute( hSqlSelectFamilyName, sSelectFamilyName )
.head 7 -  Call SqlGetResultSetCount ( hSqlSelectFamilyName, nCount )
.head 7 +  If nTipy = 2 and nCount < nY-1
.head 8 -  Call SqlDisconnect( hSqlSelectFamilyName )
.head 8 -  Call Refresh( 4 )
.head 8 -  Call VisWaitCursor(FALSE)
.head 8 -  Return 1
.head 7 +  If GalConnect( hSqlSelectSexLitter )
.head 8 -  Call GalConnect( hSqlSelectWeanedLiter )
.head 8 -  Call SqlPrepare( hSqlSelectWeanedLiter, sSelectWeanedLiter )
.head 8 -  Call GalConnect( hSqlSelectStrainParent )
.head 8 -  Call SqlPrepare( hSqlSelectStrainParent, sSelectStrainParent )
.head 8 -  Call GalConnect( hSqlSelectStrain)
.head 8 -  Call SqlPrepare( hSqlSelectStrain, sSelectStrain )
.head 8 +  If nTipy = 2 or nTipy = 5
.head 9 +  While nNewRow < nY-1
.head 10 -  Set nNewRow = SalTblInsertRow( tblBreeding, TBL_MaxRow )
.head 9 -  Set i = nNewRow
.head 9 +  While SqlFetchNext( hSqlSelectFamilyName, nFetch ) and i >=0
.head 10 +  If not nFinishD
.head 11 -  Set nFinishD = ColDays
.head 11 -  Set nFinishLID = nLitterId
.head 10 -  Set nStartD = ColDays
.head 10 -  Set nStartLID = nLitterId
.head 10 -  Call SqlExecute( hSqlSelectFamely )
.head 10 -  Call SqlFetchNext( hSqlSelectFamely, nFetchLitter )
.head 10 -  Call SqlExecute( hSqlSelectCage )
.head 10 -  Call SqlFetchNext( hSqlSelectCage, nFetchLitter )
.head 10 -  Call SqlPrepare( hSqlSelectSexLitter, sSelectSexLitter )
.head 10 -  Set sSexLitter = "W"
.head 10 -  Call SqlExecute( hSqlSelectSexLitter )
.head 10 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 10 -  Set ColFemales = nCountSex
.head 10 -  Set nCountSex = 0
.head 10 -  Set sSexLitter = "M"
.head 10 -  Call SqlExecute( hSqlSelectSexLitter )
.head 10 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 10 -  Set ColMales = nCountSex
.head 10 -  Set nCountSex = 0
.head 10 -  Set sSexLitter = "U"
.head 10 -  Call SqlPrepareAndExecute( hSqlSelectSexLitter, "
select count(lc.LITTER_ID)
from    LITTER_CHILD lc
where  lc.litter_id = :nLitterId
and	lc.DEAD = 0
and	@NULLVALUE(LC.GESCHLECHT, 'U') = :sSexLitter
into :nCountSex
")
.head 10 -  ! Call SqlExecute( hSqlSelectSexLitter )
.head 10 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 10 -  Set ColUnk = nCountSex
.head 10 -  Set nCountSex = 0
.head 10 -  Set ColBatch = GetBatch( dtDate )
.head 10 -  Set ColHepi_date = dtDate
.head 10 -  Call SqlExecute( hSqlSelectWeanedLiter )
.head 10 -  Set colLitterID = nLitterId
.head 10 +  While SqlFetchNext( hSqlSelectWeanedLiter, nFetchLitter )
.head 11 +  If sCountSex = 'W'
.head 12 -  Set ColWeanedFemales = ColWeanedFemales + 1
.head 11 +  If sCountSex = 'M'
.head 12 -  Set ColWeanedMales = ColWeanedMales + 1
.head 11 +  If sStrainT and  ColStrain = ''
.head 12 -  Set ColStrain = sStrainT
.head 10 -  Set ColWeanedTotal = ColWeanedFemales + ColWeanedMales
.head 10 +  If dtAEDate
.head 11 -  Set dtDate = dtAEDate
.head 11 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Gray, TRUE )
.head 11 -  ! Call VisTblSetRowColorEx(tblBreeding, nNewRow, COLOR_Gray, COLOR_White)
.head 10 +  Else
.head 11 -  Set dtDate = dtDate + dfDay
.head 11 +  If ColDays > dfDay
.head 12 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Red, TRUE )
.head 12 -  ! Call VisTblSetRowColorEx(tblBreeding, nNewRow, COLOR_Red, COLOR_White)
.head 11 +  If ColDays = dfDay
.head 12 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Green, TRUE )
.head 12 -  ! Call VisTblSetRowColorEx(tblBreeding, nNewRow, COLOR_Green, COLOR_White)
.head 10 -  Call SqlExists( "
select  s.STRAIN_KEY
from    LITTER_CHILD lc, STRAIN_N s
where  lc.litter_id = :nLitterId
and	lc.ID_STRAIN = s.ID
into  :ColStrain
", bOk )
.head 10 +  If ColStrain =""
.head 11 -  Call SqlExecute( hSqlSelectStrainParent )
.head 11 +  While SqlFetchNext( hSqlSelectStrainParent, nFetchLitter )
.head 12 +  If sCountSex = 'W'
.head 13 -  Set sStrainF = sStrain
.head 12 +  If sCountSex = 'M'
.head 13 -  Set sStrainM = sStrain
.head 11 -  Call SqlExecute( hSqlSelectStrain )
.head 11 -  Call SqlFetchNext( hSqlSelectStrain, nFetchLitter )
.head 10 -  Set ColDateWeaned = dtDate
.head 10 +  Select Case ( SalDateWeekday ( dtDate  ) )
.head 11 +  Case 0
.head 12 -  Set ColWeekday = 'Saturday'
.head 12 -  Break
.head 11 +  Case 1
.head 12 -  Set ColWeekday = 'Sunday'
.head 12 -  Break
.head 11 +  Case 2
.head 12 -  Set ColWeekday= 'Monday'
.head 12 -  Break
.head 11 +  Case 3
.head 12 -  Set ColWeekday= 'Tuesday'
.head 12 -  Break
.head 11 +  Case 4
.head 12 -  Set ColWeekday= 'Wednesday'
.head 12 -  Break
.head 11 +  Case 5
.head 12 -  Set ColWeekday = 'Thursday'
.head 12 -  Break
.head 11 +  Case 6
.head 12 -  Set ColWeekday = 'Friday'
.head 12 -  Break
.head 11 +  Default
.head 12 -  Set ColWeekday = ''
.head 12 -  Break
.head 10 -  Set nNewRow = nNewRow - 1
.head 10 -  ! Call SalTblSetRow ( tblBreeding, nNewRow )
.head 10 -  Call SalTblSetContext( tblBreeding, nNewRow )
.head 10 -  ! Set nNewRow = SalTblInsertRow( tblBreeding, TBL_MaxRow )
.head 10 -  Set dtAEDate = DATETIME_Null
.head 10 -  Set i = i - 1
.head 8 +  Else
.head 9 -  Set i = 0
.head 9 -  Set nNewRow = SalTblInsertRow( tblBreeding, TBL_MaxRow )
.head 9 +  While SqlFetchNext( hSqlSelectFamilyName, nFetch ) and i < nY
.head 10 +  If not nStartD
.head 11 -  Set nStartD = ColDays
.head 11 -  Set nStartLID = nLitterId
.head 10 -  Set nFinishD = ColDays
.head 10 -  Set nFinishLID = nLitterId
.head 10 -  Call SqlExecute( hSqlSelectFamely )
.head 10 -  Call SqlFetchNext( hSqlSelectFamely, nFetchLitter )
.head 10 -  Call SqlExecute( hSqlSelectCage )
.head 10 -  Call SqlFetchNext( hSqlSelectCage, nFetchLitter )
.head 10 -  Call SqlPrepare( hSqlSelectSexLitter, sSelectSexLitter )
.head 10 -  Set sSexLitter = "W"
.head 10 -  Call SqlExecute( hSqlSelectSexLitter )
.head 10 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 10 -  Set ColFemales = nCountSex
.head 10 -  Set nCountSex = 0
.head 10 -  Set sSexLitter = "M"
.head 10 -  Call SqlExecute( hSqlSelectSexLitter )
.head 10 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 10 -  Set ColMales = nCountSex
.head 10 -  Set nCountSex = 0
.head 10 -  Set sSexLitter = "U"
.head 10 -  Call SqlPrepareAndExecute( hSqlSelectSexLitter, "
select count(lc.LITTER_ID)
from    LITTER_CHILD lc
where  lc.litter_id = :nLitterId
and	lc.DEAD = 0
and	@NULLVALUE(LC.GESCHLECHT, 'U') = :sSexLitter
into :nCountSex
")
.head 10 -  ! Call SqlExecute( hSqlSelectSexLitter )
.head 10 -  Call SqlFetchNext( hSqlSelectSexLitter, nFetchLitter )
.head 10 -  Set ColUnk = nCountSex
.head 10 -  Set nCountSex = 0
.head 10 -  Set ColBatch = GetBatch( dtDate )
.head 10 -  Set ColHepi_date = dtDate
.head 10 -  Call SqlExecute( hSqlSelectWeanedLiter )
.head 10 -  Set colLitterID = nLitterId
.head 10 +  While SqlFetchNext( hSqlSelectWeanedLiter, nFetchLitter )
.head 11 +  If sCountSex = 'W'
.head 12 -  Set ColWeanedFemales = ColWeanedFemales + 1
.head 11 +  If sCountSex = 'M'
.head 12 -  Set ColWeanedMales = ColWeanedMales + 1
.head 11 +  If sStrainT and  ColStrain = ''
.head 12 -  Set ColStrain = sStrainT
.head 10 -  Set ColWeanedTotal = ColWeanedFemales + ColWeanedMales
.head 10 +  If dtAEDate
.head 11 -  Set dtDate = dtAEDate
.head 11 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Gray, TRUE )
.head 11 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Gray, TRUE )
.head 10 +  Else
.head 11 -  Set dtDate = dtDate + dfDay
.head 11 +  If ColDays > dfDay
.head 12 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Red, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Red, TRUE )
.head 11 +  If ColDays = dfDay
.head 12 -  Call SalTblSetCellTextColor ( ColBatch, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDateWeaned, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeekday, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFamily_name, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColDays, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColStrain, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRelship, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColHepi_date, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColFemales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColMales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColUnk, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedFemales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedMales, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColWeanedTotal, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage_NR, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRack, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColCage, COLOR_Green, TRUE )
.head 12 -  Call SalTblSetCellTextColor ( ColRoom, COLOR_Green, TRUE )
.head 10 -  Call SqlExists( "
select  s.STRAIN_KEY
from    LITTER_CHILD lc, STRAIN_N s
where  lc.litter_id = :nLitterId
and	lc.ID_STRAIN = s.ID
into  :ColStrain
", bOk )
.head 10 +  If ColStrain =""
.head 11 -  Call SqlExecute( hSqlSelectStrainParent )
.head 11 +  While SqlFetchNext( hSqlSelectStrainParent, nFetchLitter )
.head 12 +  If sCountSex = 'W'
.head 13 -  Set sStrainF = sStrain
.head 12 +  If sCountSex = 'M'
.head 13 -  Set sStrainM = sStrain
.head 11 -  Call SqlExecute( hSqlSelectStrain )
.head 11 -  Call SqlFetchNext( hSqlSelectStrain, nFetchLitter )
.head 10 -  Set ColDateWeaned = dtDate
.head 10 +  Select Case ( SalDateWeekday ( dtDate  ) )
.head 11 +  Case 0
.head 12 -  Set ColWeekday = 'Saturday'
.head 12 -  Break
.head 11 +  Case 1
.head 12 -  Set ColWeekday = 'Sunday'
.head 12 -  Break
.head 11 +  Case 2
.head 12 -  Set ColWeekday= 'Monday'
.head 12 -  Break
.head 11 +  Case 3
.head 12 -  Set ColWeekday= 'Tuesday'
.head 12 -  Break
.head 11 +  Case 4
.head 12 -  Set ColWeekday= 'Wednesday'
.head 12 -  Break
.head 11 +  Case 5
.head 12 -  Set ColWeekday = 'Thursday'
.head 12 -  Break
.head 11 +  Case 6
.head 12 -  Set ColWeekday = 'Friday'
.head 12 -  Break
.head 11 +  Default
.head 12 -  Set ColWeekday = ''
.head 12 -  Break
.head 10 -  ! Call SalTblSetRowFlags( tblBreeding, nNewRow, ROW_New, FALSE )
.head 10 -  Set nNewRow = SalTblInsertRow( tblBreeding, TBL_MaxRow )
.head 10 -  Set dtAEDate = DATETIME_Null
.head 10 -  Set i = i + 1
.head 9 -  Call SalTblDeleteRow(tblBreeding, nNewRow, 0)
.head 7 +  If nTipy != 2 and nCount < nY
.head 8 -  Call pbDown.Disable(  )
.head 8 -  Call pbFinish.Disable(  )
.head 7 +  Else
.head 8 -  Call pbDown.Enable(  )
.head 8 -  Call pbFinish.Enable(  )
.head 7 +  If nPaype = 1
.head 8 +  If nTipy = 2 and nCount > nY+1
.head 9 -  Set nPaype = nPaype + 1
.head 8 +  Else
.head 9 -  Call pbUp.Disable(  )
.head 9 -  Call pbStart.Disable(  )
.head 7 +  Else
.head 8 -  Call pbUp.Enable(  )
.head 8 -  Call pbStart.Enable(  )
.head 7 +  If nTipy = 0
.head 8 -  Set sStrainC = "NULL"
.head 7 -  Call SqlDisconnect( hSqlSelectFamilyName )
.head 7 -  Call SqlDisconnect( hSqlSelectSexLitter )
.head 7 -  Call SqlDisconnect( hSqlSelectFamely )
.head 7 -  Call SqlDisconnect( hSqlSelectCage )
.head 7 -  Call SqlDisconnect( hSqlSelectStrainParent )
.head 7 -  Call SqlDisconnect( hSqlSelectStrain )
.head 7 -  Call ChengeColor(  )
.head 7 -  Call SalTblQueryLinesPerRow( tblBreeding, nFetchLitter )
.head 5 -  ! Call ChengeColor()
.head 5 -  Call VisWaitCursor(FALSE)
.head 3 +  Function: FocusRow
.head 4 -  Description:
.head 4 -  Returns
.head 4 +  Parameters
.head 5 -  Number: nCageNR
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nMinRow
.head 5 -  Number: nTempRow
.head 5 -  Window Handle: hWndFocus
.head 5 -  String: sStrain
.head 4 +  Actions
.head 5 +  If not nCageNR
.head 6 -  Return FALSE
.head 5 +  If nCageNR = ColCage_NR
.head 6 -  Return TRUE
.head 5 -  Call SalTblQueryFocus (tblBreeding, nTempRow, ColCage_NR)
.head 5 -  Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, FALSE )
.head 5 -  Set hWndFocus = SalGetFocus()
.head 5 -  Set nMinRow = TBL_MinRow
.head 5 +  Loop
.head 6 +  If SalTblFindNextRow ( tblBreeding, nMinRow, 0, 0)
.head 7 +  If nCageNR = SalStrToNumber( VisTblGetCell( tblBreeding, nMinRow, ColCage_NR ))
.head 8 -  Call SalTblSetFocusRow  (tblBreeding, nMinRow)
.head 8 -  Call SalTblSetRowFlags( tblBreeding, nMinRow, ROW_Selected, TRUE )
.head 8 -  Break
.head 6 +  Else
.head 7 -  Call SalTblSetFocusRow  (tblBreeding, nTempRow)
.head 7 -  Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, TRUE )
.head 7 -  Break
.head 5 -  Call ChengeColor()
.head 5 -  Call SalSetFocus( hWndFocus )
.head 3 +  Function: LoadSettings
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sRoom
.head 4 +  Actions
.head 5 -  Set dfDate =  frmAtlantaMain.tblFE.GetTime4Refresh()
.head 5 -  Set dfBatch = GetBatch( dfDate )
.head 5 -  Set dfStartDate = SalDateWeekBegin  ( dfDate )
.head 5 -  Set dfFinishDate = dfStartDate + 6
.head 5 -  Set cbWeanedLitter = GalGetProfileBooleanX( "BREEDINGBOOS", "WeanedLitter", TRUE, sUserINIFileName )
.head 5 -  Set cbUseInterval = GalGetProfileBooleanX( "BREEDINGBOOS", "UseInterval", TRUE, sUserINIFileName )
.head 5 -  Set sRoom = GalGetProfileStringX( "BREEDINGBOOS", "Room", "" , sUserINIFileName )
.head 5 +  If sRoom != STRING_Null
.head 6 -  Set dfRoom = SalStrToNumber( sRoom )
.head 5 -  Set dfDay = GalGetProfileNumberX( "BREEDINGBOOS", "Day", 21, sUserINIFileName )
.head 3 +  Function: SaveSettings
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sRoom
.head 4 +  Actions
.head 5 -  Call GalSetProfileBoolean("BREEDINGBOOS",'WeanedLitter', cbWeanedLitter, sUserINIFileName )
.head 5 -  Call GalSetProfileBoolean("BREEDINGBOOS",'UseInterval', cbUseInterval, sUserINIFileName )
.head 5 +  If dfRoom = NUMBER_Null
.head 6 -  Set sRoom = ""
.head 5 +  Else
.head 6 -  Set sRoom = SalNumberToStrX( dfRoom, 0 )
.head 5 -  Call GalSetProfileString( "BREEDINGBOOS", "Room", sRoom, sUserINIFileName )
.head 5 -  Call GalSetProfileNumber( "BREEDINGBOOS", "Day", dfDay, sUserINIFileName )
.head 3 +  Function: ChengeColor
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nMinRow
.head 5 -  Number: nP
.head 5 -  Number: nB
.head 5 -  Number: nTempRow
.head 5 -  Window Handle: hWndFocus
.head 4 +  Actions
.head 5 -  ! Set sStrain = ColStrain
.head 5 -  Call SalTblQueryFocus (tblBreeding, nTempRow, ColCage_NR)
.head 5 -  Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, FALSE )
.head 5 -  Set nMinRow = TBL_MinRow
.head 5 +  While nMinRow < TBL_MaxRow
.head 6 +  If SalTblFindNextRow ( tblBreeding, nMinRow, 0, 0)
.head 7 -  Call SalTblSetContext( tblBreeding, nMinRow )
.head 7 -  Set nP= SalColorGet(ColStrain, COLOR_IndexCellText )
.head 7 +  If sStrainC = ColStrain
.head 8 -  Call VisTblSetRowColorEx(tblBreeding, nMinRow, nP,COLOR_Yellow)
.head 7 +  Else
.head 8 -  Call VisTblSetRowColorEx(tblBreeding, nMinRow, nP, COLOR_White)
.head 7 +  If nSelectLID = colLitterID
.head 8 -  Call SalTblSetFocusRow  (tblBreeding, nMinRow)
.head 8 -  Call SalTblSetRowFlags( tblBreeding, nMinRow, ROW_Selected, TRUE )
.head 6 -  ! Set nMinRow = nMinRow + 1
.head 6 +  Else
.head 7 -  Break
.head 5 -  Call SalHideWindow( tblBreeding )
.head 5 -  Call SalShowWindow( tblBreeding )
.head 2 -  Window Parameters
.head 2 +  Window Variables
.head 3 -  Number: nCageNR
.head 3 -  Number: nMinRow
.head 3 -  Number: nTempRow
.head 3 -  String: sStrainC
.head 3 -  Number: nColor
.head 3 -  Number: nColorB
.head 3 -  Number: nX
.head 3 -  Number: nY
.head 3 -  Number: nStartD
.head 3 -  Number: nFinishD
.head 3 -  Number: nStartLID
.head 3 -  Number: nFinishLID
.head 3 -  Number: nPaype
.head 3 -  ! String: sStrain
.head 3 -  Number: nSelectLID
.head 3 -  Boolean: bRefresh
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call Initialize("")
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam , lParam )
.head 4 -  Call LoadSettings()
.head 4 -  ! Set dfDate =  frmAtlantaMain.lbKHELeft.GetTime4Refresh()
.head 4 -  ! Set dfDay = 21
.head 4 -  ! Set dfBatch = GetBatch( dfDate )
.head 4 -  ! Set dfStartDate = SalDateWeekBegin  ( dfDate )
.head 4 -  ! Set dfFinishDate = dfStartDate + 6
.head 4 -  Set sStrainC = "NULL"
.head 4 -  Set nPaype = 2
.head 4 -  Call Refresh(0)
.head 3 +  On SAM_Destroy
.head 4 -  Call SaveSettings(  )
.head 4 -  Set hWndBreedingBook = hWndNULL
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam , lParam )
.head 3 -  ! On SAM_Close
.head 3 +  On SAM_DoubleClick
.head 4 -  ! Set sStrain = ColStrain
.head 4 -  ! Call SalTblQueryFocus (tblBreeding, nTempRow, ColCage_NR)
.head 4 -  ! Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, FALSE )
.head 4 -  ! Set nMinRow = TBL_MinRow
.head 4 +  ! While nMinRow < TBL_MaxRow
.head 5 +  If SalTblFindNextRow ( tblBreeding, nMinRow, 0, 0)
.head 6 -  Call VisTblGetRowColor (tblBreeding, nMinRow, nColor, nColorB)
.head 6 +  If sStrain = ColStrain
.head 7 -  Call VisTblSetRowColorEx(tblBreeding, nMinRow-1, nColor, COLOR_Yellow)
.head 6 +  Else
.head 7 -  Call VisTblSetRowColorEx(tblBreeding, nMinRow-1, nColor, COLOR_White)
.head 5 -  ! Set nMinRow = nMinRow + 1
.head 5 +  Else
.head 6 -  Break
.head 4 -  ! Call SalTblSetFocusRow  (tblBreeding, nTempRow)
.head 4 -  ! Call SalTblSetRowFlags( tblBreeding, nTempRow, ROW_Selected, TRUE )
.head 4 -  Set nCageNR = ColCage_NR
.head 4 -  Call SalSendMsg( hWndStar2000 , AM_GoToCageNR, nCageNR, lParam )
.head 4 +  If cbWeanedLitter
.head 5 -  Call SalPostMsg( hWndStar2000 , AM_OpenDL, colLitterID, 0)
.head 3 +  On AM_Breeding_Focus
.head 4 -  Call FocusRow( wParam)
.head 3 +  On AM_Breeding_Refresh
.head 4 -  Call Refresh( 0 )
.head 3 +  On AM_Breeding_OpenDL
.head 4 +  If wParam = ColCage_NR and cbWeanedLitter
.head 5 -  Set hWndStar2000.nHandleForExclude = frmAtlantaMain.tblFE.nSelectedRow
.head 5 -  Call SalPostMsg( hWndStar2000 , AM_OpenDL, colLitterID, 0)
.head 3 +  On SAM_Click
.head 4 -  Call SalSendClassMessage( SAM_Click, wParam , lParam )
.head 4 -  Set sStrainC = ColStrain
.head 4 -  Set nSelectLID = colLitterID
.head 4 -  Call ChengeColor()
.head 3 +  On WM_FINISHMUVESIZE
.head 4 -  Call Refresh( 3 )
.head 4 -  ! Set bRefresh = FALSE
.head 1 +  Dialog Box: dlgQuestion
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title:
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? Class Default
.head 3 -  Docking Orientation: Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  3.438"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 0.958"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Vertical Scroll? Class Default
.head 3 -  Horizontal Scroll? Class Default
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbYES
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Yes
.head 4 -  Window Location and Size
.head 5 -  Left: 0.488"
.head 5 -  Top: 0.6"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalEndDialog( hWndForm, IDYES)
.head 5 +  On WM_KEYDOWN
.head 6 -  Call SalSendMsg( hWndForm, WM_KEYDOWN, wParam, lParam )
.head 3 +  Pushbutton: pbNO
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: No
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 0.604"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalEndDialog( hWndForm, IDNO)
.head 5 +  On WM_KEYDOWN
.head 6 -  Call SalSendMsg( hWndForm, WM_KEYDOWN, wParam, lParam )
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: 0.792"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: 0.792"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Multiline Field: mlQuestion
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsMultilineField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  String Type: Class Default
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Border? No
.head 5 -  Word Wrap? Yes
.head 5 -  Vertical Scroll? No
.head 5 -  Window Location and Size
.head 6 -  Left: 0.288"
.head 6 -  Top: 0.073"
.head 6 -  Width:  3.0"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.5"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_SetFocus
.head 6 -  ! Call SalSendMsg( hWndItem, SAM_KillFocus, 0, 0 )
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 +  On SAM_Create
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 -  On SAM_Activate
.head 5 +  On SAM_CreateComplete
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 +  On SAM_KillFocus
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 +  On WM_KEYDOWN
.head 6 -  Call SalSendMsg( hWndForm, WM_KEYDOWN, wParam, lParam )
.head 5 +  On WM_CHAR
.head 6 -  ! Set mlQuestion = sQuestion
.head 6 -  Return TRUE
.head 2 +  Functions
.head 3 +  Function: Scale
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nX
.head 5 -  Number: nY
.head 5 -  Number: nXPoz
.head 5 -  Number: nYPoz
.head 5 -  Number: nFontSize
.head 5 -  Number: nFontEnh
.head 5 -  String: sFontName
.head 5 -  Number: nSize
.head 5 -  Number: nW
.head 5 -  Number: nH
.head 4 +  Actions
.head 5 -  Set nScale = GetOptionNumberUW("Dialogs", "Scale dialog", 1 )
.head 5 -  Set nSize = GetOptionNumberUW("dlgQuestion", "Size Font", 10 )
.head 5 -  Call SalGetWindowSize ( hWndForm, nX, nY )
.head 5 -  Set nX = 3.45
.head 5 -  Set nY = 1.38
.head 5 -  Call SalSetWindowSize ( hWndForm, nX*nScale, nY*nScale)

.head 5 -  Call SalGetWindowLoc( mlQuestion, nXPoz, nYPoz )
.head 5 -  Call SalSetWindowLoc( mlQuestion, nXPoz*nScale, nYPoz*nScale )
.head 5 -  Call SalGetWindowSize ( mlQuestion, nX, nY )
.head 5 -  Call SalSetWindowSize ( mlQuestion, nX*nScale, nY*nScale)
.head 5 -  Call SalFontGet(mlQuestion, sFontName, nFontSize, nFontEnh )
.head 5 -  Call SalFontSet ( mlQuestion, sFontName , nSize*nScale,  nFontEnh  )
.head 5 -  Set nW = nXPoz*nScale + nX*nScale
.head 5 -  !
.head 5 -  Call SalGetWindowLoc( pbYES, nXPoz, nYPoz )
.head 5 -  Call SalSetWindowLoc( pbYES, nXPoz*nScale, nYPoz*nScale )
.head 5 -  Call SalGetWindowSize ( pbYES, nX, nY )
.head 5 -  Call SalSetWindowSize ( pbYES, nX*nScale, nY*nScale)
.head 5 -  Call SalFontGet(pbYES, sFontName, nFontSize, nFontEnh )
.head 5 -  Call SalFontSet ( pbYES, sFontName , nSize*nScale,  nFontEnh   )
.head 5 -  Set nH = nYPoz*nScale + nY*nScale + 0.25
.head 5 -  !
.head 5 -  Call SalGetWindowLoc( pbNO, nXPoz, nYPoz )
.head 5 -  Call SalSetWindowLoc( pbNO, nXPoz*nScale, nYPoz*nScale )
.head 5 -  Call SalGetWindowSize ( pbNO, nX, nY )
.head 5 -  Call SalSetWindowSize ( pbNO, nX*nScale, nY*nScale)
.head 5 -  Call SalFontGet(pbNO, sFontName, nFontSize, nFontEnh )
.head 5 -  Call SalFontSet ( pbNO, sFontName , nSize*nScale,  nFontEnh   )
.head 5 -  ! Call SalSetWindowSize ( hWndForm, nW, nH)

.head 2 +  Window Parameters
.head 3 -  String: sQuestion
.head 2 +  Window Variables
.head 3 -  Boolean: bSpeachText
.head 3 -  Number: nScale
.head 2 +  Message Actions
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Call dlgQuestion.Hide(  )
.head 4 -  Call SalSetWindowText( dlgQuestion, "Service Workflow" )
.head 4 -  Call dlgQuestion.Scale(  )
.head 4 -  Call dlgQuestion.Show(  )
.head 4 -  Set mlQuestion = sQuestion
.head 4 -  ! Call SalSetFocus( pbYES )
.head 4 -  Set bSpeachText = GalGetProfileBooleanX( "System", "TextToSpeach", FALSE, sUserINIFileName )
.head 4 +  If bSpeachText
.head 5 -  Call StartSeparateEXE ('READ.EXE /name=Service')
.head 3 +  On SAM_Close
.head 4 -  Call SalGetWindowSize ( hWndForm, n1, n2 )
.head 4 -  Call SalSetWindowSize ( hWndForm, n1/nScale, n2/nScale )
.head 4 -  Call SalSendClassMessage( SAM_Close, wParam, lParam )
.head 3 +  On WM_KEYDOWN
.head 4 +  If wParam = VK_Y
.head 5 -  Call SalSendMsg( pbYES, SAM_Click, 0, 0 )
.head 4 +  If wParam = VK_N
.head 5 -  Call SalSendMsg( pbNO, SAM_Click, 0, 0 )
.head 1 +  Dialog Box: dlgQuestionMod
.head 2 -  Class: clsDialogOkCancel
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title:
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Modeless
.head 3 -  Allow Dock to Parent? Class Default
.head 3 -  Docking Orientation: Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  3.45"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.115"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Vertical Scroll? Class Default
.head 3 -  Horizontal Scroll? Class Default
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbYES
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Yes
.head 4 -  Window Location and Size
.head 5 -  Left: 0.488"
.head 5 -  Top: 0.74"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  ! Call SalPostMsg( SalParentWindow( hWndForm ), AM_Done_Close, 0, 1 )
.head 6 -  Set bPressButton = TRUE
.head 6 -  Call SalPostMsg( tblShowService, AM_Done_Close, 0, 1)
.head 6 -  Call SalSendMsg( hWndForm, SAM_Close, wParam,lParam )
.head 5 +  On WM_KEYDOWN
.head 6 -  Call SalSendMsg( hWndForm, WM_KEYDOWN, wParam, lParam )
.head 3 +  Pushbutton: pbNO
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsPushbutton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: No
.head 4 -  Window Location and Size
.head 5 -  Left: 1.688"
.head 5 -  Top: 0.74"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  ! Call SalPostMsg( SalParentWindow( hWndForm ), AM_Done_Close, 0, 0)
.head 6 -  Set bPressButton = TRUE
.head 6 -  Call SalPostMsg( tblShowService, AM_Done_Close, 0, 0)
.head 6 -  Call SalSendMsg( hWndForm, SAM_Close, wParam,lParam )
.head 5 +  On WM_KEYDOWN
.head 6 -  Call SalSendMsg( hWndForm, WM_KEYDOWN, wParam, lParam )
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: 0.792"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDialogOkCancel
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: 0.792"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? No
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Multiline Field: mlQuestion
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsMultilineField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Class Default
.head 5 -  String Type: Class Default
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Border? No
.head 5 -  Word Wrap? Yes
.head 5 -  Vertical Scroll? No
.head 5 -  Window Location and Size
.head 6 -  Left: 0.288"
.head 6 -  Top: 0.073"
.head 6 -  Width:  3.1"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.667"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_SetFocus
.head 6 -  ! Call SalSendMsg( hWndItem, SAM_KillFocus, 0, 0 )
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 +  On SAM_Create
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 -  On SAM_Activate
.head 5 +  On SAM_CreateComplete
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 +  On SAM_KillFocus
.head 6 -  Call SalColorSet ( mlQuestion, COLOR_IndexWindow, SalColorGet ( hWndForm, COLOR_IndexWindow ))
.head 5 +  On WM_KEYDOWN
.head 6 -  Call SalSendMsg( hWndForm, WM_KEYDOWN, wParam, lParam )
.head 5 +  On WM_CHAR
.head 6 -  ! Set mlQuestion = sQuestion
.head 6 -  Return TRUE
.head 2 +  Functions
.head 3 +  Function: Scale
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nX
.head 5 -  Number: nY
.head 5 -  Number: nXPoz
.head 5 -  Number: nYPoz
.head 5 -  Number: nFontSize
.head 5 -  Number: nFontEnh
.head 5 -  String: sFontName
.head 5 -  Number: nSize
.head 5 -  Number: nW
.head 5 -  Number: nH
.head 4 +  Actions
.head 5 -  Set nScale = GetOptionNumberUW("Dialogs", "Scale dialog", 1 )
.head 5 -  Set nSize = GetOptionNumberUW("dlgQuestion", "Size Font", 10 )
.head 5 -  Call SalGetWindowSize ( hWndForm, nX, nY )
.head 5 -  Set nX = 3.45
.head 5 -  Set nY = 1.35
.head 5 -  Call SalSetWindowSize ( hWndForm, nX*nScale, nY*nScale)

.head 5 -  Call SalGetWindowLoc( mlQuestion, nXPoz, nYPoz )
.head 5 -  Call SalSetWindowLoc( mlQuestion, nXPoz*nScale, nYPoz*nScale )
.head 5 -  Call SalGetWindowSize ( mlQuestion, nX, nY )
.head 5 -  Call SalSetWindowSize ( mlQuestion, nX*nScale, nY*nScale)
.head 5 -  Call SalFontGet(mlQuestion, sFontName, nFontSize, nFontEnh )
.head 5 -  Call SalFontSet ( mlQuestion, sFontName , nSize*nScale,  nFontEnh  )
.head 5 -  !
.head 5 -  Call SalGetWindowLoc( pbYES, nXPoz, nYPoz )
.head 5 -  Call SalSetWindowLoc( pbYES, nXPoz*nScale, nYPoz*nScale )
.head 5 -  Call SalGetWindowSize ( pbYES, nX, nY )
.head 5 -  Call SalSetWindowSize ( pbYES, nX*nScale, nY*nScale)
.head 5 -  Call SalFontGet(pbYES, sFontName, nFontSize, nFontEnh )
.head 5 -  Call SalFontSet ( pbYES, sFontName , nSize*nScale,  nFontEnh   )
.head 5 -  !
.head 5 -  Call SalGetWindowLoc( pbNO, nXPoz, nYPoz )
.head 5 -  Call SalSetWindowLoc( pbNO, nXPoz*nScale, nYPoz*nScale )
.head 5 -  Call SalGetWindowSize ( pbNO, nX, nY )
.head 5 -  Call SalSetWindowSize ( pbNO, nX*nScale, nY*nScale)
.head 5 -  Call SalFontGet(pbNO, sFontName, nFontSize, nFontEnh )
.head 5 -  Call SalFontSet ( pbNO, sFontName , nSize*nScale,  nFontEnh   )
.head 5 -  ! Call SalSetWindowSize ( hWndForm, nW, nH)

.head 2 +  Window Parameters
.head 3 -  String: sQuestion
.head 2 +  Window Variables
.head 3 -  Boolean: bSpeachText
.head 3 -  Boolean: bPressButton
.head 3 -  Number: nScale
.head 2 +  Message Actions
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Set bPressButton = FALSE
.head 4 -  Call dlgQuestionMod.Hide(  )
.head 4 -  Call dlgQuestionMod.Scale(  )
.head 4 -  Call SalSetWindowText( dlgQuestionMod, "Service Workflow" )
.head 4 -  Call dlgQuestionMod.Show(  )
.head 4 -  Set mlQuestion = sQuestion
.head 4 -  ! Call SalSetFocus( pbYES )
.head 4 -  Set hQuestionDialog = hWndForm
.head 4 -  Set bSpeachText = GalGetProfileBooleanX( "System", "TextToSpeach", FALSE, sUserINIFileName )
.head 4 +  If bSpeachText
.head 5 -  Call StartSeparateEXE ('READ.EXE /name=Service')
.head 3 +  On SAM_Destroy
.head 4 -  Set hQuestionDialog = hWndNULL
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 3 +  On WM_KEYDOWN
.head 4 +  If wParam = VK_Y
.head 5 -  Call SalSendMsg( pbYES, SAM_Click, 0, 0 )
.head 4 +  If wParam = VK_N
.head 5 -  Call SalSendMsg( pbNO, SAM_Click, 0, 0 )
.head 3 +  On WM_CHAR
.head 4 -  ! Set mlQuestion = sQuestion
.head 4 -  Return TRUE
.head 3 +  On SAM_Close
.head 4 -  Call SalGetWindowSize ( hWndForm, n1, n2 )
.head 4 -  Call SalSetWindowSize ( hWndForm, n1/nScale, n2/nScale )
.head 4 +  If not bPressButton
.head 5 -  Call SalPostMsg( tblShowService, AM_Done_Close, 0, IDTERMINATE)
.head 4 -  Call SalSendClassMessage( SAM_Close, wParam, lParam )
.head 1 +  Table Window: tblShowService
.head 2 -  Class: clsTableBrowse
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 144
.head 2 -  Icon File:
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Visible at Design time? Yes
.head 3 -  Automatically Created at Runtime? Class Default
.head 3 -  Initial State: Class Default
.head 3 -  Maximizable? Class Default
.head 3 -  Minimizable? Class Default
.head 3 -  System Menu? Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  9.717"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 2.94"
.head 4 -  Height Editable? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  View: Class Default
.head 3 -  Allow Row Sizing? Class Default
.head 3 -  Lines Per Row: Class Default
.head 3 -  Allow Child Docking? Class Default
.head 3 -  Docking Orientation: Class Default
.head 2 -  Memory Settings
.head 3 -  Maximum Rows in Memory: Class Default
.head 3 -  Discardable? Class Default
.head 2 -  Description:
.head 2 -  Named Menus
.head 2 -  Menu
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 +  Contents
.head 4 +  Pushbutton: pbExit
.head 5 -  Class Child Ref Key: 21
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 1
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbRefresh
.head 5 -  Class Child Ref Key: 20
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 2
.head 5 -  Window Location and Size
.head 6 -  Left: 1.963"
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbFirst
.head 5 -  Class Child Ref Key: 16
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 3
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbPrev
.head 5 -  Class Child Ref Key: 17
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 4
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbNext
.head 5 -  Class Child Ref Key: 18
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 5
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbLast
.head 5 -  Class Child Ref Key: 19
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsTableBrowse
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 6
.head 5 -  Window Location and Size
.head 6 -  Left: Class Default
.head 6 -  Top: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 -  Message Actions
.head 4 +  Pushbutton: pbFinish
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsHintedPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 7
.head 5 -  Window Location and Size
.head 6 -  Left: 0.375"
.head 6 -  Top: 0.02"
.head 6 -  Width:  0.35"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.29"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name: OK.BMP
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage(SAM_Create, wParam, lParam)
.head 7 -  Set sHint = "Mark as finished"
.head 6 +  On SAM_Click
.head 7 -  Set nCurrentRow = TBL_MinRow
.head 7 +  If SalTblFindNextRow( tblShowService, nCurrentRow,ROW_Edited , 0 )
.head 8 -  Call MarkFinished()
.head 7 +  Else
.head 8 -  Call SalMessageBox( 'You need to select at least one of the lines!', 'Message', 0 )
.head 4 +  Pushbutton: pbSelect
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbuttonMarkSelect
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 8
.head 5 -  Window Location and Size
.head 6 -  Left: 1.05"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 7 -  Set strStatusText = GetMessageXX( 1236, 'Markierung aller ausgewhlten Zeilen', sGhsMSG_Hint_FileName )
.head 7 -  Set sHint = strStatusText
.head 4 +  Pushbutton: pbSelectAll
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbuttonMarkSelectAll
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 9
.head 5 -  Window Location and Size
.head 6 -  Left: 0.75"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 7 -  Set strStatusText = GetMessageXX( 1235, 'Markierung aller Zeilen', sGhsMSG_Hint_FileName )
.head 7 -  Set sHint = strStatusText
.head 4 +  Pushbutton: pbUnselect
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbuttonMarkUnselect
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 10
.head 5 -  Window Location and Size
.head 6 -  Left: 1.35"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 7 -  Set strStatusText = GetMessageXX( 1237, 'Entmarkierung aller ausgewhlten Zeilen', sGhsMSG_Hint_FileName )
.head 7 -  Set sHint = strStatusText
.head 4 +  Pushbutton: pbUnselectAll
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbuttonMarkUnselectAll
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 11
.head 5 -  Window Location and Size
.head 6 -  Left: 1.65"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 7 -  Set strStatusText = GetMessageXX( 1238, 'Entmarkierung aller Zeilen', sGhsMSG_Hint_FileName )
.head 7 -  Set sHint = strStatusText
.head 4 -  Background Text: 12
.head 5 -  Resource Id: 26333
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsBackgroundText
.head 5 -  Window Location and Size
.head 6 -  Left: 2.988"
.head 6 -  Top: 0.07"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Justify: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 4 +  Data Field: dfDateService
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsDataFieldDateTime
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Data
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Editable? Class Default
.head 5 -  Display Settings
.head 6 -  Window Location and Size
.head 7 -  Left: 3.788"
.head 7 -  Top: 0.021"
.head 7 -  Width:  1.8"
.head 7 -  Width Editable? Class Default
.head 7 -  Height: Class Default
.head 7 -  Height Editable? Class Default
.head 6 -  Visible? Class Default
.head 6 -  Border? Class Default
.head 6 -  Justify: Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Font Name: Class Default
.head 6 -  Font Size: Class Default
.head 6 -  Font Enhancement: Class Default
.head 6 -  Text Color: Class Default
.head 6 -  Background Color: Class Default
.head 6 -  Input Mask: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 7 -  Set dfDateService = dtWorkDate
.head 6 +  On SAM_AnyEdit
.head 7 -  Call SalSendMsg( pbMedRecord, AM_Refresh, wParam, lParam )
.head 6 +  ! On SAM_Validate
.head 7 +  If dfDateService != dtWorkDate
.head 8 -  Call SalSendClassMessage( SAM_Validate, wParam, lParam )
.head 8 -  Set dtWorkDate =dfDateService
.head 8 -  Call SalSendMsg( tblShowService, AM_Refresh, wParam, lParam)
.head 4 -  Background Text: 13
.head 5 -  Resource Id: 7569
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class:
.head 5 -  Window Location and Size
.head 6 -  Left: 3.688"
.head 6 -  Top: 0.094"
.head 6 -  Width:  0.8"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.167"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? No
.head 5 -  Justify: Left
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 4 +  Pushbutton: pbMedRecord
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPushbutton
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 14
.head 5 -  Window Location and Size
.head 6 -  Left: 2.35"
.head 6 -  Top: 0.021"
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name: MR_FORM.BMP
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Click
.head 7 -  Set bPressMDRecord=TRUE
.head 7 -  Call Show_Medical_Records( tblShowService.ColFall, tblShowService.ColNr  )
.head 6 +  On AM_Refresh
.head 7 +  If Check_Medical_Records( hSessionServices,  tblShowService.ColFall, tblShowService.ColNr  )
.head 8 -  Call pbMedRecord.Enable(  )
.head 7 +  Else
.head 8 -  Call pbMedRecord.Disable(  )
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage(SAM_Create, wParam, lParam)
.head 7 -  Call pbMedRecord.Disable(  )
.head 4 +  Pushbutton: pbCancel
.head 5 -  Class Child Ref Key: 0
.head 5 -  Class ChildKey: 0
.head 5 -  Class: clsPbDelete
.head 5 -  Property Template:
.head 5 -  Class DLL Name:
.head 5 -  Title: 15
.head 5 -  Window Location and Size
.head 6 -  Left: 2.688"
.head 6 -  Top: 0.021"
.head 6 -  Width:  0.3"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: Class Default
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Keyboard Accelerator: Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Picture File Name:
.head 5 -  Picture Transparent Color: Class Default
.head 5 -  Image Style: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  Button Appearance: Class Default
.head 5 +  Message Actions
.head 6 +  On SAM_Create
.head 7 -  Call SalSendClassMessage(SAM_Create, wParam, lParam)
.head 7 -  Set sHint = "Mark as canceled"
.head 6 +  On SAM_Click
.head 7 -  Set nCurrentRow = TBL_MinRow
.head 7 +  If SalTblFindNextRow( tblShowService, nCurrentRow,ROW_Edited , 0 )
.head 8 -  Call MarkCanceled()
.head 7 +  Else
.head 8 -  Call GalMessageBox( 'Message','You need to select at least one of the lines!',  MB_Ok)
.head 2 +  Contents
.head 3 +  Column: ColFall
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 16
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColRack
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 17
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColCage
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 18
.head 4 -  Visible? Yes
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: String
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColName
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 19
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  1.45"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColDescr
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 20
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  1.6"
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColComment
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 21
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Long String
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColUser
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 22
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColDate
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDateTimeColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 23
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColDate0
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDateTimeColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 24
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColDate1
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsDateTimeColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 25
.head 4 -  Visible? Class Default
.head 4 -  Editable? No
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 26
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColNr
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 27
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColType
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 28
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColWorklist
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 29
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: ColLitterId
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 30
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colChildNr
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 31
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Class Default
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 3 +  Column: colLstID
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsColumn
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Visible? No
.head 4 -  Editable? Class Default
.head 4 -  Maximum Data Length: Class Default
.head 4 -  Data Type: Number
.head 4 -  Justify: Class Default
.head 4 -  Width:  Class Default
.head 4 -  Width Editable? Class Default
.head 4 -  Format: Class Default
.head 4 -  Country: Class Default
.head 4 -  Input Mask: Class Default
.head 4 -  Cell Options
.head 5 -  Cell Type? Class Default
.head 5 -  Multiline Cell? Class Default
.head 5 -  Cell DropDownList
.head 6 -  Sorted? Class Default
.head 6 -  Vertical Scroll? Class Default
.head 6 -  Auto Drop Down? Class Default
.head 6 -  Allow Text Editing? Class Default
.head 5 -  Cell CheckBox
.head 6 -  Check Value:
.head 6 -  Uncheck Value:
.head 6 -  Ignore Case? Class Default
.head 4 -  List Values
.head 4 -  Message Actions
.head 2 +  Functions
.head 3 +  Function: MarkFinished
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! Sql Handle: hSql
.head 5 -  ! Number: nAct
.head 5 -  Sql Handle: hSqlLoc
.head 5 -  Number: nFetch
.head 5 -  Boolean: bOk
.head 5 -  Number: nDone
.head 4 +  Actions
.head 5 -  Set bOk = FALSE
.head 5 +  If not SqlCreateStatement( hSessionServices, hSqlLoc ) 
.head 6 -  Return FALSE
.head 5 +  If not bStartDone
.head 6 -  Set dtDt = hWndKHE.clsNewFE.GetTime4Refresh(  )
.head 6 -  Set nCurrentRow = TBL_MinRow
.head 6 -  Set hTemp= hWndKHE.clsNewFE.nSelectedRow
.head 5 -  Call SqlPrepare( hSqlLoc, "select Uniq_nr from gruppe where stat_key=:tblShowService.ColRack and gruppe_key=:tblShowService.ColCage into :nCageNR ")
.head 5 -  Set bStartDone = TRUE
.head 5 -  Set bWaitProcess = TRUE
.head 5 +  While (not bOk) and SalTblFindNextRow( tblShowService, nCurrentRow , ROW_Edited, 0 )
.head 6 -  Call SalTblSetContext( tblShowService, nCurrentRow  )
.head 6 -  Call SalTblSetFocusRow ( tblShowService, nCurrentRow )
.head 6 +  If ColType = "A" or ColType = "L"
.head 7 -  Call hWndKHE.clsNewFE.OpenPosByFallKey( ColFall )
.head 6 +  Else If ColType = "C"
.head 7 -  Call SqlExecute( hSqlLoc )
.head 7 -  Call SqlFetchNext( hSqlLoc, nFetch )
.head 7 +  If nCageNR>0
.head 8 -  Call hWndKHE.clsNewFE.GoToCageNR( nCageNR )
.head 6 -  Set nDone = DoneService_ForSession( hSessionServices, tblShowService.colLstID,tblShowService.ColFall, tblShowService.ColNr, dtDt, TRUE ,TRUE) 
.head 6 +  If nDone=0 or  nDone = WAIT_WEANWIDGET
.head 7 -  Set bStartDone = TRUE
.head 7 -  Set bOk = TRUE
.head 6 +  Else
.head 7 -  Set bStartDone = FALSE
.head 7 +  If hWndTblShowService = hWndNULL
.head 8 +  If SalIsWindowVisible( hWndRack2DView )
.head 9 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrp ))
.head 8 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 8 -  Break
.head 5 -  Set bWaitProcess = FALSE
.head 5 +  If hWndTblShowService != hWndNULL and  (not bOk)
.head 6 -  Set bStartDone = FALSE
.head 6 +  If hWndWorklist
.head 7 -  Call SalSendMsg( hWndWorklist, AM_Refresh, 0, 0 )
.head 6 -  Call SalSendMsg(hWndForm, AM_Refresh, 0, 0)
.head 6 -  Set hWndCurent = SalGetFocus(  )
.head 6 +  If SalIsWindowVisible( hWndRack2DView )
.head 7 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrp ))
.head 6 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 6 -  Call SalSetFocus( hWndCurent )
.head 6 +  If not SalTblAnyRows(tblShowService, 0,0)
.head 7 +  If VisWinIsWindow( hWnd_MR4Lst )
.head 8 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 8 -  Set bOk = TRUE
.head 7 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 6 +  Else
.head 7 -  Call SalSetFocus( tblShowService )
.head 7 -  Call SalTblSetContext( tblShowService, 0 )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, 0 )
.head 5 +  Else
.head 6 +  If SalIsWindowVisible( hWndRack2DView )
.head 7 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrp ))
.head 6 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 5 -  Return bOk
.head 3 +  Function: FindMRAndOpen
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Boolean: bFindServ
.head 4 +  Actions
.head 5 -  Set bFindServ = FALSE
.head 5 -  Set nCurrentRow = TBL_MinRow
.head 5 +  While SalTblFindNextRow(  tblShowService, nCurrentRow , 0, 0 )
.head 6 -  Call SalTblSetFocusRow ( tblShowService, nCurrentRow )
.head 6 -  Call SalTblSetContext( tblShowService, nCurrentRow  )
.head 6 +  If Check_Medical_Records(hSessionServices, tblShowService.ColFall, tblShowService.ColNr )
.head 7 -  Set bFindServ = TRUE
.head 7 -  Break
.head 5 +  If bFindServ
.head 6 -  Return SalSendMsg( pbMedRecord, SAM_Click, wParam, lParam )
.head 5 +  Else
.head 6 -  Return TRUE
.head 3 +  Function: StartAutoDoneServices
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Boolean: bOk
.head 5 -  Sql Handle: hSqlCageName
.head 5 -  String: sCageName
.head 5 -  Number: nFetch
.head 5 -  Number: nDone
.head 4 +  Actions
.head 5 -  Set bOk = FALSE
.head 5 +  If not GalConnect (hSqlCageName)
.head 6 -  Set bOk = TRUE
.head 5 -  Call SqlPrepareAndExecute( hSqlCageName, "select X_POS_LABEL || Y_POS_LABEL 
					    from gruppe
					     where einricht_id=:nEinrichtId
					        and stat_key=:tblShowService.ColRack
    					        and gruppe_key=:tblShowService.ColCage
    into :sCageName" ) 
.head 5 -  Call SqlFetchNext(hSqlCageName, nFetch)
.head 5 -  Call SqlDisconnect( hSqlCageName )
.head 5 +  If not bStartDone
.head 6 -  Set dtDt = hWndKHE.clsNewFE.GetTime4Refresh(  )
.head 6 -  Set nCurrentRow = TBL_MinRow
.head 6 -  Set hTemp= hWndKHE.clsNewFE.nSelectedRow
.head 5 -  Set bStartDone = TRUE
.head 5 -  Set bWaitProcess = TRUE
.head 5 +  While nReturnAsk !=IDTERMINATE  and (not bOk) and SalTblFindNextRow( tblShowService, nCurrentRow , 0, 0 )
.head 6 -  Call SalTblSetFocusRow ( tblShowService, nCurrentRow )
.head 6 -  Call SalTblSetContext( tblShowService, nCurrentRow  )
.head 6 +  If tblShowService.ColType = 'A'
.head 7 +  If bNotModal
.head 8 -  Call SalCreateWindow( dlgQuestionMod, hWndStar2000, "Do you want to apply " || tblShowService.ColDescr || " service to animal number " || SalNumberToStrX( tblShowService.ColFall, 0 ) ||"?")
.head 8 -  Set bOk = TRUE
.head 7 +  Else
.head 8 -  Set nReturnAsk =  GalMessageBox( "Service Workflow" ,   "Do you want to apply " || tblShowService.ColDescr || " service 
to animal number " || SalNumberToStrX( tblShowService.ColFall, 0 ) ||"?" , MB_YesNoCancelStop)
.head 8 +  If nReturnAsk = IDYES
.head 9 -  Set nDone = DoneService_ForSession( hSessionServices, tblShowService.colLstID,tblShowService.ColFall, tblShowService.ColNr, dtDt, TRUE ,TRUE)
.head 9 +  If nDone = 0 or nDone = WAIT_WEANWIDGET
.head 10 -  Set bOk = TRUE
.head 8 +  Else If nReturnAsk = IDSTOP
.head 9 -  Set nDone = StopServiceWithCheck(hSessionServices,tblShowService.ColFall, tblShowService.ColNr, "DELETE")
.head 8 +  Else If nReturnAsk = IDCANCEL
.head 9 -  Set nReturnAsk = IDTERMINATE
.head 6 +  Else
.head 7 +  If bNotModal
.head 8 -  Call SalCreateWindow( dlgQuestionMod, hWndStar2000, "Do you want to apply " || tblShowService.ColDescr || " service to cage " || sCageName || " in rack " || RemoveLead0( tblShowService.ColRack ) || " ?")
.head 8 -  Set bOk = TRUE
.head 7 +  Else
.head 8 -  Set nReturnAsk =  GalMessageBox( "Service Workflow" ,   "Do you want to apply " || tblShowService.ColDescr || " service 
to cage " || sCageName || " in rack " || RemoveLead0( tblShowService.ColRack ) || " ?" , MB_YesNoCancelStop)
.head 8 +  If nReturnAsk = IDYES
.head 9 -  Set nDone = DoneService_ForSession( hSessionServices, tblShowService.colLstID,tblShowService.ColFall, tblShowService.ColNr, dtDt, TRUE ,TRUE)
.head 9 +  If nDone = 0 or nDone = WAIT_WEANWIDGET
.head 10 -  Set bOk = TRUE
.head 8 +  Else If nReturnAsk = IDSTOP
.head 9 -  Set nDone = StopServiceWithCheck(hSessionServices,tblShowService.ColFall, tblShowService.ColNr, "DELETE")
.head 8 +  Else If nReturnAsk = IDCANCEL
.head 9 -  Set nReturnAsk = IDTERMINATE
.head 5 -  Set bWaitProcess = FALSE
.head 5 +  If not bOk
.head 6 -  Set bStartDone = FALSE
.head 6 -  Call SalSendMsg(hWndForm, AM_Refresh, 0, 0)
.head 6 +  If hWndWorklist
.head 7 -  Call SalSendMsg( hWndWorklist, AM_Refresh, 0, 0 )
.head 6 -  Set hWndCurent = SalGetFocus(  )
.head 6 +  If SalIsWindowVisible( hWndRack2DView )
.head 7 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrp ))
.head 6 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 6 -  Call SalSetFocus( hWndCurent )
.head 6 +  If VisWinIsWindow( hWnd_MR4Lst )
.head 7 -  Call SalSendMsg(hWnd_MR4Lst, SAM_Close, 0, 0)
.head 6 +  If nReturnAsk = IDTERMINATE
.head 7 -  Set nReturnAsk = 0
.head 7 -  Call SalPostMsg(hWndStar2000, AM_ToggleNewRow, 0, IDTERMINATE)
.head 6 +  Else
.head 7 -  Call SalPostMsg(hWndStar2000, AM_ToggleNewRow, 0, 0)
.head 6 +  If not SalTblAnyRows(tblShowService, 0,0)
.head 7 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 6 +  Else
.head 7 -  Call SalSetFocus( tblShowService )
.head 7 -  Call SalTblSetContext( tblShowService, 0  )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, 0 )
.head 7 -  Call SalSetFocus(hWndKHE)
.head 5 -  Return bOk
.head 3 +  Function: MarkCanceled
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Sql Handle: hSqlLoc
.head 5 -  Number: nFetch
.head 5 -  Boolean: bOk
.head 4 +  Actions
.head 5 -  Set bOk = TRUE
.head 5 +  If not GalConnect(hSqlLoc)
.head 6 -  Return FALSE
.head 5 +  If not SqlCreateStatement( hSessionServices , hSqlLoc ) 
.head 6 -  Return FALSE
.head 5 -  Set nCurrentRow = TBL_MinRow
.head 5 +  While (bOk) and SalTblFindNextRow( tblShowService, nCurrentRow , ROW_Edited, 0 )
.head 6 -  Call SalTblSetContext( tblShowService, nCurrentRow  )
.head 6 -  Call SalTblSetFocusRow ( tblShowService, nCurrentRow )
.head 6 -  Set bOk = StopServiceWithCheck(hSessionServices,tblShowService.ColFall, tblShowService.ColNr, "DELETE")
.head 5 +  If hWndTblShowService != hWndNULL and  bOk
.head 6 -  Set bStartDone = FALSE
.head 6 +  If hWndWorklist
.head 7 -  Call SalSendMsg( hWndWorklist, AM_Refresh, 0, 0 )
.head 6 -  Call SalSendMsg(hWndForm, AM_Refresh, 0, 0)
.head 6 -  Set hWndCurent = SalGetFocus(  )
.head 6 +  If SalIsWindowVisible( hWndRack2DView )
.head 7 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrp ))
.head 6 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 6 -  Call SalSetFocus( hWndCurent )
.head 6 +  If not SalTblAnyRows(tblShowService, 0,0)
.head 7 +  If VisWinIsWindow( hWnd_MR4Lst )
.head 8 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 8 -  Set bOk = TRUE
.head 7 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 6 +  Else
.head 7 -  Call SalSetFocus( tblShowService )
.head 7 -  Call SalTblSetContext( tblShowService, 0 )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, 0 )
.head 5 +  Else
.head 6 +  If SalIsWindowVisible( hWndRack2DView )
.head 7 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( sGrp ))
.head 6 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 5 -  Return bOk
.head 3 +  Function: Refresh
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Sql Handle: hSqlComent
.head 5 -  Sql Handle: hSqlPrepare
.head 5 -  Number: nNewRow
.head 5 -  Number: nFetch
.head 5 -  Boolean: bOk
.head 5 -  String: sSelect
.head 5 -  Number: nCageID
.head 5 -  Number: nRackID
.head 5 -  Number: nScrID
.head 5 -  Number: nLevelSelect
.head 4 +  Actions
.head 5 +  If SalTblAnyRows( tblShowService, 0, 0 )
.head 6 -  Set nNewRow = TBL_MaxRow
.head 6 -  Call SalTblFindPrevRow( tblShowService, nNewRow, 0, 0 )
.head 6 +  While nNewRow >= 0
.head 7 -  Call SalTblDeleteRow( tblShowService, nNewRow, TBL_NoAdjust )
.head 7 -  Call VisTblSetRowColorEx( tblShowService, nNewRow, COLOR_Black, COLOR_White)
.head 7 -  Set nNewRow = nNewRow - 1
.head 5 +  If not GalConnect(hSqlComent) or not GalConnect(hSqlPrepare)
.head 6 -  Set bOk = FALSE
.head 5 +  Else
.head 6 -  Set bOk = TRUE
.head 6 -  Call SqlPrepare( hSqlComent, "select le.IND_BEGR
			   from lst_erf le
			  where einricht_id= :nEinrichtId
     			        and fall_key=:tblShowService.ColFall
   			         and lst_erf_nr = :tblShowService.ColNr
			into :tblShowService.ColComment
 " )
.head 5 -  Set sTmp="  order by 17,6,7,1,16	     
 	    into :tblShowService.ColName,
	           :tblShowService.ColDescr,
	           :tblShowService.ColUser,
	         
	           :tblShowService.ColDate,
	           :tblShowService.ColID,
	           :tblShowService.ColFall,
	           :tblShowService.ColNr,
	           :tblShowService.ColDate0,
                           :tblShowService.ColDate1,
	           :tblShowService.ColCage,
                           :tblShowService.ColRack,
                           :tblShowService.ColType,
	         :tblShowService.sTmp1,
                           :tblShowService.ColWorklist,
        	           :tblShowService.ColLitterId,
	           :tblShowService.colChildNr,
	           :tblShowService.sTmp2,
	            :tblShowService.colLstID
                          	"
.head 5 -  Set nCageID = oPosData.nCageID
.head 5 -  Set nRackID = oPosData.nRackID
.head 5 -  Set nScrID = oPosData.nScreenID
.head 5 -  Set nLevelSelect = hWndKHE.clsNewFE.nSelectedLevel 
.head 5 +  If nLevelSelect = FEL_Cage
.head 6 -  Call SalSetWindowText( hWndForm, "Cage services" )
.head 5 +  Else If nLevelSelect = FEL_Pos
.head 6 -  Call SalSetWindowText( hWndForm, "Animal services" )
.head 5 +  Else If nLevelSelect = FEL_Rack
.head 6 -  Call SalSetWindowText( hWndForm, "Rack services" )
.head 5 +  ! If bOk
.head 6 -  ! Prepare and execute cages services
.head 6 +  If nLevelSelect = FEL_Cage
.head 7 +  If bPerformSevicesOnlyInWL
.head 8 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name, l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, 'C',l.ISALERT, l_e.lst_work_key,0,0,0, l.ID
                        from sysadm.lst_erf l_e left join  sysadm.benutzer b on b.benutzer_id=l_e.benutzer_id left join  sysadm.lst_work lw on lw.lst_work_key = l_e.lst_work_key,  sysadm.LEISTUNG l, sysadm.bewegung bew, sysadm.ben_abteilung ba
  	     where l_e.done!=1
                and  l_e.cage_id = :nCageID 
                and  l_e.lst_erf_von<= :tblShowService.dfDateService
                and  l_e.STORNIERT='N'
                and   l_e.lst_work_key is not null     
  	and  bew.fall_key = l_e.fall_key
                and  bew.einricht_id= l_e.einricht_id
                and  bew.BA_KEY not in ( 'AE', 'VE', 'UE', 'RE' )
                                         
   		and l.id=l_e.lst_id
                and @nullvalue(l.abt_key,'S') != 'SYSTEM' 
        

                and ba.benutzer_id = :nUserId
                and ba.einricht_id = l_e.einricht_id
                and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY"
.head 7 +  Else 
.head 8 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name, l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, 'C',l.ISALERT, l_e.lst_work_key,0,0,0,l.ID
                      from sysadm.lst_erf l_e , sysadm.benutzer b,  sysadm.LEISTUNG l, sysadm.bewegung bew, sysadm.ben_abteilung ba
  	     where l_e.done!=1
                and  l_e.cage_id = :nCageID 
                and  l_e.lst_erf_von<= :tblShowService.dfDateService
                and  l_e.STORNIERT='N'
                and  b.benutzer_id=l_e.benutzer_id
  	and  bew.fall_key = l_e.fall_key
                and  bew.einricht_id= l_e.einricht_id
                and  bew.BA_KEY not in ( 'AE', 'VE', 'UE', 'RE' )
                                         
   		and l.id =l_e.lst_id
                and @nullvalue(l.abt_key,'S') != 'SYSTEM' 
               
                and ba.benutzer_id = :nUserId
                and ba.einricht_id = l_e.einricht_id
                and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY"
.head 7 -  Set sSelect = sSelect || sTmp
.head 7 -  Call SqlPrepareAndExecute( hSqlPrepare, sSelect )
.head 7 +  Loop 
.head 8 -  Set nNewRow = SalTblInsertRow( tblShowService, TBL_MaxRow )
.head 8 -  Call SalTblSetFocusRow ( tblShowService, nNewRow )
.head 8 -  Call SalTblSetContext( tblShowService, nNewRow  )
.head 8 +  If SqlFetchNext( hSqlPrepare, nFetch )
.head 9 -  Call VisTblSetRowColorEx( tblShowService, nNewRow, COLOR_Black, COLOR_Sky)
.head 9 -  Call SqlExecute( hSqlComent )
.head 9 +  If tblShowService.ColCage = STRING_Null
.head 10 -  Set tblShowService.ColCage = oPosData.sCage
.head 9 +  If tblShowService.ColRack = STRING_Null
.head 10 -  Set tblShowService.ColRack = oPosData.sRack
.head 9 -  Call SqlFetchNext( hSqlComent, nFetch )
.head 9 -  Call SalTblSetRowFlags( tblShowService, nNewRow, ROW_New, FALSE )
.head 8 +  Else 
.head 9 -  Call SalTblDeleteRow( tblShowService, nNewRow, TBL_NoAdjust )
.head 9 -  Break 
.head 6 -  !
.head 6 -  ! Prepare and execute animal services
.head 6 +  If hWndKHE.clsNewFE.nSelectedLevel = KHEL_Gruppe
.head 7 +  If bPerformSevicesOnlyInWL
.head 8 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, @if(l_le.litter_id,'L','A'),l.ISALERT, 
l_e.lst_work_key, l_le.litter_id, l_le.child_nr,1,l.ID
     from sysadm.fall f, sysadm.lst_erf l_e left join sysadm.litter_lsterf l_le on  l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr left join  sysadm.lst_work lw on l_e.lst_work_key = lw.lst_work_key 
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where 
                f.last_cage_id = :nCageID
        and   f.geloescht = 'N'
        and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
       and   l_e.lst_work_key is not null                 
       and   l_e.done!=1
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
     
       and @nullvalue(l.abt_key,'S') != 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 

       and   l.id =l_e.lst_id
       and   l.tarif_key = l_e.tarif_key

        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
       "
.head 7 +  Else 
.head 8 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, @if(l_le.litter_id,'L','A'),l.ISALERT, 
l_e.lst_work_key, l_le.litter_id, l_le.child_nr,1,l.ID
  from sysadm.fall f, sysadm.lst_erf l_e left join sysadm.litter_lsterf l_le on  l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr 
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where 
                f.last_cage_id =  :nCageID
       and   f.geloescht = 'N'
       and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
          
       and   l_e.done!=1
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
     
       and @nullvalue(l.abt_key,'S') != 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 

       and   l.id =l_e.lst_id
        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
 "
.head 6 +  Else 
.head 7 +  If bPerformSevicesOnlyInWL
.head 8 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, @if(l_le.litter_id,'L','A'),l.ISALERT, 
l_e.lst_work_key, l_le.litter_id, l_le.child_nr,1, l.ID
     from sysadm.fall f, sysadm.lst_erf l_e left join sysadm.litter_lsterf l_le on  l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr left join  sysadm.lst_work lw on l_e.lst_work_key = lw.lst_work_key 
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where  f.fall_key =  :tblShowService.sBet
       and   f.last_cage_id= :nCageID 
       and   f.geloescht = 'N'
     
       and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
       and   l_e.lst_work_key is not null                 
       and   l_e.done!=1
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
     
       and @nullvalue(l.abt_key,'S') != 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 

       and   l.id =l_e.lst_id
      
        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
       "
.head 7 +  Else 
.head 8 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, @if(l_le.litter_id,'L','A'),l.ISALERT, 
l_e.lst_work_key, l_le.litter_id, l_le.child_nr,1,l.ID
     from sysadm.fall f, sysadm.lst_erf l_e left join sysadm.litter_lsterf l_le on  l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr 
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where  f.fall_key =  :tblShowService.sBet
       and   f.last_cage_id = :nCageID

       and   f.geloescht = 'N'

       and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
         
       and   l_e.done!=1
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
     
       and @nullvalue(l.abt_key,'S') != 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 

       and   l.id=l_e.lst_id
       

        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
 "
.head 6 -  Set sSelect = sSelect || sTmp
.head 6 -  Call SqlPrepareAndExecute( hSqlPrepare, sSelect )
.head 6 +  Loop 
.head 7 -  Set nNewRow = SalTblInsertRow( tblShowService, TBL_MaxRow )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, nNewRow )
.head 7 -  Call SalTblSetContext( tblShowService, nNewRow  )
.head 7 +  If SqlFetchNext( hSqlPrepare, nFetch )
.head 8 +  If ColType = 'A'
.head 9 -  Call VisTblSetRowColorEx( tblShowService, nNewRow, COLOR_Black, COLOR_LightGreen )
.head 8 +  Else If ColType = 'L'
.head 9 -  Call VisTblSetRowColorEx( tblShowService, nNewRow,COLOR_Black, COLOR_Yellow )
.head 9 -  Set ColDescr = "   " || ColDescr
.head 8 -  Call SqlExecute( hSqlComent )
.head 8 +  If tblShowService.ColCage = STRING_Null
.head 9 -  Set tblShowService.ColCage = oPosData.sCage
.head 8 +  If tblShowService.ColRack = STRING_Null
.head 9 -  Set tblShowService.ColRack = oPosData.sRack
.head 8 -  Call SqlFetchNext( hSqlComent, nFetch )
.head 8 -  Call SalTblSetRowFlags( tblShowService, nNewRow, ROW_New, FALSE )
.head 7 +  Else 
.head 8 -  Call SalTblDeleteRow( tblShowService, nNewRow, TBL_NoAdjust )
.head 8 -  Break 
.head 6 -  !
.head 6 -  ! Prepare and execute system services
.head 6 +  If hWndKHE.clsNewFE.nSelectedLevel = KHEL_Gruppe
.head 7 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, 'S',l.ISALERT, l_e.lst_work_key, 
0,0,2,l.ID
     from sysadm.fall f, sysadm.lst_erf l_e left join sysadm.litter_lsterf l_le on  l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr 
        , sysadm.benutzer b  ,sysadm. LEISTUNG l, sysadm.ben_abteilung ba
    where 
                f.last_cage_id = :nCageID
       and   f.geloescht = 'N'
       and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
                
       and   l_e.done!=1
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
     
       and @nullvalue(l.abt_key,'S') = 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 

       and   l.id =l_e.lst_id

        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
 "
.head 6 +  Else 
.head 7 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, 'S',l.ISALERT, l_e.lst_work_key, 
0,0,2, l.ID
     from sysadm.fall f, sysadm.lst_erf l_e left join sysadm.litter_lsterf l_le on  l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr 
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where  f.fall_key =  :tblShowService.sBet
       and   f.last_cage_id = :nCageID
    
       and   f.geloescht = 'N'
       
       and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
             
       and   l_e.done!=1
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
     
       and @nullvalue(l.abt_key,'S') = 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 

       and   l.id=l_e.lst_id
       and   l.tarif_key = l_e.tarif_key

        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
 "
.head 6 -  Set sSelect = sSelect || sTmp
.head 6 -  Call SqlPrepareAndExecute( hSqlPrepare, sSelect )
.head 6 +  Loop 
.head 7 -  Set nNewRow = SalTblInsertRow( tblShowService, TBL_MaxRow )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, nNewRow )
.head 7 -  Call SalTblSetContext( tblShowService, nNewRow  )
.head 7 +  If SqlFetchNext( hSqlPrepare, nFetch )
.head 8 -  Call VisTblSetRowColorEx( tblShowService, nNewRow, COLOR_Black, COLOR_LightGray )
.head 8 -  Call SqlExecute( hSqlComent )
.head 8 +  If tblShowService.ColCage = STRING_Null
.head 9 -  Set tblShowService.ColCage = oPosData.sCage
.head 8 +  If tblShowService.ColRack = STRING_Null
.head 9 -  Set tblShowService.ColRack = oPosData.sRack
.head 8 -  Call SqlFetchNext( hSqlComent, nFetch )
.head 8 -  Call SalTblSetRowFlags( tblShowService, nNewRow, ROW_New, FALSE )
.head 7 +  Else 
.head 8 -  Call SalTblDeleteRow( tblShowService, nNewRow, TBL_NoAdjust )
.head 8 -  Break 
.head 6 -  Call SqlDisconnect( hSqlComent )
.head 6 -  Call SqlDisconnect( hSqlPrepare )
.head 5 +  If bOk
.head 6 -  ! Prepare and execute animal services
.head 6 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, @if(l_le.litter_id,'L','A'),l.ISALERT, 
l_e.lst_work_key, l_le.litter_id, l_le.child_nr,1,l.ID
     from sysadm.fall f
join gruppe g on (g.id=f.last_cage_id)
, sysadm.lst_erf l_e 
left join sysadm.litter_lsterf l_le on  (l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr)
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where 1=1 "
.head 6 +  If nLevelSelect = FEL_Pos
.head 7 -  Set sSelect = sSelect || "
and f.fall_key=:tblShowService.sBet 
and g.id = :nCageID"
.head 6 +  Else If nLevelSelect = FEL_Cage
.head 7 -  Set sSelect = sSelect || "
and g.id = :nCageID"
.head 6 +  Else If nLevelSelect = FEL_Rack
.head 7 -  Set sSelect = sSelect || "
and g.rack_id = :nRackID
and f.last_scr_id=:nScrID "
.head 6 -  Set sSelect = sSelect || " and   f.geloescht = 'N'
        and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null                
       and   l_e.done=0
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
       and   b.benutzer_id=l_e.benutzer_id 
       and   l.id =l_e.lst_id
       and   l.tarif_key = l_e.tarif_key
        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY"
.head 6 +  If bPerformSevicesOnlyInWL 
.head 7 -  Set sSelect = sSelect || "
and   l_e.lst_work_key is not null   "
.head 6 +  Else
.head 7 -  Set sSelect = sSelect || "
and @nullvalue(l.abt_key,'S') != 'SYSTEM'   "
.head 6 -  Set sSelect = sSelect || sTmp
.head 6 -  Call SqlPrepareAndExecute( hSqlPrepare, sSelect )
.head 6 +  Loop
.head 7 -  Set nNewRow = SalTblInsertRow( tblShowService, TBL_MaxRow )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, nNewRow )
.head 7 -  Call SalTblSetContext( tblShowService, nNewRow  )
.head 7 +  If SqlFetchNext( hSqlPrepare, nFetch )
.head 8 +  If ColType = 'A'
.head 9 -  Call VisTblSetRowColorEx( tblShowService, nNewRow, COLOR_Black, COLOR_LightGreen )
.head 8 +  Else If ColType = 'L'
.head 9 -  Call VisTblSetRowColorEx( tblShowService, nNewRow,COLOR_Black, COLOR_Yellow )
.head 9 -  Set ColDescr = "   " || ColDescr
.head 8 -  Call SqlExecute( hSqlComent )
.head 8 +  If tblShowService.ColCage = STRING_Null
.head 9 -  Set tblShowService.ColCage = oPosData.sCage
.head 8 +  If tblShowService.ColRack = STRING_Null
.head 9 -  Set tblShowService.ColRack = oPosData.sRack
.head 8 -  Call SqlFetchNext( hSqlComent, nFetch )
.head 8 -  Call SalTblSetRowFlags( tblShowService, nNewRow, ROW_New, FALSE )
.head 7 +  Else
.head 8 -  Call SalTblDeleteRow( tblShowService, nNewRow, TBL_NoAdjust )
.head 8 -  Break
.head 6 -  ! Prepare and execute system services
.head 6 -  Set sSelect = " select distinct l.LST_KEY, l.lst_bez,b.benutzer_name,  l_e.LST_ERF_VON, l_e.lst_key, l_e.fall_key, l_e.lst_erf_nr, l_e.LST_ERF_VON, l_e.LST_ERF_VON, l_e.gruppe_key, l_e.STAT_KEY, 'S',l.ISALERT, l_e.lst_work_key, 
0,0,2, l.ID
     from sysadm.fall f
join gruppe g on (g.id=f.last_cage_id), sysadm.lst_erf l_e 
left join sysadm.litter_lsterf l_le on  (l_le.einricht_id=l_e.einricht_id and l_le.fall_key=l_e.fall_key and l_le.lst_erf_nr=l_e.lst_erf_nr) 
        , sysadm.benutzer b  , sysadm.LEISTUNG l, sysadm.ben_abteilung ba
    where  1=1"
.head 6 +  If nLevelSelect = FEL_Pos
.head 7 -  Set sSelect = sSelect || "
and f.fall_key=:tblShowService.sBet 
and g.id = :nCageID"
.head 6 +  Else If nLevelSelect = FEL_Cage
.head 7 -  Set sSelect = sSelect || "
and g.id = :nCageID"
.head 6 +  Else If nLevelSelect = FEL_Rack
.head 7 -  Set sSelect = sSelect || "
and g.rack_id = :nRackID
and f.last_scr_id=:nScrID "
.head 6 -  Set sSelect = sSelect || "
       and   f.geloescht = 'N'
       and   l_e.fall_key=f.fall_key
       and   l_e.einricht_id = f.einricht_id
       and   l_e.tarif_key is not null
       and   l_e.done=0
       and   l_e.lst_erf_von<=:tblShowService.dfDateService
       and   l_e.STORNIERT='N'
       and @nullvalue(l.abt_key,'S') = 'SYSTEM' 
       and   b.benutzer_id=l_e.benutzer_id 
       and   l.id=l_e.lst_id
       and   l.tarif_key = l_e.tarif_key
        and ba.benutzer_id = :nUserId
        and ba.einricht_id = l_e.einricht_id
        and @nullvalue(l.abt_key,ba.ABT_KEY) = ba.ABT_KEY
 "
.head 6 -  Set sSelect = sSelect || sTmp
.head 6 -  Call SqlPrepareAndExecute( hSqlPrepare, sSelect )
.head 6 +  Loop
.head 7 -  Set nNewRow = SalTblInsertRow( tblShowService, TBL_MaxRow )
.head 7 -  Call SalTblSetFocusRow ( tblShowService, nNewRow )
.head 7 -  Call SalTblSetContext( tblShowService, nNewRow  )
.head 7 +  If SqlFetchNext( hSqlPrepare, nFetch )
.head 8 -  Call VisTblSetRowColorEx( tblShowService, nNewRow, COLOR_Black, COLOR_LightGray )
.head 8 -  Call SqlExecute( hSqlComent )
.head 8 +  If tblShowService.ColCage = STRING_Null
.head 9 -  Set tblShowService.ColCage = oPosData.sCage
.head 8 +  If tblShowService.ColRack = STRING_Null
.head 9 -  Set tblShowService.ColRack = oPosData.sRack
.head 8 -  Call SqlFetchNext( hSqlComent, nFetch )
.head 8 -  Call SalTblSetRowFlags( tblShowService, nNewRow, ROW_New, FALSE )
.head 7 +  Else
.head 8 -  Call SalTblDeleteRow( tblShowService, nNewRow, TBL_NoAdjust )
.head 8 -  Break
.head 6 -  Call SqlDisconnect( hSqlComent )
.head 6 -  Call SqlDisconnect( hSqlPrepare )
.head 5 -  Call SalTblDefineRowHeader( tblShowService, "" , 20 , TBL_RowHdr_Visible | TBL_RowHdr_MarkEdits , hWndForm)
.head 5 -  Return bOk
.head 2 +  Window Parameters
.head 3 -  Boolean: bNotModal
.head 2 +  Window Variables
.head 3 -  String: sSqlStr
.head 3 -  String: sTmp
.head 3 -  String: sAbt
.head 3 -  String: sStat
.head 3 -  Number: sBet
.head 3 -  String: sGrp
.head 3 -  FunctionalVar: oPosData
.head 4 -  Class: cPositionData
.head 3 -  Date/Time: dtWorkDate
.head 3 -  Number: nCurrentRow
.head 3 -  Boolean: bStartDone
.head 3 -  Boolean: bPressMDRecord
.head 3 -  Window Handle: hWndCurent
.head 3 -  Number: nActSelectOne
.head 3 -  Number: nActUnSelectOne
.head 3 -  Sql Handle: hSql
.head 3 -  Number: nFetch
.head 3 -  Date/Time: dtDt
.head 3 -  Number: hTemp
.head 3 -  Number: nCageNR
.head 3 -  Number: nDoneService
.head 3 -  Number: nReturnAsk
.head 3 -  Sql Handle: hSqlCagesServ
.head 3 -  Sql Handle: hSqlAnimalServ
.head 3 -  Sql Handle: hSqlLitterServ
.head 3 -  Sql Handle: hSqlSystemServ
.head 3 -  Sql Handle: hSqlAnimalServ1
.head 3 -  Sql Handle: hSqlLitterServ1
.head 3 -  Sql Handle: hSqlSystemServ1
.head 3 -  !
.head 3 -  Sql Handle: hSessionServices
.head 3 -  String: sTmp1
.head 3 -  String: sTmp2
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Set bStartDone = FALSE
.head 4 -  Set nReturnAsk = 0
.head 4 -  Set bPressMDRecord= FALSE
.head 4 -  Call SalSendClassMessage( SAM_Create, 0, 0 )
.head 4 -  Call hWndKHE.clsNewFE._GetPositionID( hWndKHE.clsNewFE.nSelectedRow, oPosData )
.head 4 -  ! oPosData
.head 4 -  Set sBet = oPosData.nAnimalID
.head 4 -  Set dtWorkDate=hWndKHE.clsNewFE.GetTime4Refresh(  )
.head 4 -  Set nActSelectOne = VisWinLoadAccelerator( pbSelect, SAM_Click , KDS_Ctrl , VK_F3 , 0 )
.head 4 -  Set hWndTblShowService = hWndForm
.head 4 -  Call SqlCreateSession( hSessionServices, "" )
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage(SAM_CreateComplete, wParam, lParam )
.head 4 -  Call SalSendMsg(tblShowService , AM_Refresh, wParam, lParam )
.head 4 +  If bAutoShowTableSevices and sQuestionOnShowTableServices = "ON"
.head 5 -  Call SalTblSetFocusRow( tblShowService, 0 )
.head 5 -  Call StartAutoDoneServices()
.head 3 +  On AM_Refresh
.head 4 +  If bPressMDRecord
.head 5 -  Set bPressMDRecord= FALSE
.head 5 +  If SalIsWindowVisible( hWndRack2DView )
.head 6 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( oPosData.sCage ))
.head 5 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 4 +  If lParam
.head 5 -  Call hWndKHE.clsNewFE._GetPositionID( hWndKHE.clsNewFE.nSelectedRow, oPosData )
.head 4 -  Call Refresh()
.head 3 +  On SAM_RowHeaderClick
.head 4 -  Call SalSendClassMessage( SAM_RowHeaderClick, 0, 0 )
.head 4 -  Set nCurrentRow= TBL_MinRow
.head 4 +  If SalTblFindNextRow( tblShowService, nCurrentRow, ROW_Selected, 0 )
.head 5 +  If ColType = 'S'
.head 6 -  Call SalTblSetRowFlags( tblShowService, nCurrentRow, ROW_Edited, FALSE )
.head 5 +  Else
.head 6 +  If SalTblQueryRowFlags( tblShowService, nCurrentRow, ROW_Edited)
.head 7 -  Call SalTblSetRowFlags( tblShowService, nCurrentRow, ROW_Edited, FALSE )
.head 6 +  Else
.head 7 -  Call SalTblSetRowFlags( tblShowService, nCurrentRow, ROW_Edited, TRUE )
.head 3 +  On AM_Select
.head 4 -  Call SalTblQueryFocus( tblShowService, nCurrentRow,  hWndCurent)
.head 4 -  Call SalTblSetRowFlags( tblShowService, nCurrentRow, ROW_Edited, TRUE )
.head 3 +  On AM_SelectPosted
.head 4 -  Call SalWaitCursor( TRUE )
.head 4 -  Set nCurrentRow = TBL_MinRow
.head 4 +  Loop
.head 5 +  If not SalTblFindNextRow ( hWndItem, nCurrentRow, ROW_Selected, 0 )
.head 6 -  Break
.head 5 -  Call SalTblSetRowFlags( hWndItem, nCurrentRow, ROW_Edited, TRUE )
.head 5 -  Call SalTblSetRowFlags( hWndItem, nCurrentRow, ROW_Selected, FALSE )
.head 4 -  Call SalWaitCursor( FALSE )
.head 3 +  On AM_Unselect
.head 4 -  Call SalTblQueryFocus( tblShowService, nCurrentRow,  hWndCurent)
.head 4 -  Call SalTblSetRowFlags( tblShowService, nCurrentRow, ROW_Edited, FALSE )
.head 3 +  On AM_UnselectPosted
.head 4 -  Call SalWaitCursor( TRUE )
.head 4 -  Set nCurrentRow = TBL_MinRow
.head 4 +  Loop
.head 5 +  If not SalTblFindNextRow ( hWndItem, nCurrentRow, ROW_Selected, 0 )
.head 6 -  Break
.head 5 -  Call SalTblSetRowFlags( hWndItem, nCurrentRow, ROW_Edited, FALSE )
.head 5 -  Call SalTblSetRowFlags( hWndItem, nCurrentRow, ROW_Selected, FALSE )
.head 4 -  Call SalWaitCursor( FALSE )
.head 3 +  On AM_SelectAll
.head 4 -  Call SalSendMsg( hWndForm, AM_SelectAllPosted, 0, 0 )
.head 3 +  On AM_SelectAllPosted
.head 4 -  Call SalWaitCursor( TRUE )
.head 4 -  Set nCurrentRow = TBL_MinRow
.head 4 +  Loop
.head 5 +  If not SalTblFindNextRow ( hWndItem, nCurrentRow, 0, 0 )
.head 6 -  Break
.head 5 -  Call SalTblSetRowFlags( hWndItem, nCurrentRow, ROW_Edited, TRUE )
.head 4 -  !
.head 4 -  Call SalWaitCursor( FALSE )
.head 3 +  On AM_UnselectAll
.head 4 -  Call SalSendMsg( hWndForm, AM_UnselectAllPosted, 0, 0 )
.head 3 +  On AM_UnselectAllPosted
.head 4 -  Call SalWaitCursor( TRUE )
.head 4 -  Set nCurrentRow = TBL_MinRow
.head 4 +  Loop
.head 5 +  If not SalTblFindNextRow ( hWndItem, nCurrentRow, 0, 0 )
.head 6 -  Break
.head 5 -  Call SalTblSetRowFlags( hWndItem, nCurrentRow, ROW_Edited, FALSE )
.head 4 -  Call SalWaitCursor( FALSE )
.head 3 +  On SAM_Click
.head 4 -  Call SalSendMsg( pbMedRecord, AM_Refresh, wParam, lParam )
.head 3 +  On WM_LBUTTONDBLCLK
.head 4 -  Call SalSendMsg( pbMedRecord, AM_Refresh, wParam, lParam )
.head 4 +  If SalIsWindowEnabled(pbMedRecord)
.head 5 -  Call SalSendMsg( pbMedRecord, SAM_Click, 0, 0 )
.head 3 +  On SAM_Destroy
.head 4 +  If hSessionServices
.head 5 -  Call SqlFreeSession( hSessionServices )
.head 4 -  Set hWndTblShowService=hWndNULL
.head 4 -  Call VisWinFreeAccelerator( nActSelectOne )
.head 4 -  Call VisWinFreeAccelerator( nActUnSelectOne )
.head 4 +  If VisWinIsWindow(hQuestionDialog)
.head 5 -  Call SalSendMsg( hQuestionDialog, SAM_Close, 0, 0 )
.head 4 -  Call SalSendClassMessage( SAM_Destroy, 0, 0 )
.head 3 +  On AM_Done
.head 4 +  If bStartDone or lParam
.head 5 +  If hWndTblShowService != hWndNULL
.head 6 +  If bAutoShowTableSevices and sQuestionOnShowTableServices = "ON"
.head 7 -  Call StartAutoDoneServices()
.head 7 -  Return FALSE
.head 6 +  Else
.head 7 -  Call MarkFinished(  )
.head 7 -  Return FALSE
.head 4 +  Else If bPressMDRecord
.head 5 -  Set bPressMDRecord= FALSE
.head 5 -  Call SalSendMsg( tblShowService, AM_Refresh, wParam, lParam )
.head 5 -  Set hWndCurent = SalGetFocus(  )
.head 5 +  If SalIsWindowVisible( hWndRack2DView )
.head 6 -  Call SalSendMsg(hWndRack2DView, AM_Refresh, RACK2D_RefreshContent, SalHStringToNumber( oPosData.sCage ))
.head 5 -  Call SalSendMsg(hWndKHE, AM_KHE_ForcedPopulateCurrent, 0, 0)
.head 5 -  Call SalSetFocus( hWndCurent )
.head 5 +  If tblShowService.ColName=STRING_Null
.head 6 +  If VisWinIsWindow( hWnd_MR4Lst )
.head 7 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 7 -  Return TRUE
.head 6 -  Call SalSendMsg(tblShowService, SAM_Close, 0, 0)
.head 6 -  Return FALSE
.head 5 +  Else
.head 6 -  Call SalSetFocus( tblShowService )
.head 6 -  Call SalTblSetContext( tblShowService, 1  )
.head 6 -  Call SalTblSetFocusRow ( tblShowService, 1 )
.head 3 +  On AM_Update
.head 4 +  If not bStartDone
.head 5 -  ! Call SalSendClassMessage( AM_Update, wParam, lParam )
.head 3 +  On AM_Ok
.head 4 -  Call SalSendMsg( pbFinish, SAM_Click, wParam, lParam )
.head 3 +  On AM_Done_Close
.head 4 +  If bStartDone and hWndTblShowService != hWndNULL
.head 5 +  If lParam = 1
.head 6 -  Set nDoneService = DoneService_ForSession( hSessionServices, tblShowService.colLstID,tblShowService.ColFall, tblShowService.ColNr, dtDt, TRUE ,TRUE) 
.head 6 +  If nDoneService = 0 or nDoneService = WAIT_WEANWIDGET
.head 7 -  Return TRUE
.head 5 -  Set nReturnAsk = lParam
.head 5 +  If hWndTblShowService != hWndNULL
.head 6 -  Call StartAutoDoneServices(  )
.head 5 -  Return FALSE
.head 4 +  Else
.head 5 -  Return FALSE
.head 3 +  On AM_KHE_CloseGrp
.head 4 -  Call SalTblSetFocusRow( tblShowService, 0 )
.head 4 +  If SalNumberToHString( wParam ) = oPosData.sCage and SalNumberToHString( lParam ) = oPosData.sRack
.head 5 -  Call SalSendMsg( tblShowService, SAM_Close, 0, 0 )
.head 3 +  On AM_WidgetDone
.head 4 +  If hTemp != NUMBER_Null
.head 5 +  If Not SalListSetSelect( hWndKHE, hWndKHE.clsKHExplorerLeft.GetItemIndex( hTemp ) )
.head 6 -  Call hWndKHE.clsKHExplorerLeft.SetOutlineRedraw ( TRUE)
.head 5 +  Else
.head 6 -  Call hWndKHE.clsKHExplorerLeft.ActivateSelectedItem(  )
.head 4 +  If bStartDone
.head 5 +  If wParam = 1
.head 6 +  If not DoneServiceWithoutCheck(  tblShowService.ColName, tblShowService.ColFall, tblShowService.ColNr, dtDt, TRUE)
.head 7 -  Return TRUE
.head 5 -  Call SalSendMsg( hWndTblShowService, AM_Done, 0, 0 )
.head 3 +  On GM_NEED_TOOLBAR_RESIZE
.head 4 -  Return TRUE
.head 1 +  Dialog Box: dlgTransferCages
.head 2 -  Class: cDlgUseOption
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: 357
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? Class Default
.head 3 -  Docking Orientation: Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  6.238"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 2.146"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Vertical Scroll? Class Default
.head 3 -  Horizontal Scroll? Class Default
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDlgUseOption
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 1
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: Class Default
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 +  Message Actions
.head 5 +  On WM_KEYUP
.head 6 -  Return SalSendMsg(dlgTransferCages, WM_KEYUP, wParam, lParam)
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDlgUseOption
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: 2
.head 4 -  Window Location and Size
.head 5 -  Left: Class Default
.head 5 -  Top: Class Default
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Child Table: tblTransfer
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsChildTableBrowse
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left: -0.013"
.head 6 -  Top: -0.01"
.head 6 -  Width:  6.2"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 1.5"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Class Default
.head 5 -  Font Size: Class Default
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: Class Default
.head 5 -  View: Class Default
.head 5 -  Allow Row Sizing? Class Default
.head 5 -  Lines Per Row: Class Default
.head 4 -  Memory Settings
.head 5 -  Maximum Rows in Memory: Class Default
.head 5 -  Discardable? Class Default
.head 4 +  Contents
.head 5 +  Column: colScrFrom
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: 4
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRackFrom
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: 5
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCageFrom
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: 6
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colScrTo
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: 7
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colRackTo
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: 8
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 5 +  Column: colCageTo
.head 6 -  Class Child Ref Key: 0
.head 6 -  Class ChildKey: 0
.head 6 -  Class: clsColumn
.head 6 -  Property Template:
.head 6 -  Class DLL Name:
.head 6 -  Title: 9
.head 6 -  Visible? Class Default
.head 6 -  Editable? No
.head 6 -  Maximum Data Length: Class Default
.head 6 -  Data Type: Class Default
.head 6 -  Justify: Class Default
.head 6 -  Width:  Class Default
.head 6 -  Width Editable? Class Default
.head 6 -  Format: Class Default
.head 6 -  Country: Class Default
.head 6 -  Input Mask: Class Default
.head 6 -  Cell Options
.head 7 -  Cell Type? Class Default
.head 7 -  Multiline Cell? Class Default
.head 7 -  Cell DropDownList
.head 8 -  Sorted? Class Default
.head 8 -  Vertical Scroll? Class Default
.head 8 -  Auto Drop Down? Class Default
.head 8 -  Allow Text Editing? Class Default
.head 7 -  Cell CheckBox
.head 8 -  Check Value:
.head 8 -  Uncheck Value:
.head 8 -  Ignore Case? Class Default
.head 6 -  List Values
.head 6 -  Message Actions
.head 4 +  Functions
.head 5 +  Function: PopulateTabl
.head 6 -  Description: Repopulating table window contents from database
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 +  Local variables
.head 7 -  Number: nI
.head 7 -  Number: nMax
.head 7 -  Number: nRow
.head 6 +  Actions
.head 7 -  Call SalTblClearSelection( tblTransfer )
.head 7 -  Call SalArrayGetUpperBound(oSource,1,nMax)
.head 7 -  Set nI = 0
.head 7 +  While nI <= nMax
.head 8 -  Set nRow =  SalTblInsertRow( tblTransfer, TBL_MaxRow )
.head 8 -  Call SalTblSetContext( tblTransfer, nRow )
.head 8 -  Set colScrFrom = oSource[nI].sScreen
.head 8 -  Set colRackFrom = oSource[nI].sRack
.head 8 -  Set colCageFrom = oSource[nI].sCage
.head 8 -  Set colScrTo = oTarget[nI].sScreen
.head 8 -  Set colRackTo = oTarget[nI].sRack
.head 8 -  Set colCageTo = oTarget[nI].sCage
.head 8 -  Set nI = nI + 1
.head 7 -  Call SalTblSetFlagsAnyRows( tblTransfer, ROW_New	, FALSE, 0, 0 )
.head 4 -  Window Variables
.head 4 -  Message Actions
.head 3 -  Background Text: 3
.head 4 -  Resource Id: 9744
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.0"
.head 5 -  Top: 0.0"
.head 5 -  Width:  0.0"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.0"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Justify: Left
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 2 +  Functions
.head 3 +  Function: OK
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Return SalEndDialog( hWndForm, IDOK )
.head 3 +  Function: CANCEL
.head 4 -  Description:
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Return SalEndDialog( hWndForm, IDCANCEL )
.head 2 +  Window Parameters
.head 3 -  FunctionalVar: oSource[*]
.head 4 -  Class: cPositionData
.head 3 -  FunctionalVar: oTarget[*]
.head 4 -  Class: cPositionData
.head 3 -  Number: nTypeTitle
.head 2 -  Window Variables
.head 2 +  Message Actions
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, 0, 0 )
.head 4 -  Call dlgTransferCages.SetTitleForm( nTypeTitle )
.head 4 -  Call tblTransfer.PopulateTabl()
.head 4 -  Call SalSetFocus(pbOk)
.head 3 +  On WM_KEYUP
.head 4 +  Select Case wParam
.head 5 +  Case VK_Enter
.head 6 +  If SalIsWindowEnabled(pbOk)
.head 7 -  Call SalSendMsg(pbOk , SAM_Click, 0, 0 )
.head 6 -  Break
.head 5 +  Case VK_Escape
.head 6 -  Call SalSendMsg(pbCancel, SAM_Click,0,0)
.head 6 -  Break
.head 5 +  ! Case VK_LEFT
.head 6 +  If SalIsWindowEnabled(pbPrev)
.head 7 -  Call SalSendMsg( pbPrev, SAM_Click ,wParam , lParam )
.head 6 -  Break
.head 5 +  ! Case VK_RIGHT
.head 6 +  If SalIsWindowEnabled(pbNext)
.head 7 -  Call SalSendMsg( pbNext, SAM_Click ,wParam , lParam )
.head 6 -  Break
.head 5 +  Default
.head 6 -  Break
.head 1 +  Form Window: frmDetailInfoInAE
.head 2 -  Class: clsSimpleForm
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Detail information
.head 2 -  Icon File:
.head 2 -  Accessories Enabled? No
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Automatically Created at Runtime? Class Default
.head 3 -  Initial State: Class Default
.head 3 -  Maximizable? No
.head 3 -  Minimizable? No
.head 3 -  Allow Child Docking? Class Default
.head 3 -  Docking Orientation: Class Default
.head 3 -  System Menu? Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  4.338"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 2.188"
.head 4 -  Height Editable? Class Default
.head 3 -  Form Size
.head 4 -  Width:  Class Default
.head 4 -  Height: Class Default
.head 4 -  Number of Pages: Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 2 -  Description:
.head 2 -  Named Menus
.head 2 -  Menu
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? No
.head 4 -  Size: Default
.head 4 -  Size Editable? Yes
.head 4 -  Docking Toolbar? No
.head 4 -  Toolbar Docking Orientation: Top | Bottom
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 -  Resizable? No
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Multiline Field: mlInfo
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsMultilineField
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 32000
.head 5 -  String Type: Long String
.head 5 -  Editable? No
.head 4 -  Display Settings
.head 5 -  Border? Class Default
.head 5 -  Word Wrap? Class Default
.head 5 -  Vertical Scroll? Class Default
.head 5 -  Window Location and Size
.head 6 -  Left: 0.088"
.head 6 -  Top: 0.073"
.head 6 -  Width:  0.6"
.head 6 -  Width Editable? Class Default
.head 6 -  Height: 0.333"
.head 6 -  Height Editable? Class Default
.head 5 -  Visible? Class Default
.head 5 -  Font Name: Courier New
.head 5 -  Font Size: 12
.head 5 -  Font Enhancement: Class Default
.head 5 -  Text Color: Class Default
.head 5 -  Background Color: 3D Highlight Color
.head 4 +  Message Actions
.head 5 +  On WM_RBUTTONDOWN
.head 6 -  Set hWndRighClickedItem = hWndItem
.head 6 -  Call SalTrackPopupMenu( hWndStar2000, 'menuCutCopyPaste', TPM_CursorX | TPM_CursorY, 0, 0 )
.head 6 -  Return 0
.head 2 +  Functions
.head 3 +  Function: Setsize
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nW
.head 5 -  Number: nH
.head 5 -  Number: nX1
.head 5 -  Number: nY1
.head 5 -  Number: nX2
.head 5 -  Number: nY2
.head 4 +  Actions
.head 5 -  Call GetClientRect( frmDetailInfoInAE, nX1, nY1, nX2, nY2 )
.head 5 -  Set nW = SalPixelsToFormUnits( frmDetailInfoInAE, (nX2-nX1), FALSE )
.head 5 -  Set nH = SalPixelsToFormUnits( frmDetailInfoInAE, (nY2-nY1), TRUE )
.head 5 -  ! Call SalGetWindowSize( frmDetailInfoInAE, nW, nH )
.head 5 -  Call SalSetWindowSize( mlInfo, nW, nH )
.head 5 -  Call SalSetWindowLoc( mlInfo, 0, 0 )
.head 3 +  Function: Load
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nSize
.head 5 -  String: sName
.head 5 -  Number: nEnh
.head 4 +  Actions
.head 5 -  ! Set sName = GetOptionStringUW( sSection, "Font_Name_Info", 'Courier New')
.head 5 -  ! Set nSize  = GetOptionNumberUW(sSection, "Font_Size_Info", 12  )
.head 5 -  ! Set nEnh = GetOptionNumberUW(sSection, "Font_Enh_Info", 0  )
.head 5 -  ! Call salsetf
.head 3 +  Function: SetTitle
.head 4 -  Description:
.head 4 -  Returns
.head 4 +  Parameters
.head 5 -  String: sTitle
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Call SalSetWindowText( hWndForm, sTitle )
.head 2 -  Window Parameters
.head 2 -  Window Variables
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalSendClassMessage( SAM_Create, wParam, lParam )
.head 4 -  Call SalSetWindowLoc( mlInfo, -0.15, -0.15 )
.head 4 -  ! Call Setsize()
.head 4 -  Call Load()
.head 4 -  Set hDetailInfoAE = hWndForm
.head 4 -  Call SalSendMsg(hWndStar2000, AM_KHE_RefreshBtn,27,1 )
.head 3 +  On SAM_Destroy
.head 4 -  Set hDetailInfoAE = hWndNULL
.head 4 -  Call SalSendMsg(hWndStar2000, AM_KHE_RefreshBtn,27,1 )
.head 4 -  Call SalSendClassMessage( SAM_Destroy, wParam, lParam )
.head 3 +  On WM_Size
.head 4 -  Call Setsize(  )
.head 1 +  Dialog Box: dlgAssignSlots
.head 2 -  Class: cDlgUseOption
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Assign/Unassign slots to current screen
.head 2 -  Accessories Enabled? Class Default
.head 2 -  Visible? Class Default
.head 2 -  Display Settings
.head 3 -  Display Style? Class Default
.head 3 -  Visible at Design time? Yes
.head 3 -  Type of Dialog: Class Default
.head 3 -  Allow Dock to Parent? Class Default
.head 3 -  Docking Orientation: Class Default
.head 3 -  Window Location and Size
.head 4 -  Left: Default
.head 4 -  Top: Default
.head 4 -  Width:  2.825"
.head 4 -  Width Editable? Class Default
.head 4 -  Height: 1.427"
.head 4 -  Height Editable? Class Default
.head 3 -  Absolute Screen Location? Class Default
.head 3 -  Font Name: Class Default
.head 3 -  Font Size: Class Default
.head 3 -  Font Enhancement: Class Default
.head 3 -  Text Color: Class Default
.head 3 -  Background Color: Class Default
.head 3 -  Resizable? Class Default
.head 3 -  Vertical Scroll? Class Default
.head 3 -  Horizontal Scroll? Class Default
.head 2 -  Description:
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Class Default
.head 4 -  Location? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Size: Class Default
.head 4 -  Size Editable? Class Default
.head 4 -  Docking Toolbar? Class Default
.head 4 -  Toolbar Docking Orientation: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Resizable? Class Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 +  Pushbutton: pbOk
.head 4 -  Class Child Ref Key: 1
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDlgUseOption
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 0.188"
.head 5 -  Top: 0.979"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Pushbutton: pbCancel
.head 4 -  Class Child Ref Key: 2
.head 4 -  Class ChildKey: 0
.head 4 -  Class: cDlgUseOption
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left: 1.488"
.head 5 -  Top: 0.979"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Keyboard Accelerator: Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: Class Default
.head 4 -  Image Style: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 -  Button Appearance: Class Default
.head 4 -  Message Actions
.head 3 +  Radio Button: rbHor
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsRadioButton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Horizontal
.head 4 -  Window Location and Size
.head 5 -  Left: 0.288"
.head 5 -  Top: 0.156"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Set nMode = 1
.head 6 -  Call SetButtons(  )
.head 6 -  Call SalSendMsg(hWndForm, AM_CGStart, 0, 0)
.head 3 +  Radio Button: rbVert
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsRadioButton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Vertically
.head 4 -  Window Location and Size
.head 5 -  Left: 0.288"
.head 5 -  Top: 0.406"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Set nMode = 2
.head 6 -  Call SetButtons(  )
.head 6 -  Call SalSendMsg(hWndForm, AM_CGStart, 0, 0)
.head 3 +  Radio Button: rbRect
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class: clsRadioButton
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title: Rectangle
.head 4 -  Window Location and Size
.head 5 -  Left: 0.288"
.head 5 -  Top: 0.656"
.head 5 -  Width:  Class Default
.head 5 -  Width Editable? Class Default
.head 5 -  Height: Class Default
.head 5 -  Height Editable? Class Default
.head 4 -  Visible? Class Default
.head 4 -  Font Name: Class Default
.head 4 -  Font Size: Class Default
.head 4 -  Font Enhancement: Class Default
.head 4 -  Text Color: Class Default
.head 4 -  Background Color: Class Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Set nMode = 3
.head 6 -  Call SetButtons(  )
.head 6 -  Call SalSendMsg(hWndForm, AM_CGStart, 0, 0)
.head 2 +  Functions
.head 3 +  Function: SetButtons
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 +  If nMode = 1
.head 6 -  Set rbHor = TRUE
.head 6 -  Set rbVert = FALSE
.head 6 -  Set rbRect = FALSE
.head 5 +  Else If nMode = 2
.head 6 -  Set rbHor = FALSE
.head 6 -  Set rbVert = TRUE
.head 6 -  Set rbRect = FALSE
.head 5 +  Else If nMode = 3
.head 6 -  Set rbHor = FALSE
.head 6 -  Set rbVert = FALSE
.head 6 -  Set rbRect = TRUE
.head 5 +  Else
.head 6 -  Set rbHor = FALSE
.head 6 -  Set rbVert = FALSE
.head 6 -  Set rbRect = FALSE
.head 2 +  Window Parameters
.head 3 -  Number: nFlag
.head 3 -  Boolean: bVirt
.head 3 -  Receive Number: nMode
.head 2 -  Window Variables
.head 2 +  Message Actions
.head 3 +  On SAM_CreateComplete
.head 4 -  Call SalSendClassMessage( SAM_CreateComplete, wParam, lParam )
.head 4 -  Set nMode = - 1
.head 4 +  If not (nFlag&1)
.head 5 -  Call rbHor.Disable(  )
.head 4 +  Else
.head 5 -  Set nMode = 1
.head 4 +  If not (nFlag&2)
.head 5 -  Call rbVert.Disable(  )
.head 4 +  Else
.head 5 +  If nMode = - 1
.head 6 -  Set nMode = 2
.head 4 +  If not (nFlag&4)
.head 5 -  Call rbRect.Disable(  )
.head 4 +  Else
.head 5 +  If nMode = - 1
.head 6 -  Set nMode = 3
.head 4 -  Call SetButtons()
.head 4 -  Call SalSendMsg(hWndForm, AM_CGStart, 0, 0)
.head 3 +  On AM_Ok
.head 4 -  Call SalSendMsg(hWndRack2DView, AM_CGStop , 0, 0)
.head 4 -  Return TRUE
.head 3 +  On AM_Cancel
.head 4 -  Call SalSendMsg(hWndRack2DView, AM_CGStop , 0, 0)
.head 4 -  Return TRUE
.head 3 +  On AM_CGStart
.head 4 +  If bVirt
.head 5 -  Call SalSendMsg(hWndRack2DViewVirt, AM_CGStart, nMode + 10, 0)
.head 4 +  Else
.head 5 -  Call SalSendMsg(hWndRack2DView, AM_CGStart, nMode + 10, 0)
.head 0 -  












